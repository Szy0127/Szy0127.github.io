<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"szy0127.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="kvm 内存intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;manuals&#x2F;64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf  guest自己配置的页表完成GVA-&gt;GP">
<meta property="og:type" content="article">
<meta property="og:title" content="kvm 内存">
<meta property="og:url" content="http://szy0127.github.io/2024/01/18/virtualization/kvm%20%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="S blog">
<meta property="og:description" content="kvm 内存intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;manuals&#x2F;64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf  guest自己配置的页表完成GVA-&gt;GP">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\Shen\AppData\Roaming\Typora\typora-user-images\image-20230703194155548.png">
<meta property="og:image" content="http://jake.dothome.co.kr/wp-content/uploads/2017/01/do_swap_page-1a.png">
<meta property="article:published_time" content="2024-01-18T08:13:41.190Z">
<meta property="article:modified_time" content="2023-09-05T06:31:54.595Z">
<meta property="article:author" content="szy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\Shen\AppData\Roaming\Typora\typora-user-images\image-20230703194155548.png">


<link rel="canonical" href="http://szy0127.github.io/2024/01/18/virtualization/kvm%20%E5%86%85%E5%AD%98/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://szy0127.github.io/2024/01/18/virtualization/kvm%20%E5%86%85%E5%AD%98/","path":"2024/01/18/virtualization/kvm 内存/","title":"kvm 内存"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>kvm 内存 | S blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">S blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#kvm-%E5%86%85%E5%AD%98"><span class="nav-number">1.</span> <span class="nav-text">kvm 内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#VMCS"><span class="nav-number">1.1.</span> <span class="nav-text">VMCS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="nav-number">1.2.</span> <span class="nav-text">启动与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#module-init"><span class="nav-number">1.2.1.</span> <span class="nav-text">module init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#create"><span class="nav-number">1.2.2.</span> <span class="nav-text">create</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cr3"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">cr3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmu"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">mmu</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#run"><span class="nav-number">1.2.3.</span> <span class="nav-text">run</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EPT"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">EPT</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.3.1.1.</span> <span class="nav-text">构造流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E9%A1%B5%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="nav-number">1.2.3.1.2.</span> <span class="nav-text">页表页的获取</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CR3"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">CR3</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EPT-VIOLATION"><span class="nav-number">1.3.</span> <span class="nav-text">EPT VIOLATION</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GVA-GPA"><span class="nav-number">1.3.1.</span> <span class="nav-text">GVA-&gt;GPA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GPA-HVA"><span class="nav-number">1.3.2.</span> <span class="nav-text">GPA-&gt;HVA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HVA-HPA"><span class="nav-number">1.3.3.</span> <span class="nav-text">HVA-&gt;HPA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E9%A1%B5%E8%A1%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">遍历页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%85%A5%E6%98%A0%E5%B0%84"><span class="nav-number">1.3.5.</span> <span class="nav-text">加入映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#swap"><span class="nav-number">1.4.</span> <span class="nav-text">swap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#swap-out"><span class="nav-number">1.4.1.</span> <span class="nav-text">swap out</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swap-in"><span class="nav-number">1.4.2.</span> <span class="nav-text">swap in</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">szy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2024/01/18/virtualization/kvm%20%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="kvm 内存 | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          kvm 内存
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-01-18 16:13:41" itemprop="dateCreated datePublished" datetime="2024-01-18T16:13:41+08:00">2024-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-05 14:31:54" itemprop="dateModified" datetime="2023-09-05T14:31:54+08:00">2023-09-05</time>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>4.7k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>17 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="kvm-内存"><a href="#kvm-内存" class="headerlink" title="kvm 内存"></a>kvm 内存</h1><p><a target="_blank" rel="noopener" href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf">intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;manuals&#x2F;64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf</a></p>
<ul>
<li>guest自己配置的页表完成GVA-&gt;GPA翻译 kvm不管这个数据结构</li>
<li>kvm的memslot完成GPA-&gt;HVA翻译 kvm维护这个数据结构，参数由用户态(qemu)提供</li>
<li>kvm的EPT(spt)完成GPA-&gt;HPA翻译，完全由kvm分配维护。需要结合memslot与自己进程的页表构造EPT</li>
<li>内核模块完成HVA-&gt;HPA翻译，涉及到VMA、页表等数据结构，在kvm需要的时候提供查询</li>
</ul>
<h2 id="VMCS"><a href="#VMCS" class="headerlink" title="VMCS"></a>VMCS</h2><p>一个vcpu对应一个VMCS，包括一套寄存器和一个虚拟MMU等。</p>
<p><code>kvm_vm_ioctl_create_vcpu</code>会设置对应的虚拟mmu信息</p>
<p>通过硬件提供的扩展指令设置当前的VMCS并且读写VMCS的域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vmcs_load</span><span class="params">(<span class="keyword">struct</span> vmcs *vmcs)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 phys_addr = __pa(vmcs);</span><br><span class="line">	u8 error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(__ex(ASM_VMX_VMPTRLD_RAX) <span class="string">&quot;; setna %0&quot;</span></span></span><br><span class="line"><span class="params">			: <span class="string">&quot;=qm&quot;</span>(error) : <span class="string">&quot;a&quot;</span>(&amp;phys_addr), <span class="string">&quot;m&quot;</span>(phys_addr)</span></span><br><span class="line"><span class="params">			: <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;kvm: vmptrld %p/%llx failed\n&quot;</span>,</span><br><span class="line">		       vmcs, phys_addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> __vmcs_writel(<span class="type">unsigned</span> <span class="type">long</span> field, <span class="type">unsigned</span> <span class="type">long</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	u8 error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(__ex(ASM_VMX_VMWRITE_RAX_RDX) <span class="string">&quot;; setna %0&quot;</span></span></span><br><span class="line"><span class="params">		       : <span class="string">&quot;=q&quot;</span>(error) : <span class="string">&quot;a&quot;</span>(value), <span class="string">&quot;d&quot;</span>(field) : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(error))</span><br><span class="line">		vmwrite_error(field, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">vmcs_field</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	HOST_RSP                        = <span class="number">0x00006c14</span>,</span><br><span class="line">	HOST_RIP                        = <span class="number">0x00006c16</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>field赋值给rdx，value赋值给rax，随后此条汇编指令执行<code>vmcs[%rdx]=%rax</code></p>
<h2 id="启动与配置"><a href="#启动与配置" class="headerlink" title="启动与配置"></a>启动与配置</h2><h3 id="module-init"><a href="#module-init" class="headerlink" title="module init"></a>module init</h3><p>加载module时会根据arch进行相关的硬件初始化，并直接在硬件允许的情况下打开EPT的设置</p>
<p>(module_init)<code>vmx_init</code>-&gt;<code>kvm_init</code>-&gt;<code>kvm_arch_hardware_setup</code>-&gt;<code>hardware_setup</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> __read_mostly enable_ept = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">hardware_setup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cpu_has_vmx_ept() ||</span><br><span class="line">	    !cpu_has_vmx_ept_4levels() ||</span><br><span class="line">	    !cpu_has_vmx_ept_mt_wb() ||</span><br><span class="line">	    !cpu_has_vmx_invept_global())</span><br><span class="line">		enable_ept = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span> (enable_ept)</span><br><span class="line">			vmx_enable_tdp();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			kvm_disable_tdp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vmx_enable_tdp</code>-&gt;<code>kvm_enable_tdp</code></p>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><h4 id="cr3"><a href="#cr3" class="headerlink" title="cr3"></a>cr3</h4><p>用户态可以设置sreg 指定cr3的值</p>
<p>[q]这里用户态(例如qemu)配置cr3的值是否可有可无？操作系统启动不都是会自己配置页表和cr3吗</p>
<p>操作系统(如chcore)会在打开mmu之前先进行页表配置，如何兼容这样的操作系统？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kvm_arch_vcpu_ioctl_set_sregs</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> kvm_sregs *sregs)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	vcpu-&gt;arch.cr3 = sregs-&gt;cr3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以kvm-hello-world为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vm-&gt;mem = mmap(<span class="literal">NULL</span>, mem_size, PROT_READ | PROT_WRITE,</span><br><span class="line">		   MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">memreg.guest_phys_addr = <span class="number">0</span>;</span><br><span class="line">memreg.memory_size = <span class="number">0x200000</span>;</span><br><span class="line">memreg.userspace_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vm-&gt;mem;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> pml4_addr = <span class="number">0x2000</span>;</span><br><span class="line"><span class="type">uint64_t</span> *pml4 = (<span class="type">void</span> *)(vm-&gt;mem + pml4_addr);</span><br><span class="line"><span class="type">uint64_t</span> pdpt_addr = <span class="number">0x3000</span>;</span><br><span class="line"><span class="type">uint64_t</span> *pdpt = (<span class="type">void</span> *)(vm-&gt;mem + pdpt_addr);</span><br><span class="line"><span class="type">uint64_t</span> pd_addr = <span class="number">0x4000</span>;</span><br><span class="line"><span class="type">uint64_t</span> *pd = (<span class="type">void</span> *)(vm-&gt;mem + pd_addr);</span><br><span class="line">pml4[<span class="number">0</span>] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pdpt_addr;</span><br><span class="line">pdpt[<span class="number">0</span>] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pd_addr;</span><br><span class="line">pd[<span class="number">0</span>] = PDE64_PRESENT | PDE64_RW | PDE64_USER | PDE64_PS;</span><br><span class="line"></span><br><span class="line">sregs-&gt;cr3 = pml4_addr;</span><br></pre></td></tr></table></figure>

<p>这是存储的是GPA，但是修改的是HVA。当进行地址翻译时，第一阶段页表存储的GPA本身就会被EPT翻译到HPA（或者GPA-&gt;HVA，再通过EPT Violation建立GPA-&gt;HPA）</p>
<p>这里每个index都是0，且最后一级PTE没有地址，所以做的是0x0-&gt;0x0的地址映射，GPA&#x3D;GVA</p>
<h4 id="mmu"><a href="#mmu" class="headerlink" title="mmu"></a>mmu</h4><p>用户态ioctl创建vcpu时，进行虚拟mmu初始化</p>
<p><code>kvm_vm_ioctl</code>-&gt;<code>kvm_vm_ioctl_create_vcpu</code>-&gt;<code>kvm_arch_vcpu_setup</code>-&gt;<code>kvm_mmu_setup</code>-&gt;<code>init_kvm_mmu</code>-&gt;<code>init_kvm_tdp_mmu</code></p>
<p>这里的配置是看后续函数调用和函数内部分支的依据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_kvm_mmu</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (tdp_enabled)</span><br><span class="line">		init_kvm_tdp_mmu(vcpu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_kvm_tdp_mmu</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_mmu</span> *<span class="title">context</span> =</span> &amp;vcpu-&gt;arch.mmu;</span><br><span class="line"></span><br><span class="line">	context-&gt;base_role.word = <span class="number">0</span>;</span><br><span class="line">	context-&gt;base_role.smm = is_smm(vcpu);</span><br><span class="line">	context-&gt;base_role.ad_disabled = (shadow_accessed_mask == <span class="number">0</span>);</span><br><span class="line">	context-&gt;page_fault = tdp_page_fault;</span><br><span class="line">	context-&gt;sync_page = nonpaging_sync_page;</span><br><span class="line">	context-&gt;invlpg = nonpaging_invlpg;</span><br><span class="line">	context-&gt;update_pte = nonpaging_update_pte;</span><br><span class="line">	context-&gt;shadow_root_level = kvm_x86_ops-&gt;get_tdp_level(vcpu);</span><br><span class="line">	context-&gt;root_hpa = INVALID_PAGE;</span><br><span class="line">	context-&gt;direct_map = <span class="literal">true</span>;</span><br><span class="line">	context-&gt;set_cr3 = kvm_x86_ops-&gt;set_tdp_cr3;</span><br><span class="line">	context-&gt;get_cr3 = get_cr3;</span><br><span class="line">	context-&gt;get_pdptr = kvm_pdptr_read;</span><br><span class="line">	context-&gt;inject_page_fault = kvm_inject_page_fault;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_paging(vcpu)) &#123;</span><br><span class="line">		context-&gt;nx = <span class="literal">false</span>;</span><br><span class="line">		context-&gt;gva_to_gpa = nonpaging_gva_to_gpa;</span><br><span class="line">		context-&gt;root_level = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_long_mode(vcpu)) &#123;</span><br><span class="line">		context-&gt;nx = is_nx(vcpu);</span><br><span class="line">		context-&gt;root_level = is_la57_mode(vcpu) ?</span><br><span class="line">				PT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;</span><br><span class="line">		reset_rsvds_bits_mask(vcpu, context);</span><br><span class="line">		context-&gt;gva_to_gpa = paging64_gva_to_gpa;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_pae(vcpu)) &#123;</span><br><span class="line">		context-&gt;nx = is_nx(vcpu);</span><br><span class="line">		context-&gt;root_level = PT32E_ROOT_LEVEL;</span><br><span class="line">		reset_rsvds_bits_mask(vcpu, context);</span><br><span class="line">		context-&gt;gva_to_gpa = paging64_gva_to_gpa;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		context-&gt;nx = <span class="literal">false</span>;</span><br><span class="line">		context-&gt;root_level = PT32_ROOT_LEVEL;</span><br><span class="line">		reset_rsvds_bits_mask(vcpu, context);</span><br><span class="line">		context-&gt;gva_to_gpa = paging32_gva_to_gpa;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	update_permission_bitmask(vcpu, context, <span class="literal">false</span>);</span><br><span class="line">	update_pkru_bitmask(vcpu, context, <span class="literal">false</span>);</span><br><span class="line">	update_last_nonleaf_level(vcpu, context);</span><br><span class="line">	reset_tdp_shadow_zero_bits_mask(vcpu, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>每次run之前都会reload mmu</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vcpu_enter_guest</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    r = kvm_mmu_reload(vcpu);</span><br><span class="line">    kvm_x86_ops-&gt;run(vcpu);</span><br><span class="line">    r = kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kvm_mmu_reload</code>-&gt;<code>kvm_mmu_load</code>-&gt;<code>mmu_alloc_roots</code>-&gt;<code>mmu_alloc_direct_roots</code></p>
<h4 id="EPT"><a href="#EPT" class="headerlink" title="EPT"></a>EPT</h4><p>spt是shadow page table 虽然命名是影子页表，但实际上是EPT复用了这个数据结构。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/huang987246510/article/details/105645656/">内存虚拟化软件基础——KVM SPT_spt和ept_享乐主的博客-CSDN博客</a></p>
<p><img src="C:\Users\Shen\AppData\Roaming\Typora\typora-user-images\image-20230703194155548.png" alt="image-20230703194155548"></p>
<p>这里page table page不是只记录一个基地址然后用指针连接，而是每个page都会对应一个<code>kvm_mmu_page</code>结构体，spt成员变量为真实的page table page</p>
<p>这里root_hpa是EPT的基地址（HPA）</p>
<h5 id="构造流程"><a href="#构造流程" class="headerlink" title="构造流程"></a>构造流程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kvm_mmu_load</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	r = mmu_alloc_roots(vcpu);</span><br><span class="line">	vcpu-&gt;arch.mmu.set_cr3(vcpu, vcpu-&gt;arch.mmu.root_hpa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mmu_alloc_direct_roots</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_mmu_page</span> *<span class="title">sp</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> i;</span><br><span class="line">	<span class="keyword">if</span> (vcpu-&gt;arch.mmu.shadow_root_level &gt;= PT64_ROOT_4LEVEL) &#123;</span><br><span class="line">		spin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class="line">		<span class="keyword">if</span>(make_mmu_pages_available(vcpu) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			spin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		sp = kvm_mmu_get_page(vcpu, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">				vcpu-&gt;arch.mmu.shadow_root_level, <span class="number">1</span>, ACC_ALL);</span><br><span class="line">		++sp-&gt;root_count;</span><br><span class="line">		spin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class="line">		vcpu-&gt;arch.mmu.root_hpa = __pa(sp-&gt;spt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> kvm_mmu_page *<span class="title function_">kvm_mmu_get_page</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu,</span></span><br><span class="line"><span class="params">				<span class="type">gfn_t</span> gfn,<span class="type">gva_t</span> gaddr,<span class="type">unsigned</span> level,<span class="type">int</span> direct, <span class="type">unsigned</span> access)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">kvm_mmu_page_role</span> <span class="title">role</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> quadrant;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_mmu_page</span> *<span class="title">sp</span>;</span></span><br><span class="line">	<span class="type">bool</span> need_sync = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> flush = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> collisions = <span class="number">0</span>;</span><br><span class="line">	LIST_HEAD(invalid_list);</span><br><span class="line"></span><br><span class="line">	role = vcpu-&gt;arch.mmu.base_role;</span><br><span class="line">	role.level = level;</span><br><span class="line">	role.direct = direct;</span><br><span class="line">	<span class="keyword">if</span> (role.direct)</span><br><span class="line">		role.cr4_pae = <span class="number">0</span>;</span><br><span class="line">	role.access = access;</span><br><span class="line">	for_each_valid_sp(vcpu-&gt;kvm, sp, gfn) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp-&gt;gfn != gfn) &#123;</span><br><span class="line">			collisions++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!need_sync &amp;&amp; sp-&gt;unsync)</span><br><span class="line">			need_sync = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (sp-&gt;role.word != role.word)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	++vcpu-&gt;kvm-&gt;stat.mmu_cache_miss;</span><br><span class="line">	sp = kvm_mmu_alloc_page(vcpu, direct);</span><br><span class="line">	sp-&gt;gfn = gfn;</span><br><span class="line">	sp-&gt;role = role;</span><br><span class="line">	hlist_add_head(&amp;sp-&gt;hash_link,</span><br><span class="line">		&amp;vcpu-&gt;kvm-&gt;arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);</span><br><span class="line">	sp-&gt;mmu_valid_gen = vcpu-&gt;kvm-&gt;arch.mmu_valid_gen;</span><br><span class="line">	clear_page(sp-&gt;spt);</span><br><span class="line">	kvm_mmu_flush_or_zap(vcpu, &amp;invalid_list, <span class="literal">false</span>, flush);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> kvm_mmu_page *<span class="title function_">kvm_mmu_alloc_page</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">int</span> direct)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_mmu_page</span> *<span class="title">sp</span>;</span></span><br><span class="line"></span><br><span class="line">	sp = mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_page_header_cache);</span><br><span class="line">	sp-&gt;spt = mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_page_cache);</span><br><span class="line">	<span class="keyword">if</span> (!direct)</span><br><span class="line">		sp-&gt;gfns = mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_page_cache);</span><br><span class="line">	set_page_private(virt_to_page(sp-&gt;spt), (<span class="type">unsigned</span> <span class="type">long</span>)sp);</span><br><span class="line">	list_add(&amp;sp-&gt;link, &amp;vcpu-&gt;kvm-&gt;arch.active_mmu_pages);</span><br><span class="line">	kvm_mod_used_mmu_pages(vcpu-&gt;kvm, +<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>kvm_mmu_get_page</code>是后续缺页异常添加页表页也会复用到的函数，作用就是返回(不存在时分配)page这个数据结构，不涉及页表页间的连接（配置页表项）</p>
<p><code>kvm_mmu_page</code> 用hash table维护，这样可以直接找到某个地址对应的页表页，不需要遍历4级页表。</p>
<p>这里root给的gfn是0，即GPA是0。初始化只有第一级页表页且不存在任何页表项。</p>
<p>这里虽然每次run都会get_page，但是只有第一次会真的alloc，其他时候都会直接返回第一级页表页。</p>
<p>在第一次run时，kvm不会先根据memslot创建好所有的映射，而是等guest真的访问了再在ept violation中加入对应的页表项。（刚运行时，VM的代码段需要被读取并执行，触发大量ept violation；写内存操作又会触发ept violation）</p>
<p><code>kvm_mmu_flush_or_zap</code>会在一定条件下flush tlb，但是这里的条件都被给了false(linux6.4版本在这里没有flush tlb)</p>
<h5 id="页表页的获取"><a href="#页表页的获取" class="headerlink" title="页表页的获取"></a>页表页的获取</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">mmu_memory_cache_alloc</span><span class="params">(<span class="keyword">struct</span> kvm_mmu_memory_cache *mc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *p;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!mc-&gt;nobjs);</span><br><span class="line">	p = mc-&gt;objects[--mc-&gt;nobjs];</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mmu_topup_memory_cache_page</span><span class="params">(<span class="keyword">struct</span> kvm_mmu_memory_cache *cache,</span></span><br><span class="line"><span class="params">				       <span class="type">int</span> min)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *page;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cache-&gt;nobjs &gt;= min)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (cache-&gt;nobjs &lt; ARRAY_SIZE(cache-&gt;objects)) &#123;</span><br><span class="line">		page = (<span class="type">void</span> *)__get_free_page(GFP_KERNEL_ACCOUNT);</span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		cache-&gt;objects[cache-&gt;nobjs++] = page;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿page最后会调<code>mm/page_alloc.c</code>的<code>__alloc_pages_nodemask</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/linux/mm.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> page_address(page) lowmem_page_address(page)</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">lowmem_page_address</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> page_to_virt(page);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> page_to_virt(x)	__va(PFN_PHYS(page_to_pfn(x)))</span></span><br><span class="line"><span class="comment">//arch/x86/include/asm</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pa(x)		__phys_addr((unsigned long)(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))</span></span><br><span class="line"><span class="comment">//include/linux/pfn.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PHYS(x)	((phys_addr_t)(x) &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="comment">//arch/x86/mm/physaddr.c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __phys_addr(<span class="type">unsigned</span> <span class="type">long</span> x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> y = x - __START_KERNEL_map;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(x &gt; y)) &#123;</span><br><span class="line">		x = y + phys_base;</span><br><span class="line">		VIRTUAL_BUG_ON(y &gt;= KERNEL_IMAGE_SIZE);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		x = y + (__START_KERNEL_map - PAGE_OFFSET);</span><br><span class="line">		VIRTUAL_BUG_ON((x &gt; y) || !phys_addr_valid(x));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vcpu-&gt;arch.mmu.root_hpa = __pa(sp-&gt;spt);</code>可以看到EPT基地址用的是内核在内存模块拿到的页并转换为的物理地址，即HPA</p>
<h4 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vmx_set_cr3</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">unsigned</span> <span class="type">long</span> cr3)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> guest_cr3;</span><br><span class="line">	u64 eptp;</span><br><span class="line">	guest_cr3 = cr3;</span><br><span class="line">	<span class="keyword">if</span> (enable_ept) &#123;</span><br><span class="line">		eptp = construct_eptp(vcpu, cr3);</span><br><span class="line">		vmcs_write64(EPT_POINTER, eptp);</span><br><span class="line">		<span class="keyword">if</span> (is_paging(vcpu) || is_guest_mode(vcpu))</span><br><span class="line">			guest_cr3 = kvm_read_cr3(vcpu);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			guest_cr3 = vcpu-&gt;kvm-&gt;arch.ept_identity_map_addr;</span><br><span class="line">		ept_load_pdptrs(vcpu);</span><br><span class="line">	&#125;</span><br><span class="line">	vmx_flush_tlb(vcpu, <span class="literal">true</span>);</span><br><span class="line">	vmcs_writel(GUEST_CR3, guest_cr3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>vmx_set_cr3</code>一方面把用户的cr3写到VMCS中，另一方面把自己构造的EPT也写到VMCS中</p>
<p>操作系统都会先在不开MMU的情况下配置页表，然后打开MMU，这些都不会下陷到VMM（不使用cr3，只使用ept）</p>
<p>每次进入non-root模式会把当前VMCS的cr3赋值给cr3，使用cr3和VMCS的EPT</p>
<h2 id="EPT-VIOLATION"><a href="#EPT-VIOLATION" class="headerlink" title="EPT VIOLATION"></a>EPT VIOLATION</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vmx_handle_exit</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (exit_reason &lt; kvm_vmx_max_exit_handlers</span><br><span class="line">	    &amp;&amp; kvm_vmx_exit_handlers[exit_reason])</span><br><span class="line">		<span class="keyword">return</span> kvm_vmx_exit_handlers[exit_reason](vcpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GVA-GPA"><a href="#GVA-GPA" class="headerlink" title="GVA-&gt;GPA"></a>GVA-&gt;GPA</h3><p>Guest的GVA-&gt;GPA缺页异常由自己完成，<code>EPT_VIOLATION</code>只存在于存在GVA-&gt;GPA但不存在GPA-&gt;HPA的情况</p>
<p>发生<code>EPT_VIOLATION</code>前 异常的GPA会被自动保存到当前VMCS的<code>GUEST_PHYSICAL_ADDRESS</code>字段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_ept_violation</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">gpa_t</span> gpa=vmcs_read64(GUEST_PHYSICAL_ADDRESS);</span><br><span class="line">    <span class="keyword">return</span> kvm_mmu_page_fault(vcpu, gpa, error_code, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kvm_mmu_page_fault</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">gpa_t</span> cr2_or_gpa, u64 error_code,</span></span><br><span class="line"><span class="params">		       <span class="type">void</span> *insn, <span class="type">int</span> insn_len)</span></span><br><span class="line">&#123;</span><br><span class="line">	r = vcpu-&gt;arch.mmu.page_fault(vcpu, cr2_or_gpa,</span><br><span class="line">					       lower_32_bits(error_code),<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (r == RET_PF_RETRY)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tdp_page_fault</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">gpa_t</span> gpa, u32 error_code,<span class="type">bool</span> prefault)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">kvm_pfn_t</span> pfn;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">int</span> level;</span><br><span class="line">	<span class="type">bool</span> force_pt_level;</span><br><span class="line">	<span class="type">gfn_t</span> gfn = gpa &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmu_seq;</span><br><span class="line">	<span class="type">int</span> write = error_code &amp; PFERR_WRITE_MASK;</span><br><span class="line">	<span class="type">bool</span> map_writable;</span><br><span class="line">	<span class="type">bool</span> lpage_disallowed = (error_code &amp; PFERR_FETCH_MASK) &amp;&amp;</span><br><span class="line">				is_nx_huge_page_enabled();</span><br><span class="line"></span><br><span class="line">	MMU_WARN_ON(!VALID_PAGE(vcpu-&gt;arch.mmu.root_hpa));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (page_fault_handle_page_track(vcpu, error_code, gfn))</span><br><span class="line">		<span class="keyword">return</span> RET_PF_EMULATE;</span><br><span class="line"></span><br><span class="line">	r = mmu_topup_memory_caches(vcpu);</span><br><span class="line">	<span class="keyword">if</span> (r)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	force_pt_level =</span><br><span class="line">		lpage_disallowed ||</span><br><span class="line">		!check_hugepage_cache_consistency(vcpu, gfn, PT_DIRECTORY_LEVEL);</span><br><span class="line">	level = mapping_level(vcpu, gfn, &amp;force_pt_level);</span><br><span class="line">	<span class="keyword">if</span> (likely(!force_pt_level)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (level &gt; PT_DIRECTORY_LEVEL &amp;&amp;</span><br><span class="line">		    !check_hugepage_cache_consistency(vcpu, gfn, level))</span><br><span class="line">			level = PT_DIRECTORY_LEVEL;</span><br><span class="line">		gfn &amp;= ~(KVM_PAGES_PER_HPAGE(level) - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fast_page_fault(vcpu, gpa, level, error_code))</span><br><span class="line">		<span class="keyword">return</span> RET_PF_RETRY;</span><br><span class="line"></span><br><span class="line">	mmu_seq = vcpu-&gt;kvm-&gt;mmu_notifier_seq;</span><br><span class="line">	smp_rmb();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (try_async_pf(vcpu, prefault, gfn, gpa, &amp;pfn, write, &amp;map_writable))</span><br><span class="line">		<span class="keyword">return</span> RET_PF_RETRY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (handle_abnormal_pfn(vcpu, <span class="number">0</span>, gfn, pfn, ACC_ALL, &amp;r))</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	r = RET_PF_RETRY;</span><br><span class="line">	spin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class="line">	<span class="keyword">if</span> (mmu_notifier_retry(vcpu-&gt;kvm, mmu_seq))</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	<span class="keyword">if</span> (make_mmu_pages_available(vcpu) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	<span class="keyword">if</span> (likely(!force_pt_level))</span><br><span class="line">		transparent_hugepage_adjust(vcpu, gfn, &amp;pfn, &amp;level);</span><br><span class="line">	r = __direct_map(vcpu, gpa, write, map_writable, level, pfn,</span><br><span class="line">			 prefault, lpage_disallowed);</span><br><span class="line">out_unlock:</span><br><span class="line">	spin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class="line">	kvm_release_pfn_clean(pfn);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GPA-HVA"><a href="#GPA-HVA" class="headerlink" title="GPA-&gt;HVA"></a>GPA-&gt;HVA</h3><p>先根据memslot做GPA-&gt;HVA</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">try_async_pf</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">bool</span> prefault, <span class="type">gfn_t</span> gfn,</span></span><br><span class="line"><span class="params">			 <span class="type">gpa_t</span> cr2_or_gpa, <span class="type">kvm_pfn_t</span> *pfn, <span class="type">bool</span> write,</span></span><br><span class="line"><span class="params">			 <span class="type">bool</span> *writable)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_memory_slot</span> *<span class="title">slot</span>;</span></span><br><span class="line">	<span class="type">bool</span> async;</span><br><span class="line"></span><br><span class="line">	slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</span><br><span class="line">	async = <span class="literal">false</span>;</span><br><span class="line">	*pfn = __gfn_to_pfn_memslot(slot, gfn, <span class="literal">false</span>, &amp;async, write, writable);</span><br><span class="line">	<span class="keyword">if</span> (!async)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* *pfn has correct page already */</span></span><br><span class="line">	<span class="keyword">if</span> (!prefault &amp;&amp; kvm_can_do_async_pf(vcpu)) &#123;</span><br><span class="line">		trace_kvm_try_async_get_page(cr2_or_gpa, gfn);</span><br><span class="line">		<span class="keyword">if</span> (kvm_find_async_pf_gfn(vcpu, gfn)) &#123;</span><br><span class="line">			trace_kvm_async_pf_doublefault(cr2_or_gpa, gfn);</span><br><span class="line">			kvm_make_request(KVM_REQ_APF_HALT, vcpu);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (kvm_arch_setup_async_pf(vcpu, cr2_or_gpa, gfn))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pfn = __gfn_to_pfn_memslot(slot, gfn, <span class="literal">false</span>, <span class="literal">NULL</span>, write, writable);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里pfn并没有检查返回值，如果是错误情况会在后面用到的时候进行处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">kvm_pfn_t</span> __gfn_to_pfn_memslot(<span class="keyword">struct</span> kvm_memory_slot *slot, <span class="type">gfn_t</span> gfn,</span><br><span class="line">			       <span class="type">bool</span> atomic, <span class="type">bool</span> *async, <span class="type">bool</span> write_fault,</span><br><span class="line">			       <span class="type">bool</span> *writable)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> addr = __gfn_to_hva_many(slot, gfn, <span class="literal">NULL</span>, write_fault);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr == KVM_HVA_ERR_RO_BAD) &#123;</span><br><span class="line">		<span class="keyword">if</span> (writable)</span><br><span class="line">			*writable = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> KVM_PFN_ERR_RO_FAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (kvm_is_error_hva(addr)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (writable)</span><br><span class="line">			*writable = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> KVM_PFN_NOSLOT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (writable &amp;&amp; memslot_is_readonly(slot)) &#123;</span><br><span class="line">		*writable = <span class="literal">false</span>;</span><br><span class="line">		writable = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hva_to_pfn(addr, atomic, async, write_fault,</span><br><span class="line">			  writable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__gfn_to_hva_many</code>-&gt;<code>__gfn_to_hva_memslot</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line">__gfn_to_hva_memslot(<span class="keyword">struct</span> kvm_memory_slot *slot, <span class="type">gfn_t</span> gfn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> offset = gfn - slot-&gt;base_gfn;</span><br><span class="line">	offset = array_index_nospec(offset, slot-&gt;npages);</span><br><span class="line">	<span class="keyword">return</span> slot-&gt;userspace_addr + offset * PAGE_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回的hva是guest发生page fault的GPA对应的HVA</p>
<p><code>KVM_PFN_NOSLOT</code>会在<code>set_spte</code>中通过<code>is_noslot_pfn</code> <code>mark_mmio_spte</code>特殊处理 下一次访问会触发EPT misconfig</p>
<h3 id="HVA-HPA"><a href="#HVA-HPA" class="headerlink" title="HVA-&gt;HPA"></a>HVA-&gt;HPA</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">kvm_pfn_t</span> <span class="title function_">hva_to_pfn</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">bool</span> atomic, <span class="type">bool</span> *async,</span></span><br><span class="line"><span class="params">			<span class="type">bool</span> write_fault, <span class="type">bool</span> *writable)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="type">kvm_pfn_t</span> pfn = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> npages, r;</span><br><span class="line">	<span class="keyword">if</span> (hva_to_pfn_fast(addr, atomic, async, write_fault, writable, &amp;pfn))</span><br><span class="line">		<span class="keyword">return</span> pfn;</span><br><span class="line">	npages = hva_to_pfn_slow(addr, async, write_fault, writable, &amp;pfn);</span><br><span class="line">	<span class="keyword">if</span> (npages == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> pfn;</span><br><span class="line">	down_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">if</span> (npages == -EHWPOISON ||</span><br><span class="line">	      (!async &amp;&amp; check_user_page_hwpoison(addr))) &#123;</span><br><span class="line">		pfn = KVM_PFN_ERR_HWPOISON;</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">	&#125;</span><br><span class="line">retry:</span><br><span class="line">	vma = find_vma_intersection(current-&gt;mm, addr, addr + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (vma == <span class="literal">NULL</span>)</span><br><span class="line">		pfn = KVM_PFN_ERR_FAULT;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (vma-&gt;vm_flags &amp; (VM_IO | VM_PFNMAP)) &#123;</span><br><span class="line">		r = hva_to_pfn_remapped(vma, addr, async, write_fault, writable, &amp;pfn);</span><br><span class="line">		<span class="keyword">if</span> (r == -EAGAIN)</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">		<span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">			pfn = KVM_PFN_ERR_FAULT;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (async &amp;&amp; vma_is_valid(vma, write_fault))</span><br><span class="line">			*async = <span class="literal">true</span>;</span><br><span class="line">		pfn = KVM_PFN_ERR_FAULT;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">	up_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过mm模块的<code>find_vma_intersection</code>找到和[addr,addr+1)相交的VMA，如果不存在说明HVA是错的(用户态memslot申请的地址空间并没有用malloc或mmap获取)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hva_to_pfn_remapped</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">			       <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">bool</span> *async,</span></span><br><span class="line"><span class="params">			       <span class="type">bool</span> write_fault, <span class="type">bool</span> *writable,</span></span><br><span class="line"><span class="params">			       <span class="type">kvm_pfn_t</span> *p_pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">kvm_pfn_t</span> pfn;</span><br><span class="line">	<span class="type">pte_t</span> *ptep;</span><br><span class="line">	<span class="type">spinlock_t</span> *ptl;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	r = follow_pte_pmd(vma-&gt;vm_mm, addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;ptep, <span class="literal">NULL</span>, &amp;ptl);</span><br><span class="line">	<span class="keyword">if</span> (r) &#123;</span><br><span class="line">		<span class="type">bool</span> unlocked = <span class="literal">false</span>;</span><br><span class="line">		r = fixup_user_fault(current, current-&gt;mm, addr,</span><br><span class="line">				     (write_fault ? FAULT_FLAG_WRITE : <span class="number">0</span>), &amp;unlocked);</span><br><span class="line">		<span class="keyword">if</span> (unlocked)</span><br><span class="line">			<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">		<span class="keyword">if</span> (r)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		r = follow_pte_pmd(vma-&gt;vm_mm, addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;ptep, <span class="literal">NULL</span>, &amp;ptl);</span><br><span class="line">		<span class="keyword">if</span> (r)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (write_fault &amp;&amp; !pte_write(*ptep)) &#123;</span><br><span class="line">		pfn = KVM_PFN_ERR_RO_FAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (writable)</span><br><span class="line">		*writable = pte_write(*ptep);</span><br><span class="line">	pfn = pte_pfn(*ptep);</span><br><span class="line">	<span class="keyword">if</span> (!kvm_try_get_pfn(pfn))</span><br><span class="line">		r = -EFAULT;</span><br><span class="line">out:</span><br><span class="line">	pte_unmap_unlock(ptep, ptl);</span><br><span class="line">	*p_pfn = pfn;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __follow_pte_pmd(<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> address,</span><br><span class="line">			    <span class="type">unsigned</span> <span class="type">long</span> *start, <span class="type">unsigned</span> <span class="type">long</span> *end,</span><br><span class="line">			    <span class="type">pte_t</span> **ptepp, <span class="type">pmd_t</span> **pmdpp, <span class="type">spinlock_t</span> **ptlp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pgd_t</span> *pgd;</span><br><span class="line">	<span class="type">p4d_t</span> *p4d;</span><br><span class="line">	<span class="type">pud_t</span> *pud;</span><br><span class="line">	<span class="type">pmd_t</span> *pmd;</span><br><span class="line">	<span class="type">pte_t</span> *ptep;</span><br><span class="line"></span><br><span class="line">	pgd = pgd_offset(mm, address);</span><br><span class="line">	<span class="keyword">if</span> (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	p4d = p4d_offset(pgd, address);</span><br><span class="line">	<span class="keyword">if</span> (p4d_none(*p4d) || unlikely(p4d_bad(*p4d)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	pud = pud_offset(p4d, address);</span><br><span class="line">	<span class="keyword">if</span> (pud_none(*pud) || unlikely(pud_bad(*pud)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	pmd = pmd_offset(pud, address);</span><br><span class="line">	VM_BUG_ON(pmd_trans_huge(*pmd));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pmd_huge(*pmd)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!pmdpp)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (start &amp;&amp; end) &#123;</span><br><span class="line">			*start = address &amp; PMD_MASK;</span><br><span class="line">			*end = *start + PMD_SIZE;</span><br><span class="line">			mmu_notifier_invalidate_range_start(mm, *start, *end);</span><br><span class="line">		&#125;</span><br><span class="line">		*ptlp = pmd_lock(mm, pmd);</span><br><span class="line">		<span class="keyword">if</span> (pmd_huge(*pmd)) &#123;</span><br><span class="line">			*pmdpp = pmd;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		spin_unlock(*ptlp);</span><br><span class="line">		<span class="keyword">if</span> (start &amp;&amp; end)</span><br><span class="line">			mmu_notifier_invalidate_range_end(mm, *start, *end);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start &amp;&amp; end) &#123;</span><br><span class="line">		*start = address &amp; PAGE_MASK;</span><br><span class="line">		*end = *start + PAGE_SIZE;</span><br><span class="line">		mmu_notifier_invalidate_range_start(mm, *start, *end);</span><br><span class="line">	&#125;</span><br><span class="line">	ptep = pte_offset_map_lock(mm, pmd, address, ptlp);</span><br><span class="line">	<span class="keyword">if</span> (!pte_present(*ptep))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	*ptepp = ptep;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">unlock:</span><br><span class="line">	pte_unmap_unlock(ptep, *ptlp);</span><br><span class="line">	<span class="keyword">if</span> (start &amp;&amp; end)</span><br><span class="line">		mmu_notifier_invalidate_range_end(mm, *start, *end);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arch/arc/include/asm/pgtable.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_index(addr)		((addr) &gt;&gt; PGDIR_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_offset(mm, addr)	(((mm)-&gt;pgd)+pgd_index(addr))</span></span><br></pre></td></tr></table></figure>

<p>pgd p4d pud pmd分别是一二三四级页表，直接通过一些宏直接来索引。</p>
<p>这里通过内核中维护的当前进程的页表信息找到EPT中缺失的HVA-&gt;HPA，也就是说当前进程页表拥有的HVA-&gt;HPA映射处于某种原因没有被更新到EPT上</p>
<p>如果进程页表中也不存在对应的页表项，说明对该进程发生了一般的page fault，调用</p>
<p><code>fixup_user_fault</code>-&gt;<code>handle_mm_fault</code>-&gt;<code>__handle_mm_fault</code>处理</p>
<p>内核mm模块保证了这时HPA对应的VMA、物理页、进程页表都存在且合法，后续把GVA-&gt;HPA加入EPT即可</p>
<p>写保护？</p>
<p>换页？</p>
<h3 id="遍历页表"><a href="#遍历页表" class="headerlink" title="遍历页表"></a>遍历页表</h3><p>shadow_addr &#x3D; root_hpa &#x3D; EPT的基地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_shadow_entry(_vcpu, _addr, _walker)    \</span></span><br><span class="line"><span class="meta">	for (shadow_walk_init(&amp;(_walker), _vcpu, _addr);	\</span></span><br><span class="line"><span class="meta">	     shadow_walk_okay(&amp;(_walker));			\</span></span><br><span class="line"><span class="meta">	     shadow_walk_next(&amp;(_walker)))</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shadow_walk_init</span><span class="params">(<span class="keyword">struct</span> kvm_shadow_walk_iterator *iterator,</span></span><br><span class="line"><span class="params">			     <span class="keyword">struct</span> kvm_vcpu *vcpu, u64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	iterator-&gt;addr = addr;</span><br><span class="line">	iterator-&gt;shadow_addr = vcpu-&gt;arch.mmu.root_hpa;</span><br><span class="line">	iterator-&gt;level = vcpu-&gt;arch.mmu.shadow_root_level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">shadow_walk_okay</span><span class="params">(<span class="keyword">struct</span> kvm_shadow_walk_iterator *iterator)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (iterator-&gt;level &lt; PT_PAGE_TABLE_LEVEL)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	iterator-&gt;index = SHADOW_PT_INDEX(iterator-&gt;addr, iterator-&gt;level);</span><br><span class="line">	iterator-&gt;sptep	= ((u64 *)__va(iterator-&gt;shadow_addr)) + iterator-&gt;index;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shadow_walk_next</span><span class="params">(<span class="keyword">struct</span> kvm_shadow_walk_iterator *iterator)</span></span><br><span class="line">&#123;</span><br><span class="line">	__shadow_walk_next(iterator, *iterator-&gt;sptep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __shadow_walk_next(<span class="keyword">struct</span> kvm_shadow_walk_iterator *iterator,</span><br><span class="line">			       u64 spte)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (is_last_spte(spte, iterator-&gt;level)) &#123;</span><br><span class="line">		iterator-&gt;level = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iterator-&gt;shadow_addr = spte &amp; PT64_BASE_ADDR_MASK;</span><br><span class="line">	--iterator-&gt;level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于页表项和EPT基地址都记录的是物理地址，即HPA，这里访问都需要先转成虚拟地址即HVA来使用。</p>
<h3 id="加入映射"><a href="#加入映射" class="headerlink" title="加入映射"></a>加入映射</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leoufung/article/details/52661968">__direct_map 函数解析之影子页表的构建_direct map_leoufung的博客-CSDN博客</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __direct_map(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">gpa_t</span> gpa, <span class="type">int</span> write,</span><br><span class="line">			<span class="type">int</span> map_writable, <span class="type">int</span> level, <span class="type">kvm_pfn_t</span> pfn,</span><br><span class="line">			<span class="type">bool</span> prefault, <span class="type">bool</span> lpage_disallowed)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_shadow_walk_iterator</span> <span class="title">it</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_mmu_page</span> *<span class="title">sp</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">gfn_t</span> gfn = gpa &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	<span class="type">gfn_t</span> base_gfn = gfn;</span><br><span class="line">	<span class="keyword">if</span> (!VALID_PAGE(vcpu-&gt;arch.mmu.root_hpa))</span><br><span class="line">		<span class="keyword">return</span> RET_PF_RETRY;</span><br><span class="line">	trace_kvm_mmu_spte_requested(gpa, level, pfn);</span><br><span class="line">	for_each_shadow_entry(vcpu, gpa, it) &#123;</span><br><span class="line">		disallowed_hugepage_adjust(it, gfn, &amp;pfn, &amp;level);</span><br><span class="line">		base_gfn = gfn &amp; ~(KVM_PAGES_PER_HPAGE(it.level) - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (it.level == level)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		drop_large_spte(vcpu, it.sptep);</span><br><span class="line">		<span class="keyword">if</span> (!is_shadow_present_pte(*it.sptep)) &#123;</span><br><span class="line">			sp = kvm_mmu_get_page(vcpu, base_gfn, it.addr,</span><br><span class="line">					      it.level - <span class="number">1</span>, <span class="literal">true</span>, ACC_ALL);</span><br><span class="line">			link_shadow_page(vcpu, it.sptep, sp);</span><br><span class="line">			<span class="keyword">if</span> (lpage_disallowed)</span><br><span class="line">				account_huge_nx_page(vcpu-&gt;kvm, sp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = mmu_set_spte(vcpu, it.sptep, ACC_ALL,</span><br><span class="line">			   write, level, base_gfn, pfn, prefault,</span><br><span class="line">			   map_writable);</span><br><span class="line">	direct_pte_prefetch(vcpu, it.sptep);</span><br><span class="line">	++vcpu-&gt;stat.pf_fixed;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kvm_mmu_get_page</code>在不存在的情况下创建欣的页表页，<code>link_shadow_page</code>连接两级页表，<code>mmu_set_spte</code>在最后一级页表填入HPA</p>
<p>遍历页表的循环动态补全了GPA对应的页表页，最后写入映射到HPA的页表项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rmap_add</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, u64 *spte, <span class="type">gfn_t</span> gfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_mmu_page</span> *<span class="title">sp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_rmap_head</span> *<span class="title">rmap_head</span>;</span></span><br><span class="line"></span><br><span class="line">	sp = page_header(__pa(spte));</span><br><span class="line">	kvm_mmu_page_set_gfn(sp, spte - sp-&gt;spt, gfn);</span><br><span class="line">	rmap_head = gfn_to_rmap(vcpu-&gt;kvm, gfn, sp);</span><br><span class="line">	<span class="keyword">return</span> pte_list_add(vcpu, spte, rmap_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且会加入反向映射</p>
<p><code>mmu_set_spte</code>-&gt;<code>kvm_flush_remote_tlbs</code>-&gt;<code>kvm_make_all_cpus_request(kvm, KVM_REQ_TLB_FLUSH)</code></p>
<p><code>vcpu_enter_guest</code>-&gt;<code>kvm_vcpu_flush_tlb</code>-&gt;<code>vmx_flush_tlb</code>-&gt;<code>__vmx_flush_tlb</code>-&gt;<code>ept_sync_context(construct_eptp(vcpu, vcpu-&gt;arch.mmu.root_hpa));</code>-&gt;<code>__invept</code></p>
<p>最后用到VMX的<code>INVEPT</code>指令 手册<code>28.3.3.4 Guidelines for Use of the INVEPT Instruction</code></p>
<blockquote>
<p> the INVEPT instruction to invalidate information cached from the  EPT paging structures.</p>
</blockquote>
<p>tlb存的是GVA-&gt;HPA 还是HVA-&gt;HPA不确定，和VMX在硬件上的具体实现有关，所以需要特殊VMX指令而不是普通flush tlb的指令例如<code>invlpg</code>而是仍然需要使用VMX扩展指令？</p>
<h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/588911110">linux内核源码解析- 匿名页面生命周期 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.openeuler.org/en/blog/liqunsheng/2020-11-26-swap.html">Linux 中的内存交换 (openeuler.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LoyenWang/p/11827153.html">【原创】（十）Linux内存管理 - zoned page frame allocator - 5 - LoyenWang - 博客园 (cnblogs.com)</a></p>
<p>[<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010923083/article/details/116278456">内核内存] [arm64] 内存回收4—shrink_node函数详解_shrink函数_早起的虫儿有鹰吃的博客-CSDN博客</a></p>
<h3 id="swap-out"><a href="#swap-out" class="headerlink" title="swap out"></a>swap out</h3><p>mm&#x2F;vmscan.c <code>shrink_page_list</code> 高版本<code>shrink_folio_list</code></p>
<p><code>shrink_page_list</code>-&gt;<code>rmap_walk</code>-&gt;<code>try_to_unmap_one</code> -&gt; <code>mmu_notifier_invalidate_range_start</code></p>
<p>解映射(内核自己的  还有通知KVM EPT的)</p>
<p><code>kvm_unmap_hva_range</code> <code>kvm_handle_hva_range</code> <code>kvm_unmap_rmapp</code> <code>kvm_zap_rmapp</code> <code>rmap_get_first</code> <code>drop_spte ``rmap_remove</code> <code>pte_list_remove</code></p>
<p><code>page_vma_mapped_walk</code> 根据page结构体存的信息拿到对应的vma 再遍历页表拿到pte 最后unmap pte</p>
<p><code>shrink_page_list</code>-&gt;<code>pageout</code> 写磁盘</p>
<p>内核为了节约空间 先找VMA 再找pte 但是kvm是直接维护的spte</p>
<p><img src="http://jake.dothome.co.kr/wp-content/uploads/2017/01/do_swap_page-1a.png" alt="image"></p>
<p>[Linux中的Anonymous Pages和Swap <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/70964551">一] - 知乎 (zhihu.com)</a></p>
<p>[Qemu-kvm memory 虚拟化 | Tian-Daye on the Way (xingguotian.github.io)](<a target="_blank" rel="noopener" href="https://xingguotian.github.io/2019/08/23/qemu-kvm">https://xingguotian.github.io/2019/08/23/qemu-kvm</a> 内存虚拟化&#x2F;)</p>
<p><a target="_blank" rel="noopener" href="http://www.wowotech.net/memory_management/reverse_mapping.html">逆向映射的演进 (wowotech.net)</a></p>
<p>建立反向映射：<a target="_blank" rel="noopener" href="https://www.codenong.com/cs106477291/">5. EPT机制 | 码农家园 (codenong.com)</a></p>
<p>KVM的EPT维护一个rmap 反向映射</p>
<p>KVM启动先向内核mm模块注册一个回调函数，内核发生swap会通知KVM处理</p>
<p>解开反向映射：<a target="_blank" rel="noopener" href="https://www.openeuler.org/en/blog/liqunsheng/2020-11-26-swap.html">Linux 中的内存交换 (openeuler.org)</a></p>
<h3 id="swap-in"><a href="#swap-in" class="headerlink" title="swap in"></a>swap in</h3><p><code>do_swap_page</code>-&gt;<code>do_wp_page</code>-&gt;<code>wp_page_copy</code>-&gt;<code>set_pte_at_notify</code>-&gt;<code>mmu_notifier_change_pte</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mm/memory.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __handle_mm_fault(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> address,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_fault</span> <span class="title">vmf</span> =</span> &#123;</span><br><span class="line">		.vma = vma,</span><br><span class="line">		.address = address &amp; PAGE_MASK,</span><br><span class="line">		.flags = flags,</span><br><span class="line">		.pgoff = linear_page_index(vma, address),</span><br><span class="line">		.gfp_mask = __get_fault_gfp_mask(vma),</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> dirty = flags &amp; FAULT_FLAG_WRITE;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> vma-&gt;vm_mm;</span><br><span class="line">	<span class="type">pgd_t</span> *pgd;</span><br><span class="line">	<span class="type">p4d_t</span> *p4d;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	pgd = pgd_offset(mm, address);</span><br><span class="line">	p4d = p4d_alloc(mm, pgd, address);</span><br><span class="line">	<span class="keyword">if</span> (!p4d)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">	vmf.pud = pud_alloc(mm, p4d, address);</span><br><span class="line">	<span class="keyword">if</span> (!vmf.pud)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">    ...</span><br><span class="line">	vmf.pmd = pmd_alloc(mm, vmf.pud, address);</span><br><span class="line">	<span class="keyword">if</span> (!vmf.pmd)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> handle_pte_fault(&amp;vmf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_pte_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    vmf-&gt;pte = pte_offset_map(vmf-&gt;pmd, vmf-&gt;address);</span><br><span class="line">    vmf-&gt;orig_pte = *vmf-&gt;pte;</span><br><span class="line"> 	<span class="keyword">if</span> (!pte_present(vmf-&gt;orig_pte))</span><br><span class="line">		<span class="keyword">return</span> do_swap_page(vmf);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pte_offset_map(dir,addr) pte_offset(dir, addr)</span></span><br><span class="line">Expands to:</span><br><span class="line">((<span class="type">pte_t</span> *)(((((((*vmf-&gt;pmd).pud).pgd))) &amp; (~(((<span class="number">1UL</span>) &lt;&lt; (<span class="number">13</span>))<span class="number">-1</span>)))) + (((vmf-&gt;address) &gt;&gt; <span class="number">13</span>) &amp; (((<span class="number">1UL</span>) &lt;&lt; ((<span class="number">21</span> - <span class="number">13</span>))) - <span class="number">1</span>)))</span><br><span class="line"><span class="comment">//arch/arc/include/asm/pgtable.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pte_present(x)			(pte_val(x) &amp; _PAGE_PRESENT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_PRESENT       (1&lt;&lt;10)	<span class="comment">/* TLB entry is valid (H) */</span></span></span><br></pre></td></tr></table></figure>

<p>虽然代码注释说的是TLB是否有效，但是<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/gorman/html/understand/understand006.html#3.1">Page Table Management (kernel.org)</a>这个链接提到这个bit的意思是</p>
<blockquote>
<p> Page is resident in memory and not swapped out</p>
</blockquote>
<p>EPT并不是根据pte的bit判断swap，而是直接调用mm模块去处理，或者async直接返回用户态，挂起vcpu。</p>
<p><a target="_blank" rel="noopener" href="https://xingguotian.github.io/">Tian-Daye on the Way (xingguotian.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiongtianliuyun/article/details/108295111">Qemu-kvm memory 虚拟化_Cliff Yang的博客-CSDN博客</a></p>
<blockquote>
<p>调用hva_to_pfn时，如果这个函数判断是新分配的内存页，则表明该gfn到pfn的映射并未建立，如果内存页被交换到了磁盘上，则会设置async为true，这样tdp_page_fault就会成功返回，并将当前VCPU线程挂起来。——《QEMUKVM源码解析与应用》</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">kvm_pfn_t</span> <span class="title function_">hva_to_pfn</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">bool</span> atomic, <span class="type">bool</span> *async,</span></span><br><span class="line"><span class="params">			<span class="type">bool</span> write_fault, <span class="type">bool</span> *writable)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="type">kvm_pfn_t</span> pfn = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> npages, r;</span><br><span class="line">	<span class="keyword">if</span> (hva_to_pfn_fast(addr, atomic, async, write_fault, writable, &amp;pfn))</span><br><span class="line">		<span class="keyword">return</span> pfn;</span><br><span class="line">	npages = hva_to_pfn_slow(addr, async, write_fault, writable, &amp;pfn);</span><br><span class="line">	<span class="keyword">if</span> (npages == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> pfn;</span><br><span class="line">	down_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">if</span> (npages == -EHWPOISON ||</span><br><span class="line">	      (!async &amp;&amp; check_user_page_hwpoison(addr))) &#123;</span><br><span class="line">		pfn = KVM_PFN_ERR_HWPOISON;</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">	&#125;</span><br><span class="line">retry:</span><br><span class="line">	vma = find_vma_intersection(current-&gt;mm, addr, addr + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (vma == <span class="literal">NULL</span>)</span><br><span class="line">		pfn = KVM_PFN_ERR_FAULT;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (vma-&gt;vm_flags &amp; (VM_IO | VM_PFNMAP)) &#123;</span><br><span class="line">		r = hva_to_pfn_remapped(vma, addr, async, write_fault, writable, &amp;pfn);</span><br><span class="line">		<span class="keyword">if</span> (r == -EAGAIN)</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">		<span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">			pfn = KVM_PFN_ERR_FAULT;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (async &amp;&amp; vma_is_valid(vma, write_fault))</span><br><span class="line">			*async = <span class="literal">true</span>;</span><br><span class="line">		pfn = KVM_PFN_ERR_FAULT;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">	up_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch14lev1sec2.html">Memory Areas (gigatux.nl)</a><code>VM_IO</code>表示</p>
<blockquote>
<p>The area maps a device’s I&#x2F;O space</p>
</blockquote>
<p>这里async传入指针，有两个作用</p>
<ol>
<li>指针空或非空表示是否支持async，指导内层函数</li>
<li>如果指针非空，true&#x2F;false表示是否需要async(例如swap0，指导外层函数)</li>
</ol>
<p><code>hva_to_pfn_slow</code>-&gt;<code>get_user_page_nowait</code>-&gt;<code>get_user_pages</code>-&gt;<code>__get_user_pages</code> -&gt;<code>faultin_page</code>-&gt;<code>handle_mm_fault</code>-&gt;<code>__handle_mm_fault</code>-&gt;<code>handle_pte_fault</code>-&gt;<code>do_swap_page</code></p>
<p>这里是同步处理swap</p>
<p>下面是异步处理swap</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">try_async_pf</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">bool</span> prefault, <span class="type">gfn_t</span> gfn,</span></span><br><span class="line"><span class="params">			 <span class="type">gpa_t</span> cr2_or_gpa, <span class="type">kvm_pfn_t</span> *pfn, <span class="type">bool</span> write,</span></span><br><span class="line"><span class="params">			 <span class="type">bool</span> *writable)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (!prefault &amp;&amp; kvm_can_do_async_pf(vcpu)) &#123;</span><br><span class="line">		trace_kvm_try_async_get_page(cr2_or_gpa, gfn);</span><br><span class="line">		<span class="keyword">if</span> (kvm_find_async_pf_gfn(vcpu, gfn)) &#123;</span><br><span class="line">			trace_kvm_async_pf_doublefault(cr2_or_gpa, gfn);</span><br><span class="line">			kvm_make_request(KVM_REQ_APF_HALT, vcpu);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (kvm_arch_setup_async_pf(vcpu, cr2_or_gpa, gfn))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*pfn = __gfn_to_pfn_memslot(slot, gfn, <span class="literal">false</span>, <span class="literal">NULL</span>, write, writable);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//include/linux/kvm_host.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">kvm_make_request</span><span class="params">(<span class="type">int</span> req, <span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	smp_wmb();</span><br><span class="line">	set_bit(req &amp; KVM_REQUEST_MASK, &amp;vcpu-&gt;requests);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果vm支持async，直接返回，不处理；否则再调用一次<code>gfn_to_pfn</code>并不支持async强制同步swap</p>
<p>kvm_make_request对当前vcpu有作用，例如挂起</p>
<p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v4.15/virtual/kvm/vcpu-requests.html">KVM VCPU Requests — The Linux Kernel documentation</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tdp_page_fault</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">gpa_t</span> gpa, u32 error_code,<span class="type">bool</span> prefault)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">if</span> (try_async_pf(vcpu, prefault, gfn, gpa, &amp;pfn, write, &amp;map_writable))</span><br><span class="line">		<span class="keyword">return</span> RET_PF_RETRY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kvm_mmu_page_fault</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">gpa_t</span> cr2_or_gpa, u64 error_code,</span></span><br><span class="line"><span class="params">		       <span class="type">void</span> *insn, <span class="type">int</span> insn_len)</span></span><br><span class="line">&#123;</span><br><span class="line">	r = vcpu-&gt;arch.mmu.page_fault(vcpu, cr2_or_gpa,</span><br><span class="line">					       lower_32_bits(error_code),<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (r == RET_PF_RETRY)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_ept_violation</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">gpa_t</span> gpa=vmcs_read64(GUEST_PHYSICAL_ADDRESS);</span><br><span class="line">    <span class="keyword">return</span> kvm_mmu_page_fault(vcpu, gpa, error_code, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vmx_handle_exit</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (exit_reason &lt; kvm_vmx_max_exit_handlers</span><br><span class="line">	    &amp;&amp; kvm_vmx_exit_handlers[exit_reason])</span><br><span class="line">		<span class="keyword">return</span> kvm_vmx_exit_handlers[exit_reason](vcpu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vcpu_enter_guest</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (kvm_request_pending(vcpu)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) &#123;</span><br><span class="line">            <span class="comment">/* Page is swapped out. Do synthetic halt */</span></span><br><span class="line">            vcpu-&gt;arch.apf.halted = <span class="literal">true</span>;</span><br><span class="line">            r = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">   		...</span><br><span class="line">    &#125;</span><br><span class="line">    r = kvm_mmu_reload(vcpu);</span><br><span class="line">    kvm_x86_ops-&gt;run(vcpu);</span><br><span class="line">    r = kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vcpu_run</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm</span> *<span class="title">kvm</span> =</span> vcpu-&gt;kvm;</span><br><span class="line">	vcpu-&gt;srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu);</span><br><span class="line">	vcpu-&gt;arch.l1tf_flush_l1d = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (kvm_vcpu_running(vcpu)) &#123;</span><br><span class="line">			r = vcpu_enter_guest(vcpu);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r = vcpu_block(kvm, vcpu);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (r &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">	srcu_read_unlock(&amp;kvm-&gt;srcu, vcpu-&gt;srcu_idx);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kvm_arch_vcpu_ioctl_run</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="keyword">struct</span> kvm_run *kvm_run)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (kvm_run-&gt;immediate_exit)</span><br><span class="line">		r = -EINTR;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		r = vcpu_run(vcpu);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//virt/kvm/kvm_main.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">kvm_vcpu_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">			   <span class="type">unsigned</span> <span class="type">int</span> ioctl, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (ioctl) &#123;</span><br><span class="line">	<span class="keyword">case</span> KVM_RUN: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">oldpid</span>;</span></span><br><span class="line">		r = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (arg)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		oldpid = rcu_access_pointer(vcpu-&gt;pid);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(oldpid != current-&gt;pids[PIDTYPE_PID].pid)) &#123;</span><br><span class="line">			<span class="comment">/* The thread running this VCPU changed. */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">newpid</span> =</span> get_task_pid(current, PIDTYPE_PID);</span><br><span class="line"></span><br><span class="line">			rcu_assign_pointer(vcpu-&gt;pid, newpid);</span><br><span class="line">			<span class="keyword">if</span> (oldpid)</span><br><span class="line">				synchronize_rcu();</span><br><span class="line">			put_pid(oldpid);</span><br><span class="line">		&#125;</span><br><span class="line">		r = kvm_arch_vcpu_ioctl_run(vcpu, vcpu-&gt;run);</span><br><span class="line">		trace_kvm_userspace_exit(vcpu-&gt;run-&gt;exit_reason, r);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">kvm_vcpu_fops</span> =</span> &#123;</span><br><span class="line">	.release        = kvm_vcpu_release,</span><br><span class="line">	.unlocked_ioctl = kvm_vcpu_ioctl,</span><br><span class="line">	.mmap           = kvm_vcpu_mmap,</span><br><span class="line">	.llseek		= noop_llseek,</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>之后这个错误就一路返回到用户态了，然后挂起vcpu。等待内核管理内存的线程swap in</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/01/18/virtualization/virtualization-misc/" rel="prev" title="virtualization misc">
                  <i class="fa fa-angle-left"></i> virtualization misc
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">szy</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">9k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">32 mins.</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
