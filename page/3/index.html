<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"szy0127.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"preload":true}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="S blog">
<meta property="og:url" content="http://szy0127.github.io/page/3/index.html">
<meta property="og:site_name" content="S blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="szy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://szy0127.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>S blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">S blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">szy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2025/02/04/papers/WESEE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/04/papers/WESEE/" class="post-title-link" itemprop="url">WESEE: Using Malicious #VC Interrupts to Break AMD SEV-SNP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-02-04 20:48:29 / Modified: 20:53:17" itemprop="dateCreated datePublished" datetime="2025-02-04T20:48:29+08:00">2025-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="WESEE-Using-Malicious-VC-Interrupts-to-Break-AMD-SEV-SNP"><a href="#WESEE-Using-Malicious-VC-Interrupts-to-Break-AMD-SEV-SNP" class="headerlink" title="WESEE: Using Malicious #VC Interrupts to Break AMD SEV-SNP"></a>WESEE: Using Malicious #VC Interrupts to Break AMD SEV-SNP</h1><p>IEEE S&amp;P 2024</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NjMyMzI3ZjhiYTRjYmU1M2U3MTM1MzIzNTBjZjgwNzdfRW5FMzNOSmlHUkRGQkdzSnpoVlVnSm9ZTG1ZRVBUUVNfVG9rZW46TDVKNmJtTHJIb25Wb1d4RkZXTGM0NXlmbmxmXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<p>Linux kernel作为最广泛使用的支持CVM的guest OS，攻击面仍然很大，通过精心利用某些漏洞（如恶意中断）可以完成端到端的攻击（root shell）。</p>
<p><a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-25742">&gt; CVE-2024-25742</a></p>
<h2 id="Background：-VC-exception"><a href="#Background：-VC-exception" class="headerlink" title="Background：#VC exception"></a>Background：#VC exception</h2><h3 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h3><p>SEV-ES保护了寄存器，增加GHCB用于Guest-Host通信</p>
<p>当发生某些vmexit时，hypervisor需要当前guest的寄存器信息为guest提供服务</p>
<ul>
<li>cpuid</li>
<li>rdtsc</li>
<li>MMIO</li>
</ul>
<p>引入#VC exception（中断号29） 便于拷贝相应的寄存器信息</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MDBiMjgyYzM4NWEyNDYzM2Q5YjNkN2MzY2ZjNWJiNmNfRXlZUXc3Vmo4cmlaYnBUZ3h2S0paYXJkemNyQUVUcHBfVG9rZW46TzlLdmJWczNmb013NE14ZGRqcWNNamZLbktjXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<p>exception_number和exit_reason可以由软件配置！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svm-&gt;vmcb-&gt;control.event_inj = user_data_npf_ex.exception_number | SVM_EVTINJ_VALID | SVM_EVTINJ_VALID_ERR | SVM_EVTINJ_TYPE_INTR;</span><br><span class="line">svm-&gt;vmcb-&gt;control.event_inj_err = user_data_npf_ex.exception_error_code;</span><br></pre></td></tr></table></figure>

<h3 id="Simple-attack"><a href="#Simple-attack" class="headerlink" title="Simple attack"></a>Simple attack</h3><p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmVjZGJjM2RmNDU4MGFjZTZmNzUwMzc2ZDViOGQ1NjVfWEQ0QXBab0Z5aTUyaDBxa3JYYmF1YVIxRjhhQ25NRzVfVG9rZW46V0dJcGJKZTdEb0JqeUx4Z2d2YmNEdUFHbjFlXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YzFhZGRlODIxYWVhYTE0NjQ0OTE4N2ExMGU1ZjcxODNfWGo0cERFWVFQWUppVEN0THhZYjNuWEFiWTllMW1FMFRfVG9rZW46WTdxN2I2TnZob0dZZUJ4dDlWNWM3WWxZbnNiXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<h3 id="VC-ability"><a href="#VC-ability" class="headerlink" title="VC ability"></a>VC ability</h3><ul>
<li>Chaining multiple #VC</li>
<li>Nesting #VC in non-critical section</li>
</ul>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzk1NGJkYmM5N2Q5MGFmODhhNDhiZDRiZmQzZDBhNzhfQ0tlSE1ZMUg5YTlQV0k5dmdTZnVsVW1iYjRIOEtXUTVfVG9rZW46VDVSa2J4TThEb2hVUlV4NjQwN2N3Qk55bkw3XzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NzYxYTZkYzVlYWYxNzY0YjgzMzBhN2NmODQyY2I5YjlfeTF3TUZEYkx2NkVSa2sxdDFGM2V5OHdpS3NieW5CclpfVG9rZW46Vnc2VWJKZnIxb243VDB4MjJxOWNVSFFBbnBoXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<p>只用vmmcall和mmio read&#x2F;write 三种情况就可以构造足够强大的attack primitives</p>
<h2 id="Attack-Primitives"><a href="#Attack-Primitives" class="headerlink" title="Attack Primitives"></a>Attack Primitives</h2><p>利用vanilla linux内vc_handler的处理逻辑配合恶意#VC中断实现更强大的功能。</p>
<h3 id="Skip-Instructions"><a href="#Skip-Instructions" class="headerlink" title="Skip Instructions"></a>Skip Instructions</h3><p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YTE1ZjViOTExZDljM2MzYmNmYmI3ZDcwNDBmNmU5YjJfWnM3WklhcXN6SmFudzJ6R2lnbHRteHNXV2M2ZzVtM0NfVG9rZW46WlNmbWJiOUZib0R1cTZ4dk1JMGNpcVBsbk5mXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<p>guest的VC handler根据hypervisor的处理结果：</p>
<ul>
<li>OK：增加rip（执行下一行指令）</li>
<li>RETRY：不增加rip（重新执行一遍原指令）</li>
</ul>
<p>exit_reason为vmmcall，rax不进行修改，返回success</p>
<p>记为S</p>
<h3 id="Read-Write-Rax"><a href="#Read-Write-Rax" class="headerlink" title="Read&amp;Write Rax"></a>Read&amp;Write Rax</h3><ul>
<li>exit_reason为vmmcall，rax进行修改，返回success-&gt;记为 WraxS</li>
<li>利用nesting VC 跳过line8-line13，共15行汇编，(WraxS).15S &#x3D; Wrax</li>
</ul>
<h3 id="Reading-Kernel-Memory"><a href="#Reading-Kernel-Memory" class="headerlink" title="Reading Kernel Memory"></a>Reading Kernel Memory</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [rdi], rbx</span><br></pre></td></tr></table></figure>

<p>hypervisor需要rdi指向地址的值与rbx的值</p>
<ul>
<li>并不是直接mov rbx到GHCB，而是有另一块内存（context）进行中转</li>
<li>中转的过程中会使用rax保存rbx的值所在的内存地址，然后用memcpy复制到GHCB</li>
<li>利用Wrax修改rax指向guest secret va，memcpy会把secret 拷贝到GHCB暴露给hypervisor</li>
<li>利用Wrax绕过后续的检查</li>
</ul>
<p>记为Rmem</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YmFkYTlkZGJkZjA4YzFiZDA2ZTdmODMzZTA0NDIxZTJfOWVLZGd3cDlRV0M5YWV2NkdvcUVaR21HVGxlM1czTUNfVG9rZW46SnFHdmJqY216b0gzMEt4UDRIemN3aXRnbkhiXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<h3 id="Writing-Kernel-Memory"><a href="#Writing-Kernel-Memory" class="headerlink" title="Writing Kernel Memory"></a>Writing Kernel Memory</h3><p>Wmem原理同Rmem</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rbx, [rdi]</span><br></pre></td></tr></table></figure>

<p>guest需要把hypervisor提供的值放到寄存器rbx中</p>
<ul>
<li>并不是直接把GHCB内存mov到rbx，而是有另一块内存（context）进行中转</li>
<li>中转的过程中会使用rax保存rbx的值所在的内存地址，然后用memcpy复制到这块地址</li>
<li>利用Wrax修改rax指向guest target va，memcpy会把hypervisor准备的恶意值拷贝到guest私有内存</li>
<li>利用Wrax绕过检查</li>
</ul>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YTA5YmNjNDUyYjQ1NmEyY2EyNjUyOTc4YzNiOWUxMGZfYkp2NEVuVUx5RmRFVHBmc2NVTG9sZ3hoSjFlZUViNDRfVG9rZW46S0JuTmJvWEpSb1o0NDd4MElnOWNzd3FpbnVkXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<h3 id="Arbitrary-Code-Injection"><a href="#Arbitrary-Code-Injection" class="headerlink" title="Arbitrary Code Injection"></a>Arbitrary Code Injection</h3><p>目标：往.text section注入恶意的shellcode</p>
<ul>
<li>提前静态分析，得到内核页表基地址所在地址（不考虑地址随机化的情况下）</li>
<li>Rmem读出页表基地址（CR3的值），Wmem改页表权限</li>
</ul>
<h2 id="Problems-To-be-Solved"><a href="#Problems-To-be-Solved" class="headerlink" title="Problems To be Solved"></a>Problems To be Solved</h2><h3 id="Where-To-Inject-？"><a href="#Where-To-Inject-？" class="headerlink" title="Where To Inject ？"></a>Where To Inject ？</h3><p>绕过ASLR</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ODI1NDEwNDNhYWJhMDA0YjllMjBjMTFkN2VmOTJlOTNfOHhxSjJSRUlJZ3VLUzZVRThwTFZOdk9Hd28ydUZYTHFfVG9rZW46WDJjaGJNWUdGb2tLeE14TzRoN2NKcW1CbmhmXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<ul>
<li>kernel在地址随机化之前，早期的地址是固定的。</li>
<li>提前分析得出kernel在地址随机化之前的最后一个page地址 （0x7a753000）</li>
<li>运行时，这个page之后的page地址就可以计算出随机的PKbase</li>
</ul>
<h3 id="When-To-Inject？"><a href="#When-To-Inject？" class="headerlink" title="When To Inject？"></a>When To Inject？</h3><ul>
<li>离线采样得到page序列，同之前的攻击（Heckler等）</li>
<li>运行时hypervisor修改stage2页表权限，通过page fault得到guest正在执行的page 序列</li>
<li>直接通过guest的符号表可以找到函数对应的固定地址（同PKbase进行计算）</li>
</ul>
<h2 id="Case-studies"><a href="#Case-studies" class="headerlink" title="Case studies"></a>Case studies</h2><h3 id="Leaking-keys-from-Kernel-TLS"><a href="#Leaking-keys-from-Kernel-TLS" class="headerlink" title="Leaking keys from Kernel TLS"></a>Leaking keys from Kernel TLS</h3><p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWNiMGVhNjM3MWI0ODhhZmVhNzQwYjZlNzk3YjE5ZDVfT0pHdXQ2WFpJajZTOVgxRUV6M1VMam9QZDd0VmpIT2JfVG9rZW46WGtBSmJmNnh6b0xOdXB4bDhyV2Mxb01xbndiXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<h3 id="Disabling-Firewall"><a href="#Disabling-Firewall" class="headerlink" title="Disabling Firewall"></a>Disabling Firewall</h3><p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YTI3YzJlNWY5MTRkYThjYmFhMGI5ZTM3MGI0YzUxMzRfM1haVkVXbzlONnhsYTJhTEdGNE1QQTNqTTZuR0Z1eG9fVG9rZW46UnNjSWJDUTExb0VJVjV4QmxodWNacmpWbkZiXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<p>改16bytes</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDVjNTY2Nzc5YzY4NjQ3MTNlMDUzMDQ4MTQzNTBlYmZfSEU2eGZZRHZLT1ZtNmMzQWVpTmlGNHpVNnZXWnpNNkZfVG9rZW46TjhqM2JwekJ3bzBJNGp4MVlDN2M0dGNCbjliXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<p>绕过所有iptables的规则</p>
<h3 id="Gaining-a-Root-Shell-in-the-SEV-SNP-VM"><a href="#Gaining-a-Root-Shell-in-the-SEV-SNP-VM" class="headerlink" title="Gaining a Root Shell in the SEV-SNP VM"></a>Gaining a Root Shell in the SEV-SNP VM</h3><p>利用kernel API：call_usermodehelper</p>
<p>以root权限创建一个用户态进程，参数为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c rm /tmp/t; mknod /tmp/t p;</span><br><span class="line">/bin/sh 0&lt;/tmp/t \| nc -ln 8001 1&gt;/tmp/t</span><br></pre></td></tr></table></figure>

<p>创建一个root shell并通过8001端口向外通信</p>
<p>作者将这段逻辑构造为shellcode （392bytes）并注入到icmp_rcv中，可以通过ping触发</p>
<p>暂时无法在飞书文档外展示此内容</p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><ul>
<li>SEV-SNP</li>
<li>Linux kernel v6.5.0</li>
<li>Ubuntu 20.04.6 LTS</li>
<li>QEMU v8.0.0</li>
</ul>
<h3 id="Primitives"><a href="#Primitives" class="headerlink" title="Primitives"></a>Primitives</h3><ul>
<li>216450 instruction skips&#x2F;s </li>
<li>9.25 memory reads&#x2F;s</li>
<li>8.95 memory writes&#x2F;s</li>
</ul>
<h3 id="Case-studies-1"><a href="#Case-studies-1" class="headerlink" title="Case studies"></a>Case studies</h3><p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NDAxNmM3ZTg1MjljMGNlMTMzZmNlMTI2NmRlNjc3ZTBfd0U2alJKZnFXUVh3RGs5dVlOZWpCTEt2MGNObU1UVWhfVG9rZW46UXNHOGI0WGdHb0xNNkp4TG13SWNLWDEybndjXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<p>分别需要5.97 0.36 8.1s</p>
<h2 id="Defense"><a href="#Defense" class="headerlink" title="Defense"></a>Defense</h2><p><a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e3ef461af35a8c74f2f4ce6616491ddb355a208f">x86&#x2F;sev: Harden #VC instruction emulation somewhat</a></p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YzM1ZTVlMzE1ZTIxZDcxMDMxMTkzNjZkZjQ4NDljNjFfQnhkN1BIdHFoVFRpbUtGcTg5dmxkNTU3UEpKcFh4NFZfVG9rZW46WFkzOWJBU3l6b2xtVHl4a3NRVGNBcVBDbjBnXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWFjYTcwY2I5MDNmMTkzMjRiMDE3MDYyYTUzZmQ2MzdfcjJZc3BPU1pwV1NYTUlOcWY3eG1mU0QzeXN5MlMyS0xfVG9rZW46S0tXMGJTVWFFb0tBRGN4WUh4WGN1MXAxbjRlXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2025/02/04/papers/FetchBPF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/04/papers/FetchBPF/" class="post-title-link" itemprop="url">FetchBPF: Customizable Prefetching Policies in Linux with eBPF</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-02-04 20:45:13 / Modified: 20:53:17" itemprop="dateCreated datePublished" datetime="2025-02-04T20:45:13+08:00">2025-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="FetchBPF-Customizable-Prefetching-Policies-in-Linux-with-eBPF"><a href="#FetchBPF-Customizable-Prefetching-Policies-in-Linux-with-eBPF" class="headerlink" title="FetchBPF: Customizable Prefetching Policies in Linux with eBPF"></a>FetchBPF: Customizable Prefetching Policies in Linux with eBPF</h1><p>ATC’24</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjg4YWYzNDI2Y2E2ZGNjZDliMDRhNTgwNTU1ZmZlMDJfWDFTczE1UVBzYkswT2dlQ3Y4ekdHUlhPUmp1MVpzNXJfVG9rZW46SFJSbGJyeEpBb2F1aVR4YzlEcWMzOHhabnJnXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA" alt="img"></p>
<p>基于eBPF设计了一个框架，使得用户可以定制自己的memory prefetch策略</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>linux的某些策略平均表现很好，但是很难在特定的情况下取得最好的性能。</p>
<h3 id="Memory-prefetching"><a href="#Memory-prefetching" class="headerlink" title="Memory prefetching"></a>Memory prefetching</h3><p>内存压力大时，内存页会被swap out，之后需要用时，swap in会很慢</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NjZmOWIyOWFhNDg0NTRhMDhlNTZhZGRlMTIyM2M5N2RfODdJWE95ZW02M0dDaGdEREJSTzg5TzhYSHBicTFzRHJfVG9rZW46UXA2R2JhdzVEb2VjYkx4cTMzdWNvc0ZBblFoXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA" alt="img"></p>
<p>为了提高性能，操作系统会预测哪些swapped out的pages可能会被用到，prefetch这些pages</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjJkNGY3OGUzZDMyNDY4NDVlYTE4ZTc4OGE5MTIxNjhfZERmWmI3S001RXpLem5QdGFPVXRaUmtvU0NkMXNKckFfVG9rZW46R3RYcGJxNXFub2N2MGZ4alNxY2NJYlhKbnJmXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA" alt="img"></p>
<p>一个好的prefetch策略需要兼顾Accuracy与Coverage：</p>
<ul>
<li>Coverage：cache hits &#x2F; (cache hits + cache misses) 尽可能让之后可能发生的page fault的pages都被prefetch到</li>
<li>Accuracy：cache hits &#x2F; prefetch pages 需要保证不能prefetch太多没用的page 反而拖慢了性能</li>
</ul>
<h4 id="Linux-default-prefetch-policy"><a href="#Linux-default-prefetch-policy" class="headerlink" title="Linux default prefetch policy"></a>Linux default prefetch policy</h4><ul>
<li>只考虑sequantial pattern</li>
<li>只看过去2个page fault，如果连续，则prefetch连续的后几个pages</li>
</ul>
<h4 id="SOTA-prefetch-policy"><a href="#SOTA-prefetch-policy" class="headerlink" title="SOTA prefetch policy"></a>SOTA prefetch policy</h4><ul>
<li>LEAP：ATC‘20</li>
<li>HoPP：HPCA‘23</li>
</ul>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MWQ4M2EzZGE2MjU0Njc5NWY0MDRhOGFkMWVhNDg1NTJfRTVNY2dFZ241M3Z0Q2FIWmlIY2ljNWpaZlM3UDhVaDBfVG9rZW46T2lLbWJwa2VOb2FXQWR4Y0VmTWNxZkZSbnZiXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA" alt="img"></p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Y4NDdlZmJlMjI5Y2E0NzY4ZGZlOTJjMDU5ZmQ1NWFfZGl5cGF1MXB2WmVqbUdNcElWTjVQUGJNeEJub290N3BfVG9rZW46QXVlM2JDdnZZbzNHSzB4NlVOOWNZSllLblFiXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA" alt="img"></p>
<h4 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h4><p>不同allocation pattern和不同access pattern下 各个memory prefetch policy的性能表现</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MmI4MjIyYjk4ZjI5Yjc5YTRkMTE1NzJiY2JiOGFiYTJfUklQWFZpUkFJVjZmOXNNOVVrdWFDV3dkcEViQXhzdUhfVG9rZW46QWo3QmJaZGQ2b0hVZTl4YXVJS2N6Ykg0bkpoXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA" alt="img"></p>
<p>结论：没有一个policy会在任何条件下比其他的policy都好。需要最适合某个application，必须为这个application定制policy</p>
<h3 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a>eBPF</h3><blockquote>
<p>eBPF 是一项革命性的技术，起源于 Linux 内核，它可以在特权上下文中（如操作系统内核）运行沙盒程序。它用于安全有效地扩展内核的功能，而无需通过更改内核源代码或加载内核模块的方式来实现。</p>
</blockquote>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MzdhY2I4MzY3NTUwZGM1YjI1MDNjYjBlOTk3MjRmOTNfUlhRWnNGMnQyWGNnOFVPMWZ1a3hnY1EyMEplSWZLMFpfVG9rZW46VTU1Y2IzQVpHb0lTaUR4QlFMT2NDVXR0bjJjXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA" alt="img"></p>
<h2 id="Strawman-design"><a href="#Strawman-design" class="headerlink" title="Strawman design"></a>Strawman design</h2><p>改linux 实现多种prefetch policy ，根据历史的memory access pattern进行动态切换</p>
<p>问题</p>
<ol>
<li>难以支持任意数量的policy</li>
<li>很难存在一个特定的policy集合 可以适应所有的access pattern</li>
<li>在linux中实现工程量大</li>
<li>需要说服linux上游接受 需要耗费更多精力和时间</li>
</ol>
<h2 id="Design-and-implementation"><a href="#Design-and-implementation" class="headerlink" title="Design and implementation"></a>Design and implementation</h2><p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MjFmMTBhNDY2NWIxOGUyNGQ3MjUxMmMwM2ZlOWI2YjNfU3NrQ3ptdTI5MjhoQW96RVBtWXZkNVBmY3h3dTZmVXVfVG9rZW46U3BmTmJzRjFXb2N5cDF4MkNPZmNBWFpmbkplXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA" alt="img"></p>
<h3 id="eBPF-Hook"><a href="#eBPF-Hook" class="headerlink" title="eBPF Hook"></a>eBPF Hook</h3><ul>
<li>(A)prefetch_stats：page fault时触发，用于记录fault pages的历史信息，便于policy找到access pattern</li>
<li>(B)prefetch_policy：执行prefetch policy时触发，需要根据算法找到需要prefetch的pages并且请求prefetch 这些pages</li>
</ul>
<h3 id="Helper-Functions"><a href="#Helper-Functions" class="headerlink" title="Helper Functions"></a>Helper Functions</h3><ul>
<li>(1)bpf_prefetch_physical_page：根据物理地址发出I&#x2F;O请求</li>
<li>(2)bpf_prefetch_virtual_page：根据虚拟地址发出I&#x2F;O请求</li>
<li>(3)bpf_&lt;start&#x2F;stop&gt;_block_plug：选择性batch上两个接口发出的I&#x2F;O请求</li>
</ul>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=OTc4MDBhYTVlODYyZGE3N2ZkYzVmZjkyYjljNDNlYmRfN0xlQ3pFZE1JTWo2Mk9kZ1RGTnJhcmFGZTZYcE9xN1RfVG9rZW46TTA4UmJ1WlJZb2xIU0F4ZVdURmNqczRPblRmXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA" alt="img"></p>
<h3 id="Policy-example-LEAP"><a href="#Policy-example-LEAP" class="headerlink" title="Policy example(LEAP)"></a>Policy example(LEAP)</h3><ul>
<li>eBPF map: 存储memory access history</li>
<li>prefetch_stats: 在map中存入page fault地址以及与前一个page fault地址的差</li>
<li>prefetch_policy：用Boyer-Moore识别出majority stride，调用bpf_prefetch_physical_page进行prefetch</li>
</ul>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h3 id="Microbenchmarks"><a href="#Microbenchmarks" class="headerlink" title="Microbenchmarks"></a>Microbenchmarks</h3><p>分配5GB array</p>
<p>Allocation patterns：</p>
<ul>
<li>Sequential allocation（sqn）</li>
<li>Random allocation（random）：模拟多个线程同时alloc pages （这种情况使用virtual address会比physical address好）</li>
</ul>
<p>Access patterns：</p>
<ul>
<li>Sequential（sqn）</li>
<li>stride（stride）：相隔3 pages</li>
<li>ladder（ladder）：increasing stride</li>
</ul>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDY1N2ExNWVmOWI1MDE3OWViZjgzZWI2YjE1MjU5ZWRfTVNNZ0Q5SHdYNlNkSGYzaldUNnpkUk9TbGRFbm5vM0ZfVG9rZW46SDFBMmJpRWREb0VCR1R4TGtsZ2Nwd1hFbnZlXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA" alt="img"></p>
<ul>
<li>Accuracy、Coverage： eBPF实现版本与linux kernel版本几乎完全一致</li>
<li>Execution time：eBPF带来的overhead可以忽略不计</li>
</ul>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YjZkY2UzZTNiZDgzZTM0Yjg2MTIwNjA4OWM4MmVjODJfcUE2Z3NCQW5PVTBXV2t3dkY4WmFnZ1NwVVF3aTNTOWpfVG9rZW46QWRFbmJzblRib2UyTm14eUhVemNkSWVVbmFiXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA" alt="img"></p>
<ul>
<li>latency大部分的开销在page retrieval （I&#x2F;O）</li>
<li>eBPF程序被JIT编译为机器指令，性能与kernel functions差别不大</li>
</ul>
<h3 id="Macrobenchmarks"><a href="#Macrobenchmarks" class="headerlink" title="Macrobenchmarks"></a>Macrobenchmarks</h3><ul>
<li>VoltDB上运行TPC-C</li>
<li>Redis’ memtier benchmark</li>
<li>Twitter dataset上运行PageRank与betweeness centrality</li>
</ul>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDc4NDQzYWNhMTExYzVjN2I3NjdjYWFlNjU4ZWRhOGNfbVl2U0ZpaVpNWG9JRU52ZzNNUXhHMmF0ZThuVEo1YUtfVG9rZW46TmZkZ2JhWWg1bzBINll4UFNsaGM2YzU4bmdwXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA" alt="img"></p>
<ul>
<li>对比policy及与之对应的eBPF版本，仍然没有明显的性能差别</li>
<li>好的policy在可用内存少时优势更明显</li>
</ul>
<p>关于VMA policy作者的解释：这些对性能要求极高的程序耗费了大量的时间为linux的prefetch policy做了优化</p>
<p>FetchBPF希望改变这种方式，设计policy去适配application，而不是优化application的访存模式去适配policy</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>本文基于eBPF设计了框架FetchBPF，使得用户可以根据程序的访存模式自定义内存预取策略来达到最优的性能。FetchBPF框架可以在几乎没有额外性能开销的情况下达到一致的内存预取功能。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2025/02/04/papers/Sabre/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/04/papers/Sabre/" class="post-title-link" itemprop="url">Sabre: Hardware-Accelerated Snapshot Compression for Serverless MicroVMs </a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-02-04 20:44:14 / Modified: 20:53:17" itemprop="dateCreated datePublished" datetime="2025-02-04T20:44:14+08:00">2025-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>4 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Sabre-Hardware-Accelerated-Snapshot-Compression-for-Serverless-MicroVMs"><a href="#Sabre-Hardware-Accelerated-Snapshot-Compression-for-Serverless-MicroVMs" class="headerlink" title="Sabre: Hardware-Accelerated Snapshot Compression for Serverless MicroVMs"></a>Sabre: Hardware-Accelerated Snapshot Compression for Serverless MicroVMs</h1><p>OSDI24</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MTNkYmUwZDlhYjFmN2RkMWZjY2EzMThhMzRmMGM0NDNfN3RIV0RvUkZZb1JvQTJzdk1IekhNam0wOWF2N3NWTGVfVG9rZW46QWpiZ2JBaVhIb0FLQnR4T0h3UGNzN0VRbjJlXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA" alt="img"></p>
<p>利用硬件加速器IAA压缩VM snapshot，优化serverless场景下microVM cold start慢的问题</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>问题：serverless场景下microVM冷启动 启动时间久</p>
<ul>
<li>解决方案：采用VM snapshot 把guest VM memory存到文件里 下次读文件恢复而不是从头启动</li>
</ul>
<p>问题：如果存了整个guest memory restore的时候全部load进去太大了</p>
<ul>
<li>解决方案: on-demand paging，触发page fault才映射 和传统进程&#x2F;VM 一样 （现有系统如firecracker采用的方式 baseline1）</li>
</ul>
<p>问题：page fault导致性能差</p>
<ul>
<li>解决方案：prefetch 预测工作集（working set）<ul>
<li>REAP（record-and-replay）是asplops21加速snapshot的方案，提出用working set记录一次function call的pages prefetch这些page （SOTA方案 baseline2）</li>
</ul>
</li>
</ul>
<p>snapshot和WS file的大小很影响效率 越小性能越好 </p>
<ul>
<li>解决方案：压缩</li>
</ul>
<p>问题：解压缩占时间 且在cold start关键路径上</p>
<h2 id="IAA"><a href="#IAA" class="headerlink" title="IAA"></a>IAA</h2><h3 id="IAA介绍"><a href="#IAA介绍" class="headerlink" title="IAA介绍"></a>IAA介绍</h3><p>Intel In-Memory Analytic Accelerator 集成在CPU SoC上的一个PCIe设备</p>
<p>用户态应用向IAA工作队列提交请求</p>
<p>目前主要用在数据库上</p>
<p>IAA提供C接口 直接用intel提供的库</p>
<p>相对于就是最简单的压缩的接口 源数据(uint8*)&lt;–&gt;压缩后的数据(uint8*)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">qpl_path_t</span> execution_path = qpl_path_software;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">source</span><span class="params">(source_size, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">destination</span><span class="params">(source_size / <span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">reference</span><span class="params">(source_size, <span class="number">7</span>)</span></span>;</span><br><span class="line">std::unique_ptr&lt;<span class="type">uint8_t</span>[]&gt; job_buffer;</span><br><span class="line"><span class="type">uint32_t</span>                   size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Job initialization</span></span><br><span class="line">qpl_status status = <span class="built_in">qpl_get_job_size</span>(execution_path, &amp;size);</span><br><span class="line"><span class="keyword">if</span> (status != QPL_STS_OK) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;An error &quot;</span> &lt;&lt; status &lt;&lt; <span class="string">&quot; acquired during job size getting.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">job_buffer   = std::<span class="built_in">make_unique</span>&lt;<span class="type">uint8_t</span>[]&gt;(size);</span><br><span class="line">qpl_job* job = <span class="built_in">reinterpret_cast</span>&lt;qpl_job*&gt;(job_buffer.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">status = <span class="built_in">qpl_init_job</span>(execution_path, job);</span><br><span class="line"><span class="keyword">if</span> (status != QPL_STS_OK) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;An error &quot;</span> &lt;&lt; status &lt;&lt; <span class="string">&quot; acquired during job initializing.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Performing a compression operation</span></span><br><span class="line">job-&gt;op            = qpl_op_compress;</span><br><span class="line">job-&gt;level         = qpl_default_level;</span><br><span class="line">job-&gt;next_in_ptr   = source.<span class="built_in">data</span>();</span><br><span class="line">job-&gt;next_out_ptr  = destination.<span class="built_in">data</span>();</span><br><span class="line">job-&gt;available_in  = source_size;</span><br><span class="line">job-&gt;available_out = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(destination.<span class="built_in">size</span>());</span><br><span class="line">job-&gt;flags         = QPL_FLAG_FIRST | QPL_FLAG_LAST | QPL_FLAG_DYNAMIC_HUFFMAN | QPL_FLAG_OMIT_VERIFY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compression</span></span><br><span class="line">status = <span class="built_in">qpl_execute_job</span>(job);</span><br><span class="line"><span class="keyword">if</span> (status != QPL_STS_OK) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;An error &quot;</span> &lt;&lt; status &lt;&lt; <span class="string">&quot; acquired during compression.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> compressed_size = job-&gt;total_out;</span><br></pre></td></tr></table></figure>

<h3 id="IAA能力探索"><a href="#IAA能力探索" class="headerlink" title="IAA能力探索"></a>IAA能力探索</h3><p>对比用IAA硬件压缩与软件压缩的性能：</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YWQwYjU3Mzk1NGM5YjFmMTg5YjkxNTkzZjgxZjUyZDRfYXd0QzNYTWlBdVRUTGVUaEEwVUV6V2wxRkxKTk1BTlNfVG9rZW46SGtnWmJLTVdDb1FrY3p4amwyd2N2eGZYbjViXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA" alt="img"></p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NjQwYzQyNmIwYTBkNTZmMmI2OWFkZjQzM2FiMmQ3ZTBfZ0xLaHo1UXM3TUtZWlVFYlBlNU1IQzhDVUlpWW1maFFfVG9rZW46U2tyQ2JXWEMwb2Q0cTB4eWZRNWNnVnZybk5jXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA" alt="img"></p>
<p>用硬件压缩比软件快（可以支持异步，不占用CPU cycle， 但是这个工作没用到）</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDFkZDNkNTc2NDQzY2EyOWI1MTc1ZTRmMDQ4MmRjZmVfUG95aGpkdEdQMkxjMHRZODNLSTBHN0lMYmhzQVBWMEhfVG9rZW46VnUxQ2JqT3d0bzRmUml4SnpKTWNSOFRhbnZnXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA" alt="img"></p>
<p>可扩展性没问题</p>
<p>后续测试仍用single thread single job完成</p>
<p>PRS(<em>Page Request Service</em> ) IAA集成了处理page fault的功能</p>
<p>不需要操作系统先把文件内容读到内存里，可以用mmap 然后硬件通过PRS拿到数据</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NGZmNjI0MGU5MDRhNzA1NmUwMzdmNTA3MGI1MjFhMTlfcnNDMDhWSVRoaERTekp0NHFTQ2F0MTM2cldHY0RaRmVfVG9rZW46THprcmJvZ0Iyb1Eyb014OWhYRGNiTXJsbktmXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA" alt="img"></p>
<ul>
<li>Decompress比Disk Read要快，不会拖慢整体时间</li>
<li>O_DIRECT是为了绕过page cache提高性能（REAP使用的优化方式之一）</li>
<li>Disk Read与Disk Read+Decompress重合 -&gt; decompress和disk read overlap 是streaming的操作</li>
</ul>
<p>这里对IAA的测试和分析理论上提出了应用于microVM snapshot性能提升的可行性</p>
<h2 id="sabre-design"><a href="#sabre-design" class="headerlink" title="sabre design"></a>sabre design</h2><p>扩展压缩&#x2F;解压一段数据的功能至：</p>
<ol>
<li>压缩&#x2F;解压多块内存区域</li>
<li>压缩的数据存到文件，恢复时读取再解压</li>
</ol>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQ2MDEwY2M5ZGVmY2Q1NjY0MDUwM2NjN2E2ZjMwODRfSEV1aHI4cTExazVlM2w3S1RRM2FzMjN1Q1Y0cnpBVG1fVG9rZW46SUptYmI1emtNb1lhSER4dTBsdGNIS1RqbkZkXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA" alt="img"></p>
<p>snapshot保存memory之外还会保存memory partition压缩前后的位置信息</p>
<p>snapshot和prefetch各提出了两种方案</p>
<h3 id="snapshot"><a href="#snapshot" class="headerlink" title="snapshot"></a>snapshot</h3><ol>
<li>每块不连续的内存先复制到一块连续的buffer上，然后压缩一次</li>
<li>每块不连续的内存独立压缩，压缩后的数据连续存到磁盘里</li>
</ol>
<h3 id="prefetch"><a href="#prefetch" class="headerlink" title="prefetch"></a>prefetch</h3><ol>
<li>解压一次，根据记录的信息恢复到不同的内存区域（通过userfaultfd，多一次memory copy 但是因为DMA连续 所以性能好）</li>
<li>根据记录的信息解压多次</li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="microbenchmark"><a href="#microbenchmark" class="headerlink" title="microbenchmark"></a>microbenchmark</h3><p>先和不压缩比，然后和软件压缩比</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MWI1YjQxMjVkOGQ4ODI3MmQwNmM5Y2RkMjJjNDIyNzlfVFhKa0pESmFZVzgwbzVaR0ZWVkE4R0U2YlU0SnZ2ejFfVG9rZW46UFdGR2I3ZDRlb2pIT0Z4OEhhemNva0NablVnXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA" alt="img"></p>
<p>passthrough表示读不压缩的snapshot(174.5MB)</p>
<p>sparsity表示连续page大小 1表示每个page都被一个empty page隔开</p>
<p>压缩率是2.2x 所以考虑到磁盘读，最大的加速比就是2.2 sabre是1.9</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=N2M1YmViNTQ0NGJmMzIyMjk0OGNkZDA0ZDE5MGFkM2NfdERBQXpqa2RMdmJlcWhVaWtKTDEzZDlQOTREeFo5N3lfVG9rZW46SU1aOGJYOEw5b20xTUl4WkFaN2NQSzBOblFkXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA" alt="img"></p>
<p>比较软件方案</p>
<ul>
<li>create：IAA最快</li>
<li>restore-single：IAA最快</li>
<li>restore-scattered: 稀疏性越弱IAA越快</li>
</ul>
<h3 id="end-to-end"><a href="#end-to-end" class="headerlink" title="end-to-end"></a>end-to-end</h3><p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjg5ZjM1NzY2NzhlNDc1YTNjM2RkYTZkNjllMDZkNzZfQ3IxVzlGMndEaW9HenRDaDlFeUdpUHNTMTBPakNSQUJfVG9rZW46SXZSWGJqMWJkb0dCaDF4bHE2TGNQWjhzbjFiXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA" alt="img"></p>
<p>已经集成到firecracker中</p>
<p>使用KVM提供的dirty pages Diff Snapshot</p>
<p>数据大，粒度粗，选择用scattered（没有对比）</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YzQ2OWFkY2JkYjEyOTI3OTE0Y2E1Mjc4YjQzNTU1MjdfcERyOE1qTzdUcUNQbWJDb2N3VUtzRzIzMVd6OHJDb01fVG9rZW46Tkd0Z2JKTVlObzdNcEd4eFdsMmN1cVlRbjFmXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA" alt="img"></p>
<p>baseline是snapshot 不压缩 不prefetch</p>
<ul>
<li>baseline使用on-demand paging VM load的时候耗时少 但是函数调用会触发一系列page fault</li>
<li>Sabre在VM load时需要恢复guest memory 耗时多 但是prefetch了内存 函数调用快</li>
</ul>
<p>最高64% cold start加速</p>
<p>和SOTA方案REAP比</p>
<p>REAP的working set记录的page比较分散 选择用single-chunk（没有对比）</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NWM2MmE4YjM2NDU2Mjk5ODhhZWJjNWQzY2FlNTYwZjNfaWtvWlRhZ2lrcE01Q01JelFRMjNlemdzYjZleFVEYXRfVG9rZW46WE1GbmJoaHU2b0JJUWR4TWVvQ2NIRkVpbmhlXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA" alt="img"></p>
<p>Working set对于一个固定的应用来说是不变的，sabre压缩了WS file 所以性能更好了</p>
<p>以cnn-image-classification为例，压缩比为3.10 prefetch加速38.73% 又因为该场景中REAP prefetch耗时占比大 最终Sabre达到19.2%的优势</p>
<p>对function invocation占比大的场景优势不明显（这个serverless函数本身启动耗时）</p>
<p><img src="https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MDBiYzUxYWE0NTg0ZmM3YjIxNDZjM2FjYjU0ZDdiMmFfYzc0Tm1abU9LbzhUSDdJbk96MnUyMmFsdU9ET0NkeGFfVG9rZW46RWc3VmJsbXFwb1JOM0h4aUdsbmNzQnVMbkdkXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>创新地提出把硬件加速器IAA应用于压缩VM snapshot，并通过合理的设计成功加速了microVM cold start</p>
<h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><ol>
<li>IAA加速压缩&#x2F;解压是否可以应用在其他场景中？ (有正在进行的VM migration的工作<a target="_blank" rel="noopener" href="https://lore.kernel.org/all/20240319164527.1873891-1-yuan1.liu@intel.com/T/%EF%BC%89">https://lore.kernel.org/all/20240319164527.1873891-1-yuan1.liu@intel.com/T/）</a></li>
<li>探索新硬件提供的其他功能</li>
</ol>
<ul>
<li>IAA：加密、CRC offload、data filtering等<a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/content-details/721858/intel-in-memory-analytics-accelerator-architecture-specification.html">https://www.intel.com/content/www/us/en/content-details/721858/intel-in-memory-analytics-accelerator-architecture-specification.html</a></li>
<li>其他硬件 例如DLB<a target="_blank" rel="noopener" href="https://www.intel.cn/content/www/cn/zh/products/docs/processors/xeon-accelerated/4th-gen-xeon-scalable-processors-product-brief.html">https://www.intel.cn/content/www/cn/zh/products/docs/processors/xeon-accelerated/4th-gen-xeon-scalable-processors-product-brief.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2024/09/17/virtualization/virtualization-misc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/17/virtualization/virtualization-misc/" class="post-title-link" itemprop="url">virtualization misc</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-09-17 19:48:04" itemprop="dateCreated datePublished" datetime="2024-09-17T19:48:04+08:00">2024-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/virtualization/" itemprop="url" rel="index"><span itemprop="name">virtualization</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>8k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>7 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="virtualization-misc"><a href="#virtualization-misc" class="headerlink" title="virtualization misc"></a>virtualization misc</h1><h2 id="host上开启嵌套虚拟化"><a href="#host上开启嵌套虚拟化" class="headerlink" title="host上开启嵌套虚拟化"></a>host上开启嵌套虚拟化</h2><p><a target="_blank" rel="noopener" href="https://www.linux-kvm.org/page/Nested_Guests">Nested Guests - KVM (linux-kvm.org)</a></p>
<p>看<code>/sys/module/kvm_intel/parameters/nested</code> </p>
<p>可以修改vmx.c<code>static bool __read_mostly nested = 1;</code>然后重新编译kvm模块</p>
<p>host VM <code>cat /proc/cpuinfo | grep vmx</code>有内容说明配置正确</p>
<p>此时跑kvm-hello-world没问题</p>
<p><code>qemu-img resize xxx.img +10G</code>可以加磁盘容量；编译内核需要的内存比较大，开4G</p>
<h2 id="hostVM-编译内核模块"><a href="#hostVM-编译内核模块" class="headerlink" title="hostVM 编译内核模块"></a>hostVM 编译内核模块</h2><p>环境变量有问题</p>
<p>单独编译kvm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  CC [M]  /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm/mmu/mmu.o</span><br><span class="line">In file included from /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm/trace.h:1741,</span><br><span class="line">                 from /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm/x86.c:86:</span><br><span class="line">./include/trace/define_trace.h:95:42: fatal error: ../../arch/x86/kvm/trace.h: No such file or directory</span><br><span class="line">   95 | #include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span><br><span class="line">      |                                          ^</span><br><span class="line">compilation terminated.</span><br><span class="line">make[1]: *** [scripts/Makefile.build:297: /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm/x86.o] Error 1</span><br><span class="line">make[1]: *** Waiting for unfinished jobs....</span><br><span class="line">make: *** [Makefile:1914: /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm] Error 2</span><br><span class="line">make: Leaving directory &#x27;/usr/src/linux-headers-5.15.0-75-generic&#x27;</span><br><span class="line">make: *** [Makefile:46: update] Error 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p>把<code>kvm/trace.h</code>的相对路径改为绝对路径</p>
<p>不知道为什么linux会被替换为1，还得把路径的linux给去掉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> TRACE_INCLUDE_PATH</span></span><br><span class="line"><span class="comment">//#define TRACE_INCLUDE_PATH ../../arch/x86/kvm</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRACE_INCLUDE_PATH /usr/src/source-5.15.0/source-5.15.0/arch/x86/kvm</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> TRACE_INCLUDE_FILE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRACE_INCLUDE_FILE trace</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="hostVM加载内核模块"><a href="#hostVM加载内核模块" class="headerlink" title="hostVM加载内核模块"></a>hostVM加载内核模块</h2><p>编译没问题，加载模块出错</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod /usr/src/source-5.15.0/source-5.15.0/arch/x86/kvm/kvm.ko</span><br><span class="line">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, 0000000</span><br><span class="line">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero              for</span><br><span class="line">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonz                ero</span><br><span class="line">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is non                 znsmod: ERROR: could not insert module /usr/src/source-5.15.0/source-5.15.0/arch/x86/kvm/kvm.                 [  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, oc 00000000</span><br><span class="line">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, oc 0000000</span><br><span class="line">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, oc 00000</span><br><span class="line">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1,</span><br><span class="line">loc 00000000392e449f, val ffffffffc0777953</span><br><span class="line">insmod: ERROR: could not insert module /usr/src/source-5.15.0/source-5.15.0/arch/x86/kvm/kvm.ko: Invalid modul</span><br><span class="line">e `n`k`j`nformat</span><br><span class="line">make: *** [Makefile:49: update] Error 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/71746914/linux-kernel-module-development-module-x86-modules-skipping-invalid-relocatio">c - Linux Kernel Module Development “module: x86&#x2F;modules: Skipping invalid relocation target, existing value is nonzero for type 1” - Stack Overflow</a></p>
<p>执行第一句后系统提示换内核并重启，从75-generic换到76-generic 然后就好了</p>
<p>目前的img</p>
<ul>
<li><p>内核代码</p>
</li>
<li><p>make bison flex等编译内核的工具</p>
</li>
<li><p>brctl tunctl ifconfig配网络</p>
</li>
<li><p>kvm-hello-world用于简单测试</p>
<p>ubuntu.img镜像，启动脚本</p>
</li>
</ul>
<h2 id="hostVM启动guestVM"><a href="#hostVM启动guestVM" class="headerlink" title="hostVM启动guestVM"></a>hostVM启动guestVM</h2><p>启动后出错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Booting from Hard Disk...</span><br><span class="line">error: invalid arch-independent ELF magic.</span><br><span class="line">Entering rescue mode...</span><br><span class="line">grub rescue&gt;</span><br></pre></td></tr></table></figure>

<p>镜像有问题，换镜像就好了</p>
<h2 id="hostVM编译内核"><a href="#hostVM编译内核" class="headerlink" title="hostVM编译内核"></a>hostVM编译内核</h2><p>整体编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/objtool/include/objtool/elf.h:10:10: fatal error: gelf.h: No such fy</span><br><span class="line">   10 | #include &lt;gelf.h&gt;</span><br><span class="line">      |          ^~~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">compilation terminated.</span><br><span class="line">make[3]: *** [/usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/build/Makefile.build:97: /usr/src/linux-source-5.15.01</span><br><span class="line">make[2]: *** [Makefile:56: /usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/objtool/objtool-in.o] Error 2</span><br><span class="line">make[1]: *** [Makefile:69: objtool] Error 2</span><br><span class="line">make: *** [Makefile:1417: tools/objtool] Error 2</span><br><span class="line">make: *** Waiting for unfinished jobs....</span><br><span class="line">make[4]: *** [/usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/build/Makefile.build:97: /usr/src/linux-source-5.15.01</span><br><span class="line">make[4]: *** Waiting for unfinished jobs....</span><br><span class="line">  CC      /usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/bpf/resolve_btfids/libbpf/staticobjs/ringbuf.o</span><br><span class="line">libbpf.c:47:10: fatal error: libelf.h: No such file or directory</span><br><span class="line">   47 | #include &lt;libelf.h&gt;</span><br><span class="line">      |          ^~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">make[4]: *** [/usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/build/Makefile.build:97: /usr/src/linux-source-5.15.01</span><br><span class="line">make[3]: *** [Makefile:158: /usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/bpf/resolve_btfids/libbpf/staticobjs/li2</span><br><span class="line">make[2]: *** [Makefile:48: /usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/bpf/resolve_btfids//libbpf/libbpf.a] Err2</span><br><span class="line">make[1]: *** [Makefile:72: bpf/resolve_btfids] Error 2</span><br><span class="line">make: *** [Makefile:1417: tools/bpf/resolve_btfids] Error 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42000667/article/details/125205105">fatal error: libelf.h: No such file or directory 解决方案_正义之兔的博客-CSDN博客</a></p>
<p>之后编译会报更多的错</p>
<p>解决方案：</p>
<p>不在VM里面编译，在host上编译</p>
<p>换了一台电脑 出现找不到某个.so</p>
<p>解决方案：</p>
<p><code>sudo ln -s /snap/core20/1974/usr/lib/x86_64-linux-gpu/libcrypto.so.1.1 /usr/lib/libcrypto.so.1.1</code></p>
<h2 id="host用自定义内核启动hostVM"><a href="#host用自定义内核启动hostVM" class="headerlink" title="host用自定义内核启动hostVM"></a>host用自定义内核启动hostVM</h2><p>内核启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">VFS: Cannot open root device &quot;vda1&quot; or unknown-block(0,0): error -6</span><br><span class="line">[    0.485922] Please append a correct &quot;root=&quot; boot option; here are the available partitions:</span><br><span class="line">[    0.486970] 0b00         1048575 sr0</span><br><span class="line">[    0.486971]  driver: sr</span><br><span class="line">[    0.487755] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br><span class="line">[    0.488791] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.15.18 #3</span><br><span class="line">[    0.489541] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 044</span><br><span class="line">[    0.490981] Call Trace:</span><br><span class="line">[    0.491304]  dump_stack+0x6d/0x8b</span><br><span class="line">[    0.491730]  panic+0xf7/0x25a</span><br><span class="line">[    0.492111]  mount_block_root+0x1f6/0x2da</span><br><span class="line">[    0.492623]  ? set_debug_rodata+0x34/0x34</span><br><span class="line">[    0.493134]  mount_root+0x38/0x3a</span><br><span class="line">[    0.493560]  prepare_namespace+0x139/0x18e</span><br><span class="line">[    0.494087]  kernel_init_freeable+0x22c/0x259</span><br><span class="line">[    0.494640]  ? rest_init+0xb0/0xb0</span><br><span class="line">[    0.495075]  kernel_init+0xe/0x110</span><br><span class="line">[    0.495507]  ret_from_fork+0x35/0x40</span><br><span class="line">[    0.495981] Kernel Offset: 0x1c400000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)</span><br><span class="line">[    0.497305] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p>不用host的config，用<code>make defconfig</code></p>
<h2 id="hostVM使用kvm模块"><a href="#hostVM使用kvm模块" class="headerlink" title="hostVM使用kvm模块"></a>hostVM使用kvm模块</h2><p>没有内核模块kvm 手动复制进去加载会报格式错误</p>
<p><code>/lib/modules</code>只有原来的版本 和新的内核版本对不上</p>
<p>解决方案：</p>
<p>config加入<code>CONFIG_KVM=y</code>及<code>CONFIG_KVM_INTEL=y</code></p>
<h2 id="hostVM使用virtio-balloon模块"><a href="#hostVM使用virtio-balloon模块" class="headerlink" title="hostVM使用virtio-balloon模块"></a>hostVM使用virtio-balloon模块</h2><p><code>CONFIG_VIRTIO_BALLOON=m</code> 传入hostVM insmod加载 lsmod查看</p>
<p>实际上可以用y直接编译进内核 即使lsmod看不见也是可用的</p>
<p>qemu加入启动参数 这样qemu monitor有balloon相关命令 但是可能失效</p>
<p>guest中balloon加载mod后会瞬间起效</p>
<h2 id="guestVM内存超过hostVM"><a href="#guestVM内存超过hostVM" class="headerlink" title="guestVM内存超过hostVM"></a>guestVM内存超过hostVM</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@jammy:~$ ./boot.sh</span><br><span class="line">[   37.106705] __vm_enough_memory: pid: 472, comm: qemu-system-x86, not enough memory for the allocation</span><br><span class="line">qemu-system-x86_64: cannot set up guest memory &#x27;pc.ram&#x27;: Cannot allocate memory</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ruiy/p/11607036.html">openstack kvm cannot set up guest memory ‘pc.ram’: Cannot allocate memory - 秦瑞It行程实录 - 博客园 (cnblogs.com)</a></p>
<p><code> sudo bash -c &quot;echo 1 &gt; /proc/sys/vm/overcommit_memory&quot;</code></p>
<h2 id="hostVM-用perf"><a href="#hostVM-用perf" class="headerlink" title="hostVM 用perf"></a>hostVM 用perf</h2><p>需要在host上编译hostVM image的source里面 编译perf</p>
<p>如果编译报错 不是代码的问题 是依赖的问题 可能少了很多依赖没装 少哪个装哪个 最后少了pkg-config</p>
<p>hostVM 用apt装 libbabeltrace-ctf-dev 等 也可以直接复制.so</p>
<p>config加入<code>CONFIG_BPF_SYSCALL=y</code></p>
<p>record后面必须加<code>-e cpu-clock</code> 否则会每次写入0.002M 无sample 和宿主机行为不一样</p>
<p>火焰图下的FlameGraph脚本需要sudo</p>
<h2 id="perf看不到kernel-symbol"><a href="#perf看不到kernel-symbol" class="headerlink" title="perf看不到kernel symbol"></a>perf看不到kernel symbol</h2><p>用-p pid可看到报错提示</p>
<p>根据提示<code>sudo bash -c &quot;echo -1 &gt; /proc/sys/kernel/perf_event_paranoid&quot;</code></p>
<p>值是2 disallow kernel profiling</p>
<h2 id="guest-perf"><a href="#guest-perf" class="headerlink" title="guest perf"></a>guest perf</h2><p>tools目录 <code>make LDFLAGS=-static perf</code> ldd perf看到not a dynamic executable</p>
<h2 id="VM增大磁盘容量"><a href="#VM增大磁盘容量" class="headerlink" title="VM增大磁盘容量"></a>VM增大磁盘容量</h2><p>先qemu-img resize</p>
<p>然后进虚拟机 fdisk -l 看设备</p>
<p>然后fdisk 设备  删分区 加分区  </p>
<p><a target="_blank" rel="noopener" href="https://taoshu.in/unix/resize-qemu-ext4.html#google_vignette">https://taoshu.in/unix/resize-qemu-ext4.html#google_vignette</a></p>
<h2 id="hostVM网络工具"><a href="#hostVM网络工具" class="headerlink" title="hostVM网络工具"></a>hostVM网络工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@jammy:~$ make network</span><br><span class="line">sudo brctl addbr br0</span><br><span class="line">add bridge failed: Package not installed</span><br><span class="line">make: *** [Makefile:2: network] Error 1</span><br></pre></td></tr></table></figure>

<p>config加入<code>CONFIG_BRIDGE=y</code> <code>CONFIG_TUN=y</code> <code>CONFIG_TAP=y</code></p>
<p>必须是y 不能是m</p>
<p>guestVM启动分配的mac地址必须不可以和hostVM一样</p>
<h2 id="ssh连接hostVM"><a href="#ssh连接hostVM" class="headerlink" title="ssh连接hostVM"></a>ssh连接hostVM</h2><p>默认优先级是从外至内的</p>
<p>guestVM ctrl a x会退出两个 用ssh不会</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yjk13703623757/article/details/114936739">解决Permission denied (publickey)._Locutus的博客-CSDN博客</a></p>
<h2 id="soc-term"><a href="#soc-term" class="headerlink" title="soc term"></a>soc term</h2><p>如果不能配网络的情况下 用这个</p>
<p><a target="_blank" rel="noopener" href="https://review.trustedfirmware.org/plugins/gitiles/OP-TEE/build/+/c79ecf72671f50cf8768514245bce5e46cfe4fa5/soc_term.py">soc_term.py - OP-TEE&#x2F;build - Gitiles (trustedfirmware.org)</a></p>
<h2 id="挂载文件"><a href="#挂载文件" class="headerlink" title="挂载文件"></a>挂载文件</h2><p>用virtfs </p>
<p><code>sudo mount -t 9p -o trans=virtio,version=9p2000.L host0 /mnt/shared</code></p>
<h2 id="gdb-调内核"><a href="#gdb-调内核" class="headerlink" title="gdb 调内核"></a>gdb 调内核</h2><p>内核编译打开debug info</p>
<p>内核目录下 <code>gdb vmlinux</code> 然后<code>target remote localhost:1234</code></p>
<p>可以用hb代替b 可以启动完成后ctrl c 然后b 然后c</p>
<p>启动加<code>-S -gdb tcp::1234</code></p>
<p>需要加<code>-append &quot;nokaslr&quot;</code> 否则断点打了不会停</p>
<h2 id="balloon"><a href="#balloon" class="headerlink" title="balloon"></a>balloon</h2><p><a target="_blank" rel="noopener" href="http://ssdxiao.github.io/linux/2017/03/20/Virtio-Balloon.html">Virtio-Balloon超详细分析 (ssdxiao.github.io)</a></p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>修改host上的<code>linux_stable</code> 使用defconfig并加入kvm的配置</p>
<p>-kernel启动hostVM后把bzImage复制（scp）进hostVM，hostVM用同样的image启动guestVM</p>
<p>hostVM ubuntu password 创建后先配置网络 然后host上用ssh连hostVM</p>
<p>guestVM ubuntu 123</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">net:</span></span><br><span class="line">        sudo brctl addbr br0</span><br><span class="line">        sudo ip addr flush dev ens4</span><br><span class="line">        sudo brctl addif br0 ens4</span><br><span class="line">        sudo tunctl -t tap0 -u ubuntu</span><br><span class="line">        sudo brctl addif br0 tap0</span><br><span class="line">        sudo ifconfig ens4 up</span><br><span class="line">        sudo ifconfig tap0 up</span><br><span class="line">        sudo ifconfig br0 up</span><br><span class="line">        sudo dhclient br0</span><br><span class="line"></span><br><span class="line"><span class="section">mem:</span></span><br><span class="line">        sudo bash -c <span class="string">&quot;echo 1 &gt; /proc/sys/vm/overcommit_memory&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">swap:</span></span><br><span class="line">        sudo swapon test_swap</span><br><span class="line"></span><br><span class="line"><span class="section">watchmsg:</span></span><br><span class="line">        watch <span class="string">&quot;dmesg | tail -n 20&quot;</span></span><br><span class="line"><span class="section">watchfree:</span></span><br><span class="line">        watch <span class="string">&quot;free -mh&quot;</span></span><br><span class="line"><span class="section">init:</span></span><br><span class="line">        make net</span><br><span class="line">        make mem</span><br><span class="line">        make swap</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2024/09/17/virtualization/virtio%20queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/17/virtualization/virtio%20queue/" class="post-title-link" itemprop="url">virtio queue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-09-17 19:48:03 / Modified: 19:48:04" itemprop="dateCreated datePublished" datetime="2024-09-17T19:48:03+08:00">2024-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/virtualization/" itemprop="url" rel="index"><span itemprop="name">virtualization</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>5.6k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>5 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="virtio-queue"><a href="#virtio-queue" class="headerlink" title="virtio queue"></a>virtio queue</h1><h2 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangquan1992/article/details/120649182">virtio-net 实现机制_sg_init_one_老王不让用的博客-CSDN博客</a></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>简单设计：一个环形队列 固定大小 生产者消费者 两个指针</p>
<p>这样所有通信固定在了这个队列里</p>
<p>virtio可以动态申请和释放共享内存，用一块固定的共享内存队列记录通信使用的共享内存的地址</p>
<p>这个队列为desc 默认128长度</p>
<p>真正的共享内存是scatterlist</p>
<p>并且 desc并不是单纯的先进先出的队列，而是一个无序的链表，所有请求不需要顺序处理 所以两个指针是不够的 必须记录哪些位置是新生产的  哪些位置被消费了</p>
<p>实现中用数组 分别索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vring_create_virtqueue</span><br><span class="line">vring_create_virtqueue_split</span><br><span class="line">vring_alloc_queue_split</span><br><span class="line">	-&gt; vring_split-&gt;vring.desc = vring_alloc_queue(num)</span><br></pre></td></tr></table></figure>

<p>前者是avai ring qemu把新请求的desc id放在里面  然后更新这个avai ring的index</p>
<p>qemu会维护这个avai ring的last index 然后avai_ring[last_index]读到desc id desc[desc_id]读到真正的信息的共享内存地址 然后再读数据 </p>
<p>同理 use ring表示另一侧</p>
<p>实现中 desc avail used用的是一块连续的物理内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vstatic <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">vring_init</span><span class="params">(<span class="keyword">struct</span> vring *vr, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">void</span> *p,</span></span><br><span class="line"><span class="params">			      <span class="type">unsigned</span> <span class="type">long</span> align)</span></span><br><span class="line">&#123;</span><br><span class="line">	vr-&gt;num = num;</span><br><span class="line">	vr-&gt;desc = p;</span><br><span class="line">	vr-&gt;avail = (<span class="keyword">struct</span> vring_avail *)((<span class="type">char</span> *)p + num * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> vring_desc));</span><br><span class="line">	vr-&gt;used = (<span class="type">void</span> *)(((<span class="type">uintptr_t</span>)&amp;vr-&gt;avail-&gt;ring[num] + <span class="keyword">sizeof</span>(__virtio16)</span><br><span class="line">		+ align<span class="number">-1</span>) &amp; ~(align - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="guest"><a href="#guest" class="headerlink" title="guest"></a>guest</h3><p>scatterlist是内核数据结构 只是记录了page地址 并没有读数据</p>
<p><code>sg-&gt;page_link = (unsigned long)page</code></p>
<p>调用vring_map_one_sg-&gt;sg_phys拿到gpa记录在desc中</p>
<p>sg-&gt;length就是buflen 即pfn个数乘长度(4字节 最多256个 共1024字节)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">desc[i].addr = vring_map_one_sg(sg)</span><br><span class="line">desc[i].len = sg-&gt;length</span><br><span class="line"></span><br><span class="line">vring.avail-&gt;ring[avail] = i</span><br><span class="line">vring.avail-&gt;idx++</span><br></pre></td></tr></table></figure>

<p>这里把地址展开 其实就是sg-&gt;page_link 也就是page的地址 GPA</p>
<p>所以这里sg用的buf 必须也是提前制定好的共享内存 相当于绕了一圈回来了 最终还是一块固定的共享内存</p>
<p>并且sg本身存了个地址 然后又拿了地址 跟sg没什么关系 qemu这边也并不会访问到sg 只是为了复用一些函数？</p>
<p>是virtio_balloon结构体中的pfns数组</p>
<p>每次balloon guest把pfn写在这块固定的共享内存上(pfns) 然后把这个地址写到一个sg中 再把这个地址写到desc中 再把desc索引写到avail中 qemu从avail拿到desc索引 再拿pfns地址  传来传去就是一个固定的地址 </p>
<h3 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h3><p>从avail拿到desc索引</p>
<p>从desc拿到GPA 转成HVA</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">i = vring_avail_ring(last_avail_idx++)</span><br><span class="line">vring_split_desc_read(&amp;desc,i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">virtqueue_map_desc(desc.addr,desc.len)&#123;</span><br><span class="line">	iov[0].iov_base = dma_memory_map(desc.addr)</span><br><span class="line">	iov[0].iov_len = desc.len</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里dma_memory_map-&gt;address_space_map把GPA转为HVA 但是代码实现看起来非常复杂</p>
<blockquote>
<p>Map a physical memory region into a host virtual address</p>
</blockquote>
<p>用HVA copy guest的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">elem = virtqueue_pop(vq,sizeof(VirtQueueElement));</span><br><span class="line">while(iov_to_buf(elem-&gt;out_sg,elem-&gt;out_num,offset,&amp;pfn,4)==4)</span><br><span class="line"></span><br><span class="line">if(offset &lt;= iov[0].iov_len)</span><br><span class="line">	memcpy(buf,iov[0].iov_base + offset,bytes)</span><br></pre></td></tr></table></figure>

<h3 id="used"><a href="#used" class="headerlink" title="used"></a>used</h3><h2 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h2><h3 id="glib"><a href="#glib" class="headerlink" title="glib"></a>glib</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73494896/article/details/127011228">详细介绍Glib 主事件循环轻度分析与编程应用_g_main_loop_run_极致Linux内核的博客-CSDN博客</a></p>
<p>事件循环</p>
<p>例如connect拿到fd  glib会包装poll 响应时dispatch调用callback</p>
<h3 id="eventfd"><a href="#eventfd" class="headerlink" title="eventfd"></a>eventfd</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/40572954">让事件飞 ——Linux eventfd 原理与实践 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/393748176">Linux fd 系列 — eventfd 是什么？ - 知乎 (zhihu.com)</a></p>
<p>一个eventfd维护一个8bit的整型 write对应累加 read对应清零</p>
<p>当值是0时read会阻塞</p>
<p>producer用write 1 consumer用read实现阻塞</p>
<h3 id="mmio"><a href="#mmio" class="headerlink" title="mmio"></a>mmio</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9Zv7XcsvlVwDDjTn85-SZQ">Linux虚拟化KVM-Qemu分析（十二）之ioeventfd与irqfd (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/huang987246510/article/details/105618557">qemu中的eventfd——ioeventfd_享乐主的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1518217">virtIO前后端notify机制详解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<ol>
<li>mmio的地址不能提交给kvm然后让guest访问 应该qemu来模拟，这里模拟的写操作会到<code>virtio_pci_config_write</code>处理</li>
<li>为了提高效率 mmio的地址与eventfd绑定，kvm不需要回到qemu 而是直接通过eventfd通知qemu</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps virtio_pci_config_ops = &#123;</span><br><span class="line">    .read = virtio_pci_config_read,</span><br><span class="line">    .write = virtio_pci_config_write,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_pci_bus_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span>&#123;</span><br><span class="line">	k-&gt;set_guest_notifiers = virtio_pci_set_guest_notifiers;</span><br><span class="line">    	-&gt;virtio_pci_set_guest_notifier</span><br><span class="line">            -&gt;event_notifier_init	</span><br><span class="line">            	-&gt;eventfd</span><br><span class="line">	k-&gt;device_plugged = virtio_pci_device_plugged;</span><br><span class="line">    	-&gt;memory_region_init_io(&amp;proxy-&gt;bar, OBJECT(proxy),&amp;virtio_pci_config_ops,</span><br><span class="line">			proxy, <span class="string">&quot;virtio-pci&quot;</span>, size);</span><br><span class="line">    k-&gt;ioeventfd_assign = virtio_pci_ioeventfd_assign;</span><br><span class="line">    	-&gt;memory_region_add_eventfd-&gt;memory_region_transaction_commit-&gt;address_space_update_ioeventfds-&gt;address_space_add_del_ioeventfds-&gt;MEMORY_LISTEMER_CALL(eventfd_add)</span><br><span class="line">            -&gt;kvm_set_ioeventfd_mmio</span><br><span class="line">            	-&gt;kvm_vm_ioctl(kvm_state, KVM_IOEVENTFD, &amp;iofd);</span><br><span class="line">&#125;</span><br><span class="line">kvm</span><br><span class="line">kvm_assign_ioeventfd_idx</span><br></pre></td></tr></table></figure>

<p>qemu端 virt queue 注册handle_output<code>typedef void (*VirtIOHandleOutput)(VirtIODevice *, VirtQueue *);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">memory_region_dispatch_write</span><br><span class="line">memory_region_write_accessor</span><br><span class="line">virtio_pci_config_write</span><br><span class="line">virtio_ioport_write&#123;</span><br><span class="line">	<span class="keyword">case</span> VIRTIO_PCI_QUEUE_NOTIFY:</span><br><span class="line">        virtio_queue_notify(vdev, val);</span><br><span class="line">        	-&gt;<span class="keyword">if</span>(vq-&gt;host_notifier_enabled)</span><br><span class="line">                event_notifier_set(&amp;vq-&gt;host_notifier);</span><br><span class="line">    		<span class="keyword">else</span>	vq-&gt;handle_output(vdev,vq)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>guest </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">virtqueue_kick</span><br><span class="line">virtqueue_notify</span><br><span class="line"><span class="type">bool</span> <span class="title function_">vp_notify</span><span class="params">(<span class="keyword">struct</span> virtqueue *vq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* we write the queue&#x27;s selector into the notification register to</span></span><br><span class="line"><span class="comment">	 * signal the other end */</span></span><br><span class="line">	iowrite16(vq-&gt;index, vp_dev-&gt;ldev.ioaddr + VIRTIO_PCI_QUEUE_NOTIFY);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kvm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_ept_misconfig</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span>&#123;</span><br><span class="line">    gpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);</span><br><span class="line">	<span class="keyword">if</span> (!is_guest_mode(vcpu) &amp;&amp;</span><br><span class="line">	    !kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, <span class="number">0</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        	-&gt;ioeventfd_write</span><br><span class="line">                -&gt;eventfd_signal (counter增加 唤醒)</span><br><span class="line">        <span class="comment">//正常执行返回0 提前退出</span></span><br><span class="line">		<span class="keyword">return</span> kvm_skip_emulated_instruction(vcpu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回0 会让kvm进入下一次vcpu_run的循环 不会退出ioctl到qemu</p>
<p>qemu在哪里等待这个eventfd  被唤醒后如何处理 网上没有相关的介绍</p>
<blockquote>
<p>host通知guest当然是通过注入中断的方式，首先调用的是virtio_notify，继而调用virtio_notify_vector并把中断向量作为参数传递进去。这里就调用了设备关联的notify函数，具体实现为virtio_pci_notify函数，常规中断（非MSI）会调用qemu_set_irq，在8259a中断控制器的情况下回调用kvm_pic_set_irq，然后到了kvm_set_irq，这里就会通过kvm_vm_ioctl和KVM交互，接口为KVM_IRQ_LINE，通知KVM对guest进行中断的注入。KVm里的kvm_vm_ioctl函数会对此调用进行处理，具体就是调用kvm_vm_ioctl_irq_line，之后就调用kvm_set_irq函数进行注入了。之后的流程参看中断虚拟化部分。</p>
</blockquote>
<p>hw&#x2F;virtio&#x2F;virtio-pci.c</p>
<p>virio_ioport_write</p>
<p>virtio_pci_config_ops</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42681961/article/details/82827911">qemu-kvm 对mmio的模拟_qemu mmio-CSDN博客</a></p>
<p>guest:</p>
<p>drivers&#x2F;virtio&#x2F;virtio_pci_legacy.c</p>
<p>vq-&gt;priv &#x3D; … VIRTIO_PCI_QUEUE_NOTIFY</p>
<p>qemu:</p>
<p>memory_region_add_eventfd(VIRTIO_PCI_QUEUE_NOTIFY)</p>
<p><a href="read://https_blog.csdn.net/?url=https%3A%2F%2Fblog.csdn.net%2Fqq_41596356%2Farticle%2Fdetails%2F128441953">virtio前端驱动通知机制分析 (csdn.net)</a></p>
<p>这里说</p>
<blockquote>
<p><code>iowrite VIRTIO_PCI_QUEUE_NOTIFY</code> 后会产生一个 <code>vm-exit</code>，<code>KVM</code> 会判断 <code>exit_reason</code>， <code>I/O</code> 操作对应的执行函数是 <code>virtio_ioport_write()</code> 。</p>
</blockquote>
<p>kvm使用的eventfd来自do_eventfd  在fs&#x2F;eventfd.c</p>
<p>qemu在哪里用？</p>
<p><a target="_blank" rel="noopener" href="https://tinylab.org/qemu-vhost/">Qemu vhost 原理分析 - 泰晓科技 (tinylab.org)</a> 3.1节 有完整的调用路径 但是是需要kvm退回到qemu的 </p>
<p>guest中balloon直接循环virtqueue_notify</p>
<p>qemu中accel&#x2F;kvm&#x2F;kvm-all.c kvm_cpu_exec加代码统计 是mmio</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kvm_cpu_exec</span><br><span class="line">	-&gt;address_space_rw</span><br><span class="line">		-&gt;address_space_write</span><br><span class="line">			-&gt;memory_region_dispatch_write</span><br></pre></td></tr></table></figure>



<p>kvm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npf_interception</span><br><span class="line">	-&gt;kvm_mmu_page_fault</span><br><span class="line">    	-&gt;x86_emulate_instruction</span><br><span class="line">            -&gt;x86_emulate_insn</span><br><span class="line">                -&gt;writeback</span><br><span class="line">                    -&gt;segmented_write</span><br><span class="line">                        -&gt;emulator_write_emulated</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2024/09/17/virtualization/kvm-ubuntu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/17/virtualization/kvm-ubuntu/" class="post-title-link" itemprop="url">KVM-Ubuntu</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-09-17 19:48:03" itemprop="dateCreated datePublished" datetime="2024-09-17T19:48:03+08:00">2024-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/virtualization/" itemprop="url" rel="index"><span itemprop="name">virtualization</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>9.6k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>9 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="KVM-Ubuntu"><a href="#KVM-Ubuntu" class="headerlink" title="KVM-Ubuntu"></a>KVM-Ubuntu</h1><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p><code>sys_fd = open(&quot;/dev/kvm&quot;)</code></p>
<p>之后用<code>ioctl(fd,CMD,0)</code>给kvm发送指令</p>
<p>fd分为kvm的sys_fd，VM的vm_fd和VCPU的vcpu_fd</p>
<ul>
<li><p><code>KVM_CREATE_VM</code>：创建VM 拿到VM对应的fd</p>
</li>
<li><p><code>KVM_SET_USER_MEMORY_REGION</code>：注册<code>kvm_userspace_memory_region</code>结构体，需要自己设置一个地址(可用mmap)作为VM地址空间的起始位置。这里VMM的一个char数组，对应到VM的整个地址空间</p>
</li>
<li><p><code>KVM_CREATE_VCPU</code>：用VM的fd创建VCPU，拿到fd，之后运行VM都是通过vcpu</p>
<p>需要把拿到的fd通过mmap映射到<code>kvm_run</code>结构体上 方便拿到退出原因 io信息</p>
</li>
<li><p><code>KVM_SET_SREGS</code>：设置<code>kvm_sregs</code>结构体，其中包括了cr0 cr3 cr4等系统寄存器，可以自己配置页表，地址用GPA，但是PTE用HVA</p>
</li>
<li><p><code>KVM_RUN</code>：运行VM，VM发生exit时这句语句返回</p>
</li>
<li><p><code>KVM_GET_REGS</code>：拿寄存器到<code>kvm_regs</code>结构体，可通过<code>.rax</code>访问</p>
</li>
</ul>
<p>输出用<code>outb</code></p>
<p>配合</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_IO:</span><br><span class="line">	<span class="keyword">if</span> (vcpu-&gt;kvm_run-&gt;io.direction == KVM_EXIT_IO_OUT</span><br><span class="line">		&amp;&amp; vcpu-&gt;kvm_run-&gt;io.port == <span class="number">0xEA</span>) &#123;</span><br><span class="line">		<span class="type">char</span> *p = (<span class="type">char</span> *)vcpu-&gt;kvm_run;</span><br><span class="line">		fwrite(p + vcpu-&gt;kvm_run-&gt;io.data_offset,</span><br><span class="line">		vcpu-&gt;kvm_run-&gt;io.size, <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line">		fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="core"><a href="#core" class="headerlink" title="core"></a>core</h3><p><a target="_blank" rel="noopener" href="https://ubuntu.com/download/kvm">Install Ubuntu Core on KVM | Ubuntu</a></p>
<p><code>sudo qemu-system-x86_64 -smp 2 -m 2048 -net nic,model=virtio -net user,hostfwd=tcp::8022-:22,hostfwd=tcp::8090-:80 -nographic -drive file=/usr/share/OVMF/OVMF_CODE.fd,if=pflash,format=raw,unit=0,readonly=on -drive file=ubuntu-core-20-amd64.img,cache=none,format=raw,id=disk1,if=none -device virtio-blk-pci,drive=disk1,bootindex=1 -machine accel=kvm</code></p>
<p>需要设置<code>-nographic</code>这样启动界面会在执行qemu的shell中被打印 可以输入和按回车选择</p>
<p>这个官方镜像的启动是需要输入ubuntu账号的，并且需要在ubuntu网站中上传自己的rsa key 然后ssh登录虚拟机的时候需要</p>
<p>启动qemu的窗口会显示无用的信息 需要另开窗口<code>ssh -p 8022 szy0127@localhost</code>登录虚拟机</p>
<p>ubuntu官方提供的img镜像apt和dpkg都没有，连安装命令都很困难</p>
<p>关闭qemu后虚拟机退出，重启后数据都在</p>
<h3 id="cloud"><a href="#cloud" class="headerlink" title="cloud"></a>cloud</h3><p><a target="_blank" rel="noopener" href="https://cloudinit.readthedocs.io/en/latest/tutorial/qemu.html">Core tutorial with QEMU - cloud-init 23.2 documentation (cloudinit.readthedocs.io)</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-x86_64                                            \</span><br><span class="line">    -net nic                                                    \</span><br><span class="line">    -net tap,ifname=tap0,script=no,downscript=no\</span><br><span class="line">    -machine accel=kvm:tcg                                      \</span><br><span class="line">    -cpu host                                                   \</span><br><span class="line">    -m 512                                                      \</span><br><span class="line">    -nographic                                                  \</span><br><span class="line">    -hda jammy-server-cloudimg-amd64.img                        \</span><br><span class="line">    -smbios type=1,serial=ds=&#x27;nocloud-net;s=http://192.168.21.220:8000/&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-x86_64 \</span><br><span class="line">        -cpu host \</span><br><span class="line">        --enable-kvm \</span><br><span class="line">        -smp 1 \</span><br><span class="line">        -m 1G \</span><br><span class="line">        -nographic \</span><br><span class="line">        -device virtio-blk-pci,drive=vdisk \</span><br><span class="line">        -drive if=none,id=vdisk,file=jammy-server-cloudimg-amd64.img,format=qcow2 \</span><br><span class="line">        -device virtio-net-pci,netdev=vnet,mac=52:54:00:12:34:88 \</span><br><span class="line">        -netdev tap,id=vnet,ifname=tap0,script=no,downscript=no \</span><br><span class="line">        -smbios type=1,serial=ds=&#x27;nocloud-net;s=http://192.168.21.220:8000/&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要保证IMDS webserver启动好且网络可达 user模式的<code>10.0.2.2</code> 在net模式不可用</p>
<p>启动qemu的进程会直接打开虚拟机的shell</p>
<p>用户名ubuntu 密码password</p>
<p>关闭qemu后虚拟机退出，重启后数据也都在</p>
<p>指定编译出的kernel</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-x86_64 \</span><br><span class="line">    -cpu host \</span><br><span class="line">    --enable-kvm \</span><br><span class="line">    -smp 1 \</span><br><span class="line">    -m 4G \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -append &quot;console=ttyS0 ignore_loglevel root=/dev/vda1&quot; \</span><br><span class="line">    -device virtio-blk-pci,drive=vdisk \</span><br><span class="line">    -drive if=none,id=vdisk,file=jammy-server-cloudimg-amd64.img,format=qcow2 \</span><br><span class="line">    -device virtio-net-pci,netdev=vnet,mac=52:54:00:12:34:88 \</span><br><span class="line">    -netdev tap,id=vnet,ifname=tap0,script=no,downscript=no \</span><br><span class="line">    #-smbios type=1,serial=ds=&#x27;nocloud-net;s=http://192.168.21.220:8000/&#x27;</span><br><span class="line">    #-snapshot \</span><br></pre></td></tr></table></figure>



<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>ip route add default via 192.168.12.1<br>netplan apply<br>vim &#x2F;etc&#x2F;netplan&#x2F;50-cloud-init.yaml</p>
<h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><p>user mode可以访问外网 但是ping被ban了</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_43406494/article/details/124827927">QEMU–用户模式网络_qemu 网络模式_play maker的博客-CSDN博客</a></p>
<p>host不能访问guest，guest可以访问host</p>
<h3 id="tap-0"><a href="#tap-0" class="headerlink" title="tap 0"></a>tap 0</h3><p>没有tun模块 要自己编译以后启动</p>
<p><a target="_blank" rel="noopener" href="https://www.php1.cn/detail/YuanDaiMaGuanLiG_143ec260.html">ubuntu下安装tun模块图文详细教程 - 第一PHP社区 (php1.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/larryliuqing/article/details/27127843">用TAP方式让QEMU虚拟机与host联网_qemu tap0_拉里山姆的博客-CSDN博客</a></p>
<p>只能虚拟机和主机相互连通 虚拟机无法访问互联网</p>
<h3 id="tap-1"><a href="#tap-1" class="headerlink" title="tap 1"></a>tap 1</h3><p><a target="_blank" rel="noopener" href="https://gist.github.com/extremecoders-re/e8fd8a67a515fee0c873dcafc81d811c">Setting up Qemu with a tap interface (github.com)</a></p>
<p>虚拟机内部的网卡没有ip 如果输dhclient会卡死  原因是dhclient是跳板机 需要宿主机转发 出于安全考虑被宿主机拦截</p>
<p>需要在宿主机上执行<code>sudo iptables -P FORWARD ACCEPT</code> 每次重启后需要再次执行</p>
<p><code>tcpdump -i tap0</code> 看网络包流通情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">        sudo brctl addbr br0</span><br><span class="line">        sudo ip addr flush dev ens4</span><br><span class="line">        sudo brctl addif br0 ens4</span><br><span class="line">        sudo tunctl -t tap0 -u ubuntu</span><br><span class="line">        sudo brctl addif br0 tap0</span><br><span class="line">        sudo ifconfig ens4 up</span><br><span class="line">        sudo ifconfig tap0 up</span><br><span class="line">        sudo ifconfig br0 up</span><br><span class="line">        sudo dhclient br0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有tunctl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip tuntap add dev tap0 mod tap</span><br></pre></td></tr></table></figure>

<p>如果看不见网卡 需要打开guest内核的config_virtio_net m变为y</p>
<p>进入guest需要sudo dhclient xxx</p>
<h2 id="内核信息"><a href="#内核信息" class="headerlink" title="内核信息"></a>内核信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">szy@broadwell:~$ sudo ls  /sys/kernel/debug/kvm/</span><br><span class="line">136814-12            halt_poll_success_ns  invlpg          max_mmu_page_hash_collisions  mmu_recycled            pf_guest</span><br><span class="line">exits                halt_successful_poll  io_exits        mmio_exits                    mmu_shadow_zapped       remote_tlb_flush</span><br><span class="line">fpu_reload           halt_wakeup           irq_exits       mmu_cache_miss                mmu_unsync              req_event</span><br><span class="line">halt_attempted_poll  host_state_reload     irq_injections  mmu_flooded                   nmi_injections          request_irq</span><br><span class="line">halt_exits           hypercalls            irq_window      mmu_pde_zapped                nmi_window              signal_exits</span><br><span class="line">halt_poll_fail_ns    insn_emulation        l1d_flush       mmu_pte_updated               nx_largepages_splitted  tlb_flush</span><br><span class="line">halt_poll_invalid    insn_emulation_fail   largepages      mmu_pte_write                 pf_fixed</span><br><span class="line">szy@broadwell:~$ sudo ls  /sys/kernel/debug/kvm/136814-12</span><br><span class="line">exits                 halt_successful_poll  io_exits                      mmio_exits       mmu_shadow_zapped       remote_tlb_flush</span><br><span class="line">fpu_reload            halt_wakeup           irq_exits                     mmu_cache_miss   mmu_unsync              req_event</span><br><span class="line">halt_attempted_poll   host_state_reload     irq_injections                mmu_flooded      nmi_injections          request_irq</span><br><span class="line">halt_exits            hypercalls            irq_window                    mmu_pde_zapped   nmi_window              signal_exits</span><br><span class="line">halt_poll_fail_ns     insn_emulation        l1d_flush                     mmu_pte_updated  nx_largepages_splitted  tlb_flush</span><br><span class="line">halt_poll_invalid     insn_emulation_fail   largepages                    mmu_pte_write    pf_fixed                vcpu0</span><br><span class="line">halt_poll_success_ns  invlpg                max_mmu_page_hash_collisions  mmu_recycled     pf_guest                vcpu1</span><br><span class="line">szy@broadwell:~$ sudo cat  /sys/kernel/debug/kvm/136814-12/exits</span><br><span class="line">5449424</span><br></pre></td></tr></table></figure>

<p>文件夹名是qemu的pid</p>
<h2 id="修改内核"><a href="#修改内核" class="headerlink" title="修改内核"></a>修改内核</h2><h3 id="整体编译"><a href="#整体编译" class="headerlink" title="整体编译"></a>整体编译</h3><p><a target="_blank" rel="noopener" href="https://kernelnewbies.org/KernelBuild">KernelBuild - Linux Kernel Newbies</a></p>
<p><code>make -j8</code> 这里编译完可以拿到bzImage  给qemu的-kernel参数使用 <code>arch/x86/bzImage</code></p>
<p><code>sudo make modules_install install</code></p>
<p>选择kernel并重启<code>~/grublist/grub-list.py</code></p>
<p>broadwell下tmux<code>sudo minicom -D /dev/ttyUSB0</code> 通过串口而不是ssh连bionic 即使内核或网络崩溃无法ssh也可以观察</p>
<p>升级内核后网络设备有问题 无法访问外网且没有ip   4.15识别到enp15s0 但是需要手动dhclient拿ip 虽然拿到相同的ip，但是只有broadwell可以ping通bionic 跳板机仍然无法ping通</p>
<p>目前成功修改的路径为<code>/usr/src/linux-source-4.15.0/linux-source-4.15.0</code> grublist显示为<code>Ubuntu, with Linux 4.15.18</code></p>
<p>修改<code>arch/x86/kernel/paravirt.c#default_banner</code> 可以启动时看到输出 </p>
<img src="C:\Users\Shen\AppData\Roaming\Typora\typora-user-images\image-20230628204908934.png" alt="image-20230628204908934" style="zoom:50%;" />

<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">szy @ bionic-x99 <span class="keyword">in</span> ~ [20:22:54]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find /lib/modules/4.15.18/ -name kvm.ko</span></span><br><span class="line">/lib/modules/4.15.18/kernel/arch/x86/kvm/kvm.ko</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">szy @ bionic-x99 <span class="keyword">in</span> ~ [20:31:58] C:1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kvm-ok</span></span><br><span class="line">INFO: /dev/kvm exists</span><br><span class="line">KVM acceleration can be used</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">szy @ bionic-x99 <span class="keyword">in</span> ~ [20:32:05]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo rmmod kvm-intel</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">szy @ bionic-x99 <span class="keyword">in</span> ~ [20:32:12]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo rmmod kvm</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">szy @ bionic-x99 <span class="keyword">in</span> ~ [20:32:14]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kvm-ok</span></span><br><span class="line">INFO: /dev/kvm does not exist</span><br><span class="line">HINT:   sudo modprobe kvm_intel</span><br><span class="line">INFO: For more detailed results, you should run this as root</span><br><span class="line">HINT:   sudo /usr/sbin/kvm-ok</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">szy @ bionic-x99 <span class="keyword">in</span> ~ [20:32:18] C:1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo insmod /lib/modules/4.15.18/kernel/arch/x86/kvm/kvm.ko</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">szy @ bionic-x99 <span class="keyword">in</span> ~ [20:32:25]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo insmod /lib/modules/4.15.18/kernel/arch/x86/kvm/kvm-intel.ko</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">szy @ bionic-x99 <span class="keyword">in</span> ~ [20:32:31]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kvm-ok</span></span><br><span class="line">INFO: /dev/kvm exists</span><br><span class="line">KVM acceleration can be used</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">szy @ bionic-x99 <span class="keyword">in</span> /usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm [21:00:33] C:1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo insmod /usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm/kvm-intel.ko</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">szy @ bionic-x99 <span class="keyword">in</span> /usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm [21:00:39]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dmesg | <span class="built_in">tail</span> -10</span></span><br><span class="line">[25416.145711] kvm: loading out-of-tree module taints kernel.</span><br><span class="line">[25416.151778] kvm: module verification failed: signature and/or required key missing - tainting kernel</span><br><span class="line">[25435.886621] kvm module modified by szy</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">szy @ bionic-x99 <span class="keyword">in</span> /usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm [21:00:51] C:1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kvm-ok</span></span><br><span class="line">INFO: /dev/kvm exists</span><br><span class="line">KVM acceleration can be used</span><br></pre></td></tr></table></figure>



<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">///usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm/Makefile</span><br><span class="line"><span class="section">update:</span></span><br><span class="line">        sudo make -C /lib/modules/4.15.18/build M=<span class="variable">$(PWD)</span> modules -j10</span><br><span class="line">        sudo rmmod kvm-intel</span><br><span class="line">        sudo rmmod kvm</span><br><span class="line">        sudo insmod <span class="variable">$(PWD)</span>/kvm.ko</span><br><span class="line">        sudo insmod <span class="variable">$(PWD)</span>/kvm-intel.ko</span><br><span class="line">        kvm-ok</span><br><span class="line"></span><br><span class="line"><span class="section">remove:</span></span><br><span class="line">        sudo rmmod kvm-intel</span><br><span class="line">        sudo rmmod kvm</span><br><span class="line"><span class="section">install:</span></span><br><span class="line">        sudo insmod <span class="variable">$(PWD)</span>/kvm.ko</span><br><span class="line">        sudo insmod <span class="variable">$(PWD)</span>/kvm-intel.ko</span><br><span class="line">        kvm-ok</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h2><h3 id="调用逻辑"><a href="#调用逻辑" class="headerlink" title="调用逻辑"></a>调用逻辑</h3><p>用户态qemu通过ioctl发起一次run</p>
<p><code>kvm_vcpu_ioctl</code>-&gt;<code>kvm_arch_vcpu_ioctl_run</code>-&gt;<code>vcpu_run</code>-&gt;<code>vcpu_enter_guest</code>-&gt;<code>vmx_vcpu_run</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vcpu_run</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span>&#123;    </span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        r = vcpu_enter_guest(vcpu);</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>如果KVM能处理exit就继续循环 否则回到用户态qemu 由qemu再次调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vcpu_enter_guest</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span>&#123;</span><br><span class="line">    kvm_x86_ops-&gt;run(vcpu);</span><br><span class="line">    ++vcpu-&gt;stat.exits;</span><br><span class="line">	<span class="keyword">return</span> kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>vmx_vcpu_run</code>中由汇编<code>ASM_VMX_VMLAUNCH</code>进入VM执行，VM退出后会紧接着执行下面的几行汇编</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p><code>x86.c&gt;vcpu_enter_guest</code>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">++vcpu-&gt;stat.exits;</span><br><span class="line"><span class="keyword">if</span>(vcpu-&gt;stat.exits % <span class="number">1000</span>==<span class="number">0</span>)&#123;</span><br><span class="line">	printk(<span class="string">&quot;vcpu exits:%lld\n&quot;</span>,vcpu-&gt;stat.exits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kvm的函数是需要一个vcpu作为参数的 exit为vcpu的成员变量</p>
<p>直接在内核改</p>
<p>vmx.c中增加全局变量，核心函数为<code>vmx_vcpu_run</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str_values</span> &#123;</span></span><br><span class="line">        <span class="type">int</span>             val;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>      *str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">str_values</span> <span class="title">vmx_exit_reasons</span>[] =</span> &#123;</span><br><span class="line">        VMX_EXIT_REASONS</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//static int exit_type_num = sizeof(vmx_exit_reasons)/sizeof(struct str_values);</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> exit_counts[<span class="number">65</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> exit_last_time[<span class="number">65</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> exit_total_cost_time[<span class="number">65</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> total_exit_count;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> exit_last_reason=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* <span class="title function_">get_exit_reason_string</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;=<span class="number">64</span> ;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vmx_exit_reasons[i].val == val)&#123;</span><br><span class="line">                        <span class="keyword">return</span> vmx_exit_reasons[i].str;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> u64 <span class="title function_">get_timestamp_now</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">        u64 timestamp;</span><br><span class="line">        do_gettimeofday(&amp;tv);</span><br><span class="line">        timestamp = (u64)tv.tv_sec * <span class="number">1000000</span> + tv.tv_usec;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_exit_counts</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> index[n];</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ;i &lt; n ;i++)&#123; <span class="comment">// find ith biggest number</span></span><br><span class="line">                <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(j= <span class="number">0</span> ; j&lt;= <span class="number">64</span>; j++)&#123;</span><br><span class="line">                        <span class="type">int</span> k;</span><br><span class="line">                        <span class="type">int</span> duplicated = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; i ; k++)&#123; <span class="comment">//prevent duplicated</span></span><br><span class="line">                                <span class="keyword">if</span>(index[k] == j)&#123;</span><br><span class="line">                                        duplicated = <span class="number">1</span>;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(duplicated)&#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">int</span> count = exit_counts[j];</span><br><span class="line">                        <span class="keyword">if</span>(count &gt;= max)&#123;</span><br><span class="line">                                index[i] = j;</span><br><span class="line">                                max = count;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(exit_counts[index[i]] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="type">char</span>* reason = get_exit_reason_string(index[i]);</span><br><span class="line">                        u64 aver_cost_time = exit_total_cost_time[index[i]]/exit_counts[index[i]];</span><br><span class="line">                        printk(<span class="string">&quot;exit reason:[%d]%s,counts:%lld,average cost time:%lld\n&quot;</span>,index[i],reason?reason : <span class="string">&quot;not found&quot;</span>,exit_counts[index[i]],aver_cost_time);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vmx-&gt;exit_reason = vmx-&gt;fail ? <span class="number">0xdead</span> : vmcs_read32(VM_EXIT_REASON);</span><br><span class="line">        <span class="keyword">if</span>(!vmx-&gt;fail)&#123;</span><br><span class="line">                total_exit_count++;</span><br><span class="line">                exit_last_reason=(u16)vmx-&gt;exit_reason;</span><br><span class="line">                exit_last_time[exit_last_reason] = now;</span><br><span class="line">                exit_counts[exit_last_reason]++;</span><br><span class="line">                <span class="keyword">if</span>(total_exit_count%<span class="number">10000</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//printk(KERN_INFO &quot;time now:%llu\n&quot;, timestamp);</span></span><br><span class="line">                        show_exit_counts(<span class="number">5</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                exit_last_reason = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内核模块 不能include time并且用time获得时间，只能用linux&#x2F;time的do_gettimeofday</p>
<p>或者使用rdtsc获取cycle数 rdtsc可以直接用，也可以用同名汇编</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2024/09/17/virtualization/kvm%20%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/17/virtualization/kvm%20%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">kvm 内存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-09-17 19:48:03" itemprop="dateCreated datePublished" datetime="2024-09-17T19:48:03+08:00">2024-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/virtualization/" itemprop="url" rel="index"><span itemprop="name">virtualization</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>28k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>26 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="kvm-内存"><a href="#kvm-内存" class="headerlink" title="kvm 内存"></a>kvm 内存</h1><p><a target="_blank" rel="noopener" href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf">intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;manuals&#x2F;64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf</a></p>
<ul>
<li>guest自己配置的页表完成GVA-&gt;GPA翻译 kvm不管这个数据结构</li>
<li>kvm的memslot完成GPA-&gt;HVA翻译 kvm维护这个数据结构，参数由用户态(qemu)提供</li>
<li>kvm的EPT(spt)完成GPA-&gt;HPA翻译，完全由kvm分配维护。需要结合memslot与自己进程的页表构造EPT</li>
<li>内核模块完成HVA-&gt;HPA翻译，涉及到VMA、页表等数据结构，在kvm需要的时候提供查询</li>
</ul>
<h2 id="VMCS"><a href="#VMCS" class="headerlink" title="VMCS"></a>VMCS</h2><p>一个vcpu对应一个VMCS，包括一套寄存器和一个虚拟MMU等。</p>
<p><code>kvm_vm_ioctl_create_vcpu</code>会设置对应的虚拟mmu信息</p>
<p>通过硬件提供的扩展指令设置当前的VMCS并且读写VMCS的域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vmcs_load</span><span class="params">(<span class="keyword">struct</span> vmcs *vmcs)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 phys_addr = __pa(vmcs);</span><br><span class="line">	u8 error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(__ex(ASM_VMX_VMPTRLD_RAX) <span class="string">&quot;; setna %0&quot;</span></span></span><br><span class="line"><span class="params">			: <span class="string">&quot;=qm&quot;</span>(error) : <span class="string">&quot;a&quot;</span>(&amp;phys_addr), <span class="string">&quot;m&quot;</span>(phys_addr)</span></span><br><span class="line"><span class="params">			: <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;kvm: vmptrld %p/%llx failed\n&quot;</span>,</span><br><span class="line">		       vmcs, phys_addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> __vmcs_writel(<span class="type">unsigned</span> <span class="type">long</span> field, <span class="type">unsigned</span> <span class="type">long</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	u8 error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(__ex(ASM_VMX_VMWRITE_RAX_RDX) <span class="string">&quot;; setna %0&quot;</span></span></span><br><span class="line"><span class="params">		       : <span class="string">&quot;=q&quot;</span>(error) : <span class="string">&quot;a&quot;</span>(value), <span class="string">&quot;d&quot;</span>(field) : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(error))</span><br><span class="line">		vmwrite_error(field, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">vmcs_field</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	HOST_RSP                        = <span class="number">0x00006c14</span>,</span><br><span class="line">	HOST_RIP                        = <span class="number">0x00006c16</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>field赋值给rdx，value赋值给rax，随后此条汇编指令执行<code>vmcs[%rdx]=%rax</code></p>
<h2 id="启动与配置"><a href="#启动与配置" class="headerlink" title="启动与配置"></a>启动与配置</h2><h3 id="module-init"><a href="#module-init" class="headerlink" title="module init"></a>module init</h3><p>加载module时会根据arch进行相关的硬件初始化，并直接在硬件允许的情况下打开EPT的设置</p>
<p>(module_init)<code>vmx_init</code>-&gt;<code>kvm_init</code>-&gt;<code>kvm_arch_hardware_setup</code>-&gt;<code>hardware_setup</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> __read_mostly enable_ept = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">hardware_setup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cpu_has_vmx_ept() ||</span><br><span class="line">	    !cpu_has_vmx_ept_4levels() ||</span><br><span class="line">	    !cpu_has_vmx_ept_mt_wb() ||</span><br><span class="line">	    !cpu_has_vmx_invept_global())</span><br><span class="line">		enable_ept = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span> (enable_ept)</span><br><span class="line">			vmx_enable_tdp();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			kvm_disable_tdp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vmx_enable_tdp</code>-&gt;<code>kvm_enable_tdp</code></p>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><h4 id="cr3"><a href="#cr3" class="headerlink" title="cr3"></a>cr3</h4><p>用户态可以设置sreg 指定cr3的值</p>
<p>[q]这里用户态(例如qemu)配置cr3的值是否可有可无？操作系统启动不都是会自己配置页表和cr3吗</p>
<p>操作系统(如chcore)会在打开mmu之前先进行页表配置，如何兼容这样的操作系统？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kvm_arch_vcpu_ioctl_set_sregs</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> kvm_sregs *sregs)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	vcpu-&gt;arch.cr3 = sregs-&gt;cr3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以kvm-hello-world为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vm-&gt;mem = mmap(<span class="literal">NULL</span>, mem_size, PROT_READ | PROT_WRITE,</span><br><span class="line">		   MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">memreg.guest_phys_addr = <span class="number">0</span>;</span><br><span class="line">memreg.memory_size = <span class="number">0x200000</span>;</span><br><span class="line">memreg.userspace_addr = (<span class="type">unsigned</span> <span class="type">long</span>)vm-&gt;mem;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> pml4_addr = <span class="number">0x2000</span>;</span><br><span class="line"><span class="type">uint64_t</span> *pml4 = (<span class="type">void</span> *)(vm-&gt;mem + pml4_addr);</span><br><span class="line"><span class="type">uint64_t</span> pdpt_addr = <span class="number">0x3000</span>;</span><br><span class="line"><span class="type">uint64_t</span> *pdpt = (<span class="type">void</span> *)(vm-&gt;mem + pdpt_addr);</span><br><span class="line"><span class="type">uint64_t</span> pd_addr = <span class="number">0x4000</span>;</span><br><span class="line"><span class="type">uint64_t</span> *pd = (<span class="type">void</span> *)(vm-&gt;mem + pd_addr);</span><br><span class="line">pml4[<span class="number">0</span>] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pdpt_addr;</span><br><span class="line">pdpt[<span class="number">0</span>] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pd_addr;</span><br><span class="line">pd[<span class="number">0</span>] = PDE64_PRESENT | PDE64_RW | PDE64_USER | PDE64_PS;</span><br><span class="line"></span><br><span class="line">sregs-&gt;cr3 = pml4_addr;</span><br></pre></td></tr></table></figure>

<p>这是存储的是GPA，但是修改的是HVA。当进行地址翻译时，第一阶段页表存储的GPA本身就会被EPT翻译到HPA（或者GPA-&gt;HVA，再通过EPT Violation建立GPA-&gt;HPA）</p>
<p>这里每个index都是0，且最后一级PTE没有地址，所以做的是0x0-&gt;0x0的地址映射，GPA&#x3D;GVA</p>
<h4 id="mmu"><a href="#mmu" class="headerlink" title="mmu"></a>mmu</h4><p>用户态ioctl创建vcpu时，进行虚拟mmu初始化</p>
<p><code>kvm_vm_ioctl</code>-&gt;<code>kvm_vm_ioctl_create_vcpu</code>-&gt;<code>kvm_arch_vcpu_setup</code>-&gt;<code>kvm_mmu_setup</code>-&gt;<code>init_kvm_mmu</code>-&gt;<code>init_kvm_tdp_mmu</code></p>
<p>这里的配置是看后续函数调用和函数内部分支的依据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_kvm_mmu</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (tdp_enabled)</span><br><span class="line">		init_kvm_tdp_mmu(vcpu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_kvm_tdp_mmu</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_mmu</span> *<span class="title">context</span> =</span> &amp;vcpu-&gt;arch.mmu;</span><br><span class="line"></span><br><span class="line">	context-&gt;base_role.word = <span class="number">0</span>;</span><br><span class="line">	context-&gt;base_role.smm = is_smm(vcpu);</span><br><span class="line">	context-&gt;base_role.ad_disabled = (shadow_accessed_mask == <span class="number">0</span>);</span><br><span class="line">	context-&gt;page_fault = tdp_page_fault;</span><br><span class="line">	context-&gt;sync_page = nonpaging_sync_page;</span><br><span class="line">	context-&gt;invlpg = nonpaging_invlpg;</span><br><span class="line">	context-&gt;update_pte = nonpaging_update_pte;</span><br><span class="line">	context-&gt;shadow_root_level = kvm_x86_ops-&gt;get_tdp_level(vcpu);</span><br><span class="line">	context-&gt;root_hpa = INVALID_PAGE;</span><br><span class="line">	context-&gt;direct_map = <span class="literal">true</span>;</span><br><span class="line">	context-&gt;set_cr3 = kvm_x86_ops-&gt;set_tdp_cr3;</span><br><span class="line">	context-&gt;get_cr3 = get_cr3;</span><br><span class="line">	context-&gt;get_pdptr = kvm_pdptr_read;</span><br><span class="line">	context-&gt;inject_page_fault = kvm_inject_page_fault;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_paging(vcpu)) &#123;</span><br><span class="line">		context-&gt;nx = <span class="literal">false</span>;</span><br><span class="line">		context-&gt;gva_to_gpa = nonpaging_gva_to_gpa;</span><br><span class="line">		context-&gt;root_level = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_long_mode(vcpu)) &#123;</span><br><span class="line">		context-&gt;nx = is_nx(vcpu);</span><br><span class="line">		context-&gt;root_level = is_la57_mode(vcpu) ?</span><br><span class="line">				PT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;</span><br><span class="line">		reset_rsvds_bits_mask(vcpu, context);</span><br><span class="line">		context-&gt;gva_to_gpa = paging64_gva_to_gpa;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_pae(vcpu)) &#123;</span><br><span class="line">		context-&gt;nx = is_nx(vcpu);</span><br><span class="line">		context-&gt;root_level = PT32E_ROOT_LEVEL;</span><br><span class="line">		reset_rsvds_bits_mask(vcpu, context);</span><br><span class="line">		context-&gt;gva_to_gpa = paging64_gva_to_gpa;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		context-&gt;nx = <span class="literal">false</span>;</span><br><span class="line">		context-&gt;root_level = PT32_ROOT_LEVEL;</span><br><span class="line">		reset_rsvds_bits_mask(vcpu, context);</span><br><span class="line">		context-&gt;gva_to_gpa = paging32_gva_to_gpa;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	update_permission_bitmask(vcpu, context, <span class="literal">false</span>);</span><br><span class="line">	update_pkru_bitmask(vcpu, context, <span class="literal">false</span>);</span><br><span class="line">	update_last_nonleaf_level(vcpu, context);</span><br><span class="line">	reset_tdp_shadow_zero_bits_mask(vcpu, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>每次run之前都会reload mmu</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vcpu_enter_guest</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    r = kvm_mmu_reload(vcpu);</span><br><span class="line">    kvm_x86_ops-&gt;run(vcpu);</span><br><span class="line">    r = kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kvm_mmu_reload</code>-&gt;<code>kvm_mmu_load</code>-&gt;<code>mmu_alloc_roots</code>-&gt;<code>mmu_alloc_direct_roots</code></p>
<h4 id="EPT"><a href="#EPT" class="headerlink" title="EPT"></a>EPT</h4><p>spt是shadow page table 虽然命名是影子页表，但实际上是EPT复用了这个数据结构。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/huang987246510/article/details/105645656/">内存虚拟化软件基础——KVM SPT_spt和ept_享乐主的博客-CSDN博客</a></p>
<p><img src="C:\Users\Shen\AppData\Roaming\Typora\typora-user-images\image-20230703194155548.png" alt="image-20230703194155548"></p>
<p>这里page table page不是只记录一个基地址然后用指针连接，而是每个page都会对应一个<code>kvm_mmu_page</code>结构体，spt成员变量为真实的page table page</p>
<p>这里root_hpa是EPT的基地址（HPA）</p>
<h5 id="构造流程"><a href="#构造流程" class="headerlink" title="构造流程"></a>构造流程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kvm_mmu_load</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	r = mmu_alloc_roots(vcpu);</span><br><span class="line">	vcpu-&gt;arch.mmu.set_cr3(vcpu, vcpu-&gt;arch.mmu.root_hpa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mmu_alloc_direct_roots</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_mmu_page</span> *<span class="title">sp</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> i;</span><br><span class="line">	<span class="keyword">if</span> (vcpu-&gt;arch.mmu.shadow_root_level &gt;= PT64_ROOT_4LEVEL) &#123;</span><br><span class="line">		spin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class="line">		<span class="keyword">if</span>(make_mmu_pages_available(vcpu) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			spin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		sp = kvm_mmu_get_page(vcpu, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">				vcpu-&gt;arch.mmu.shadow_root_level, <span class="number">1</span>, ACC_ALL);</span><br><span class="line">		++sp-&gt;root_count;</span><br><span class="line">		spin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class="line">		vcpu-&gt;arch.mmu.root_hpa = __pa(sp-&gt;spt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> kvm_mmu_page *<span class="title function_">kvm_mmu_get_page</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu,</span></span><br><span class="line"><span class="params">				<span class="type">gfn_t</span> gfn,<span class="type">gva_t</span> gaddr,<span class="type">unsigned</span> level,<span class="type">int</span> direct, <span class="type">unsigned</span> access)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">kvm_mmu_page_role</span> <span class="title">role</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> quadrant;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_mmu_page</span> *<span class="title">sp</span>;</span></span><br><span class="line">	<span class="type">bool</span> need_sync = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> flush = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> collisions = <span class="number">0</span>;</span><br><span class="line">	LIST_HEAD(invalid_list);</span><br><span class="line"></span><br><span class="line">	role = vcpu-&gt;arch.mmu.base_role;</span><br><span class="line">	role.level = level;</span><br><span class="line">	role.direct = direct;</span><br><span class="line">	<span class="keyword">if</span> (role.direct)</span><br><span class="line">		role.cr4_pae = <span class="number">0</span>;</span><br><span class="line">	role.access = access;</span><br><span class="line">	for_each_valid_sp(vcpu-&gt;kvm, sp, gfn) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sp-&gt;gfn != gfn) &#123;</span><br><span class="line">			collisions++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!need_sync &amp;&amp; sp-&gt;unsync)</span><br><span class="line">			need_sync = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (sp-&gt;role.word != role.word)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	++vcpu-&gt;kvm-&gt;stat.mmu_cache_miss;</span><br><span class="line">	sp = kvm_mmu_alloc_page(vcpu, direct);</span><br><span class="line">	sp-&gt;gfn = gfn;</span><br><span class="line">	sp-&gt;role = role;</span><br><span class="line">	hlist_add_head(&amp;sp-&gt;hash_link,</span><br><span class="line">		&amp;vcpu-&gt;kvm-&gt;arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);</span><br><span class="line">	sp-&gt;mmu_valid_gen = vcpu-&gt;kvm-&gt;arch.mmu_valid_gen;</span><br><span class="line">	clear_page(sp-&gt;spt);</span><br><span class="line">	kvm_mmu_flush_or_zap(vcpu, &amp;invalid_list, <span class="literal">false</span>, flush);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> kvm_mmu_page *<span class="title function_">kvm_mmu_alloc_page</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">int</span> direct)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_mmu_page</span> *<span class="title">sp</span>;</span></span><br><span class="line"></span><br><span class="line">	sp = mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_page_header_cache);</span><br><span class="line">	sp-&gt;spt = mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_page_cache);</span><br><span class="line">	<span class="keyword">if</span> (!direct)</span><br><span class="line">		sp-&gt;gfns = mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_page_cache);</span><br><span class="line">	set_page_private(virt_to_page(sp-&gt;spt), (<span class="type">unsigned</span> <span class="type">long</span>)sp);</span><br><span class="line">	list_add(&amp;sp-&gt;link, &amp;vcpu-&gt;kvm-&gt;arch.active_mmu_pages);</span><br><span class="line">	kvm_mod_used_mmu_pages(vcpu-&gt;kvm, +<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>kvm_mmu_get_page</code>是后续缺页异常添加页表页也会复用到的函数，作用就是返回(不存在时分配)page这个数据结构，不涉及页表页间的连接（配置页表项）</p>
<p><code>kvm_mmu_page</code> 用hash table维护，这样可以直接找到某个地址对应的页表页，不需要遍历4级页表。</p>
<p>这里root给的gfn是0，即GPA是0。初始化只有第一级页表页且不存在任何页表项。</p>
<p>这里虽然每次run都会get_page，但是只有第一次会真的alloc，其他时候都会直接返回第一级页表页。</p>
<p>在第一次run时，kvm不会先根据memslot创建好所有的映射，而是等guest真的访问了再在ept violation中加入对应的页表项。（刚运行时，VM的代码段需要被读取并执行，触发大量ept violation；写内存操作又会触发ept violation）</p>
<p><code>kvm_mmu_flush_or_zap</code>会在一定条件下flush tlb，但是这里的条件都被给了false(linux6.4版本在这里没有flush tlb)</p>
<h5 id="页表页的获取"><a href="#页表页的获取" class="headerlink" title="页表页的获取"></a>页表页的获取</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">mmu_memory_cache_alloc</span><span class="params">(<span class="keyword">struct</span> kvm_mmu_memory_cache *mc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *p;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!mc-&gt;nobjs);</span><br><span class="line">	p = mc-&gt;objects[--mc-&gt;nobjs];</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mmu_topup_memory_cache_page</span><span class="params">(<span class="keyword">struct</span> kvm_mmu_memory_cache *cache,</span></span><br><span class="line"><span class="params">				       <span class="type">int</span> min)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *page;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cache-&gt;nobjs &gt;= min)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (cache-&gt;nobjs &lt; ARRAY_SIZE(cache-&gt;objects)) &#123;</span><br><span class="line">		page = (<span class="type">void</span> *)__get_free_page(GFP_KERNEL_ACCOUNT);</span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		cache-&gt;objects[cache-&gt;nobjs++] = page;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿page最后会调<code>mm/page_alloc.c</code>的<code>__alloc_pages_nodemask</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/linux/mm.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> page_address(page) lowmem_page_address(page)</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">lowmem_page_address</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> page_to_virt(page);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> page_to_virt(x)	__va(PFN_PHYS(page_to_pfn(x)))</span></span><br><span class="line"><span class="comment">//arch/x86/include/asm</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pa(x)		__phys_addr((unsigned long)(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))</span></span><br><span class="line"><span class="comment">//include/linux/pfn.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PHYS(x)	((phys_addr_t)(x) &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="comment">//arch/x86/mm/physaddr.c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __phys_addr(<span class="type">unsigned</span> <span class="type">long</span> x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> y = x - __START_KERNEL_map;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(x &gt; y)) &#123;</span><br><span class="line">		x = y + phys_base;</span><br><span class="line">		VIRTUAL_BUG_ON(y &gt;= KERNEL_IMAGE_SIZE);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		x = y + (__START_KERNEL_map - PAGE_OFFSET);</span><br><span class="line">		VIRTUAL_BUG_ON((x &gt; y) || !phys_addr_valid(x));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vcpu-&gt;arch.mmu.root_hpa = __pa(sp-&gt;spt);</code>可以看到EPT基地址用的是内核在内存模块拿到的页并转换为的物理地址，即HPA</p>
<h4 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vmx_set_cr3</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">unsigned</span> <span class="type">long</span> cr3)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> guest_cr3;</span><br><span class="line">	u64 eptp;</span><br><span class="line">	guest_cr3 = cr3;</span><br><span class="line">	<span class="keyword">if</span> (enable_ept) &#123;</span><br><span class="line">		eptp = construct_eptp(vcpu, cr3);</span><br><span class="line">		vmcs_write64(EPT_POINTER, eptp);</span><br><span class="line">		<span class="keyword">if</span> (is_paging(vcpu) || is_guest_mode(vcpu))</span><br><span class="line">			guest_cr3 = kvm_read_cr3(vcpu);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			guest_cr3 = vcpu-&gt;kvm-&gt;arch.ept_identity_map_addr;</span><br><span class="line">		ept_load_pdptrs(vcpu);</span><br><span class="line">	&#125;</span><br><span class="line">	vmx_flush_tlb(vcpu, <span class="literal">true</span>);</span><br><span class="line">	vmcs_writel(GUEST_CR3, guest_cr3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>vmx_set_cr3</code>一方面把用户的cr3写到VMCS中，另一方面把自己构造的EPT也写到VMCS中</p>
<p>操作系统都会先在不开MMU的情况下配置页表，然后打开MMU，这些都不会下陷到VMM（不使用cr3，只使用ept）</p>
<p>每次进入non-root模式会把当前VMCS的cr3赋值给cr3，使用cr3和VMCS的EPT</p>
<h2 id="EPT-VIOLATION"><a href="#EPT-VIOLATION" class="headerlink" title="EPT VIOLATION"></a>EPT VIOLATION</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vmx_handle_exit</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (exit_reason &lt; kvm_vmx_max_exit_handlers</span><br><span class="line">	    &amp;&amp; kvm_vmx_exit_handlers[exit_reason])</span><br><span class="line">		<span class="keyword">return</span> kvm_vmx_exit_handlers[exit_reason](vcpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GVA-GPA"><a href="#GVA-GPA" class="headerlink" title="GVA-&gt;GPA"></a>GVA-&gt;GPA</h3><p>Guest的GVA-&gt;GPA缺页异常由自己完成，<code>EPT_VIOLATION</code>只存在于存在GVA-&gt;GPA但不存在GPA-&gt;HPA的情况</p>
<p>发生<code>EPT_VIOLATION</code>前 异常的GPA会被自动保存到当前VMCS的<code>GUEST_PHYSICAL_ADDRESS</code>字段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_ept_violation</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">gpa_t</span> gpa=vmcs_read64(GUEST_PHYSICAL_ADDRESS);</span><br><span class="line">    <span class="keyword">return</span> kvm_mmu_page_fault(vcpu, gpa, error_code, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kvm_mmu_page_fault</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">gpa_t</span> cr2_or_gpa, u64 error_code,</span></span><br><span class="line"><span class="params">		       <span class="type">void</span> *insn, <span class="type">int</span> insn_len)</span></span><br><span class="line">&#123;</span><br><span class="line">	r = vcpu-&gt;arch.mmu.page_fault(vcpu, cr2_or_gpa,</span><br><span class="line">					       lower_32_bits(error_code),<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (r == RET_PF_RETRY)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tdp_page_fault</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">gpa_t</span> gpa, u32 error_code,<span class="type">bool</span> prefault)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">kvm_pfn_t</span> pfn;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">int</span> level;</span><br><span class="line">	<span class="type">bool</span> force_pt_level;</span><br><span class="line">	<span class="type">gfn_t</span> gfn = gpa &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmu_seq;</span><br><span class="line">	<span class="type">int</span> write = error_code &amp; PFERR_WRITE_MASK;</span><br><span class="line">	<span class="type">bool</span> map_writable;</span><br><span class="line">	<span class="type">bool</span> lpage_disallowed = (error_code &amp; PFERR_FETCH_MASK) &amp;&amp;</span><br><span class="line">				is_nx_huge_page_enabled();</span><br><span class="line"></span><br><span class="line">	MMU_WARN_ON(!VALID_PAGE(vcpu-&gt;arch.mmu.root_hpa));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (page_fault_handle_page_track(vcpu, error_code, gfn))</span><br><span class="line">		<span class="keyword">return</span> RET_PF_EMULATE;</span><br><span class="line"></span><br><span class="line">	r = mmu_topup_memory_caches(vcpu);</span><br><span class="line">	<span class="keyword">if</span> (r)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	force_pt_level =</span><br><span class="line">		lpage_disallowed ||</span><br><span class="line">		!check_hugepage_cache_consistency(vcpu, gfn, PT_DIRECTORY_LEVEL);</span><br><span class="line">	level = mapping_level(vcpu, gfn, &amp;force_pt_level);</span><br><span class="line">	<span class="keyword">if</span> (likely(!force_pt_level)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (level &gt; PT_DIRECTORY_LEVEL &amp;&amp;</span><br><span class="line">		    !check_hugepage_cache_consistency(vcpu, gfn, level))</span><br><span class="line">			level = PT_DIRECTORY_LEVEL;</span><br><span class="line">		gfn &amp;= ~(KVM_PAGES_PER_HPAGE(level) - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fast_page_fault(vcpu, gpa, level, error_code))</span><br><span class="line">		<span class="keyword">return</span> RET_PF_RETRY;</span><br><span class="line"></span><br><span class="line">	mmu_seq = vcpu-&gt;kvm-&gt;mmu_notifier_seq;</span><br><span class="line">	smp_rmb();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (try_async_pf(vcpu, prefault, gfn, gpa, &amp;pfn, write, &amp;map_writable))</span><br><span class="line">		<span class="keyword">return</span> RET_PF_RETRY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (handle_abnormal_pfn(vcpu, <span class="number">0</span>, gfn, pfn, ACC_ALL, &amp;r))</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	r = RET_PF_RETRY;</span><br><span class="line">	spin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class="line">	<span class="keyword">if</span> (mmu_notifier_retry(vcpu-&gt;kvm, mmu_seq))</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	<span class="keyword">if</span> (make_mmu_pages_available(vcpu) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	<span class="keyword">if</span> (likely(!force_pt_level))</span><br><span class="line">		transparent_hugepage_adjust(vcpu, gfn, &amp;pfn, &amp;level);</span><br><span class="line">	r = __direct_map(vcpu, gpa, write, map_writable, level, pfn,</span><br><span class="line">			 prefault, lpage_disallowed);</span><br><span class="line">out_unlock:</span><br><span class="line">	spin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class="line">	kvm_release_pfn_clean(pfn);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GPA-HVA"><a href="#GPA-HVA" class="headerlink" title="GPA-&gt;HVA"></a>GPA-&gt;HVA</h3><p>先根据memslot做GPA-&gt;HVA</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">try_async_pf</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">bool</span> prefault, <span class="type">gfn_t</span> gfn,</span></span><br><span class="line"><span class="params">			 <span class="type">gpa_t</span> cr2_or_gpa, <span class="type">kvm_pfn_t</span> *pfn, <span class="type">bool</span> write,</span></span><br><span class="line"><span class="params">			 <span class="type">bool</span> *writable)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_memory_slot</span> *<span class="title">slot</span>;</span></span><br><span class="line">	<span class="type">bool</span> async;</span><br><span class="line"></span><br><span class="line">	slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</span><br><span class="line">	async = <span class="literal">false</span>;</span><br><span class="line">	*pfn = __gfn_to_pfn_memslot(slot, gfn, <span class="literal">false</span>, &amp;async, write, writable);</span><br><span class="line">	<span class="keyword">if</span> (!async)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* *pfn has correct page already */</span></span><br><span class="line">	<span class="keyword">if</span> (!prefault &amp;&amp; kvm_can_do_async_pf(vcpu)) &#123;</span><br><span class="line">		trace_kvm_try_async_get_page(cr2_or_gpa, gfn);</span><br><span class="line">		<span class="keyword">if</span> (kvm_find_async_pf_gfn(vcpu, gfn)) &#123;</span><br><span class="line">			trace_kvm_async_pf_doublefault(cr2_or_gpa, gfn);</span><br><span class="line">			kvm_make_request(KVM_REQ_APF_HALT, vcpu);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (kvm_arch_setup_async_pf(vcpu, cr2_or_gpa, gfn))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pfn = __gfn_to_pfn_memslot(slot, gfn, <span class="literal">false</span>, <span class="literal">NULL</span>, write, writable);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里pfn并没有检查返回值，如果是错误情况会在后面用到的时候进行处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">kvm_pfn_t</span> __gfn_to_pfn_memslot(<span class="keyword">struct</span> kvm_memory_slot *slot, <span class="type">gfn_t</span> gfn,</span><br><span class="line">			       <span class="type">bool</span> atomic, <span class="type">bool</span> *async, <span class="type">bool</span> write_fault,</span><br><span class="line">			       <span class="type">bool</span> *writable)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> addr = __gfn_to_hva_many(slot, gfn, <span class="literal">NULL</span>, write_fault);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr == KVM_HVA_ERR_RO_BAD) &#123;</span><br><span class="line">		<span class="keyword">if</span> (writable)</span><br><span class="line">			*writable = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> KVM_PFN_ERR_RO_FAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (kvm_is_error_hva(addr)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (writable)</span><br><span class="line">			*writable = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> KVM_PFN_NOSLOT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (writable &amp;&amp; memslot_is_readonly(slot)) &#123;</span><br><span class="line">		*writable = <span class="literal">false</span>;</span><br><span class="line">		writable = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hva_to_pfn(addr, atomic, async, write_fault,</span><br><span class="line">			  writable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__gfn_to_hva_many</code>-&gt;<code>__gfn_to_hva_memslot</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line">__gfn_to_hva_memslot(<span class="keyword">struct</span> kvm_memory_slot *slot, <span class="type">gfn_t</span> gfn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> offset = gfn - slot-&gt;base_gfn;</span><br><span class="line">	offset = array_index_nospec(offset, slot-&gt;npages);</span><br><span class="line">	<span class="keyword">return</span> slot-&gt;userspace_addr + offset * PAGE_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回的hva是guest发生page fault的GPA对应的HVA</p>
<p><code>KVM_PFN_NOSLOT</code>会在<code>set_spte</code>中通过<code>is_noslot_pfn</code> <code>mark_mmio_spte</code>特殊处理 下一次访问会触发EPT misconfig</p>
<h3 id="HVA-HPA"><a href="#HVA-HPA" class="headerlink" title="HVA-&gt;HPA"></a>HVA-&gt;HPA</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">kvm_pfn_t</span> <span class="title function_">hva_to_pfn</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">bool</span> atomic, <span class="type">bool</span> *async,</span></span><br><span class="line"><span class="params">			<span class="type">bool</span> write_fault, <span class="type">bool</span> *writable)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="type">kvm_pfn_t</span> pfn = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> npages, r;</span><br><span class="line">	<span class="keyword">if</span> (hva_to_pfn_fast(addr, atomic, async, write_fault, writable, &amp;pfn))</span><br><span class="line">		<span class="keyword">return</span> pfn;</span><br><span class="line">	npages = hva_to_pfn_slow(addr, async, write_fault, writable, &amp;pfn);</span><br><span class="line">	<span class="keyword">if</span> (npages == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> pfn;</span><br><span class="line">	down_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">if</span> (npages == -EHWPOISON ||</span><br><span class="line">	      (!async &amp;&amp; check_user_page_hwpoison(addr))) &#123;</span><br><span class="line">		pfn = KVM_PFN_ERR_HWPOISON;</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">	&#125;</span><br><span class="line">retry:</span><br><span class="line">	vma = find_vma_intersection(current-&gt;mm, addr, addr + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (vma == <span class="literal">NULL</span>)</span><br><span class="line">		pfn = KVM_PFN_ERR_FAULT;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (vma-&gt;vm_flags &amp; (VM_IO | VM_PFNMAP)) &#123;</span><br><span class="line">		r = hva_to_pfn_remapped(vma, addr, async, write_fault, writable, &amp;pfn);</span><br><span class="line">		<span class="keyword">if</span> (r == -EAGAIN)</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">		<span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">			pfn = KVM_PFN_ERR_FAULT;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (async &amp;&amp; vma_is_valid(vma, write_fault))</span><br><span class="line">			*async = <span class="literal">true</span>;</span><br><span class="line">		pfn = KVM_PFN_ERR_FAULT;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">	up_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过mm模块的<code>find_vma_intersection</code>找到和[addr,addr+1)相交的VMA，如果不存在说明HVA是错的(用户态memslot申请的地址空间并没有用malloc或mmap获取)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hva_to_pfn_remapped</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">			       <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">bool</span> *async,</span></span><br><span class="line"><span class="params">			       <span class="type">bool</span> write_fault, <span class="type">bool</span> *writable,</span></span><br><span class="line"><span class="params">			       <span class="type">kvm_pfn_t</span> *p_pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">kvm_pfn_t</span> pfn;</span><br><span class="line">	<span class="type">pte_t</span> *ptep;</span><br><span class="line">	<span class="type">spinlock_t</span> *ptl;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	r = follow_pte_pmd(vma-&gt;vm_mm, addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;ptep, <span class="literal">NULL</span>, &amp;ptl);</span><br><span class="line">	<span class="keyword">if</span> (r) &#123;</span><br><span class="line">		<span class="type">bool</span> unlocked = <span class="literal">false</span>;</span><br><span class="line">		r = fixup_user_fault(current, current-&gt;mm, addr,</span><br><span class="line">				     (write_fault ? FAULT_FLAG_WRITE : <span class="number">0</span>), &amp;unlocked);</span><br><span class="line">		<span class="keyword">if</span> (unlocked)</span><br><span class="line">			<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">		<span class="keyword">if</span> (r)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		r = follow_pte_pmd(vma-&gt;vm_mm, addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;ptep, <span class="literal">NULL</span>, &amp;ptl);</span><br><span class="line">		<span class="keyword">if</span> (r)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (write_fault &amp;&amp; !pte_write(*ptep)) &#123;</span><br><span class="line">		pfn = KVM_PFN_ERR_RO_FAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (writable)</span><br><span class="line">		*writable = pte_write(*ptep);</span><br><span class="line">	pfn = pte_pfn(*ptep);</span><br><span class="line">	<span class="keyword">if</span> (!kvm_try_get_pfn(pfn))</span><br><span class="line">		r = -EFAULT;</span><br><span class="line">out:</span><br><span class="line">	pte_unmap_unlock(ptep, ptl);</span><br><span class="line">	*p_pfn = pfn;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __follow_pte_pmd(<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> address,</span><br><span class="line">			    <span class="type">unsigned</span> <span class="type">long</span> *start, <span class="type">unsigned</span> <span class="type">long</span> *end,</span><br><span class="line">			    <span class="type">pte_t</span> **ptepp, <span class="type">pmd_t</span> **pmdpp, <span class="type">spinlock_t</span> **ptlp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pgd_t</span> *pgd;</span><br><span class="line">	<span class="type">p4d_t</span> *p4d;</span><br><span class="line">	<span class="type">pud_t</span> *pud;</span><br><span class="line">	<span class="type">pmd_t</span> *pmd;</span><br><span class="line">	<span class="type">pte_t</span> *ptep;</span><br><span class="line"></span><br><span class="line">	pgd = pgd_offset(mm, address);</span><br><span class="line">	<span class="keyword">if</span> (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	p4d = p4d_offset(pgd, address);</span><br><span class="line">	<span class="keyword">if</span> (p4d_none(*p4d) || unlikely(p4d_bad(*p4d)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	pud = pud_offset(p4d, address);</span><br><span class="line">	<span class="keyword">if</span> (pud_none(*pud) || unlikely(pud_bad(*pud)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	pmd = pmd_offset(pud, address);</span><br><span class="line">	VM_BUG_ON(pmd_trans_huge(*pmd));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pmd_huge(*pmd)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!pmdpp)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (start &amp;&amp; end) &#123;</span><br><span class="line">			*start = address &amp; PMD_MASK;</span><br><span class="line">			*end = *start + PMD_SIZE;</span><br><span class="line">			mmu_notifier_invalidate_range_start(mm, *start, *end);</span><br><span class="line">		&#125;</span><br><span class="line">		*ptlp = pmd_lock(mm, pmd);</span><br><span class="line">		<span class="keyword">if</span> (pmd_huge(*pmd)) &#123;</span><br><span class="line">			*pmdpp = pmd;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		spin_unlock(*ptlp);</span><br><span class="line">		<span class="keyword">if</span> (start &amp;&amp; end)</span><br><span class="line">			mmu_notifier_invalidate_range_end(mm, *start, *end);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start &amp;&amp; end) &#123;</span><br><span class="line">		*start = address &amp; PAGE_MASK;</span><br><span class="line">		*end = *start + PAGE_SIZE;</span><br><span class="line">		mmu_notifier_invalidate_range_start(mm, *start, *end);</span><br><span class="line">	&#125;</span><br><span class="line">	ptep = pte_offset_map_lock(mm, pmd, address, ptlp);</span><br><span class="line">	<span class="keyword">if</span> (!pte_present(*ptep))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	*ptepp = ptep;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">unlock:</span><br><span class="line">	pte_unmap_unlock(ptep, *ptlp);</span><br><span class="line">	<span class="keyword">if</span> (start &amp;&amp; end)</span><br><span class="line">		mmu_notifier_invalidate_range_end(mm, *start, *end);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arch/arc/include/asm/pgtable.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_index(addr)		((addr) &gt;&gt; PGDIR_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_offset(mm, addr)	(((mm)-&gt;pgd)+pgd_index(addr))</span></span><br></pre></td></tr></table></figure>

<p>pgd p4d pud pmd分别是一二三四级页表，直接通过一些宏直接来索引。</p>
<p>这里通过内核中维护的当前进程的页表信息找到EPT中缺失的HVA-&gt;HPA，也就是说当前进程页表拥有的HVA-&gt;HPA映射处于某种原因没有被更新到EPT上</p>
<p>如果进程页表中也不存在对应的页表项，说明对该进程发生了一般的page fault，调用</p>
<p><code>fixup_user_fault</code>-&gt;<code>handle_mm_fault</code>-&gt;<code>__handle_mm_fault</code>处理</p>
<p>内核mm模块保证了这时HPA对应的VMA、物理页、进程页表都存在且合法，后续把GVA-&gt;HPA加入EPT即可</p>
<p>写保护？</p>
<p>换页？</p>
<h3 id="遍历页表"><a href="#遍历页表" class="headerlink" title="遍历页表"></a>遍历页表</h3><p>shadow_addr &#x3D; root_hpa &#x3D; EPT的基地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_shadow_entry(_vcpu, _addr, _walker)    \</span></span><br><span class="line"><span class="meta">	for (shadow_walk_init(&amp;(_walker), _vcpu, _addr);	\</span></span><br><span class="line"><span class="meta">	     shadow_walk_okay(&amp;(_walker));			\</span></span><br><span class="line"><span class="meta">	     shadow_walk_next(&amp;(_walker)))</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shadow_walk_init</span><span class="params">(<span class="keyword">struct</span> kvm_shadow_walk_iterator *iterator,</span></span><br><span class="line"><span class="params">			     <span class="keyword">struct</span> kvm_vcpu *vcpu, u64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	iterator-&gt;addr = addr;</span><br><span class="line">	iterator-&gt;shadow_addr = vcpu-&gt;arch.mmu.root_hpa;</span><br><span class="line">	iterator-&gt;level = vcpu-&gt;arch.mmu.shadow_root_level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">shadow_walk_okay</span><span class="params">(<span class="keyword">struct</span> kvm_shadow_walk_iterator *iterator)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (iterator-&gt;level &lt; PT_PAGE_TABLE_LEVEL)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	iterator-&gt;index = SHADOW_PT_INDEX(iterator-&gt;addr, iterator-&gt;level);</span><br><span class="line">	iterator-&gt;sptep	= ((u64 *)__va(iterator-&gt;shadow_addr)) + iterator-&gt;index;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shadow_walk_next</span><span class="params">(<span class="keyword">struct</span> kvm_shadow_walk_iterator *iterator)</span></span><br><span class="line">&#123;</span><br><span class="line">	__shadow_walk_next(iterator, *iterator-&gt;sptep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __shadow_walk_next(<span class="keyword">struct</span> kvm_shadow_walk_iterator *iterator,</span><br><span class="line">			       u64 spte)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (is_last_spte(spte, iterator-&gt;level)) &#123;</span><br><span class="line">		iterator-&gt;level = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iterator-&gt;shadow_addr = spte &amp; PT64_BASE_ADDR_MASK;</span><br><span class="line">	--iterator-&gt;level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于页表项和EPT基地址都记录的是物理地址，即HPA，这里访问都需要先转成虚拟地址即HVA来使用。</p>
<h3 id="加入映射"><a href="#加入映射" class="headerlink" title="加入映射"></a>加入映射</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leoufung/article/details/52661968">__direct_map 函数解析之影子页表的构建_direct map_leoufung的博客-CSDN博客</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __direct_map(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">gpa_t</span> gpa, <span class="type">int</span> write,</span><br><span class="line">			<span class="type">int</span> map_writable, <span class="type">int</span> level, <span class="type">kvm_pfn_t</span> pfn,</span><br><span class="line">			<span class="type">bool</span> prefault, <span class="type">bool</span> lpage_disallowed)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_shadow_walk_iterator</span> <span class="title">it</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_mmu_page</span> *<span class="title">sp</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">gfn_t</span> gfn = gpa &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	<span class="type">gfn_t</span> base_gfn = gfn;</span><br><span class="line">	<span class="keyword">if</span> (!VALID_PAGE(vcpu-&gt;arch.mmu.root_hpa))</span><br><span class="line">		<span class="keyword">return</span> RET_PF_RETRY;</span><br><span class="line">	trace_kvm_mmu_spte_requested(gpa, level, pfn);</span><br><span class="line">	for_each_shadow_entry(vcpu, gpa, it) &#123;</span><br><span class="line">		disallowed_hugepage_adjust(it, gfn, &amp;pfn, &amp;level);</span><br><span class="line">		base_gfn = gfn &amp; ~(KVM_PAGES_PER_HPAGE(it.level) - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (it.level == level)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		drop_large_spte(vcpu, it.sptep);</span><br><span class="line">		<span class="keyword">if</span> (!is_shadow_present_pte(*it.sptep)) &#123;</span><br><span class="line">			sp = kvm_mmu_get_page(vcpu, base_gfn, it.addr,</span><br><span class="line">					      it.level - <span class="number">1</span>, <span class="literal">true</span>, ACC_ALL);</span><br><span class="line">			link_shadow_page(vcpu, it.sptep, sp);</span><br><span class="line">			<span class="keyword">if</span> (lpage_disallowed)</span><br><span class="line">				account_huge_nx_page(vcpu-&gt;kvm, sp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = mmu_set_spte(vcpu, it.sptep, ACC_ALL,</span><br><span class="line">			   write, level, base_gfn, pfn, prefault,</span><br><span class="line">			   map_writable);</span><br><span class="line">	direct_pte_prefetch(vcpu, it.sptep);</span><br><span class="line">	++vcpu-&gt;stat.pf_fixed;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kvm_mmu_get_page</code>在不存在的情况下创建欣的页表页，<code>link_shadow_page</code>连接两级页表，<code>mmu_set_spte</code>在最后一级页表填入HPA</p>
<p>遍历页表的循环动态补全了GPA对应的页表页，最后写入映射到HPA的页表项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rmap_add</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, u64 *spte, <span class="type">gfn_t</span> gfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_mmu_page</span> *<span class="title">sp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm_rmap_head</span> *<span class="title">rmap_head</span>;</span></span><br><span class="line"></span><br><span class="line">	sp = page_header(__pa(spte));</span><br><span class="line">	kvm_mmu_page_set_gfn(sp, spte - sp-&gt;spt, gfn);</span><br><span class="line">	rmap_head = gfn_to_rmap(vcpu-&gt;kvm, gfn, sp);</span><br><span class="line">	<span class="keyword">return</span> pte_list_add(vcpu, spte, rmap_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且会加入反向映射</p>
<p><code>mmu_set_spte</code>-&gt;<code>kvm_flush_remote_tlbs</code>-&gt;<code>kvm_make_all_cpus_request(kvm, KVM_REQ_TLB_FLUSH)</code></p>
<p><code>vcpu_enter_guest</code>-&gt;<code>kvm_vcpu_flush_tlb</code>-&gt;<code>vmx_flush_tlb</code>-&gt;<code>__vmx_flush_tlb</code>-&gt;<code>ept_sync_context(construct_eptp(vcpu, vcpu-&gt;arch.mmu.root_hpa));</code>-&gt;<code>__invept</code></p>
<p>最后用到VMX的<code>INVEPT</code>指令 手册<code>28.3.3.4 Guidelines for Use of the INVEPT Instruction</code></p>
<blockquote>
<p> the INVEPT instruction to invalidate information cached from the  EPT paging structures.</p>
</blockquote>
<p>tlb存的是GVA-&gt;HPA 还是HVA-&gt;HPA不确定，和VMX在硬件上的具体实现有关，所以需要特殊VMX指令而不是普通flush tlb的指令例如<code>invlpg</code>而是仍然需要使用VMX扩展指令？</p>
<h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/588911110">linux内核源码解析- 匿名页面生命周期 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.openeuler.org/en/blog/liqunsheng/2020-11-26-swap.html">Linux 中的内存交换 (openeuler.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LoyenWang/p/11827153.html">【原创】（十）Linux内存管理 - zoned page frame allocator - 5 - LoyenWang - 博客园 (cnblogs.com)</a></p>
<p>[<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010923083/article/details/116278456">内核内存] [arm64] 内存回收4—shrink_node函数详解_shrink函数_早起的虫儿有鹰吃的博客-CSDN博客</a></p>
<h3 id="swap-out"><a href="#swap-out" class="headerlink" title="swap out"></a>swap out</h3><p>mm&#x2F;vmscan.c <code>shrink_page_list</code> 高版本<code>shrink_folio_list</code></p>
<p><code>shrink_page_list</code>-&gt;<code>rmap_walk</code>-&gt;<code>try_to_unmap_one</code> -&gt; <code>mmu_notifier_invalidate_range_start</code></p>
<p>解映射(内核自己的  还有通知KVM EPT的)</p>
<p><code>kvm_unmap_hva_range</code> <code>kvm_handle_hva_range</code> <code>kvm_unmap_rmapp</code> <code>kvm_zap_rmapp</code> <code>rmap_get_first</code> <code>drop_spte ``rmap_remove</code> <code>pte_list_remove</code></p>
<p><code>page_vma_mapped_walk</code> 根据page结构体存的信息拿到对应的vma 再遍历页表拿到pte 最后unmap pte</p>
<p><code>shrink_page_list</code>-&gt;<code>pageout</code> 写磁盘</p>
<p>内核为了节约空间 先找VMA 再找pte 但是kvm是直接维护的spte</p>
<p><img src="http://jake.dothome.co.kr/wp-content/uploads/2017/01/do_swap_page-1a.png" alt="image"></p>
<p>[Linux中的Anonymous Pages和Swap <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/70964551">一] - 知乎 (zhihu.com)</a></p>
<p>[Qemu-kvm memory 虚拟化 | Tian-Daye on the Way (xingguotian.github.io)](<a target="_blank" rel="noopener" href="https://xingguotian.github.io/2019/08/23/qemu-kvm">https://xingguotian.github.io/2019/08/23/qemu-kvm</a> 内存虚拟化&#x2F;)</p>
<p><a target="_blank" rel="noopener" href="http://www.wowotech.net/memory_management/reverse_mapping.html">逆向映射的演进 (wowotech.net)</a></p>
<p>建立反向映射：<a target="_blank" rel="noopener" href="https://www.codenong.com/cs106477291/">5. EPT机制 | 码农家园 (codenong.com)</a></p>
<p>KVM的EPT维护一个rmap 反向映射</p>
<p>KVM启动先向内核mm模块注册一个回调函数，内核发生swap会通知KVM处理</p>
<p>解开反向映射：<a target="_blank" rel="noopener" href="https://www.openeuler.org/en/blog/liqunsheng/2020-11-26-swap.html">Linux 中的内存交换 (openeuler.org)</a></p>
<h3 id="swap-in"><a href="#swap-in" class="headerlink" title="swap in"></a>swap in</h3><p><code>do_swap_page</code>-&gt;<code>do_wp_page</code>-&gt;<code>wp_page_copy</code>-&gt;<code>set_pte_at_notify</code>-&gt;<code>mmu_notifier_change_pte</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mm/memory.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __handle_mm_fault(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> address,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_fault</span> <span class="title">vmf</span> =</span> &#123;</span><br><span class="line">		.vma = vma,</span><br><span class="line">		.address = address &amp; PAGE_MASK,</span><br><span class="line">		.flags = flags,</span><br><span class="line">		.pgoff = linear_page_index(vma, address),</span><br><span class="line">		.gfp_mask = __get_fault_gfp_mask(vma),</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> dirty = flags &amp; FAULT_FLAG_WRITE;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> vma-&gt;vm_mm;</span><br><span class="line">	<span class="type">pgd_t</span> *pgd;</span><br><span class="line">	<span class="type">p4d_t</span> *p4d;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	pgd = pgd_offset(mm, address);</span><br><span class="line">	p4d = p4d_alloc(mm, pgd, address);</span><br><span class="line">	<span class="keyword">if</span> (!p4d)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">	vmf.pud = pud_alloc(mm, p4d, address);</span><br><span class="line">	<span class="keyword">if</span> (!vmf.pud)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">    ...</span><br><span class="line">	vmf.pmd = pmd_alloc(mm, vmf.pud, address);</span><br><span class="line">	<span class="keyword">if</span> (!vmf.pmd)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> handle_pte_fault(&amp;vmf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_pte_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    vmf-&gt;pte = pte_offset_map(vmf-&gt;pmd, vmf-&gt;address);</span><br><span class="line">    vmf-&gt;orig_pte = *vmf-&gt;pte;</span><br><span class="line"> 	<span class="keyword">if</span> (!pte_present(vmf-&gt;orig_pte))</span><br><span class="line">		<span class="keyword">return</span> do_swap_page(vmf);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pte_offset_map(dir,addr) pte_offset(dir, addr)</span></span><br><span class="line">Expands to:</span><br><span class="line">((<span class="type">pte_t</span> *)(((((((*vmf-&gt;pmd).pud).pgd))) &amp; (~(((<span class="number">1UL</span>) &lt;&lt; (<span class="number">13</span>))<span class="number">-1</span>)))) + (((vmf-&gt;address) &gt;&gt; <span class="number">13</span>) &amp; (((<span class="number">1UL</span>) &lt;&lt; ((<span class="number">21</span> - <span class="number">13</span>))) - <span class="number">1</span>)))</span><br><span class="line"><span class="comment">//arch/arc/include/asm/pgtable.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pte_present(x)			(pte_val(x) &amp; _PAGE_PRESENT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_PRESENT       (1&lt;&lt;10)	<span class="comment">/* TLB entry is valid (H) */</span></span></span><br></pre></td></tr></table></figure>

<p>虽然代码注释说的是TLB是否有效，但是<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/gorman/html/understand/understand006.html#3.1">Page Table Management (kernel.org)</a>这个链接提到这个bit的意思是</p>
<blockquote>
<p> Page is resident in memory and not swapped out</p>
</blockquote>
<p>EPT并不是根据pte的bit判断swap，而是直接调用mm模块去处理，或者async直接返回用户态，挂起vcpu。</p>
<p><a target="_blank" rel="noopener" href="https://xingguotian.github.io/">Tian-Daye on the Way (xingguotian.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiongtianliuyun/article/details/108295111">Qemu-kvm memory 虚拟化_Cliff Yang的博客-CSDN博客</a></p>
<blockquote>
<p>调用hva_to_pfn时，如果这个函数判断是新分配的内存页，则表明该gfn到pfn的映射并未建立，如果内存页被交换到了磁盘上，则会设置async为true，这样tdp_page_fault就会成功返回，并将当前VCPU线程挂起来。——《QEMUKVM源码解析与应用》</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">kvm_pfn_t</span> <span class="title function_">hva_to_pfn</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">bool</span> atomic, <span class="type">bool</span> *async,</span></span><br><span class="line"><span class="params">			<span class="type">bool</span> write_fault, <span class="type">bool</span> *writable)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="type">kvm_pfn_t</span> pfn = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> npages, r;</span><br><span class="line">	<span class="keyword">if</span> (hva_to_pfn_fast(addr, atomic, async, write_fault, writable, &amp;pfn))</span><br><span class="line">		<span class="keyword">return</span> pfn;</span><br><span class="line">	npages = hva_to_pfn_slow(addr, async, write_fault, writable, &amp;pfn);</span><br><span class="line">	<span class="keyword">if</span> (npages == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> pfn;</span><br><span class="line">	down_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">if</span> (npages == -EHWPOISON ||</span><br><span class="line">	      (!async &amp;&amp; check_user_page_hwpoison(addr))) &#123;</span><br><span class="line">		pfn = KVM_PFN_ERR_HWPOISON;</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">	&#125;</span><br><span class="line">retry:</span><br><span class="line">	vma = find_vma_intersection(current-&gt;mm, addr, addr + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (vma == <span class="literal">NULL</span>)</span><br><span class="line">		pfn = KVM_PFN_ERR_FAULT;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (vma-&gt;vm_flags &amp; (VM_IO | VM_PFNMAP)) &#123;</span><br><span class="line">		r = hva_to_pfn_remapped(vma, addr, async, write_fault, writable, &amp;pfn);</span><br><span class="line">		<span class="keyword">if</span> (r == -EAGAIN)</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">		<span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">			pfn = KVM_PFN_ERR_FAULT;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (async &amp;&amp; vma_is_valid(vma, write_fault))</span><br><span class="line">			*async = <span class="literal">true</span>;</span><br><span class="line">		pfn = KVM_PFN_ERR_FAULT;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">	up_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch14lev1sec2.html">Memory Areas (gigatux.nl)</a><code>VM_IO</code>表示</p>
<blockquote>
<p>The area maps a device’s I&#x2F;O space</p>
</blockquote>
<p>这里async传入指针，有两个作用</p>
<ol>
<li>指针空或非空表示是否支持async，指导内层函数</li>
<li>如果指针非空，true&#x2F;false表示是否需要async(例如swap0，指导外层函数)</li>
</ol>
<p><code>hva_to_pfn_slow</code>-&gt;<code>get_user_page_nowait</code>-&gt;<code>get_user_pages</code>-&gt;<code>__get_user_pages</code> -&gt;<code>faultin_page</code>-&gt;<code>handle_mm_fault</code>-&gt;<code>__handle_mm_fault</code>-&gt;<code>handle_pte_fault</code>-&gt;<code>do_swap_page</code></p>
<p>这里是同步处理swap</p>
<p>下面是异步处理swap</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">try_async_pf</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">bool</span> prefault, <span class="type">gfn_t</span> gfn,</span></span><br><span class="line"><span class="params">			 <span class="type">gpa_t</span> cr2_or_gpa, <span class="type">kvm_pfn_t</span> *pfn, <span class="type">bool</span> write,</span></span><br><span class="line"><span class="params">			 <span class="type">bool</span> *writable)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (!prefault &amp;&amp; kvm_can_do_async_pf(vcpu)) &#123;</span><br><span class="line">		trace_kvm_try_async_get_page(cr2_or_gpa, gfn);</span><br><span class="line">		<span class="keyword">if</span> (kvm_find_async_pf_gfn(vcpu, gfn)) &#123;</span><br><span class="line">			trace_kvm_async_pf_doublefault(cr2_or_gpa, gfn);</span><br><span class="line">			kvm_make_request(KVM_REQ_APF_HALT, vcpu);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (kvm_arch_setup_async_pf(vcpu, cr2_or_gpa, gfn))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*pfn = __gfn_to_pfn_memslot(slot, gfn, <span class="literal">false</span>, <span class="literal">NULL</span>, write, writable);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//include/linux/kvm_host.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">kvm_make_request</span><span class="params">(<span class="type">int</span> req, <span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	smp_wmb();</span><br><span class="line">	set_bit(req &amp; KVM_REQUEST_MASK, &amp;vcpu-&gt;requests);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果vm支持async，直接返回，不处理；否则再调用一次<code>gfn_to_pfn</code>并不支持async强制同步swap</p>
<p>kvm_make_request对当前vcpu有作用，例如挂起</p>
<p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v4.15/virtual/kvm/vcpu-requests.html">KVM VCPU Requests — The Linux Kernel documentation</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tdp_page_fault</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">gpa_t</span> gpa, u32 error_code,<span class="type">bool</span> prefault)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">if</span> (try_async_pf(vcpu, prefault, gfn, gpa, &amp;pfn, write, &amp;map_writable))</span><br><span class="line">		<span class="keyword">return</span> RET_PF_RETRY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kvm_mmu_page_fault</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="type">gpa_t</span> cr2_or_gpa, u64 error_code,</span></span><br><span class="line"><span class="params">		       <span class="type">void</span> *insn, <span class="type">int</span> insn_len)</span></span><br><span class="line">&#123;</span><br><span class="line">	r = vcpu-&gt;arch.mmu.page_fault(vcpu, cr2_or_gpa,</span><br><span class="line">					       lower_32_bits(error_code),<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (r == RET_PF_RETRY)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_ept_violation</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">gpa_t</span> gpa=vmcs_read64(GUEST_PHYSICAL_ADDRESS);</span><br><span class="line">    <span class="keyword">return</span> kvm_mmu_page_fault(vcpu, gpa, error_code, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vmx_handle_exit</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (exit_reason &lt; kvm_vmx_max_exit_handlers</span><br><span class="line">	    &amp;&amp; kvm_vmx_exit_handlers[exit_reason])</span><br><span class="line">		<span class="keyword">return</span> kvm_vmx_exit_handlers[exit_reason](vcpu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vcpu_enter_guest</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (kvm_request_pending(vcpu)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) &#123;</span><br><span class="line">            <span class="comment">/* Page is swapped out. Do synthetic halt */</span></span><br><span class="line">            vcpu-&gt;arch.apf.halted = <span class="literal">true</span>;</span><br><span class="line">            r = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">   		...</span><br><span class="line">    &#125;</span><br><span class="line">    r = kvm_mmu_reload(vcpu);</span><br><span class="line">    kvm_x86_ops-&gt;run(vcpu);</span><br><span class="line">    r = kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vcpu_run</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvm</span> *<span class="title">kvm</span> =</span> vcpu-&gt;kvm;</span><br><span class="line">	vcpu-&gt;srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu);</span><br><span class="line">	vcpu-&gt;arch.l1tf_flush_l1d = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (kvm_vcpu_running(vcpu)) &#123;</span><br><span class="line">			r = vcpu_enter_guest(vcpu);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r = vcpu_block(kvm, vcpu);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (r &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">	srcu_read_unlock(&amp;kvm-&gt;srcu, vcpu-&gt;srcu_idx);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kvm_arch_vcpu_ioctl_run</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="keyword">struct</span> kvm_run *kvm_run)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (kvm_run-&gt;immediate_exit)</span><br><span class="line">		r = -EINTR;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		r = vcpu_run(vcpu);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//virt/kvm/kvm_main.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">kvm_vcpu_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">			   <span class="type">unsigned</span> <span class="type">int</span> ioctl, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (ioctl) &#123;</span><br><span class="line">	<span class="keyword">case</span> KVM_RUN: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">oldpid</span>;</span></span><br><span class="line">		r = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (arg)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		oldpid = rcu_access_pointer(vcpu-&gt;pid);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(oldpid != current-&gt;pids[PIDTYPE_PID].pid)) &#123;</span><br><span class="line">			<span class="comment">/* The thread running this VCPU changed. */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">newpid</span> =</span> get_task_pid(current, PIDTYPE_PID);</span><br><span class="line"></span><br><span class="line">			rcu_assign_pointer(vcpu-&gt;pid, newpid);</span><br><span class="line">			<span class="keyword">if</span> (oldpid)</span><br><span class="line">				synchronize_rcu();</span><br><span class="line">			put_pid(oldpid);</span><br><span class="line">		&#125;</span><br><span class="line">		r = kvm_arch_vcpu_ioctl_run(vcpu, vcpu-&gt;run);</span><br><span class="line">		trace_kvm_userspace_exit(vcpu-&gt;run-&gt;exit_reason, r);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">kvm_vcpu_fops</span> =</span> &#123;</span><br><span class="line">	.release        = kvm_vcpu_release,</span><br><span class="line">	.unlocked_ioctl = kvm_vcpu_ioctl,</span><br><span class="line">	.mmap           = kvm_vcpu_mmap,</span><br><span class="line">	.llseek		= noop_llseek,</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>之后这个错误就一路返回到用户态了，然后挂起vcpu。等待内核管理内存的线程swap in</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2024/09/17/virtualization/balloon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/17/virtualization/balloon/" class="post-title-link" itemprop="url">balloon</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-09-17 19:48:03" itemprop="dateCreated datePublished" datetime="2024-09-17T19:48:03+08:00">2024-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/virtualization/" itemprop="url" rel="index"><span itemprop="name">virtualization</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>13 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="balloon"><a href="#balloon" class="headerlink" title="balloon"></a>balloon</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>guest使用的内核在编译时需要把config_virtio_balloon的选项打开，可以y直接编译进内核 也可以m作为模块手动加载</li>
<li>qemu启动时加入virtio-balloon选项</li>
</ul>
<p>进入虚拟机后ctrl a c进入qemu monitor</p>
<ul>
<li>info balloon查看当前balloon大小，默认为qemu启动时指定的最大内存</li>
<li>balloon xxx(mb) 调整大小</li>
</ul>
<p>显示的balloon大小为VM真实可用的内存，剩下的给host</p>
<ul>
<li>如果不加入deflate-on-oom参数，VMfree -mh显示内存为balloon大小 超过此大小触发oom killer</li>
<li>如果加入此参数，VM free -mh显示启动指定的最大参数，但是used显示分给host的值 超过balloon大小会自动调大balloon</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.linux-kvm.org/page/Projects/auto-ballooning#TODO">Projects&#x2F;auto-ballooning - KVM (linux-kvm.org)</a></p>
<p>auto balloon似乎被废弃了</p>
<p><a target="_blank" rel="noopener" href="https://www.ovirt.org/develop/projects/mom.html">MoM | oVirt</a>这个工具可能可用</p>
<p>qmp:</p>
<ul>
<li>balloon  value</li>
<li>query-balloon</li>
</ul>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>host guest1 guest2均为4G内存</p>
<ol>
<li>guest1要2G 从内存分配</li>
<li>guest2要2G swap掉guest1</li>
<li>guest1要2G swap掉guest2</li>
</ol>
<p><strong>1 正常情况  guest2要内存 host内存不够 回收 但是guest1的2G被swap</strong> 从htop中guest1的qemu 进程mem占用情况可以看出来</p>
<p>ctrl a c 输入info balloon &#x2F;balloon xxx (MB)</p>
<p>balloon后面的数字代表VM真实可用内存(不参与balloon) 这个值不能超过qemu启动分配的内存</p>
<p>balloon目前找不到合适的自动化监控，需要手动用qemu调</p>
<p><strong>2 guest2需要很多内存的时候手动进guest1的qemu monitor 调小balloon 然后reclaim会直接回收而不是swap</strong></p>
<p>balloon只会回收guest内存 不会回收host上被swap的guest的页</p>
<p><a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/1519495184466483140.html">KVM之四：内存balloon的奇妙_百度知道 (baidu.com)</a></p>
<blockquote>
<p>目前没有比较方便的、自动化的机制来管理ballooning，一般都是采用在QEMU monitor中执行balloon命令来实现ballooning的。没有对VM的有效监控，没有自动化的ballooning机制，这可能会让生产环境中实现大规模自动化部署并不很方便。</p>
</blockquote>
<p><strong>3 如果memhog后sleep 持续占用内存 那balloon会直接把这个进程kill掉 强行拿掉VM的内存</strong></p>
<p>所以用balloon和不用在结果上是有很大区别的。不用balloon host会把VM的所有内存都swap掉 不管free与否；用balloon host会强行回收VM内存 如果不够就让VMkill自己的进程 </p>
<p><strong>4 如果VM配了 swap VM会swap</strong></p>
<blockquote>
<p>如果有大量内存从VM系统中回收，Ballooning可能会降低VM操作系统运行的性能。一方面，内存的减少，可能会让VM中作为磁盘数据缓存的内存被放到气球中，从而VM中的磁盘I&#x2F;O访问会增加；另一方面，如果处理机制不够好，也可能让VM中正在运行的进程由于内存不足而执行失败。</p>
</blockquote>
<p>[<a target="_blank" rel="noopener" href="https://listman.redhat.com/archives/libvir-list/2015-December/msg00494.html">libvirt] [PATCH 2&#x2F;2] qemu: add support of optional ‘deflate-on-oom’ attribute (redhat.com)</a></p>
<p>qemu中可以加入deflate-on-oom的选项，这时候配置了balloon并不会让VM的可用内存变小，而是在VM可用内存不变的情况下增加了Used，之后不会影响VM程序的正常使用。<strong>5 当VM需要的内存大于balloon配置之后，会自动进行deflate 向host要内存 此时info balloon可以看到balloon的值被自动调大了</strong>。但是被调大之后是不会再自动缩小的</p>
<p><strong>6 VM自己swap的优先级是比deflate-on-oom的优先级高的</strong></p>
<p><strong>7 在VMlogout的时候 balloon进行回收 仍然能回收到</strong></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/edver/p/14684138.html">virtio简介（二） —— virtio-balloon guest侧驱动 - Edver - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="http://ssdxiao.github.io/linux/2017/03/20/Virtio-Balloon.html">Virtio-Balloon超详细分析 (ssdxiao.github.io)</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">virtio_driver</span> <span class="title">virtio_balloon_driver</span> =</span> &#123;</span><br><span class="line">	.feature_table = features,</span><br><span class="line">	.feature_table_size = ARRAY_SIZE(features),</span><br><span class="line">	.driver.name =	KBUILD_MODNAME,</span><br><span class="line">	.driver.owner =	THIS_MODULE,</span><br><span class="line">	.id_table =	id_table,</span><br><span class="line">	.validate =	virtballoon_validate,</span><br><span class="line">	.probe =	virtballoon_probe,</span><br><span class="line">	.remove =	virtballoon_remove,</span><br><span class="line">	.config_changed = virtballoon_changed,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">	.freeze	=	virtballoon_freeze,</span><br><span class="line">	.restore =	virtballoon_restore,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本身暴露的接口并不多 可以认为就<code>virtballoon_changed</code>一个</p>
<p>这个内核模块是前端</p>
<p>需要qemu添加<code>-device virtio-balloon-pci</code>在宿主机上创建一个balloon后端</p>
<p>qemu monitor中的balloon指令会向VM中的驱动发送指令，从而调用<code>virtballoon_changed</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __virtio_config_changed(<span class="keyword">struct</span> virtio_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">virtio_driver</span> *<span class="title">drv</span> =</span> drv_to_virtio(dev-&gt;dev.driver);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;config_enabled)</span><br><span class="line">		dev-&gt;config_change_pending = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (drv &amp;&amp; drv-&gt;config_changed)</span><br><span class="line">		drv-&gt;config_changed(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>update_balloon_size_func</code> 每次<code>virtballoon_changed</code>只会发生一次 但是调整大小的函数会触发很多次 不是一次性调整好的，并且<code>virtballoon_changed</code>是异步。如果每次update输出时间影响效率</p>
<p>内核启动时<code>vp_find_vqs_intx</code>注册<code>vp_interrupt</code> 之后向队列写入信息时会产生中断</p>
<p><code>vp_interrupt</code>-&gt;<code>vp_config_changed</code>-&gt;<code>virtio_config_changed</code>-&gt;<code>__virtio_config_changed</code></p>
<p>注册vp_interrupt的函数 追踪调用 发现是probe的init_vqs probe由virio_bus的probe调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">bind_store</span><span class="params">(<span class="keyword">struct</span> device_driver *drv, <span class="type">const</span> <span class="type">char</span> *buf,</span></span><br><span class="line"><span class="params">			  <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> *<span class="title">bus</span> =</span> bus_get(drv-&gt;bus);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">int</span> err = -ENODEV;</span><br><span class="line"></span><br><span class="line">	dev = bus_find_device_by_name(bus, <span class="literal">NULL</span>, buf);</span><br><span class="line">	<span class="keyword">if</span> (dev &amp;&amp; driver_match_device(drv, dev)) &#123;</span><br><span class="line">		err = device_driver_attach(drv, dev);</span><br><span class="line">		<span class="keyword">if</span> (!err) &#123;</span><br><span class="line">			<span class="comment">/* success */</span></span><br><span class="line">			err = count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	put_device(dev);</span><br><span class="line">	bus_put(bus);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> device *<span class="title function_">bus_find_device</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> bus_type *bus,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> device *start, <span class="type">const</span> <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">			       <span class="type">int</span> (*match)(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">void</span> *data))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">sp</span> =</span> bus_to_subsys(bus);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">klist_iter</span> <span class="title">i</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sp)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	klist_iter_init_node(&amp;sp-&gt;klist_devices, &amp;i,</span><br><span class="line">			     (start ? &amp;start-&gt;p-&gt;knode_bus : <span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">while</span> ((dev = next_device(&amp;i)))</span><br><span class="line">		<span class="keyword">if</span> (match(dev, data) &amp;&amp; get_device(dev))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	klist_iter_exit(&amp;i);</span><br><span class="line">	subsys_put(sp);</span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">device_match_name</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">void</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> sysfs_streq(dev_name(dev), name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有device维护在bus这个数据结构中</p>
<p><code>mdev_device_create</code> 创建device</p>
<p>对于qemu的info操作 似乎并不会触发内核的函数 如何通过一个接口看一下时间？</p>
<p>在update size函数中 如果无变化返回之前 加入print</p>
<p>即想查看的时候同样用修改的接口 输入一个不变的值即可</p>
<p>从结果来看比较准确且稳定</p>
<p>fill_balloon会从内核模块alloc page 表示已经拿了这个page 所以guest kernel没法用了</p>
<p>leak_balloon释放这个page</p>
<h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><h4 id="guest"><a href="#guest" class="headerlink" title="guest"></a>guest</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">balloon_page_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> alloc_page(balloon_mapping_gfp_mask() |</span><br><span class="line">				       __GFP_NOMEMALLOC | __GFP_NORETRY);</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="title function_">fill_balloon</span><span class="params">(<span class="keyword">struct</span> virtio_balloon *vb, <span class="type">size_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> num_allocated_pages;</span><br><span class="line">	<span class="type">unsigned</span> num_pfns;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	LIST_HEAD(pages);</span><br><span class="line">	num = min(num, ARRAY_SIZE(vb-&gt;pfns));</span><br><span class="line">	<span class="keyword">for</span> (num_pfns = <span class="number">0</span>; num_pfns &lt; num;</span><br><span class="line">	     num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> balloon_page_alloc();</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">//local list 和balloon_page_pop对应 只是一次性全部alloc而已</span></span><br><span class="line">		balloon_page_push(&amp;pages, page);</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_lock(&amp;vb-&gt;balloon_lock);</span><br><span class="line">	vb-&gt;num_pfns = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((page = balloon_page_pop(&amp;pages))) &#123;</span><br><span class="line">        <span class="comment">//把这次拿到的page全部加入balloon中</span></span><br><span class="line">		balloon_page_enqueue(&amp;vb-&gt;vb_dev_info, page);</span><br><span class="line">		set_page_pfns(vb, vb-&gt;pfns + vb-&gt;num_pfns, page);</span><br><span class="line">		vb-&gt;num_pages += VIRTIO_BALLOON_PAGES_PER_PAGE;</span><br><span class="line">		<span class="keyword">if</span> (!virtio_has_feature(vb-&gt;vdev,</span><br><span class="line">					VIRTIO_BALLOON_F_DEFLATE_ON_OOM))</span><br><span class="line">            <span class="comment">//如果没开DEFLATE_ON_OOM guest内核可用的page是减少的</span></span><br><span class="line">			adjust_managed_page_count(page, <span class="number">-1</span>);</span><br><span class="line">		vb-&gt;num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	num_allocated_pages = vb-&gt;num_pfns;</span><br><span class="line">	<span class="keyword">if</span> (vb-&gt;num_pfns != <span class="number">0</span>)</span><br><span class="line">		tell_host(vb, vb-&gt;inflate_vq);</span><br><span class="line">	mutex_unlock(&amp;vb-&gt;balloon_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> num_allocated_pages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>[<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010923083/article/details/115873669">内核内存] 伙伴系统4—alloc_pages(内存块分配)_早起的虫儿有鹰吃的博客-CSDN博客</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tell_host</span><span class="params">(<span class="keyword">struct</span> virtio_balloon *vb, <span class="keyword">struct</span> virtqueue *vq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">sg</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line">	sg_init_one(&amp;sg, vb-&gt;pfns, <span class="keyword">sizeof</span>(vb-&gt;pfns[<span class="number">0</span>]) * vb-&gt;num_pfns);</span><br><span class="line">	virtqueue_add_outbuf(vq, &amp;sg, <span class="number">1</span>, vb, GFP_KERNEL);</span><br><span class="line">	virtqueue_kick(vq);</span><br><span class="line">	wait_event(vb-&gt;acked, virtqueue_get_buf(vq, &amp;len));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">virtqueue_notify</span><span class="params">(<span class="keyword">struct</span> virtqueue *_vq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vring_virtqueue</span> *<span class="title">vq</span> =</span> to_vvq(_vq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(vq-&gt;broken))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (!vq-&gt;notify(_vq)) &#123;</span><br><span class="line">		vq-&gt;broken = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">vp_notify</span><span class="params">(<span class="keyword">struct</span> virtqueue *vq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* we write the queue&#x27;s selector into the notification register to</span></span><br><span class="line"><span class="comment">	 * signal the other end */</span></span><br><span class="line">    <span class="comment">// value, addr</span></span><br><span class="line">	iowrite16(vq-&gt;index, (<span class="type">void</span> __iomem *)vq-&gt;priv);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里wait_event是一个宏 传入的第二个参数会一直被调用然后sleep</p>
<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(;;)&#123;</span><br><span class="line">	if (virtqueue_get_buf(vq, &amp;len))</span><br><span class="line">		break;</span><br><span class="line">	schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h4><p>virtio:<a target="_blank" rel="noopener" href="https://blog.csdn.net/xidianjiapei001/article/details/89293914">IO虚拟化 - virtio介绍及代码分析【转】_xidianjiapei001的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/edver/category/1939743.html">虚拟化 - 随笔分类 - Edver - 博客园 (cnblogs.com)</a></p>
<p>virtqueue初始化过程：</p>
<p>virtio_pci_legacy_probe 初始化回调函数</p>
<p><code>virtballoon_probe</code>-&gt;<code>init_vqs</code>-&gt;<code>virtio_find_vqs</code>-&gt;<code>find_vqs(vp_find_vqs)</code>-&gt;<code>vp_find_vqs_msix</code>-&gt;<code>vp_setup_vq(setup_vq)</code>-&gt;<code>vring_create_virtqueue</code></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/edver/p/14684117.html">virtio简介（三） —— virtio-balloon qemu设备创建 - Edver - 博客园 (cnblogs.com)</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_balloon_device_realize</span><span class="params">(DeviceState *dev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIODevice *vdev = VIRTIO_DEVICE(dev);</span><br><span class="line">    VirtIOBalloon *s = VIRTIO_BALLOON(dev);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    virtio_init(vdev, VIRTIO_ID_BALLOON, virtio_balloon_config_size(s));</span><br><span class="line"></span><br><span class="line">    ret = qemu_add_balloon_handler(virtio_balloon_to_target,</span><br><span class="line">                                   virtio_balloon_stat, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;Only one balloon device is supported&quot;</span>);</span><br><span class="line">        virtio_cleanup(vdev);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (virtio_has_feature(s-&gt;host_features, VIRTIO_BALLOON_F_FREE_PAGE_HINT) &amp;&amp;</span><br><span class="line">        !s-&gt;iothread) &#123;</span><br><span class="line">        error_setg(errp, <span class="string">&quot;&#x27;free-page-hint&#x27; requires &#x27;iothread&#x27; to be set&quot;</span>);</span><br><span class="line">        virtio_cleanup(vdev);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;ivq = virtio_add_queue(vdev, <span class="number">128</span>, virtio_balloon_handle_output);</span><br><span class="line">    s-&gt;dvq = virtio_add_queue(vdev, <span class="number">128</span>, virtio_balloon_handle_output);</span><br><span class="line">    s-&gt;svq = virtio_add_queue(vdev, <span class="number">128</span>, virtio_balloon_receive_stats);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_queue_notify_vq</span><span class="params">(VirtQueue *vq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (vq-&gt;vring.desc &amp;&amp; vq-&gt;handle_output) &#123;</span><br><span class="line">        VirtIODevice *vdev = vq-&gt;vdev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(vdev-&gt;broken)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trace_virtio_queue_notify(vdev, vq - vdev-&gt;vq, vq);</span><br><span class="line">        vq-&gt;handle_output(vdev, vq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(vdev-&gt;start_on_kick)) &#123;</span><br><span class="line">            virtio_set_started(vdev, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_balloon_handle_output</span><span class="params">(VirtIODevice *vdev, VirtQueue *vq)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);</span><br><span class="line">    VirtQueueElement *elem;</span><br><span class="line">    MemoryRegionSection section;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        PartiallyBalloonedPage pbp = &#123;&#125;;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="type">uint32_t</span> pfn;</span><br><span class="line"></span><br><span class="line">        elem = virtqueue_pop(vq, <span class="keyword">sizeof</span>(VirtQueueElement));</span><br><span class="line">        <span class="keyword">if</span> (!elem) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iov_to_buf(elem-&gt;out_sg, elem-&gt;out_num, offset, &amp;pfn, <span class="number">4</span>) == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> p = virtio_ldl_p(vdev, &amp;pfn);</span><br><span class="line">            hwaddr pa;</span><br><span class="line"></span><br><span class="line">            pa = (hwaddr) p &lt;&lt; VIRTIO_BALLOON_PFN_SHIFT;</span><br><span class="line">            offset += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            section = memory_region_find(get_system_memory(), pa,</span><br><span class="line">                                         BALLOON_PAGE_SIZE);</span><br><span class="line">            <span class="keyword">if</span> (!section.mr) &#123;</span><br><span class="line">                trace_virtio_balloon_bad_addr(pa);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!memory_region_is_ram(section.mr) ||</span><br><span class="line">                memory_region_is_rom(section.mr) ||</span><br><span class="line">                memory_region_is_romd(section.mr)) &#123;</span><br><span class="line">                trace_virtio_balloon_bad_addr(pa);</span><br><span class="line">                memory_region_unref(section.mr);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            trace_virtio_balloon_handle_output(memory_region_name(section.mr),</span><br><span class="line">                                               pa);</span><br><span class="line">            <span class="keyword">if</span> (!virtio_balloon_inhibited()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vq == s-&gt;ivq) &#123;</span><br><span class="line">                    balloon_inflate_page(s, section.mr,</span><br><span class="line">                                         section.offset_within_region, &amp;pbp);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vq == s-&gt;dvq) &#123;</span><br><span class="line">                    balloon_deflate_page(s, section.mr, section.offset_within_region);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    g_assert_not_reached();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memory_region_unref(section.mr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        virtqueue_push(vq, elem, <span class="number">0</span>);</span><br><span class="line">        virtio_notify(vdev, vq);</span><br><span class="line">        g_free(elem);</span><br><span class="line">        virtio_balloon_pbp_free(&amp;pbp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>inflate操作是guest会立即把内存还给host</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">balloon_inflate_page</span><span class="params">(VirtIOBalloon *balloon,</span></span><br><span class="line"><span class="params">                                 MemoryRegion *mr, hwaddr mr_offset,</span></span><br><span class="line"><span class="params">                                 PartiallyBalloonedPage *pbp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *addr = memory_region_get_ram_ptr(mr) + mr_offset;</span><br><span class="line">    <span class="type">ram_addr_t</span> rb_offset, rb_aligned_offset, base_gpa;</span><br><span class="line">    RAMBlock *rb;</span><br><span class="line">    <span class="type">size_t</span> rb_page_size;</span><br><span class="line">    <span class="type">int</span> subpages;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX is there a better way to get to the RAMBlock than via a</span></span><br><span class="line"><span class="comment">     * host address? */</span></span><br><span class="line">    rb = qemu_ram_block_from_host(addr, <span class="literal">false</span>, &amp;rb_offset);</span><br><span class="line">    rb_page_size = qemu_ram_pagesize(rb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rb_page_size == BALLOON_PAGE_SIZE) &#123;</span><br><span class="line">        <span class="comment">/* Easy case */</span></span><br><span class="line"></span><br><span class="line">        ram_block_discard_range(rb, rb_offset, rb_page_size);</span><br><span class="line">        <span class="comment">/* We ignore errors from ram_block_discard_range(), because it</span></span><br><span class="line"><span class="comment">         * has already reported them, and failing to discard a balloon</span></span><br><span class="line"><span class="comment">         * page is not fatal */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	...<span class="comment">//经过测试 基本都是easy case</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ram_block_discard_range会调madvice</p>
<blockquote>
<p>MADV_WILLNEED<br>Expect access in the near future. (Hence, it might be a good idea to read some pages ahead.)</p>
<p>MADV_DONTNEED<br>Do not expect access in the near future. (For the time being, the application is finished with the given range, so the kernel can free resources associated with it.) Subsequent accesses of pages in this range will succeed, but will result either in reloading of the memory contents from the underlying mapped file (see mmap(2)) or zero-fill-on-demand pages for mappings without an underlying file.<br>MADV_REMOVE (Since Linux 2.6.16)<br>Free up a given range of pages and its associated backing store. Currently, only shmfs&#x2F;tmpfs supports this; other file systems return with the error ENOSYS.</p>
</blockquote>
<p>经过尝试后发现 <strong>通过mmap拿的内存 madvise <code>MADV_DONTNEED</code> 是会立即被回收的</strong></p>
<p>实际上这里一定需要unmap ept 否则需要相信guest kernel不会访问已经被释放的页 但是VMM不相信VM</p>
<p>这里没有手动unmap的原因是 madvise之后 内核如果真的free page 也需要修改自己的页表 并且调用mmu notify 最终通知kvm <code>kvm_mmu_notifier_invalidate_range_start</code>host上加输出可以看到</p>
<p>mm&#x2F;madvise.c </p>
<p><code>do_madvise</code>-&gt;<code>madvise_vma_behavior</code>-&gt;<code>madvise_dontneed_free</code>-&gt;<code>madvise_dontneed_single_vma</code>-&gt;<code>zap_page_range</code>-&gt;</p>
<p><code>mmu_notifier_invalidate_range_start</code> 解kvm ept</p>
<p><code>unmap_single_vma</code> 解kernel</p>
<p>这里只是unmap 但是并没有free掉相应的物理内存(修改page元数据 还给buddy system) 那不还是用不了？</p>
<blockquote>
<p>成功执行<strong>MADV_DONTNEED</strong>操作之后，访问指定区域的语义将发生变化：后续访问这些页面将会成功，但是会导致从底层映射文件中重新填充内容(用于共享文件映射、共享匿名映射及shmem等)或者导致私有映射的零填充按需页面。因此此操作是直接将page给回收了，从对私有映射的处理来看，与swap还是略微不同的。</p>
<p>需要注意的是，当应用于共享映射时，<strong>MADV_DONTNEED</strong> 可能不会立即释放范围内的页面。内核可以自由地选择合适的时机来释放页面。然而，调用进程的常驻集大小 (RSS) 将立即减少。</p>
<p>作者：蟹蟹宁<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/965b1ed71ae4">https://www.jianshu.com/p/965b1ed71ae4</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="leak"><a href="#leak" class="headerlink" title="leak"></a>leak</h3><p>用的是inflate存下来的page 一模一样的</p>
<p>其实deflate是无所谓的 根据现有的所有机制 VM想用就用就行了</p>
<p>qemu</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">virtio_balloon_handle_output</span><span class="params">(VirtIODevice *vdev, VirtQueue *vq)</span></span><br><span class="line">&#123;</span><br><span class="line">    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);</span><br><span class="line">    VirtQueueElement *elem;</span><br><span class="line">    MemoryRegionSection section;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        PartiallyBalloonedPage pbp = &#123;&#125;;</span><br><span class="line">        <span class="type">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="type">uint32_t</span> pfn;</span><br><span class="line"></span><br><span class="line">        elem = virtqueue_pop(vq, <span class="keyword">sizeof</span>(VirtQueueElement));</span><br><span class="line">        <span class="keyword">if</span> (!elem) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iov_to_buf(elem-&gt;out_sg, elem-&gt;out_num, offset, &amp;pfn, <span class="number">4</span>) == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> p = virtio_ldl_p(vdev, &amp;pfn);</span><br><span class="line">            hwaddr pa;</span><br><span class="line"></span><br><span class="line">            pa = (hwaddr) p &lt;&lt; VIRTIO_BALLOON_PFN_SHIFT;</span><br><span class="line">            offset += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            section = memory_region_find(get_system_memory(), pa,</span><br><span class="line">                                         BALLOON_PAGE_SIZE);</span><br><span class="line">            <span class="keyword">if</span> (!section.mr) &#123;</span><br><span class="line">                trace_virtio_balloon_bad_addr(pa);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!memory_region_is_ram(section.mr) ||</span><br><span class="line">                memory_region_is_rom(section.mr) ||</span><br><span class="line">                memory_region_is_romd(section.mr)) &#123;</span><br><span class="line">                trace_virtio_balloon_bad_addr(pa);</span><br><span class="line">                memory_region_unref(section.mr);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            trace_virtio_balloon_handle_output(memory_region_name(section.mr),</span><br><span class="line">                                               pa);</span><br><span class="line">            <span class="keyword">if</span> (!virtio_balloon_inhibited()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vq == s-&gt;ivq) &#123;</span><br><span class="line">                    balloon_inflate_page(s, section.mr,</span><br><span class="line">                                         section.offset_within_region, &amp;pbp);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vq == s-&gt;dvq) &#123;</span><br><span class="line">                    balloon_deflate_page(s, section.mr, section.offset_within_region);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    g_assert_not_reached();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memory_region_unref(section.mr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        virtqueue_push(vq, elem, <span class="number">0</span>);</span><br><span class="line">        virtio_notify(vdev, vq);</span><br><span class="line">        g_free(elem);</span><br><span class="line">        virtio_balloon_pbp_free(&amp;pbp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">balloon_deflate_page</span><span class="params">(VirtIOBalloon *balloon,</span></span><br><span class="line"><span class="params">                                 MemoryRegion *mr, hwaddr mr_offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *addr = memory_region_get_ram_ptr(mr) + mr_offset;</span><br><span class="line">    <span class="type">ram_addr_t</span> rb_offset;</span><br><span class="line">    RAMBlock *rb;</span><br><span class="line">    <span class="type">size_t</span> rb_page_size;</span><br><span class="line">    <span class="type">void</span> *host_addr;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX is there a better way to get to the RAMBlock than via a</span></span><br><span class="line"><span class="comment">     * host address? */</span></span><br><span class="line">    rb = qemu_ram_block_from_host(addr, <span class="literal">false</span>, &amp;rb_offset);</span><br><span class="line">    rb_page_size = qemu_ram_pagesize(rb);</span><br><span class="line"></span><br><span class="line">    host_addr = (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)addr &amp; ~(rb_page_size - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When a page is deflated, we hint the whole host page it lives</span></span><br><span class="line"><span class="comment">     * on, since we can&#x27;t do anything smaller */</span></span><br><span class="line">    ret = qemu_madvise(host_addr, rb_page_size, QEMU_MADV_WILLNEED);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        warn_report(<span class="string">&quot;Couldn&#x27;t MADV_WILLNEED on balloon deflate: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">        <span class="comment">/* Otherwise ignore, failing to page hint shouldn&#x27;t be fatal */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait_event在include&#x2F;linux&#x2F;wait.h</p>
<p>___wait_event</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2024/09/17/papers/V-probe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/17/papers/V-probe/" class="post-title-link" itemprop="url">V-probe</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-09-17 19:48:03" itemprop="dateCreated datePublished" datetime="2024-09-17T19:48:03+08:00">2024-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>3.4k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>3 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="V-probe"><a href="#V-probe" class="headerlink" title="V-probe"></a>V-probe</h1><p>ATC23</p>
<h2 id="问题与目标"><a href="#问题与目标" class="headerlink" title="问题与目标"></a>问题与目标</h2><p>IO直通的DMA操作与memory overcommitment产生冲突</p>
<p>因为DMA操作需要保证内存是固定不变的  overcommitment需要动态调整</p>
<p>现有方案：</p>
<ul>
<li>IOPF：DMA会产生pagefault，依赖memory reclaim ，swap慢 balloon通信慢 hyperupcall可能回收了DMA缓冲区导致失败</li>
<li>vIOMMU coIOMMU 让hypervisor 知道VM的DMA信息 兼容性差</li>
</ul>
<p>希望</p>
<ul>
<li>保证DMA不会失败</li>
<li>不需要特殊硬件</li>
<li>不需要修改guest内核</li>
<li>性能好</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>类似hyperupcall 但是用编译好的二进制</p>
<p>guest启动后动态加载</p>
<p>限制只能用rdi rax 不允许访问内存 不允许大于64bytes  不能跳转</p>
<p>关于page：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoutaopower/article/details/87090982">Linux 内存管理窥探（5）：page 数据结构_爱洋葱的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="http://linux.laoqinren.net/kernel/memory-page/">struct page结构体 - Notes about linux and my work (laoqinren.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/573338379">linux内核那些事之struct page - 知乎 (zhihu.com)</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_MAPCOUNT_OPS(uname, lname)					\</span></span><br><span class="line"><span class="meta">static __always_inline int Page##uname(struct page *page)		\</span></span><br><span class="line"><span class="meta">&#123;									\</span></span><br><span class="line"><span class="meta">	return atomic_read(&amp;page-&gt;_mapcount) ==				\</span></span><br><span class="line"><span class="meta">				PAGE_##lname##_MAPCOUNT_VALUE;		\</span></span><br><span class="line"><span class="meta">&#125;									\</span></span><br><span class="line"><span class="meta">static __always_inline void __SetPage##uname(struct page *page)		\</span></span><br><span class="line"><span class="meta">&#123;									\</span></span><br><span class="line"><span class="meta">	VM_BUG_ON_PAGE(atomic_read(&amp;page-&gt;_mapcount) != -1, page);	\</span></span><br><span class="line"><span class="meta">	atomic_set(&amp;page-&gt;_mapcount, PAGE_##lname##_MAPCOUNT_VALUE);	\</span></span><br><span class="line"><span class="meta">&#125;									\</span></span><br><span class="line"><span class="meta">static __always_inline void __ClearPage##uname(struct page *page)	\</span></span><br><span class="line"><span class="meta">&#123;									\</span></span><br><span class="line"><span class="meta">	VM_BUG_ON_PAGE(!Page##uname(page), page);			\</span></span><br><span class="line"><span class="meta">	atomic_set(&amp;page-&gt;_mapcount, -1);				\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PageBuddy() indicate that the page is free and in the buddy system</span></span><br><span class="line"><span class="comment"> * (see mm/page_alloc.c).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_BUDDY_MAPCOUNT_VALUE		(-128)</span></span><br><span class="line">PAGE_MAPCOUNT_OPS(Buddy, BUDDY)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> page_private(page)		((page)-&gt;private)</span></span><br></pre></td></tr></table></figure>

<p>一个用于拿是否free 一个用于拿order</p>
<p>这些函数的参数都是page结构体的GVA，所以注册函数的同时需要把guest内核page存放的GPA也一同放入</p>
<p>由于代码在host上执行，不需要GVA-&gt;GPA 所以这段代码不论是GPA-&gt;HVA还是如何翻译 总能在hypervisor上解决</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> procedure MEMORYRECLAMATION</span><br><span class="line"><span class="number">2</span>: <span class="keyword">for</span> each GFN in GUEST <span class="keyword">do</span></span><br><span class="line"><span class="number">3</span>: <span class="keyword">if</span> GFN is reclaimed then</span><br><span class="line"><span class="number">4</span>: <span class="keyword">continue</span></span><br><span class="line"><span class="number">5</span>: SP ← <span class="class"><span class="keyword">struct</span> <span class="title">page</span> <span class="title">of</span> <span class="title">GFN</span> <span class="title">in</span> <span class="title">GUEST</span></span></span><br><span class="line"><span class="class">6:</span> FREE ← GUEST.PAGE_FREE(SP)</span><br><span class="line"><span class="number">7</span>: ORD ← GUEST.PAGE_ORD(SP)</span><br><span class="line"><span class="number">8</span>: <span class="keyword">if</span> FREE and ORD ≥ MIN_ORD then</span><br><span class="line"><span class="number">9</span>: Lock MUTEX</span><br><span class="line"><span class="number">10</span>: Make the <span class="class"><span class="keyword">struct</span> <span class="title">page</span> <span class="title">GPA</span> <span class="title">range</span> <span class="title">read</span>-<span class="title">only</span></span></span><br><span class="line"><span class="class">11:</span> SP′ ← <span class="class"><span class="keyword">struct</span> <span class="title">page</span> <span class="title">of</span> <span class="title">GFN</span> <span class="title">in</span> <span class="title">GUEST</span></span></span><br><span class="line"><span class="class">12:</span> FREE′ ← GUEST.PAGE_FREE(SP′)</span><br><span class="line"><span class="number">13</span>: ORD′ ← GUEST.PAGE_ORD(SP′)</span><br><span class="line"><span class="number">14</span>: <span class="keyword">if</span> FREE′ and ORD′ ≥ MIN_ORD then</span><br><span class="line"><span class="number">15</span>: GFNst ← GFN</span><br><span class="line"><span class="number">16</span>: GFNen ← GFN + (<span class="number">1</span> &lt;&lt; ORD′)</span><br><span class="line"><span class="number">17</span>: RANGE ← [GFNst, GFNen)</span><br><span class="line"><span class="number">18</span>: Unmap EPT in RANGE</span><br><span class="line"><span class="number">19</span>: Unmap IOMMU in RANGE</span><br><span class="line"><span class="number">20</span>: Add RANGE to the reclaimed <span class="built_in">set</span></span><br><span class="line"><span class="number">21</span>: Release reclaimed pages to hypervisor</span><br><span class="line"><span class="number">22</span>: Unlock MUTEX</span><br><span class="line"><span class="number">23</span>: <span class="keyword">return</span> SUCCESS</span><br><span class="line"><span class="number">24</span>: Make the <span class="keyword">struct</span> page GPA range read-write</span><br><span class="line"><span class="number">25</span>: Unlock MUTEX</span><br><span class="line"><span class="number">26</span>: <span class="keyword">return</span> FAIL</span><br></pre></td></tr></table></figure>

<p>记录到reclaimed set中 并且解除映射</p>
<p>一旦解除映射 对应的物理内存就空出来了 满足overcommitment</p>
<p>回收代码定时触发或者事件触发</p>
<p>我认为第21行需要完成两件事</p>
<ul>
<li>这里光解除映射 实际上host还是不可用 需要用host kernel的对应函数和数据结构修改  但是已经运行在host上 并且知道guest的所有信息 并不难做到(类似qemu 可用madvise) 但是否有不一致问题？</li>
<li>修改guest struct page 标记不可用 否则guest当作free仍然分配并使用 可能导致触发大量page fault和VMexit</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> procedure PAGEFAULTHANDLER</span><br><span class="line"><span class="number">2</span>: Lock MUTEX</span><br><span class="line"><span class="number">3</span>: RANGE ← GetReclaimedRange(GUEST , GPA)</span><br><span class="line"><span class="number">4</span>: PAGES ← pages reallocated <span class="keyword">for</span> RANGE</span><br><span class="line"><span class="number">5</span>: Map RANGE to PAGES in EPT</span><br><span class="line"><span class="number">6</span>: Map RANGE to PAGES in IOMMU</span><br><span class="line"><span class="number">7</span>: Remove RANGE from the reclaimed <span class="built_in">set</span></span><br><span class="line"><span class="number">8</span>: Make the <span class="class"><span class="keyword">struct</span> <span class="title">page</span> <span class="title">GPA</span> <span class="title">range</span> <span class="title">read</span>-<span class="title">write</span></span></span><br><span class="line"><span class="class">9:</span> Unlock MUTEX</span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">Input: GUEST , GPA</span><br><span class="line">Output: RANGE</span><br><span class="line"><span class="number">11</span>: procedure GETRECLAIMEDRANGE</span><br><span class="line"><span class="number">12</span>: <span class="keyword">for</span> each RANGE in the reclaimed <span class="built_in">set</span> of GUEST <span class="keyword">do</span></span><br><span class="line"><span class="number">13</span>: SPst ← the start <span class="keyword">struct</span> page GPA in RANGE</span><br><span class="line"><span class="number">14</span>: SPen ← the end <span class="keyword">struct</span> page GPA in RANGE</span><br><span class="line"><span class="number">15</span>: <span class="keyword">if</span> SPst ≤ GPA ≤ SPen then</span><br><span class="line"><span class="number">16</span>: <span class="keyword">return</span> RANGE</span><br></pre></td></tr></table></figure>

<p>DMA发生page fault 需要重新拿回对应的物理内存</p>
<p>这时候从reclaimed set中寻找原来的地址判断长度 然后重新映射 保证了DMA用的HPA虽然在动态变化但是仍可用 </p>
<p>这里的两个函数应该都是加到hypervisor代码中去的(修改host内核)</p>
<p>普通的page fault和DMA的page fault都使用这个函数</p>
<p>所以具体实现上仍然需要支持IOPF的硬件  实验中作者是自己修改硬件来支持的</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="host与guest"><a href="#host与guest" class="headerlink" title="host与guest"></a>host与guest</h3><p>把host需要回收的page结构体都改为read only 随后再进行检查 这样做保证了满足要求的page都不会被guest修改</p>
<h3 id="reclaim与page-fault"><a href="#reclaim与page-fault" class="headerlink" title="reclaim与page fault"></a>reclaim与page fault</h3><p>用host自己的mutex lock</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这篇文章相当于设备直通场景下的hypercall 因此测试除了常规回收内存之外 还增加了特定的IO测试</p>
<p>例如tcp udp和redis</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不管guest怎么操作自己的数据结构 入口一定是在host的</p>
<p>必须保证host拥有guest数据结构的地址和布局 并且提供给这段代码才可以</p>
<p>代码其实是修改了host自己的reclaim和page fault逻辑自己执行 不需要VM enter和exit</p>
<p>这种方式和balloon完全不同 不需要guest自己任何参与 对guest来说 仍然认为自己有着全部内存 不知道二级页表映射已经失效了</p>
<ul>
<li>balloon：guest判断free guest标记不可用 host unmap</li>
<li>v-probe：host判断free (host标记guest不可用) host unmap</li>
</ul>
<p>v-probe就算不顺带解决IOPF的问题 从性能上单独来说也是碾压balloon的，因为通过在host访问guest数据结构绕开了virtio这个大框架</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2024/09/17/papers/forward/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/17/papers/forward/" class="post-title-link" itemprop="url">Operation Forwarding</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-09-17 19:48:03" itemprop="dateCreated datePublished" datetime="2024-09-17T19:48:03+08:00">2024-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>4.6k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>4 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Operation-Forwarding"><a href="#Operation-Forwarding" class="headerlink" title="Operation Forwarding"></a>Operation Forwarding</h1><p>usenix security23</p>
<p>虽然使用硬件虚拟化进行了隔离 但是microVM使用的组件还是会涉及到使用host的资源</p>
<p>策略1 container components</p>
<ul>
<li>kata container 用viriofs 提供rootfs 使得guest在这个文件夹的操作会转发到host</li>
<li>firecracker用runc jailer先在host上创建文件夹 然后复制文件 作为rootfs 使得host普通用户可以通过创建microVM利用containerd的漏洞做坏事</li>
</ul>
<blockquote>
<p>however, virtiofs is designed to offer local file system semantics and high performance. The file system performance downgrades without virtiofs in Kata Containers   </p>
</blockquote>
<p>用这个是为了性能</p>
<p>策略2 device emulator</p>
<p>策略3 host kernel module</p>
<h2 id="1-kata-container-virtiofs"><a href="#1-kata-container-virtiofs" class="headerlink" title="1 kata container virtiofs"></a>1 kata container virtiofs</h2><ol>
<li><p>container 在virtiofs的共享文件夹下创建SGIDbit的可执行文件  SGID可以临时获得程序所属组的权限</p>
</li>
<li><p>guest的virtiofs-driver会把open的system call forward给host的virtiofs daemon</p>
</li>
<li><p>通过host创建文件的权限检查 因为virfiofs daemon有root为 supplemental group</p>
<blockquote>
<p>Then it checks if the creation process has the same supplemental group as the directory owner. However, according to the virtiofs daemon’s document [31], virtiofs daemon must run as the root user and has the root group in its supplemental group  </p>
</blockquote>
</li>
<li><p>成功在host的某个目录下创建一个SGID的可执行文件</p>
</li>
</ol>
<p>vm内部和host是两个世界，所以这里无论怎么样vm还是无法利用这个可执行文件完成逃逸的。但是这个文件为host留了隐患，在host同一物理机器的任何普通用户都可以以root权限执行这个可执行文件。</p>
<blockquote>
<p>a regular user can get the host root group privileges when executing the file created by the malicious container.  </p>
</blockquote>
<p>cve的描述:</p>
<blockquote>
<p> This could allow a malicious unprivileged user inside the guest to gain access to resources accessible to the root group, potentially escalating their privileges within the guest. A malicious local user in the host might also leverage this unexpected executable file created by the guest to escalate their privileges on the host system.</p>
</blockquote>
<ol>
<li>guest内部的非root用户有root权限</li>
<li>host的非root用户有root权限</li>
</ol>
<p>报告给viriofs CVE 修复：取消掉viriofs 的root group</p>
<p><a target="_blank" rel="noopener" href="https://lists.nongnu.org/archive/html/qemu-devel/2022-01/msg05364.html">https://lists.nongnu.org/archive/html/qemu-devel/2022-01/msg05364.html</a></p>
<p>这个patch是qemu的virtiofsd  直接在启动的一开始把这个进程的所有supplemental group 都清空了 </p>
<p>一个用户可以属于多个组 但是登录的时候默认是primary group</p>
<p>其他组都是supplemental group</p>
<blockquote>
<p>If we have membership of “root” supplementary group</p>
</blockquote>
<p>root group是不是只是一个形象的表达？ 实际上只有adm sudo这种group</p>
<p>如果viriofs共享的文件夹是root 那么清空了virtiofsd的root supplemental group virtiofsd本身还怎么提供服务？最早为什么必须加？涉及到viriofs的设计 不深入研究</p>
<p><strong>利用open  策略1</strong></p>
<h2 id="2-kata-container-dirty-memory-attack"><a href="#2-kata-container-dirty-memory-attack" class="headerlink" title="2 kata container dirty memory attack"></a>2 kata container dirty memory attack</h2><ol>
<li>container中<code>dd if=/dev/zero of=/mnt/test bs=1M count=4096 oflag=direct  </code>持续生成 写文件</li>
<li>viriofs共享文件夹写write  VFS-&gt;viriofs driver-&gt;host viriofs daemon 触发host写 影响host dirty memory</li>
<li>linux kernel 维护一个值 当dirty memory超过阈值后(20%) 所有进程的写操作会从write-back变成write-through 性能下降</li>
<li>当多个container做这种操作 host的io性能可以下降90%</li>
</ol>
<p><strong>利用write 策略1</strong></p>
<blockquote>
<p>Besides, one can limit dirty memory usage of the virtiofs by adding the virtiofs daemon into cgroups.  </p>
</blockquote>
<p>virtiofs daemon就一个 给哪个vm的cgroup？</p>
<p>virtiofs团队正在努力让virtiofs daemon不需要以root运行 并且不影响用户使用</p>
<p><strong>经过测试 当某个文件被删除后 这个文件的buffer 即所有的dirty page也会马上被清空 不会再占用内存 所以仅仅靠一个container是无法达成攻击的 需要多个container一起 例如10container*4G&gt;192G(server)*20%&#x3D;38.4G</strong></p>
<p>多个container持续修改同一个文件即可 这样持续生成dirty memory</p>
<p>dirty memory在代码中的定义：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gmpy/p/12657801.html">Linux 脏数据回刷参数与调优 - 广漠飘羽 - 博客园 (cnblogs.com)</a></p>
<p>可回收内存(FILE_DIRTY) &gt; 可用内存(FREE+INACTIVE_FILE+ACTIVE_FILE) * ratio 发生回收 所以大量的匿名页是不记入的</p>
<h2 id="3-kata-container-nf-conntrack-table-attack"><a href="#3-kata-container-nf-conntrack-table-attack" class="headerlink" title="3 kata container nf_conntrack table attack"></a>3 kata container nf_conntrack table attack</h2><ol>
<li>container 疯狂connect 建立tcp连接</li>
<li>host的vhost-net kernel module调用tun_sendmsg-&gt;nf_conntrack_alloc</li>
<li>达到nf_conntrack_max 类似抽象资源攻击</li>
<li>造成随机丢包   ping 50%丢包 nginx不可用</li>
</ol>
<p>这里应该攻击的就是最终使用nf_conntrack table的网络使用者 也就是同样使用vhost-net的其他容器</p>
<p><strong>connect 策略3</strong></p>
<p>kata不修复 就给了减弱攻击的做法</p>
<p><a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/43205/nf-conntrack-table-full-dropping-packet/43220#43220">https://security.stackexchange.com/questions/43205/nf-conntrack-table-full-dropping-packet/43220#43220</a></p>
<p>调一些参数 比如timeout max</p>
<p>可以限制速率</p>
<p><a target="_blank" rel="noopener" href="https://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/">https://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/</a></p>
<h2 id="4-attack-of-vhost-net-kernel-module"><a href="#4-attack-of-vhost-net-kernel-module" class="headerlink" title="4 attack of vhost-net kernel module"></a>4 attack of vhost-net kernel module</h2><ol>
<li>container 疯狂 sendmsg&#x2F;recvmsg</li>
<li>kernel 疯狂handle_rx&#x2F;tx</li>
<li>vhost kernel worker thread使用很多cpu资源 且不计入VM使用的资源</li>
</ol>
<p>并没有显示对其他container有影响</p>
<blockquote>
<p>Specifically, a worker thread called vhost-<owner-device-emulator-process-pid> is created for each virtual machine  </p>
</blockquote>
<p><strong>sendmsg&#x2F;recvmsg 策略3</strong></p>
<p>每个VM一个 所以解决方案是把这些thread加入container的cgroup</p>
<p>实际上对于kata container 有一个sandbox_cgroup_only&#x3D;true的选项可以让vhost thread放入cgroup 但是默认是false</p>
<p>为什么这个可以让container的用户自己配置？ 那都是false不是不需要消耗资源付更多钱吗</p>
<p>可以用SRIOV</p>
<h2 id="5-firecracker-containerd-escalation"><a href="#5-firecracker-containerd-escalation" class="headerlink" title="5  firecracker-containerd escalation"></a>5  firecracker-containerd escalation</h2><p><a target="_blank" rel="noopener" href="https://github.com/firecracker-microvm/firecracker-containerd/commit/95c43cdec1b5dc92a16a732b56f482218c2b5fed">https://github.com/firecracker-microvm/firecracker-containerd/commit/95c43cdec1b5dc92a16a732b56f482218c2b5fed</a></p>
<ol>
<li><p>host 普通用户构造一个路径 申请创建microVM</p>
</li>
<li><p>firecracker-containerd是root权限运行 而代码中并没有检查参数所以涉及到的chown和create可以操作任何文件</p>
<p>并且代码使用的filepath.join会导致组合的路径逃出jail</p>
</li>
<li><p>chown可以任意修改文件权限</p>
<p>create可以任意清空文件，例如清空host的.so 让host crash</p>
</li>
</ol>
<p><strong>CreateVM 策略1</strong></p>
<p>“path&#x2F;filepath”  filepath.join 在某一个路径存在<code>/../../../</code>的情况下 最后组合的路径会把另一个前面的吃掉</p>
<p>换成”github.com&#x2F;containerd&#x2F;continuity&#x2F;fs” fs.RootPath</p>
<p>用户控制一个 可以逃出runc指定的jail路径</p>
<p><strong>CreateVM 策略1</strong></p>
<h2 id="6-firecracker-based-container-dirty-memory-attack"><a href="#6-firecracker-based-container-dirty-memory-attack" class="headerlink" title="6 firecracker-based container dirty memory attack"></a>6 firecracker-based container dirty memory attack</h2><p>类似kata container</p>
<p>但是firecracker使用的是virio-blk</p>
<p><strong>write 策略2</strong></p>
<h2 id="7-Firecracker-based-Container-Nf-conntrack-TableAttack"><a href="#7-Firecracker-based-Container-Nf-conntrack-TableAttack" class="headerlink" title="7 Firecracker-based Container Nf_conntrack TableAttack"></a>7 Firecracker-based Container Nf_conntrack TableAttack</h2><p>用virtio-net device 而不是kernel module</p>
<p>但是效果一样</p>
<p><strong>connect 策略2</strong></p>
<p>被AWS修复了  没找到怎么修复</p>
<h2 id="8-KVM-PIT-Timer-Attack"><a href="#8-KVM-PIT-Timer-Attack" class="headerlink" title="8 KVM PIT Timer Attack"></a>8 KVM PIT Timer Attack</h2><ol>
<li>guest疯狂写某写io port 触发PIT timer 且period很短</li>
<li>host调度kvm-pit线程 pit_do_work往guest插入中断</li>
<li>内核线程属于root cgroup 消耗资源不算在user space</li>
<li>cpu memory io的benchmark性能都下降</li>
</ol>
<p>个人认为这里是server的资源并不多 并且开的container太多 导致消耗大量资源的PIT thread在整体可用资源的占比变高</p>
<p><strong>outb 策略3</strong></p>
<p>qemu用HPET代替了PIT 具体实现不深入研究</p>
<p>也是一个VM一个 所以也可以放到cgroup中</p>
<p>或者直接禁用</p>
<h2 id="traditional-VM"><a href="#traditional-VM" class="headerlink" title="traditional VM"></a>traditional VM</h2><ul>
<li>dirty memory dos有效</li>
<li>nf_conntrack dos有效</li>
<li>vhost-net 有效</li>
<li>viriofs提权 有效 9pfs也有效</li>
<li>PIT 不用了 所以无效</li>
</ul>
<p>这些漏洞存在 但是普通VM不一定用 microVM定死了组件 所以一定用</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">szy</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">413k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">6:15</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
