<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"szy0127.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="TDX modulehttps:&#x2F;&#x2F;github.com&#x2F;amd&#x2F;AMD-ASPFW&#x2F;blob&#x2F;main&#x2F;fw&#x2F;psp_bl_uapps&#x2F;sev_uapp&#x2F;src&#x2F;sev_dispatch.c tdxtdcallhttps:&#x2F;&#x2F;github.com&#x2F;intel&#x2F;tdx-module&#x2F;blob&#x2F;tdx_1.5&#x2F;src&#x2F;td_dispatcher&amp;#x">
<meta property="og:type" content="article">
<meta property="og:title" content="TDX module">
<meta property="og:url" content="http://szy0127.github.io/2026/02/03/virtualization/TDX%20module/index.html">
<meta property="og:site_name" content="S blog">
<meta property="og:description" content="TDX modulehttps:&#x2F;&#x2F;github.com&#x2F;amd&#x2F;AMD-ASPFW&#x2F;blob&#x2F;main&#x2F;fw&#x2F;psp_bl_uapps&#x2F;sev_uapp&#x2F;src&#x2F;sev_dispatch.c tdxtdcallhttps:&#x2F;&#x2F;github.com&#x2F;intel&#x2F;tdx-module&#x2F;blob&#x2F;tdx_1.5&#x2F;src&#x2F;td_dispatcher&amp;#x">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://szy0127.github.io/images/OiaUbKFGfoYRvVxEqWgc2XwpnYd.png">
<meta property="og:image" content="http://szy0127.github.io/images/BsCQbP6eno1j48x2g3YcmObEneg.png">
<meta property="og:image" content="http://szy0127.github.io/images/T2FwbKKOToNlUgxsOeickQpdnrg.png">
<meta property="article:published_time" content="2026-02-03T12:38:46.293Z">
<meta property="article:modified_time" content="2026-02-03T12:38:53.541Z">
<meta property="article:author" content="szy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://szy0127.github.io/images/OiaUbKFGfoYRvVxEqWgc2XwpnYd.png">


<link rel="canonical" href="http://szy0127.github.io/2026/02/03/virtualization/TDX%20module/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://szy0127.github.io/2026/02/03/virtualization/TDX%20module/","path":"2026/02/03/virtualization/TDX module/","title":"TDX module"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>TDX module | S blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">S blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#TDX-module"><span class="nav-number">1.</span> <span class="nav-text">TDX module</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tdx"><span class="nav-number">1.1.</span> <span class="nav-text">tdx</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tdcall"><span class="nav-number">1.1.1.</span> <span class="nav-text">tdcall</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Seamcall"><span class="nav-number">1.1.2.</span> <span class="nav-text">Seamcall</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Meta-data"><span class="nav-number">1.1.3.</span> <span class="nav-text">Meta data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock"><span class="nav-number">1.1.4.</span> <span class="nav-text">Lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sum"><span class="nav-number">1.1.5.</span> <span class="nav-text">Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Check-tsc"><span class="nav-number">1.1.6.</span> <span class="nav-text">Check tsc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tlb-tracking"><span class="nav-number">1.1.7.</span> <span class="nav-text">Tlb tracking</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Partition"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">Partition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Security"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">Security</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TDH-MEM-RANGE-BLOCK"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">TDH.MEM.RANGE.BLOCK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sum-1"><span class="nav-number">1.1.7.4.</span> <span class="nav-text">Sum</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Associate-vcpu"><span class="nav-number">1.1.8.</span> <span class="nav-text">Associate vcpu</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Xmm"><span class="nav-number">1.1.9.</span> <span class="nav-text">Xmm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Branch-prediction"><span class="nav-number">1.1.10.</span> <span class="nav-text">Branch prediction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sev"><span class="nav-number">1.2.</span> <span class="nav-text">Sev</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">szy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2026/02/03/virtualization/TDX%20module/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="TDX module | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TDX module
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2026-02-03 20:38:46 / Modified: 20:38:53" itemprop="dateCreated datePublished" datetime="2026-02-03T20:38:46+08:00">2026-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>44 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="TDX-module"><a href="#TDX-module" class="headerlink" title="TDX module"></a>TDX module</h1><p><a target="_blank" rel="noopener" href="https://github.com/amd/AMD-ASPFW/blob/main/fw/psp_bl_uapps/sev_uapp/src/sev_dispatch.c">https://github.com/amd/AMD-ASPFW/blob/main/fw/psp_bl_uapps&#x2F;sev_uapp&#x2F;src&#x2F;sev_dispatch.c</a></p>
<h2 id="tdx"><a href="#tdx" class="headerlink" title="tdx"></a>tdx</h2><h3 id="tdcall"><a href="#tdcall" class="headerlink" title="tdcall"></a>tdcall</h3><p><a target="_blank" rel="noopener" href="https://github.com/intel/tdx-module/blob/tdx_1.5/src/td_dispatcher/tdx_td_dispatcher.c">https://github.com/intel/tdx-module/blob/tdx_1.5&#x2F;src&#x2F;td_dispatcher&#x2F;tdx_td_dispatcher.c</a></p>
<p>rcx 是通用寄存器 bitmap 决定哪些寄存器会从 td 传到 vmm 避免被 tdx module 清零</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">noinstr u64 __tdx_hypercall(<span class="keyword">struct</span> tdx_module_args *args)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * For TDVMCALL explicitly set RCX to the bitmap of shared registers.</span></span><br><span class="line"><span class="comment">         * The caller isn&#x27;t expected to set @args-&gt;rcx anyway.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        args-&gt;rcx = TDVMCALL_EXPOSE_REGS_MASK;</span><br><span class="line">s</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Failure of __tdcall_saved_ret() indicates a failure of the TDVMCALL</span></span><br><span class="line"><span class="comment">         * mechanism itself and that something has gone horribly wrong with</span></span><br><span class="line"><span class="comment">         * the TDX module.  __tdx_hypercall_failed() never returns.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (__tdcall_saved_ret(TDG_VP_VMCALL, args))</span><br><span class="line">                __tdx_hypercall_failed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* TDVMCALL leaf return code is in R10 */</span></span><br><span class="line">        <span class="keyword">return</span> args-&gt;r10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tdx module 记录所有通用寄存器并清零</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl tdx_tdexit_entry_point</span><br><span class="line">.globl tdx_tdentry_to_td</span><br><span class="line"></span><br><span class="line">tdx_tdexit_entry_point:</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Save all TD GPRs on module entry to LP local data</span><br><span class="line">     * Local data is located at GSBASE</span><br><span class="line">     */</span><br><span class="line">    movq %rax,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET</span><br><span class="line">    movq %rcx,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+8</span><br><span class="line">    movq %rdx,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+16</span><br><span class="line">    movq %rbx,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+24</span><br><span class="line">    movq %rsp,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+32</span><br><span class="line">    movq %rbp,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+40</span><br><span class="line">    movq %rsi,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+48</span><br><span class="line">    movq %rdi,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+56</span><br><span class="line">    movq %r8,   %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+64</span><br><span class="line">    movq %r9,   %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+72</span><br><span class="line">    movq %r10,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+80</span><br><span class="line">    movq %r11,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+88</span><br><span class="line">    movq %r12,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+96</span><br><span class="line">    movq %r13,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+104</span><br><span class="line">    movq %r14,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+112</span><br><span class="line">    movq %r15,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+120</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * clear TD GPRs on entry to the TDX module</span><br><span class="line">         */</span><br><span class="line">    xor %rax, %rax</span><br><span class="line">    xor %rcx, %rcx</span><br><span class="line">    xor %rdx, %rdx</span><br><span class="line">    xor %rbx, %rbx</span><br><span class="line">    xor %rbp, %rbp</span><br><span class="line">    xor %rsi, %rsi</span><br><span class="line">    xor %rdi, %rdi</span><br><span class="line">    xor %r8, %r8</span><br><span class="line">    xor %r9, %r9</span><br><span class="line">    xor %r10, %r10</span><br><span class="line">    xor %r11, %r11</span><br><span class="line">    xor %r12, %r12</span><br><span class="line">    xor %r13, %r13</span><br><span class="line">    xor %r14, %r14</span><br><span class="line">    xor %r15, %r15</span><br><span class="line"></span><br><span class="line">    // Protection against speculative attacks on GPRs</span><br><span class="line">    lfence</span><br><span class="line"></span><br><span class="line">    // Choose which dispatcher we want to call based on current TD VM,</span><br><span class="line">    // stored in local data before the TD entry</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_CURRENT_TD_VM_ID_OFFSET, %rax</span><br><span class="line">    test %rax, %rax</span><br><span class="line">    jnz l2_dispatcher</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Call the VMM API dispatcher</span><br><span class="line">     */</span><br><span class="line">    callq tdx_td_dispatcher</span><br><span class="line">     </span><br><span class="line">    /**</span><br><span class="line">     * Unreachable code.  panic. </span><br><span class="line">     */</span><br><span class="line">    ud2</span><br><span class="line"></span><br><span class="line">l2_dispatcher:</span><br><span class="line"></span><br><span class="line">    callq tdx_td_l2_dispatcher</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Unreachable code.  panic.</span><br><span class="line">     */</span><br><span class="line">    ud2</span><br></pre></td></tr></table></figure>

<p>gs 寄存器往后偏移的数据作为 local_data 的基地址</p>
<p>local_data_fast_ref_ptr 存的就是 local_data 的地址</p>
<p>这样做默认了 gs base 就是 local_data 为什么不直接读？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tdx_td_dispatcher</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">tdx_module_local_t</span>* tdx_local_data_ptr = get_local_data();</span><br><span class="line">            _STATIC_INLINE_ <span class="type">tdx_module_local_t</span>* <span class="title function_">get_local_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">uint64_t</span> local_data_addr;</span><br><span class="line">            </span><br><span class="line">                _ASM_ (<span class="string">&quot;movq %%gs:%c[local_data], %0\n\t&quot;</span></span><br><span class="line">                         :<span class="string">&quot;=r&quot;</span>(local_data_addr)</span><br><span class="line">                         :[local_data]<span class="string">&quot;i&quot;</span>(offsetof(<span class="type">tdx_module_local_t</span>, local_data_fast_ref_ptr)));</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">return</span> (<span class="type">tdx_module_local_t</span>*)local_data_addr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">vm_vmexit_exit_reason_t</span> vm_exit_reason;</span><br><span class="line">    <span class="type">vmx_exit_qualification_t</span> vm_exit_qualification;</span><br><span class="line">    <span class="type">vmx_exit_inter_info_t</span> vm_exit_inter_info;</span><br><span class="line"></span><br><span class="line">    <span class="type">vmx_guest_inter_state_t</span> guest_inter_state;</span><br><span class="line">    <span class="type">vmx_procbased_ctls_t</span> vm_procbased_ctls;</span><br><span class="line"></span><br><span class="line">    <span class="type">td_param_attributes_t</span> attr;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool_t</span> interrupt_occurred = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> vm_id = tdx_local_data_ptr-&gt;vp_ctx.tdvps-&gt;management.curr_vm;</span><br><span class="line"></span><br><span class="line">    tdx_sanity_check((vm_id == tdx_local_data_ptr-&gt;current_td_vm_id) &amp;&amp; (vm_id == <span class="number">0</span>),</span><br><span class="line">                     SCEC_TD_DISPATCHER_SOURCE, <span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">    stepping_filter_e vmexit_stepping_result;</span><br><span class="line">    vmexit_stepping_result = tdx_td_l1_l2_dispatcher_common_prologue(tdx_local_data_ptr, <span class="number">0</span>, &amp;vm_exit_reason,</span><br><span class="line">                                    &amp;vm_exit_qualification, &amp;vm_exit_inter_info);</span><br><span class="line"></span><br><span class="line">                stepping_filter_e <span class="title function_">tdx_td_l1_l2_dispatcher_common_prologue</span><span class="params">(<span class="type">tdx_module_local_t</span>* local_data, <span class="type">uint16_t</span> vm_id,</span></span><br><span class="line"><span class="params">                            <span class="type">vm_vmexit_exit_reason_t</span>* vm_exit_reason, <span class="type">vmx_exit_qualification_t</span>* vm_exit_qualification,</span></span><br><span class="line"><span class="params">                            <span class="type">vmx_exit_inter_info_t</span>* vm_exit_inter_info)</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">tdx_module_global_t</span>* tdx_global_data_ptr = get_global_data();</span><br><span class="line">                    </span><br><span class="line">                        TDX_LOG(<span class="string">&quot;TD Dispatcher Entry from VM %d\n&quot;</span>, vm_id);</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Execute the BHB defense sequence</span></span><br><span class="line">                        <span class="keyword">if</span> (tdx_global_data_ptr-&gt;rtm_supported)</span><br><span class="line">                        &#123;</span><br><span class="line">                            tsx_abort_sequence();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// BHB draining sequence</span></span><br><span class="line">                            <span class="comment">// There are 6 taken branches in each iteration (one CALL, four JMPs, and one JNZ),</span></span><br><span class="line">                            <span class="comment">// so for GLC (194 branch stews in BHB), NUM_ITERS = round-up(194 / 6) = 32.</span></span><br><span class="line">                            <span class="type">uint64_t</span> num_iters = NUM_OF_BHB_CLEARING_ITERATIONS;</span><br><span class="line">                            <span class="type">uint64_t</span> num_iters_multi_8 = <span class="number">8</span>*num_iters;</span><br><span class="line">                    </span><br><span class="line">                            _ASM_VOLATILE_ (</span><br><span class="line">                                <span class="string">&quot;movq %0, %%rcx\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;1:  call 2f\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;lfence\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;2:  jmp 3f\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;nop\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;3:  jmp 4f\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;nop\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;4:  jmp 5f\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;nop\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;5:  jmp 6f\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;nop\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;6:  dec %%rcx\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;jnz 1b\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;add %1, %%rsp\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;lfence\n&quot;</span></span><br><span class="line">                                : : <span class="string">&quot;a&quot;</span>(num_iters), <span class="string">&quot;b&quot;</span>(num_iters_multi_8) : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;rcx&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Save current time to verify on next TD entry and for TDEXIT filter checks</span></span><br><span class="line">                        local_data-&gt;vp_ctx.tdvps-&gt;management.last_exit_tsc = ia32_rdtsc();</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Save TD GPR state to TDVPS.</span></span><br><span class="line">                        <span class="comment">// DR&#x27;s, XSTATE and XCR&#x27;s, MSR&#x27;s will be saved if exit to TD will be required later</span></span><br><span class="line">                        <span class="comment">// In case of need of performance improvement - should be done only when actual vmexit to VMM happens</span></span><br><span class="line">                        save_guest_td_gpr_state_on_td_vmexit();</span><br><span class="line">                            <span class="type">static</span> <span class="type">void</span> <span class="title function_">save_guest_td_gpr_state_on_td_vmexit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="type">tdx_module_local_t</span>* local_data_ptr = get_local_data();</span><br><span class="line">                                <span class="type">tdvps_t</span>* tdvps_ptr = local_data_ptr-&gt;vp_ctx.tdvps;</span><br><span class="line">                            </span><br><span class="line">                                <span class="comment">// GPR&#x27;s saving: move them from local data area (already saved there by assembly prologue) to current TDVPS</span></span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rax = local_data_ptr-&gt;td_regs.rax;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rcx = local_data_ptr-&gt;td_regs.rcx;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rdx = local_data_ptr-&gt;td_regs.rdx;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rbx = local_data_ptr-&gt;td_regs.rbx;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rbp = local_data_ptr-&gt;td_regs.rbp;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rsi = local_data_ptr-&gt;td_regs.rsi;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rdi = local_data_ptr-&gt;td_regs.rdi;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r8  = local_data_ptr-&gt;td_regs.r8;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r9  = local_data_ptr-&gt;td_regs.r9;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r10 = local_data_ptr-&gt;td_regs.r10;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r11 = local_data_ptr-&gt;td_regs.r11;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r12 = local_data_ptr-&gt;td_regs.r12;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r13 = local_data_ptr-&gt;td_regs.r13;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r14 = local_data_ptr-&gt;td_regs.r14;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r15 = local_data_ptr-&gt;td_regs.r15;</span><br><span class="line">                            &#125;</span><br><span class="line">                    </span><br><span class="line">                        local_data-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_spec_ctrl = ia32_rdmsr(IA32_SPEC_CTRL_MSR_ADDR);</span><br><span class="line">                        wrmsr_opt(IA32_SPEC_CTRL_MSR_ADDR, TDX_MODULE_IA32_SPEC_CTRL,</span><br><span class="line">                                local_data-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_spec_ctrl);</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Clear NMI unblocking flag;</span></span><br><span class="line">                        <span class="comment">// For L1 this is used only for L2 VM entries following L2 VM exits</span></span><br><span class="line">                        <span class="comment">// For L2 it will be set later if required, and using on L2 VM entry</span></span><br><span class="line">                        local_data-&gt;vp_ctx.tdvps-&gt;management.nmi_unblocking_due_to_iret = <span class="literal">false</span>;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Get exit information</span></span><br><span class="line">                        ia32_vmread(VMX_VM_EXIT_REASON_ENCODE, &amp;vm_exit_reason-&gt;raw);</span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">if</span> (vm_exit_reason-&gt;vmenter_fail == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// If no failed VMENTRY occurred then the VMCS is launched after a VMEXIT</span></span><br><span class="line">                            local_data-&gt;vp_ctx.tdvps-&gt;management.vm_launched[vm_id] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        ia32_vmread(VMX_VM_EXIT_QUALIFICATION_ENCODE, &amp;vm_exit_qualification-&gt;raw);</span><br><span class="line">                        ia32_vmread(VMX_VM_EXIT_INTERRUPTION_INFO_ENCODE, &amp;vm_exit_inter_info-&gt;raw);</span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">if</span> (local_data-&gt;vp_ctx.tdr-&gt;management_fields.fatal)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// A #MC VM exit has occurred on another LP, indicating memory integrity error.</span></span><br><span class="line">                            <span class="comment">// Do an async TD exit without accessing TD memory.</span></span><br><span class="line">                            async_tdexit_to_vmm(TDX_NON_RECOVERABLE_TD_NON_ACCESSIBLE, *vm_exit_reason,</span><br><span class="line">                                                           vm_exit_qualification-&gt;raw, <span class="number">0</span>, <span class="number">0</span>, vm_exit_inter_info-&gt;raw);</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// If a preempted bus lock has been reported in the exit reason, set the local data bus lock flag.</span></span><br><span class="line">                        <span class="comment">// This flag is sticky bit; it gets reset only when reported on TD exit.</span></span><br><span class="line">                        <span class="keyword">if</span> (vm_exit_reason-&gt;bus_lock_preempted)</span><br><span class="line">                        &#123;</span><br><span class="line">                            local_data-&gt;vp_ctx.bus_lock_preempted = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// If the TD is debuggable, the host VMM can request all L2 exits to be converted to TD exits.</span></span><br><span class="line">                        <span class="keyword">if</span> ((vm_id &gt; <span class="number">0</span>) &amp;&amp; local_data-&gt;vp_ctx.tdvps-&gt;management.l2_debug_ctls[vm_id].td_exit_on_l2_vm_exit)</span><br><span class="line">                        &#123;</span><br><span class="line">                            tdx_debug_assert(local_data-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.attributes.debug == <span class="number">1</span>);</span><br><span class="line">                            async_tdexit_to_vmm(TDX_TD_EXIT_ON_L2_VM_EXIT, *vm_exit_reason, vm_exit_qualification-&gt;raw, <span class="number">0</span>, <span class="number">0</span>, vm_exit_inter_info-&gt;raw);</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">return</span> vmexit_stepping_result;</span><br><span class="line">                    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vmexit_stepping_result != FILTER_OK_CONTINUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle_vm_entry_failures(tdx_local_data_ptr, vm_exit_reason, vm_exit_qualification);</span><br><span class="line"></span><br><span class="line">    attr = tdx_local_data_ptr-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.attributes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (vm_exit_reason.basic_reason)&#123;</span><br><span class="line">        <span class="keyword">case</span> VMEXIT_REASON_VMFUNC_INSTRUCTION:</span><br><span class="line">        <span class="keyword">case</span> VMEXIT_REASON_ENCLS_INSTRUCTION:</span><br><span class="line">        <span class="keyword">case</span> VMEXIT_REASON_ENCLV_INSTRUCTION:</span><br><span class="line">        <span class="keyword">case</span> VMEXIT_REASON_ENQCMDS_PASID_TRANSLATION_FAILURE:</span><br><span class="line">        <span class="keyword">case</span> VMEXIT_REASON_SEAMCALL:</span><br><span class="line">            inject_ud();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> VMEXIT_REASON_TDCALL:</span><br><span class="line">            td_call(tdx_local_data_ptr, &amp;interrupt_occurred);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">td_call</span><span class="params">(<span class="type">tdx_module_local_t</span>* tdx_local_data_ptr, <span class="type">bool_t</span>* interrupt_occurred)</span></span><br><span class="line">    <span class="title function_">if</span> <span class="params">(!is_td_guest_in_64b_mode())</span><span class="keyword">return</span>;</span><br><span class="line">     leaf_opcode.raw = tdx_local_data_ptr-&gt;td_regs.rax;</span><br><span class="line">     <span class="keyword">if</span> ((leaf_opcode.reserved0 != <span class="number">0</span>) || (leaf_opcode.reserved1 != <span class="number">0</span>)) <span class="keyword">goto</span> EXIT;</span><br><span class="line">    <span class="keyword">if</span> ((leaf_opcode.version &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (leaf_opcode.leaf != TDG_VM_RD_LEAF))<span class="keyword">goto</span> EXIT;</span><br><span class="line">      <span class="keyword">switch</span> (leaf_opcode.leaf)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> TDG_VP_VMCALL_LEAF:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Special case.  will (or may) not return to the TD but to go to VMM.</span></span><br><span class="line">                retval = tdg_vp_vmcall(tdx_local_data_ptr-&gt;td_regs.rcx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      EXIT:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">api_error_type <span class="title function_">tdg_vp_vmcall</span><span class="params">(<span class="type">uint64_t</span> controller_value)</span></span><br><span class="line">&#123;</span><br><span class="line">    api_error_type retval = TDX_OPERAND_INVALID;</span><br><span class="line">    <span class="type">tdx_module_local_t</span>* tdx_local_data_ptr = get_local_data();</span><br><span class="line"></span><br><span class="line">    <span class="type">tdvmcall_control_t</span> control = &#123; .raw = controller_value &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> gpr_check_mask = (<span class="type">uint16_t</span>)(BIT(<span class="number">0</span>) | BIT(<span class="number">1</span>) | BIT(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdx_local_data_ptr-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.config_flags.no_rbp_mod)</span><br><span class="line">    &#123;</span><br><span class="line">        gpr_check_mask |= (<span class="type">uint16_t</span>)BIT(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bits 0, 1 and 4 and 63:32 of RCX must be 0</span></span><br><span class="line">    <span class="keyword">if</span> (((control.gpr_select &amp; gpr_check_mask) != <span class="number">0</span>) ||</span><br><span class="line">         (control.reserved != <span class="number">0</span>))<span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TDX-SEAM loads the host VMM GPRs (in its LP-scope state save area), except RAX,</span></span><br><span class="line">    <span class="comment">// with the guest TD GPR (from TDVPS).</span></span><br><span class="line">    copy_gprs_data_from_td_to_vmm(tdx_local_data_ptr, control);</span><br><span class="line">            <span class="type">static</span> <span class="type">void</span> <span class="title function_">copy_gprs_data_from_td_to_vmm</span><span class="params">(<span class="type">tdx_module_local_t</span>* tdx_local_data_ptr,</span></span><br><span class="line"><span class="params">                                                      <span class="type">tdvmcall_control_t</span> control)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Copy guest TD&#x27;s GPRs, selected by the input parameter, to the host VMM GPRs image.</span></span><br><span class="line">                <span class="comment">// Clear other non-selected GPRs.</span></span><br><span class="line">                <span class="type">td_exit_qualification_t</span> td_exit_qual = &#123; .raw = <span class="number">0</span> &#125;;</span><br><span class="line">                td_exit_qual.vm = tdx_local_data_ptr-&gt;vp_ctx.tdvps-&gt;management.curr_vm;</span><br><span class="line">                td_exit_qual.gpr_select = control.gpr_select;</span><br><span class="line">                td_exit_qual.xmm_select = control.xmm_select;</span><br><span class="line">            </span><br><span class="line">                tdx_local_data_ptr-&gt;vmm_regs.rcx = td_exit_qual.raw;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// RAX is not copied, RCX filled above, start from RDX</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">2</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((control.gpr_select &amp; BIT(i)) != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tdx_local_data_ptr-&gt;vmm_regs.gprs[i] = tdx_local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_state.gpr_state.gprs[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Avoid modifying RBP</span></span><br><span class="line">                        <span class="keyword">if</span> (!tdx_local_data_ptr-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.config_flags.no_rbp_mod ||</span><br><span class="line">                                (i != <span class="number">5</span>))</span><br><span class="line">                        &#123;</span><br><span class="line">                            tdx_local_data_ptr-&gt;vmm_regs.gprs[i] = <span class="number">0ULL</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the exit reason in RAX</span></span><br><span class="line">    <span class="comment">// Check the sticky BUS_LOCK_PREEMPTED flag, report and clear if true.</span></span><br><span class="line">    <span class="type">vm_vmexit_exit_reason_t</span> vm_exit_reason = &#123; .raw = VMEXIT_REASON_TDCALL&#125;;</span><br><span class="line">    <span class="keyword">if</span> (tdx_local_data_ptr-&gt;vp_ctx.bus_lock_preempted)</span><br><span class="line">    &#123;</span><br><span class="line">        vm_exit_reason.bus_lock_preempted = <span class="literal">true</span>;</span><br><span class="line">        tdx_local_data_ptr-&gt;vp_ctx.bus_lock_preempted = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tdx_local_data_ptr-&gt;vmm_regs.rax = vm_exit_reason.raw;</span><br><span class="line"></span><br><span class="line">    <span class="type">ia32_xcr0_t</span> xcr0 = &#123; .raw = tdx_local_data_ptr-&gt;vp_ctx.xfam &#125;;</span><br><span class="line">    xcr0.sse = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64_t</span> scrub_mask = xcr0.raw;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TDGVPVMCALL behaves as a trap-like TD exit.</span></span><br><span class="line">    <span class="comment">// TDX-SEAM advances the guest TD RIP (in TD VMCS) to the instruction following TDCALL.</span></span><br><span class="line">    td_vmexit_to_vmm(VCPU_READY, LAST_EXIT_TDVMCALL, scrub_mask, control.xmm_select, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    EXIT_FAILURE:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">td_vmexit_to_vmm</span><span class="params">(<span class="type">uint8_t</span> vcpu_state, <span class="type">uint8_t</span> last_td_exit, <span class="type">uint64_t</span> scrub_mask,</span></span><br><span class="line"><span class="params">                      <span class="type">uint16_t</span> xmm_select, <span class="type">bool_t</span> is_td_dead, <span class="type">bool_t</span> is_trap_exit)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Local data</span></span><br><span class="line">    <span class="type">tdx_module_local_t</span>* tdx_local_data_ptr = get_local_data();</span><br><span class="line">    <span class="type">vp_ctx_t</span>* vp_ctx = &amp;tdx_local_data_ptr-&gt;vp_ctx;</span><br><span class="line">    <span class="type">tdvps_t</span>* tdvps_ptr = tdx_local_data_ptr-&gt;vp_ctx.tdvps;</span><br><span class="line">    <span class="type">tdcs_t</span>* tdcs_ptr = tdx_local_data_ptr-&gt;vp_ctx.tdcs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Avoid accessing TD private memory and control structures (except TDR).</span></span><br><span class="line">    <span class="comment">// The TD is dead, no need so save its state.</span></span><br><span class="line">    <span class="keyword">if</span> (!is_td_dead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1.  Save any guest state that it has not saved as part of the common guest-side operation, e.g.,</span></span><br><span class="line">        <span class="comment">//     the extended state per TDCS.XFAM</span></span><br><span class="line">        save_guest_td_state_before_td_exit(tdcs_ptr, tdx_local_data_ptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.  Set TDVPS.STATE to one of the VCPU_READY sub states, as an indication to the next TD entry.</span></span><br><span class="line">        tdvps_ptr-&gt;management.state = vcpu_state;</span><br><span class="line">        tdvps_ptr-&gt;management.last_td_exit = last_td_exit;</span><br><span class="line">        <span class="comment">// At this point the VCPU state will no longer be accessed</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((tdvps_ptr-&gt;management.curr_vm != <span class="number">0</span>) &amp;&amp; !is_trap_exit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// On TD exit from L2 VM, write the output memory operands of TDG.VP.ENTER to memory.</span></span><br><span class="line">            <span class="comment">// This is done at this point, before the TLB tracking counter is decremented,</span></span><br><span class="line">            <span class="comment">// because after that the memory is not protected by TLB tracking and may not</span></span><br><span class="line">            <span class="comment">// be valid for writing anymore.</span></span><br><span class="line">            write_l2_enter_outputs(tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save Guest-TD XCR0 and XSS</span></span><br><span class="line">        save_guest_td_extended_state(tdvps_ptr, tdx_local_data_ptr-&gt;vp_ctx.xfam);</span><br><span class="line">            _STATIC_INLINE_ <span class="type">void</span> <span class="title function_">save_guest_td_extended_state</span><span class="params">(<span class="type">tdvps_t</span>* tdvps_ptr, <span class="type">uint64_t</span> xfam)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Set Guest XCR0 and XSS context for saving the state</span></span><br><span class="line">                ia32_xsetbv(<span class="number">0</span>, xfam &amp; XCR0_USER_BIT_MASK);</span><br><span class="line">                ia32_wrmsr(IA32_XSS_MSR_ADDR, xfam &amp; XCR0_SUPERVISOR_BIT_MASK);</span><br><span class="line">            </span><br><span class="line">                ia32_xsaves(&amp;tdvps_ptr-&gt;guest_extension_state.xbuf, xfam);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_trap_exit)<span class="comment">//true</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// TDGVPVMCALL behaves as a trap-like TD exit.</span></span><br><span class="line">            <span class="comment">// TDX-SEAM advances the guest TD RIP (in TD VMCS) to the instruction following TDCALL.</span></span><br><span class="line">            advance_guest_rip();</span><br><span class="line">                <span class="type">void</span> <span class="title function_">advance_guest_rip</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">                &#123;</span><br><span class="line">                    current_vmcs_guest_rip_advance(<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">                    clear_movss_sti_blocking();</span><br><span class="line">                    set_guest_pde_bs();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.  Execute the TD exit TLB tracking sequence, adjusting the TDCS tracking counters.</span></span><br><span class="line">        <span class="type">tdcs_epoch_tracking_fields_t</span>* epoch_tracking = &amp;tdcs_ptr-&gt;epoch_tracking;</span><br><span class="line">        (<span class="type">void</span>)_lock_xadd_16b(&amp;epoch_tracking-&gt;epoch_and_refcount.refcount[tdvps_ptr-&gt;management.vcpu_epoch &amp; <span class="number">1</span>], (<span class="type">uint16_t</span>)<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.  At this point TDR, TDCS and TDVPS will no longer be used during the flow.</span></span><br><span class="line">    <span class="comment">//     Release the shared lock on those control structures, which was acquired by TDHVPENTER.</span></span><br><span class="line">    pamt_implicit_release_lock(vp_ctx-&gt;tdr_pamt_entry, TDX_LOCK_SHARED);</span><br><span class="line">    pamt_unwalk(vp_ctx-&gt;tdvpr_pa, vp_ctx-&gt;tdvpr_pamt_block, vp_ctx-&gt;tdvpr_pamt_entry, TDX_LOCK_SHARED, PT_4KB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load host VMM state:</span></span><br><span class="line">    set_seam_vmcs_as_active();</span><br><span class="line">        _STATIC_INLINE_ <span class="type">void</span> <span class="title function_">set_seam_vmcs_as_active</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Set the SEAM VMCS as the current VMCS</span></span><br><span class="line">            <span class="comment">// SEAM VMCS addr: seamrr_base + page_size + (lp_id * page_size)</span></span><br><span class="line">            <span class="type">uint64_t</span> seam_vmcs_pa = get_global_data()-&gt;seamrr_base +</span><br><span class="line">                                    (TDX_PAGE_SIZE_IN_BYTES * (get_local_data()-&gt;lp_info.lp_id + <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">            ia32_vmptrld((<span class="type">vmcs_ptr_t</span>*)seam_vmcs_pa);</span><br><span class="line">        </span><br><span class="line">            get_local_data()-&gt;vp_ctx.active_vmcs = ACTIVE_VMCS_NONE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.  Load any host VMM state, which is not part of the output of TDHVPENTER, and that</span></span><br><span class="line">    <span class="comment">//     might have been modified by TDX-SEAM itself and by the guest TD, with synthetic INIT values.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is done before loading VMM state - to save additional XCR0/XSS save-restore</span></span><br><span class="line">    initialize_extended_state(scrub_mask);</span><br><span class="line">        <span class="type">void</span> <span class="title function_">initialize_extended_state</span><span class="params">(<span class="type">uint64_t</span> xfam)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ia32_xsetbv(<span class="number">0</span>, xfam &amp; XCR0_USER_BIT_MASK);</span><br><span class="line">            ia32_wrmsr(IA32_XSS_MSR_ADDR, xfam &amp; XCR0_SUPERVISOR_BIT_MASK);</span><br><span class="line">        </span><br><span class="line">            ia32_xrstors(&amp;get_global_data()-&gt;xbuf, xfam);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6.  Restore host VMM CPU state from the TDX-SEAM LP-scope state save area.</span></span><br><span class="line">    <span class="comment">//     At this point, any flow that needed to update the host VMM state, e.g.,</span></span><br><span class="line">    <span class="comment">//     write to RDX as an output operand, has done so by updating the state save area.</span></span><br><span class="line">    load_vmm_state_before_td_exit(tdx_local_data_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In case of TDGVPVMCALL, Guest XMM&#x27;s will be passed down to VMM, based on XFAM.SSE bit</span></span><br><span class="line">    <span class="comment">// If the bit is 0 then they won&#x27;t be zeroed by initialization</span></span><br><span class="line">    <span class="comment">// In case of Async TDEXIT, set XMM0-15 of the VMM to 0.</span></span><br><span class="line">    <span class="keyword">if</span> (last_td_exit == LAST_EXIT_TDVMCALL)</span><br><span class="line">    &#123;</span><br><span class="line">        load_xmms_by_mask(tdvps_ptr, xmm_select);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.   Run the common SEAMRET routine.</span></span><br><span class="line">    tdx_vmm_post_dispatching();</span><br><span class="line">            <span class="type">void</span> <span class="title function_">tdx_vmm_post_dispatching</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            advance_guest_rip();</span><br><span class="line">        </span><br><span class="line">            <span class="type">tdx_module_local_t</span>* local_data_ptr = get_local_data();</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// Restore IA32_SPEC_CTRL</span></span><br><span class="line">            wrmsr_opt(IA32_SPEC_CTRL_MSR_ADDR, local_data_ptr-&gt;vmm_non_extended_state.ia32_spec_ctrl,</span><br><span class="line">                                               TDX_MODULE_IA32_SPEC_CTRL);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// If simplified LAM was saved &amp; disabled, restore its state</span></span><br><span class="line">            <span class="keyword">if</span> (local_data_ptr-&gt;vmm_non_extended_state.ia32_lam_enable != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ia32_wrmsr(IA32_LAM_ENABLE_MSR_ADDR, local_data_ptr-&gt;vmm_non_extended_state.ia32_lam_enable);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            mark_lp_as_free();</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// Check that we have no mapped keyholes left</span></span><br><span class="line">            tdx_sanity_check(local_data_ptr-&gt;keyhole_state.total_ref_count == <span class="number">0</span>, SCEC_KEYHOLE_MANAGER_SOURCE, <span class="number">20</span>);</span><br><span class="line">        </span><br><span class="line">            TDX_LOG(<span class="string">&quot;tdx_vmm_post_dispatching - preparing to do SEAMRET\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">            tdx_seamret_to_vmm(); <span class="comment">// Restore GPRs and SEAMRET</span></span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">            <span class="comment">// Shouldn&#x27;t reach here:</span></span><br><span class="line">            tdx_sanity_check(<span class="number">0</span>, SCEC_VMM_DISPATCHER_SOURCE, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unreachable Code. Panic</span></span><br><span class="line">    tdx_sanity_check(<span class="number">0</span>, SCEC_TDEXIT_SOURCE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 lock 是在 vp_enter 的时候拿的 是 shared lock</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">save_guest_td_state_before_td_exit</span><span class="params">(<span class="type">tdcs_t</span>* tdcs_ptr, <span class="type">tdx_module_local_t</span>* local_data_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">tdx_module_global_t</span>* global_data = get_global_data();</span><br><span class="line"></span><br><span class="line">    <span class="type">tdvps_t</span>* tdvps_ptr = local_data_ptr-&gt;vp_ctx.tdvps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extended state control</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.xfd_supported)</span><br><span class="line">    &#123;</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_xfd = ia32_rdmsr(IA32_XFD_MSR_ADDR);</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_xfd_err = ia32_rdmsr(IA32_XFD_ERROR_MSR_ADDR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CR2 state</span></span><br><span class="line">    tdvps_ptr-&gt;guest_state.cr2 = ia32_store_cr2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XCR0 state</span></span><br><span class="line">    tdvps_ptr-&gt;guest_state.xcr0 = ia32_xgetbv(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debug state</span></span><br><span class="line">    tdvps_ptr-&gt;guest_state.dr0 = ia32_store_dr0();</span><br><span class="line">    tdvps_ptr-&gt;guest_state.dr1 = ia32_store_dr1();</span><br><span class="line">    tdvps_ptr-&gt;guest_state.dr2 = ia32_store_dr2();</span><br><span class="line">    tdvps_ptr-&gt;guest_state.dr3 = ia32_store_dr3();</span><br><span class="line">    tdvps_ptr-&gt;guest_state.dr6 = ia32_store_dr6();</span><br><span class="line"></span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_ds_area = ia32_rdmsr(IA32_DS_AREA_MSR_ADDR);</span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">ia32_xcr0_t</span>)tdvps_ptr-&gt;management.xfam).lbr)</span><br><span class="line">    &#123;</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_lbr_depth = ia32_rdmsr(IA32_LBR_DEPTH_MSR_ADDR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perfmon State</span></span><br><span class="line">    <span class="keyword">if</span> (tdcs_ptr-&gt;executions_ctl_fields.attributes.perfmon)</span><br><span class="line">    &#123;</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_fixed_ctr_ctrl = ia32_rdmsr(IA32_FIXED_CTR_CTRL_MSR_ADDR);</span><br><span class="line">        <span class="comment">//cpuid_config.values.edx.num_fcs  5bit: 0-32</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; global_data-&gt;num_fixed_ctrs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((global_data-&gt;fc_bitmap &amp; BIT(i)) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tdvps_ptr-&gt;guest_msr_state.ia32_fixed_ctr[i] = ia32_rdmsr(IA32_FIXED_CTR0_MSR_ADDR + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; NUM_PMC; i++) <span class="comment">// NUM_PMC = 8</span></span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                tdvps_ptr-&gt;guest_msr_state.ia32_a_pmc[i] = ia32_rdmsr(IA32_A_PMC0_MSR_ADDR + i);</span><br><span class="line">                tdvps_ptr-&gt;guest_msr_state.ia32_perfevtsel[i] = ia32_rdmsr(IA32_PERFEVTSEL0_MSR_ADDR + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tdvps_ptr-&gt;guest_msr_state.ia32_offcore_rsp[i] = ia32_rdmsr(IA32_OFFCORE_RSPx_MSR_ADDR + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_perf_global_status = ia32_rdmsr(IA32_PERF_GLOBAL_STATUS_MSR_ADDR);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == global_data-&gt;plt_common_config.ia32_perf_capabilities.perf_metrics_available)</span><br><span class="line">        &#123;</span><br><span class="line">            tdvps_ptr-&gt;guest_msr_state.ia32_perf_metrics = ia32_rdmsr(IA32_PERF_METRICS_MSR_ADDR);</span><br><span class="line">        &#125;</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_pebs_enable = ia32_rdmsr(IA32_PEBS_ENABLE_MSR_ADDR);</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_pebs_data_cfg = ia32_rdmsr(IA32_PEBS_DATA_CFG_MSR_ADDR);</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_pebs_ld_lat = ia32_rdmsr(IA32_PEBS_LD_LAT_MSR_ADDR);</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_pebs_frontend = ia32_rdmsr(IA32_PEBS_FRONTEND_MSR_ADDR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.waitpkg_supported)</span><br><span class="line">    &#123;</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_umwait_control= ia32_rdmsr(IA32_UMWAIT_CONTROL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.tsx_supported)</span><br><span class="line">    &#123;</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_tsx_ctrl = ia32_rdmsr(IA32_TSX_CTRL_MSR_ADDR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_uarch_misc_ctl = ia32_rdmsr(IA32_UARCH_MISC_CTL_MSR_ADDR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save the following MSRs:</span></span><br><span class="line">    <span class="comment">// IA32_STAR, IA32_LSTAR,</span></span><br><span class="line">    <span class="comment">// IA32_FMASK, IA32_KERNEL_GS_BASE, IA32_TSC_AUX</span></span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_star            = ia32_rdmsr(IA32_STAR_MSR_ADDR);</span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_lstar           = ia32_rdmsr(IA32_LSTAR_MSR_ADDR);</span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_fmask           = ia32_rdmsr(IA32_FMASK_MSR_ADDR);</span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_kernel_gs_base  = ia32_rdmsr(IA32_KERNEL_GS_BASE_MSR_ADDR);</span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_tsc_aux         = ia32_rdmsr(IA32_TSC_AUX_MSR_ADDR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">current_vmcs_guest_rip_advance</span><span class="params">(<span class="type">uint64_t</span> instruction_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> current_vmm_rip;</span><br><span class="line">    ia32_vmread(VMX_GUEST_RIP_ENCODE, &amp;current_vmm_rip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instruction_len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ia32_vmread(VMX_VM_EXIT_INSTRUCTION_LENGTH_ENCODE, &amp;instruction_len);</span><br><span class="line">        tdx_sanity_check(instruction_len != <span class="number">0</span>, SCEC_HELPERS_SOURCE, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ia32_vmwrite(VMX_GUEST_RIP_ENCODE, current_vmm_rip + instruction_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_movss_sti_blocking</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vmx_guest_inter_state_t</span> guest_inter_state;</span><br><span class="line">    ia32_vmread(VMX_GUEST_INTERRUPTIBILITY_ENCODE, &amp;guest_inter_state.raw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (guest_inter_state.blocking_by_mov_ss != <span class="number">0</span> || guest_inter_state.blocking_by_sti != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        guest_inter_state.blocking_by_mov_ss = <span class="number">0</span>;</span><br><span class="line">        guest_inter_state.blocking_by_sti = <span class="number">0</span>;</span><br><span class="line">        ia32_vmwrite(VMX_GUEST_INTERRUPTIBILITY_ENCODE, guest_inter_state.raw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_guest_pde_bs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ia32_rflags_t</span> rflags;</span><br><span class="line">    ia32_vmread(VMX_GUEST_RFLAGS_ENCODE, &amp;rflags.raw);</span><br><span class="line"></span><br><span class="line">    <span class="type">ia32_debugctl_t</span> debugctl;</span><br><span class="line">    ia32_vmread(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, &amp;debugctl.raw);</span><br><span class="line"></span><br><span class="line">    <span class="type">pending_debug_exception_t</span> pde;</span><br><span class="line">    ia32_vmread(VMX_GUEST_PND_DEBUG_EXCEPTION_ENCODE, &amp;pde.raw);</span><br><span class="line"></span><br><span class="line">    pde.bs = (rflags.tf == <span class="number">1</span> &amp;&amp; debugctl.btf == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ia32_vmwrite(VMX_GUEST_PND_DEBUG_EXCEPTION_ENCODE, pde.raw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_vmm_state_before_td_exit</span><span class="params">(<span class="type">tdx_module_local_t</span>* local_data_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">tdx_module_global_t</span>* global_data = get_global_data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear CR2 to its INIT value</span></span><br><span class="line">    ia32_load_cr2(CR2_RESET_STATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debug state restoration</span></span><br><span class="line">    init_all_dr_opt(local_data_ptr-&gt;vp_ctx.tdvps);</span><br><span class="line"></span><br><span class="line">    wrmsr_opt(IA32_DS_AREA_MSR_ADDR, local_data_ptr-&gt;vmm_non_extended_state.ia32_ds_area, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_ds_area);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (local_data_ptr-&gt;vp_ctx.xfd_supported)</span><br><span class="line">    &#123;</span><br><span class="line">        init_msr_opt(IA32_XFD_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_xfd);</span><br><span class="line">        init_msr_opt(IA32_XFD_ERROR_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_xfd_err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perfmon State</span></span><br><span class="line">    <span class="keyword">if</span> (local_data_ptr-&gt;vp_ctx.attributes.perfmon)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; global_data-&gt;num_fixed_ctrs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((global_data-&gt;fc_bitmap &amp; BIT(i)) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                init_msr_opt(IA32_FIXED_CTR0_MSR_ADDR + i, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_fixed_ctr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; NUM_PMC; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                init_msr_opt(IA32_A_PMC0_MSR_ADDR + i, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_a_pmc[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            init_msr_opt(IA32_OFFCORE_RSPx_MSR_ADDR + i, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_offcore_rsp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ia32_wrmsr(IA32_PERF_GLOBAL_STATUS_RESET_MSR_ADDR, ia32_rdmsr(IA32_PERF_GLOBAL_STATUS_MSR_ADDR));</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == global_data-&gt;plt_common_config.ia32_perf_capabilities.perf_metrics_available)</span><br><span class="line">        &#123;</span><br><span class="line">            init_msr_opt(IA32_PERF_METRICS_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_perf_metrics);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_msr_opt(IA32_UARCH_MISC_CTL_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_uarch_misc_ctl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Initialize the following MSRs:</span></span><br><span class="line"><span class="comment">     * IA32_STAR, IA32_LSTAR, IA32_FMASK, IA32_TSC_AUX,  &amp; IA32_KERNEL_GS_BASE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    init_msr_opt(IA32_TSC_AUX_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_tsc_aux);</span><br><span class="line">    init_msr_opt(IA32_STAR_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_star);</span><br><span class="line">    init_msr_opt(IA32_LSTAR_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_lstar);</span><br><span class="line">    init_msr_opt(IA32_FMASK_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_fmask);</span><br><span class="line">    init_msr_opt(IA32_KERNEL_GS_BASE_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_kernel_gs_base);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (local_data_ptr-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.cpuid_flags.tsx_supported)</span><br><span class="line">    &#123;</span><br><span class="line">        ia32_wrmsr(IA32_TSX_CTRL_MSR_ADDR, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        wrmsr_opt(IA32_TSX_CTRL_MSR_ADDR, local_data_ptr-&gt;vmm_non_extended_state.ia32_tsx_ctrl, IA32_TSX_CTRL_DISABLE_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Use vmwrite to update the following SEAM-VMCS guest fields</span></span><br><span class="line"><span class="comment">     *  IA32_DEBUGCTL, IA32_PERF_GLOBAL_CTRL, IA32_RTIT_CTL, IA32_LBR_CTL and DR7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint64_t</span> debugctl_msr_value;</span><br><span class="line">    ia32_vmread(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, &amp;debugctl_msr_value);</span><br><span class="line">    debugctl_msr_value = debugctl_msr_value &amp; IA32_DEBUGCTLMSR_MASK_BITS_PRESERVED;</span><br><span class="line">    ia32_vmwrite(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, debugctl_msr_value);</span><br><span class="line">    <span class="keyword">if</span> (local_data_ptr-&gt;vp_ctx.attributes.perfmon)</span><br><span class="line">    &#123;</span><br><span class="line">        ia32_vmwrite(VMX_GUEST_IA32_PERF_GLOBAL_CONTROL_FULL_ENCODE, VMX_GUEST_IA32_PERF_GLOBAL_CONTROL_INIT_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">ia32_xcr0_t</span>)local_data_ptr-&gt;vp_ctx.xfam).pt)</span><br><span class="line">    &#123;</span><br><span class="line">        ia32_vmwrite(VMX_GUEST_RTIT_CTL_FULL_ENCODE, VMX_GUEST_RTIT_CTL_INIT_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">ia32_xcr0_t</span>)local_data_ptr-&gt;vp_ctx.xfam).lbr)</span><br><span class="line">    &#123;</span><br><span class="line">        ia32_vmwrite(VMX_GUEST_LBR_CTL_FULL_ENCODE, VMX_GUEST_LBR_CTL_INIT_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    ia32_vmwrite(VMX_GUEST_DR7_ENCODE, VMX_GUEST_DR7_INIT_VALUE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_msr_opt</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> cur_value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (addr == IA32_FMASK_MSR_ADDR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur_value != IA32_FMASK_MSR_RESET_STATE)</span><br><span class="line">        &#123;</span><br><span class="line">            ia32_wrmsr(IA32_FMASK_MSR_ADDR, IA32_FMASK_MSR_RESET_STATE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (addr == IA32_LBR_DEPTH_MSR_ADDR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur_value != IA32_LBR_DEPTH_MSR_RESET_STATE)</span><br><span class="line">        &#123;</span><br><span class="line">            ia32_wrmsr(IA32_LBR_DEPTH_MSR_ADDR, IA32_LBR_DEPTH_MSR_RESET_STATE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// All other MSR&#x27;s are reset to 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur_value != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ia32_wrmsr(addr, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">_STATIC_INLINE_ <span class="type">uint64_t</span> <span class="title function_">ia32_store_dr0</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> dr0;</span><br><span class="line">    _ASM_VOLATILE_ (<span class="string">&quot;mov %%dr0, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (dr0));</span><br><span class="line">    <span class="keyword">return</span> dr0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_STATIC_INLINE_ <span class="type">uint64_t</span> <span class="title function_">ia32_store_dr1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> dr1;</span><br><span class="line">    _ASM_VOLATILE_ (<span class="string">&quot;mov %%dr1, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (dr1));</span><br><span class="line">    <span class="keyword">return</span> dr1;</span><br><span class="line">&#125;</span><br><span class="line">_STATIC_INLINE_ <span class="type">uint64_t</span> <span class="title function_">ia32_rdmsr</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> low,high;</span><br><span class="line">    _ASM_VOLATILE_ (<span class="string">&quot;rdmsr&quot;</span> : <span class="string">&quot;=a&quot;</span>(low), <span class="string">&quot;=d&quot;</span>(high) : <span class="string">&quot;c&quot;</span>(addr));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint64_t</span>)((((<span class="type">uint64_t</span>)(high)) &lt;&lt; <span class="number">32</span>) | (<span class="type">uint64_t</span>)(low));</span><br><span class="line">&#125;</span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">ia32_xsaves</span><span class="params">(<span class="type">void</span>* xsave_area, <span class="type">uint64_t</span> xfam)</span></span><br><span class="line">&#123;</span><br><span class="line">    _ASM_VOLATILE_ ( <span class="string">&quot;xsaves %0 \n&quot;</span> : <span class="string">&quot;=m&quot;</span>(*((<span class="type">uint64_t</span> *)xsave_area)) : <span class="string">&quot;d&quot;</span>((<span class="type">uint32_t</span>)(xfam &gt;&gt; <span class="number">32</span>)),</span><br><span class="line">            <span class="string">&quot;a&quot;</span>((<span class="type">uint32_t</span>)xfam) : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">ia32_xseglobaltbv</span><span class="params">(<span class="type">uint64_t</span> xcr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    _ASM_VOLATILE_ (<span class="string">&quot;xsetbv&quot;</span> : : <span class="string">&quot;a&quot;</span>((<span class="type">uint32_t</span>)value), <span class="string">&quot;d&quot;</span>((<span class="type">uint32_t</span>)(value &gt;&gt; <span class="number">32</span>)), <span class="string">&quot;c&quot;</span>(xcr));</span><br><span class="line">&#125;</span><br><span class="line">_STATIC_INLINE_ <span class="type">uint16_t</span> _lock_xadd_16b(<span class="type">uint16_t</span> *mem, <span class="type">uint16_t</span> quantum)</span><br><span class="line">&#123;</span><br><span class="line">    _ASM_VOLATILE_ (<span class="string">&quot;lock; xaddw %2, %0&quot;</span> : <span class="string">&quot;=m&quot;</span> ( *mem ), <span class="string">&quot;=a&quot;</span>(quantum) : <span class="string">&quot;a&quot;</span>(quantum) : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> quantum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Write to VMCS entry</span></span><br><span class="line"><span class="comment"> * @param encoding</span></span><br><span class="line"><span class="comment"> * @param value</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">ia32_vmwrite</span><span class="params">(<span class="type">uint64_t</span> encoding, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//According to SDM, in 64-bit mode the instruction will fail is given an</span></span><br><span class="line">    <span class="comment">//operand that sets encoding bit beyond 32-bit</span></span><br><span class="line">    tdx_debug_assert(encoding &lt; BIT(<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//asm instruction expects both operands to be 64bit.</span></span><br><span class="line">    <span class="type">ia32_rflags_t</span> rflags;</span><br><span class="line">    _ASM_VOLATILE_ (<span class="string">&quot;vmwriteq %1,%2\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;popq %0&quot;</span></span><br><span class="line">                        : <span class="string">&quot;=r&quot;</span>(rflags.raw)</span><br><span class="line">            :<span class="string">&quot;r&quot;</span>(value), <span class="string">&quot;r&quot;</span>(encoding)</span><br><span class="line">            : <span class="string">&quot;cc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tdx_sanity_check((rflags.cf == <span class="number">0</span> &amp;&amp; rflags.zf == <span class="number">0</span>), SCEC_VT_ACCESSORS_SOURCE, (<span class="type">uint32_t</span>)encoding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Load pointer to VMCS</span></span><br><span class="line"><span class="comment"> * @param vmcs_p</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">ia32_vmptrld</span><span class="params">(<span class="type">vmcs_ptr_t</span> *vmcs_p)</span> &#123;</span><br><span class="line">    <span class="type">ia32_rflags_t</span> rflags;</span><br><span class="line">        _ASM_VOLATILE_ (<span class="string">&quot;vmptrld %1\n&quot;</span></span><br><span class="line">                    <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">                    <span class="string">&quot;popq %0\n&quot;</span></span><br><span class="line">                    : <span class="string">&quot;=r&quot;</span>(rflags.raw)</span><br><span class="line">                        :<span class="string">&quot;m&quot;</span>(vmcs_p):<span class="string">&quot;memory&quot;</span> , <span class="string">&quot;cc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Runtime assert - VMPTRLD should always succeed</span></span><br><span class="line">        tdx_sanity_check((rflags.cf == <span class="number">0</span> &amp;&amp; rflags.zf == <span class="number">0</span>), SCEC_VT_ACCESSORS_SOURCE, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl tdx_seamret_to_vmm</span><br><span class="line">.type  tdx_seamret_to_vmm,@function</span><br><span class="line">tdx_seamret_to_vmm:</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Restore all VMM GPRs on module entry from LP local data</span><br><span class="line">     * Local data is located at GSBASE</span><br><span class="line">     */</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET,     %rax</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+8,   %rcx</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+16,  %rdx</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+24,  %rbx</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+32,  %rsp // not actually needed</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+40,  %rbp</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+48,  %rsi</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+56,  %rdi</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+64,  %r8</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+72,  %r9</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+80,  %r10</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+88,  %r11</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+96,  %r12</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+104, %r13</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+112, %r14</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+120, %r15</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Call SEAMRET</span><br><span class="line">     */</span><br><span class="line">        .byte 0x66, 0x0F, 0x01, 0xCD</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * No accesible code from this point</span><br><span class="line">     * Panic with UD2 if reached</span><br><span class="line">     */</span><br><span class="line">    ud2.section .text</span><br></pre></td></tr></table></figure>

<ul>
<li>读写内存</li>
<li>汇编指令</li>
<li>if 不确定是否成立</li>
<li>循环不确定次数</li>
</ul>
<h3 id="Seamcall"><a href="#Seamcall" class="headerlink" title="Seamcall"></a>Seamcall</h3><p>host 侧：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/intel/tdx/blob/kvm-upstream/arch/x86/kvm/vmx/tdx.c">https://github.com/intel/tdx/blob/kvm-upstream/arch/x86/kvm/vmx/tdx.c</a></p>
<p>rax&#x3D;0  前 16bit 表示 seamcall 的动作  0 表示 vmlaunch&#x2F;vmresume</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinstr <span class="type">void</span> <span class="title function_">tdx_vcpu_enter_exit</span><span class="params">(<span class="keyword">struct</span> vcpu_tdx *tdx)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tdx_module_args</span> <span class="title">args</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Avoid section mismatch with to_tdx() with KVM_VM_BUG().  The caller</span></span><br><span class="line"><span class="comment">         * should call to_tdx().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> =</span> &amp;tdx-&gt;vcpu;</span><br><span class="line"></span><br><span class="line">        guest_state_enter_irqoff();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span> optimization:</span></span><br><span class="line"><span class="comment">         * - Eliminate copy between args and vcpu-&gt;arch.regs.</span></span><br><span class="line"><span class="comment">         * - copyin/copyout registers only if (tdx-&gt;tdvmvall.regs_mask != 0)</span></span><br><span class="line"><span class="comment">         *   which means TDG.VP.VMCALL.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        args = (<span class="keyword">struct</span> tdx_module_args) &#123;</span><br><span class="line">                .rcx = tdx-&gt;tdvpr_pa,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG(reg, REG)        .reg = vcpu-&gt;arch.regs[VCPU_REGS_ ## REG]</span></span><br><span class="line">                REG(rdx, RDX),</span><br><span class="line">                REG(r8,  R8),</span><br><span class="line">                REG(r9,  R9),</span><br><span class="line">                REG(r10, R10),</span><br><span class="line">                REG(r11, R11),</span><br><span class="line">                REG(r12, R12),</span><br><span class="line">                REG(r13, R13),</span><br><span class="line">                REG(r14, R14),</span><br><span class="line">                REG(r15, R15),</span><br><span class="line">                REG(rbx, RBX),</span><br><span class="line">                REG(rdi, RDI),</span><br><span class="line">                REG(rsi, RSI),</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> REG</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        tdx-&gt;exit_reason.full = __seamcall_saved_ret(TDH_VP_ENTER, &amp;args);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG(reg, REG)        vcpu-&gt;arch.regs[VCPU_REGS_ ## REG] = args.reg</span></span><br><span class="line">                REG(rcx, RCX);</span><br><span class="line">                REG(rdx, RDX);</span><br><span class="line">                REG(r8,  R8);</span><br><span class="line">                REG(r9,  R9);</span><br><span class="line">                REG(r10, R10);</span><br><span class="line">                REG(r11, R11);</span><br><span class="line">                REG(r12, R12);</span><br><span class="line">                REG(r13, R13);</span><br><span class="line">                REG(r14, R14);</span><br><span class="line">                REG(r15, R15);</span><br><span class="line">                REG(rbx, RBX);</span><br><span class="line">                REG(rdi, RDI);</span><br><span class="line">                REG(rsi, RSI);</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> REG</span></span><br><span class="line"></span><br><span class="line">        WARN_ON_ONCE(!kvm_rebooting &amp;&amp;</span><br><span class="line">                     (tdx-&gt;exit_reason.full &amp; TDX_SW_ERROR) == TDX_SW_ERROR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((u16)tdx-&gt;exit_reason.basic == EXIT_REASON_EXCEPTION_NMI &amp;&amp;</span><br><span class="line">            is_nmi(tdexit_intr_info(vcpu))) &#123;</span><br><span class="line">                kvm_before_interrupt(vcpu, KVM_HANDLING_NMI);</span><br><span class="line">                vmx_do_nmi_irqoff();</span><br><span class="line">                kvm_after_interrupt(vcpu);</span><br><span class="line">        &#125;</span><br><span class="line">        guest_state_exit_irqoff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把需要 tdx module 处理使用的参数通过寄存器传入  也是类似 function call</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">.macro TDX_MODULE_CALL host:req ret=0 saved=0</span><br><span class="line">        FRAME_BEGIN</span><br><span class="line"></span><br><span class="line">        /* Move Leaf ID to RAX */</span><br><span class="line">        mov %rdi, %rax</span><br><span class="line"></span><br><span class="line">        /* Move other input regs from &#x27;struct tdx_module_args&#x27; */</span><br><span class="line">        movq        TDX_MODULE_rcx(%rsi), %rcx</span><br><span class="line">        movq        TDX_MODULE_rdx(%rsi), %rdx</span><br><span class="line">        movq        TDX_MODULE_r8(%rsi),  %r8</span><br><span class="line">        movq        TDX_MODULE_r9(%rsi),  %r9</span><br><span class="line">        movq        TDX_MODULE_r10(%rsi), %r10</span><br><span class="line">        movq        TDX_MODULE_r11(%rsi), %r11</span><br><span class="line"></span><br><span class="line">.if \saved</span><br><span class="line">        /*</span><br><span class="line">         * Move additional input regs from the structure.  For simplicity</span><br><span class="line">         * assume that anything needs the callee-saved regs also tramples</span><br><span class="line">         * on RDI/RSI (see VP.ENTER).</span><br><span class="line">         */</span><br><span class="line">        /* Save those callee-saved GPRs as mandated by the x86_64 ABI */</span><br><span class="line">        pushq        %rbx</span><br><span class="line">        pushq        %r12</span><br><span class="line">        pushq        %r13</span><br><span class="line">        pushq        %r14</span><br><span class="line">        pushq        %r15</span><br><span class="line"></span><br><span class="line">        movq        TDX_MODULE_r12(%rsi), %r12</span><br><span class="line">        movq        TDX_MODULE_r13(%rsi), %r13</span><br><span class="line">        movq        TDX_MODULE_r14(%rsi), %r14</span><br><span class="line">        movq        TDX_MODULE_r15(%rsi), %r15</span><br><span class="line">        movq        TDX_MODULE_rbx(%rsi), %rbx</span><br><span class="line"></span><br><span class="line">.if \ret</span><br><span class="line">        /* Save the structure pointer as RSI is about to be clobbered */</span><br><span class="line">        pushq        %rsi</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">        movq        TDX_MODULE_rdi(%rsi), %rdi</span><br><span class="line">        /* RSI needs to be done at last */</span><br><span class="line">        movq        TDX_MODULE_rsi(%rsi), %rsi</span><br><span class="line">.endif        /* \saved */</span><br><span class="line"></span><br><span class="line">.if \host</span><br><span class="line">.Lseamcall\@:</span><br><span class="line">        seamcall</span><br><span class="line">        /*</span><br><span class="line">         * SEAMCALL instruction is essentially a VMExit from VMX root</span><br><span class="line">         * mode to SEAM VMX root mode.  VMfailInvalid (CF=1) indicates</span><br><span class="line">         * that the targeted SEAM firmware is not loaded or disabled,</span><br><span class="line">         * or P-SEAMLDR is busy with another SEAMCALL.  %rax is not</span><br><span class="line">         * changed in this case.</span><br><span class="line">         *</span><br><span class="line">         * Set %rax to TDX_SEAMCALL_VMFAILINVALID for VMfailInvalid.</span><br><span class="line">         * This value will never be used as actual SEAMCALL error code as</span><br><span class="line">         * it is from the Reserved status code class.</span><br><span class="line">         */</span><br><span class="line">        jc .Lseamcall_vmfailinvalid\@</span><br><span class="line">.else</span><br><span class="line">        tdcall</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">.if \ret</span><br><span class="line">.if \saved</span><br><span class="line">        /*</span><br><span class="line">         * Restore the structure from stack to save the output registers</span><br><span class="line">         *</span><br><span class="line">         * In case of VP.ENTER returns due to TDVMCALL, all registers are</span><br><span class="line">         * valid thus no register can be used as spare to restore the</span><br><span class="line">         * structure from the stack (see &quot;TDH.VP.ENTER Output Operands</span><br><span class="line">         * Definition on TDCALL(TDG.VP.VMCALL) Following a TD Entry&quot;).</span><br><span class="line">         * For this case, need to make one register as spare by saving it</span><br><span class="line">         * to the stack and then manually load the structure pointer to</span><br><span class="line">         * the spare register.</span><br><span class="line">         *</span><br><span class="line">         * Note for other TDCALLs/SEAMCALLs there are spare registers</span><br><span class="line">         * thus no need for such hack but just use this for all.</span><br><span class="line">         */</span><br><span class="line">        pushq        %rax                /* save the TDCALL/SEAMCALL return code */</span><br><span class="line">        movq        8(%rsp), %rax        /* restore the structure pointer */</span><br><span class="line">        movq        %rsi, TDX_MODULE_rsi(%rax)        /* save RSI */</span><br><span class="line">        popq        %rax                /* restore the return code */</span><br><span class="line">        popq        %rsi                /* pop the structure pointer */</span><br><span class="line"></span><br><span class="line">        /* Copy additional output regs to the structure  */</span><br><span class="line">        movq %r12, TDX_MODULE_r12(%rsi)</span><br><span class="line">        movq %r13, TDX_MODULE_r13(%rsi)</span><br><span class="line">        movq %r14, TDX_MODULE_r14(%rsi)</span><br><span class="line">        movq %r15, TDX_MODULE_r15(%rsi)</span><br><span class="line">        movq %rbx, TDX_MODULE_rbx(%rsi)</span><br><span class="line">        movq %rdi, TDX_MODULE_rdi(%rsi)</span><br><span class="line">.endif        /* \saved */</span><br><span class="line"></span><br><span class="line">        /* Copy output registers to the structure */</span><br><span class="line">        movq %rcx, TDX_MODULE_rcx(%rsi)</span><br><span class="line">        movq %rdx, TDX_MODULE_rdx(%rsi)</span><br><span class="line">        movq %r8,  TDX_MODULE_r8(%rsi)</span><br><span class="line">        movq %r9,  TDX_MODULE_r9(%rsi)</span><br><span class="line">        movq %r10, TDX_MODULE_r10(%rsi)</span><br><span class="line">        movq %r11, TDX_MODULE_r11(%rsi)</span><br><span class="line">.endif        /* \ret */</span><br><span class="line"></span><br><span class="line">.if \saved &amp;&amp; \ret</span><br><span class="line">        /*</span><br><span class="line">         * Clear registers shared by guest for VP.VMCALL/VP.ENTER to prevent</span><br><span class="line">         * speculative use of guest&#x27;s/VMM&#x27;s values, including those are</span><br><span class="line">         * restored from the stack.</span><br><span class="line">         *</span><br><span class="line">         * See arch/x86/kvm/vmx/vmenter.S:</span><br><span class="line">         *</span><br><span class="line">         * In theory, a L1 cache miss when restoring register from stack</span><br><span class="line">         * could lead to speculative execution with guest&#x27;s values.</span><br><span class="line">         *</span><br><span class="line">         * Note: RBP/RSP are not used as shared register.  RSI has been</span><br><span class="line">         * restored already.</span><br><span class="line">         *</span><br><span class="line">         * XOR is cheap, thus unconditionally do for all leafs.</span><br><span class="line">         */</span><br><span class="line">        xorl %ecx,  %ecx</span><br><span class="line">        xorl %edx,  %edx</span><br><span class="line">        xorl %r8d,  %r8d</span><br><span class="line">        xorl %r9d,  %r9d</span><br><span class="line">        xorl %r10d, %r10d</span><br><span class="line">        xorl %r11d, %r11d</span><br><span class="line">        xorl %r12d, %r12d</span><br><span class="line">        xorl %r13d, %r13d</span><br><span class="line">        xorl %r14d, %r14d</span><br><span class="line">        xorl %r15d, %r15d</span><br><span class="line">        xorl %ebx,  %ebx</span><br><span class="line">        xorl %edi,  %edi</span><br><span class="line">.endif        /* \ret &amp;&amp; \host */</span><br><span class="line"></span><br><span class="line">.if \host</span><br><span class="line">.Lout\@:</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">.if \saved</span><br><span class="line">        /* Restore callee-saved GPRs as mandated by the x86_64 ABI */</span><br><span class="line">        popq        %r15</span><br><span class="line">        popq        %r14</span><br><span class="line">        popq        %r13</span><br><span class="line">        popq        %r12</span><br><span class="line">        popq        %rbx</span><br><span class="line">.endif        /* \saved */</span><br><span class="line"></span><br><span class="line">        FRAME_END</span><br><span class="line">        RET</span><br><span class="line"></span><br><span class="line">.if \host</span><br><span class="line">.Lseamcall_vmfailinvalid\@:</span><br><span class="line">        mov $TDX_SEAMCALL_VMFAILINVALID, %rax</span><br><span class="line">        jmp .Lseamcall_fail\@</span><br><span class="line"></span><br><span class="line">.Lseamcall_trap\@:</span><br><span class="line">        /*</span><br><span class="line">         * SEAMCALL caused #GP or #UD.  By reaching here RAX contains</span><br><span class="line">         * the trap number.  Convert the trap number to the TDX error</span><br><span class="line">         * code by setting TDX_SW_ERROR to the high 32-bits of RAX.</span><br><span class="line">         *</span><br><span class="line">         * Note cannot OR TDX_SW_ERROR directly to RAX as OR instruction</span><br><span class="line">         * only accepts 32-bit immediate at most.</span><br><span class="line">         */</span><br><span class="line">        movq $TDX_SW_ERROR, %rdi</span><br><span class="line">        orq  %rdi, %rax</span><br><span class="line"></span><br><span class="line">.Lseamcall_fail\@:</span><br><span class="line">.if \ret &amp;&amp; \saved</span><br><span class="line">        /* pop the unused structure pointer back to RSI */</span><br><span class="line">        popq %rsi</span><br><span class="line">.endif</span><br><span class="line">        jmp .Lout\@</span><br><span class="line"></span><br><span class="line">        _ASM_EXTABLE_FAULT(.Lseamcall\@, .Lseamcall_trap\@)</span><br><span class="line">.endif        /* \host */</span><br><span class="line"></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<p>Tdx module:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl tdx_seamcall_entry_point</span><br><span class="line">.type  tdx_seamcall_entry_point,@function</span><br><span class="line">tdx_seamcall_entry_point:</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Save all VMM GPRs on module entry to LP local data</span><br><span class="line">     * Local data is located at GSBASE</span><br><span class="line">     */</span><br><span class="line">    movq %rax,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET</span><br><span class="line">    movq %rcx,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+8</span><br><span class="line">    movq %rdx,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+16</span><br><span class="line">    movq %rbx,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+24</span><br><span class="line">    movq %rsp,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+32 // not actually needed</span><br><span class="line">    movq %rbp,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+40</span><br><span class="line">    movq %rsi,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+48</span><br><span class="line">    movq %rdi,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+56</span><br><span class="line">    movq %r8,   %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+64</span><br><span class="line">    movq %r9,   %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+72</span><br><span class="line">    movq %r10,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+80</span><br><span class="line">    movq %r11,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+88</span><br><span class="line">    movq %r12,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+96</span><br><span class="line">    movq %r13,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+104</span><br><span class="line">    movq %r14,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+112</span><br><span class="line">    movq %r15,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+120</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * clear VMM GPRs on entry to the TDX module</span><br><span class="line">         */</span><br><span class="line">    xor %rax, %rax</span><br><span class="line">    xor %rcx, %rcx</span><br><span class="line">    xor %rdx, %rdx</span><br><span class="line">    xor %rbx, %rbx</span><br><span class="line">    xor %rbp, %rbp</span><br><span class="line">    xor %rsi, %rsi</span><br><span class="line">    xor %rdi, %rdi</span><br><span class="line">    xor %r8, %r8</span><br><span class="line">    xor %r9, %r9</span><br><span class="line">    xor %r10, %r10</span><br><span class="line">    xor %r11, %r11</span><br><span class="line">    xor %r12, %r12</span><br><span class="line">    xor %r13, %r13</span><br><span class="line">    xor %r14, %r14</span><br><span class="line">    xor %r15, %r15</span><br><span class="line"></span><br><span class="line">    // Protection against speculative attacks on GPRs</span><br><span class="line">    lfence</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Call the VMM API dispatcher</span><br><span class="line">     */</span><br><span class="line">     callq tdx_vmm_dispatcher</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Dispatcher should not retrun to this code</span><br><span class="line">     * It returns to the VMM using SEAMRET</span><br><span class="line">     * Panic with UD2 if reached</span><br><span class="line">     */</span><br><span class="line">    ud2</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tdx_vmm_dispatcher</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Must be first thing to do before accessing local/global data or sysinfo table</span></span><br><span class="line">    <span class="type">tdx_module_local_t</span>* local_data = init_data_fast_ref_ptrs();</span><br><span class="line">        _STATIC_INLINE_ <span class="type">tdx_module_local_t</span>* <span class="title function_">init_data_fast_ref_ptrs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">tdx_module_local_t</span>* local_data = calculate_local_data();</span><br><span class="line">                    <span class="comment">// In SEAM TDX module, GSBASE holds a pointer to the local data of current thread</span></span><br><span class="line">                    <span class="comment">// We are reading GSBASE by loading effective address of 0 with GS prefix</span></span><br><span class="line">                    _STATIC_INLINE_ <span class="type">tdx_module_local_t</span>* <span class="title function_">calculate_local_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">void</span>* local_data_addr;</span><br><span class="line">                        _ASM_VOLATILE_ (<span class="string">&quot;rdgsbase %0&quot;</span></span><br><span class="line">                                        :<span class="string">&quot;=r&quot;</span>(local_data_addr)</span><br><span class="line">                                        :</span><br><span class="line">                                        :<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">return</span> (<span class="type">tdx_module_local_t</span>*)local_data_addr;</span><br><span class="line">                    &#125;</span><br><span class="line">            IF_RARE (!local_data-&gt;local_data_fast_ref_ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                local_data-&gt;local_data_fast_ref_ptr  = local_data;</span><br><span class="line">                local_data-&gt;sysinfo_fast_ref_ptr     = calculate_sysinfo_table();</span><br><span class="line">                local_data-&gt;global_data_fast_ref_ptr = calculate_global_data((<span class="type">sysinfo_table_t</span>*)</span><br><span class="line">                                                            local_data-&gt;sysinfo_fast_ref_ptr);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> local_data;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        leaf_opcode.raw = local_data-&gt;vmm_regs.rax;</span><br><span class="line">                    <span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">gprs_state_u</span></span></span><br><span class="line"><span class="class">                    &#123;</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                        &#123;</span></span><br><span class="line">                            <span class="type">uint64_t</span> rax;</span><br><span class="line">                            <span class="type">uint64_t</span> rcx;</span><br><span class="line">                            <span class="type">uint64_t</span> rdx;</span><br><span class="line">                            <span class="type">uint64_t</span> rbx;</span><br><span class="line">                            <span class="type">uint64_t</span> rsp;</span><br><span class="line">                            <span class="type">uint64_t</span> rbp;</span><br><span class="line">                            <span class="type">uint64_t</span> rsi;</span><br><span class="line">                            <span class="type">uint64_t</span> rdi;</span><br><span class="line">                            <span class="type">uint64_t</span> r8;</span><br><span class="line">                            <span class="type">uint64_t</span> r9;</span><br><span class="line">                            <span class="type">uint64_t</span> r10;</span><br><span class="line">                            <span class="type">uint64_t</span> r11;</span><br><span class="line">                            <span class="type">uint64_t</span> r12;</span><br><span class="line">                            <span class="type">uint64_t</span> r13;</span><br><span class="line">                            <span class="type">uint64_t</span> r14;</span><br><span class="line">                            <span class="type">uint64_t</span> r15;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    </span><br><span class="line">                        <span class="type">uint64_t</span> gprs[<span class="number">16</span>];</span><br><span class="line">                    &#125; <span class="type">gprs_state_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br></pre></td><td class="code"><pre><span class="line">api_error_type <span class="title function_">tdh_vp_enter</span><span class="params">(<span class="type">uint64_t</span> vcpu_handle_and_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Local data for return values and global data</span></span><br><span class="line">    <span class="type">tdx_module_local_t</span>  * local_data_ptr = get_local_data();</span><br><span class="line">    <span class="type">tdx_module_global_t</span> * global_data_ptr = get_global_data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TDVPR related variables</span></span><br><span class="line">    <span class="type">pa_t</span>                  tdvpr_pa;                    <span class="comment">// TDVPR physical address</span></span><br><span class="line">    <span class="type">tdvps_t</span>             * tdvps_ptr = <span class="literal">NULL</span>;            <span class="comment">// Pointer to the TDVPS (multi-page linear address)</span></span><br><span class="line">    <span class="type">pamt_block_t</span>          tdvpr_pamt_block;            <span class="comment">// TDVPR PAMT block</span></span><br><span class="line">    <span class="type">pamt_entry_t</span>        * tdvpr_pamt_entry_ptr;        <span class="comment">// Pointer to the TDVPR PAMT entry</span></span><br><span class="line">    <span class="type">bool_t</span>                tdvpr_locked_flag = <span class="literal">false</span>;   <span class="comment">// Indicate TDVPR is locked</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TDR related variables</span></span><br><span class="line">    <span class="type">pa_t</span>                  tdr_pa;                      <span class="comment">// TDR physical address</span></span><br><span class="line">    <span class="type">tdr_t</span>               * tdr_ptr;                     <span class="comment">// Pointer to the TDR page (linear address)</span></span><br><span class="line">    <span class="type">pamt_entry_t</span>        * tdr_pamt_entry_ptr;          <span class="comment">// Pointer to the TDR PAMT entry</span></span><br><span class="line">    <span class="type">bool_t</span>                tdr_locked_flag = <span class="literal">false</span>;     <span class="comment">// Indicate TDVPR is locked</span></span><br><span class="line"></span><br><span class="line">    <span class="type">tdcs_t</span>              * tdcs_ptr = <span class="literal">NULL</span>;             <span class="comment">// Pointer to the TDCS page (linear address)</span></span><br><span class="line">    <span class="type">bool_t</span>                op_state_locked_flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span>              td_hkid;</span><br><span class="line">    <span class="type">tdvmcall_control_t</span>    control;</span><br><span class="line">    <span class="type">bool_t</span>                td_vmcs_loaded = <span class="literal">false</span>;      <span class="comment">// Indicates whether TD VMCS was loaded</span></span><br><span class="line">    <span class="type">vcpu_and_flags_t</span>      vcpu_and_flags = &#123; .raw = vcpu_handle_and_flags &#125;;</span><br><span class="line">    <span class="type">bool_t</span>                is_sept_locked = <span class="literal">false</span>;</span><br><span class="line">    api_error_type        return_val = UNINITIALIZE_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="type">ia32_misc_enable_t</span> misc_enable = &#123; .raw = ia32_rdmsr(IA32_MISC_ENABLES_MSR_ADDR) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Boot NT4 bit should not be set</span></span><br><span class="line">    <span class="keyword">if</span> (misc_enable.boot_nt4)</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = TDX_LIMIT_CPUID_MAXVAL_SET;</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vcpu_and_flags.reserved_0 || vcpu_and_flags.reserved_1)</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = api_error_with_operand_id(TDX_OPERAND_INVALID, OPERAND_ID_RCX);</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Input VCPU handle and flags has reserved bits sets - 0x%llx\n&quot;</span>, vcpu_and_flags.raw);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tdvpr_pa.raw = <span class="number">0</span>;</span><br><span class="line">    tdvpr_pa.page_4k_num = vcpu_and_flags.tdvpra_hpa_51_12;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check and lock the TDVPR page</span></span><br><span class="line">    return_val = check_and_lock_explicit_4k_private_hpa(tdvpr_pa,</span><br><span class="line">                                                         OPERAND_ID_RCX,</span><br><span class="line">                                                         TDX_LOCK_SHARED,</span><br><span class="line">                                                         PT_TDVPR,</span><br><span class="line">                                                         &amp;tdvpr_pamt_block,</span><br><span class="line">                                                         &amp;tdvpr_pamt_entry_ptr,</span><br><span class="line">                                                         &amp;tdvpr_locked_flag);</span><br><span class="line"></span><br><span class="line">    IF_RARE (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to check/lock a TDVPR (0x%llx) - error = %llx\n&quot;</span>, tdvpr_pa.raw, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get and lock the owner TDR page</span></span><br><span class="line">    <span class="comment">// TDR is mapped in static keyhole range, and thus doesn&#x27;t need to be freed</span></span><br><span class="line">    tdr_pa = get_pamt_entry_owner(tdvpr_pamt_entry_ptr);</span><br><span class="line">    return_val = lock_and_map_implicit_tdr(tdr_pa,</span><br><span class="line">                                           OPERAND_ID_TDR,</span><br><span class="line">                                           TDX_RANGE_RW,</span><br><span class="line">                                           TDX_LOCK_SHARED,</span><br><span class="line">                                           &amp;tdr_pamt_entry_ptr,</span><br><span class="line">                                           &amp;tdr_locked_flag,</span><br><span class="line">                                           &amp;tdr_ptr);</span><br><span class="line">                              api_error_type <span class="title function_">lock_and_map_implicit_tdr</span><span class="params">(</span></span><br><span class="line"><span class="params">                                    <span class="type">pa_t</span> tdr_pa,</span></span><br><span class="line"><span class="params">                                    <span class="type">uint64_t</span> operand_id,</span></span><br><span class="line"><span class="params">                                    <span class="type">mapping_type_t</span> mapping_type,</span></span><br><span class="line"><span class="params">                                    <span class="type">lock_type_t</span> lock_type,</span></span><br><span class="line"><span class="params">                                    <span class="type">pamt_entry_t</span>** pamt_entry,</span></span><br><span class="line"><span class="params">                                    <span class="type">bool_t</span>* is_locked,</span></span><br><span class="line"><span class="params">                                    <span class="type">tdr_t</span>** tdr_p</span></span><br><span class="line"><span class="params">                                    )</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                api_error_code_e errc = pamt_implicit_get_and_lock(tdr_pa, PT_4KB, lock_type, pamt_entry);</span><br><span class="line">                                            api_error_code_e <span class="title function_">pamt_implicit_get_and_lock</span><span class="params">(<span class="type">pa_t</span> pa, <span class="type">page_size_t</span> leaf_size, <span class="type">lock_type_t</span> leaf_lock_type,</span></span><br><span class="line"><span class="params">                                                            <span class="type">pamt_entry_t</span>** pamt_entry)</span></span><br><span class="line">                                            &#123;</span><br><span class="line">                                                api_error_code_e errc;</span><br><span class="line">                                                <span class="type">pamt_entry_t</span>* tmp_pamt_entry = pamt_implicit_get(pa, leaf_size);</span><br><span class="line">                                            </span><br><span class="line">                                                <span class="keyword">if</span> ((errc = acquire_sharex_lock_hp(&amp;tmp_pamt_entry-&gt;entry_lock, leaf_lock_type, <span class="literal">false</span>)) != TDX_SUCCESS)</span><br><span class="line">                                                &#123;</span><br><span class="line">                                                    free_la(tmp_pamt_entry);</span><br><span class="line">                                                    *pamt_entry = <span class="literal">NULL</span>;</span><br><span class="line">                                                    <span class="keyword">return</span> errc;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            </span><br><span class="line">                                                *pamt_entry = tmp_pamt_entry;</span><br><span class="line">                                                <span class="keyword">return</span> TDX_SUCCESS;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                <span class="keyword">if</span> (errc != TDX_SUCCESS)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    TDX_ERROR(<span class="string">&quot;get_implicit_page_pamt_and_lock error\n&quot;</span>);</span><br><span class="line">                                    <span class="keyword">return</span> api_error_with_operand_id(errc, operand_id);</span><br><span class="line">                                &#125;</span><br><span class="line">                            </span><br><span class="line">                                *is_locked = <span class="literal">true</span>;</span><br><span class="line">                            </span><br><span class="line">                                <span class="type">uint16_t</span> hkid = get_global_data()-&gt;hkid;</span><br><span class="line">                                tdr_pa = set_hkid_to_pa(tdr_pa, hkid);</span><br><span class="line">                            </span><br><span class="line">                                <span class="type">uint64_t</span> tdr_addr = tdr_pa.full_pa;</span><br><span class="line">                            </span><br><span class="line">                                *tdr_p = map_continuous_pages(&amp;tdr_addr, <span class="number">1</span>, mapping_type, STATIC_KEYHOLE_IDX_TDR);</span><br><span class="line">                            </span><br><span class="line">                                <span class="keyword">return</span> TDX_SUCCESS;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">    IF_RARE (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to lock/map a TDR - error = %lld\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map the TDCS structure and check the state</span></span><br><span class="line">    return_val = check_state_map_tdcs_and_lock(tdr_ptr, TDX_RANGE_RW, TDX_LOCK_SHARED,</span><br><span class="line">                                               <span class="literal">false</span>, TDH_VP_ENTER_LEAF, &amp;tdcs_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;State check or TDCS lock failure - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    op_state_locked_flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the TD&#x27;s ephemeral HKID</span></span><br><span class="line">    td_hkid = tdr_ptr-&gt;key_management_fields.hkid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map the TDVPS structure</span></span><br><span class="line">    <span class="comment">// TDVPS is mapped in static keyhole range, and thus doesn&#x27;t need to be freed</span></span><br><span class="line">    tdvps_ptr = map_tdvps(tdvpr_pa, td_hkid, tdcs_ptr-&gt;management_fields.num_l2_vms, TDX_RANGE_RW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdvps_ptr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;TDVPS mapping failed\n&quot;</span>);</span><br><span class="line">        return_val = TDX_TDCX_NUM_INCORRECT;</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Associate the VCPU</span></span><br><span class="line">    <span class="type">bool_t</span> new_associate_flag = <span class="literal">false</span>;</span><br><span class="line">    return_val = check_and_associate_vcpu(tdvps_ptr, tdcs_ptr, &amp;new_associate_flag, <span class="literal">false</span>);</span><br><span class="line">                api_error_code_e <span class="title function_">check_and_associate_vcpu</span><span class="params">(<span class="type">tdvps_t</span> * tdvps_ptr,</span></span><br><span class="line"><span class="params">                                              <span class="type">tdcs_t</span> * tdcs_ptr,</span></span><br><span class="line"><span class="params">                                              <span class="type">bool_t</span>* new_association,</span></span><br><span class="line"><span class="params">                                                          <span class="type">bool_t</span> allow_disabled)</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">uint8_t</span> curr_vcpu_state = tdvps_ptr-&gt;management.state;</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *  Check the VCPU state to make sure it has been initialized and is not</span></span><br><span class="line"><span class="comment">                     *  being torn down.  This may race with state changes if the VCPU is</span></span><br><span class="line"><span class="comment">                     *  associated with another LP.  In this case the subsequent association</span></span><br><span class="line"><span class="comment">                     *  below will fail</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (!((curr_vcpu_state == VCPU_READY) ||</span><br><span class="line">                          ((curr_vcpu_state == VCPU_DISABLED) &amp;&amp; allow_disabled)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> TDX_VCPU_STATE_INCORRECT;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">return</span> associate_vcpu(tdvps_ptr, tdcs_ptr, new_association);</span><br><span class="line">                                                    api_error_code_e <span class="title function_">associate_vcpu</span><span class="params">(<span class="type">tdvps_t</span> * tdvps_ptr,</span></span><br><span class="line"><span class="params">                                                                <span class="type">tdcs_t</span> * tdcs_ptr,</span></span><br><span class="line"><span class="params">                                                                <span class="type">bool_t</span>* new_association)</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                            <span class="type">uint32_t</span>         prev_assoc_lpid;  <span class="comment">// Previous associated LPID</span></span><br><span class="line">                                            <span class="type">uint32_t</span>         curr_lp_id = get_local_data()-&gt;lp_info.lp_id;</span><br><span class="line">                                        </span><br><span class="line">                                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                             *  Atomically check that this VCPU is not associated with any LP, and</span></span><br><span class="line"><span class="comment">                                             *  associate it with the current LP.  The VCPU may already be associated</span></span><br><span class="line"><span class="comment">                                             *  with the current LP, but if it&#x27;s associated with another LP this is</span></span><br><span class="line"><span class="comment">                                             *  an error.</span></span><br><span class="line"><span class="comment">                                             */</span></span><br><span class="line">                                            prev_assoc_lpid = _lock_cmpxchg_32b(VCPU_NO_LP, <span class="comment">// Expected value: no lp</span></span><br><span class="line">                                                                                curr_lp_id,  <span class="comment">// New Value</span></span><br><span class="line">                                                                                &amp;tdvps_ptr-&gt;management.assoc_lpid); <span class="comment">// Target</span></span><br><span class="line">                                            <span class="keyword">if</span> ((prev_assoc_lpid != VCPU_NO_LP) &amp;&amp; (prev_assoc_lpid != curr_lp_id))</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="keyword">return</span> TDX_VCPU_ASSOCIATED;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        </span><br><span class="line">                                            <span class="comment">// Association succeeded.  VCPU state must be VCPU_READY_*</span></span><br><span class="line">                                        </span><br><span class="line">                                            <span class="comment">// Set ACTIVE_VMCS to -1 to indicate the need for VMPTRLD</span></span><br><span class="line">                                            get_local_data()-&gt;vp_ctx.active_vmcs = ACTIVE_VMCS_NONE;</span><br><span class="line">                                        </span><br><span class="line">                                            <span class="type">uint64_t</span> seamdb_index = get_global_data()-&gt;seamdb_index;</span><br><span class="line">                                            <span class="keyword">if</span> (tdvps_ptr-&gt;management.last_seamdb_index != seamdb_index)</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="comment">// The TDX module has been updated since the last time this VCPU was associated.</span></span><br><span class="line">                                                <span class="comment">// The VCPU remains associated with the current LP.</span></span><br><span class="line">                                                clear_module_host_state_flags(tdvps_ptr);</span><br><span class="line">                                                clear_lp_host_state_flags(tdvps_ptr);</span><br><span class="line">                                                tdvps_ptr-&gt;management.last_seamdb_index = seamdb_index;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        </span><br><span class="line">                                            <span class="comment">// If this is a new association, update TD VMCS</span></span><br><span class="line">                                            <span class="keyword">if</span> (prev_assoc_lpid == VCPU_NO_LP)</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="comment">// The current VCPU is associated with a new LP</span></span><br><span class="line">                                        </span><br><span class="line">                                                clear_lp_host_state_flags(tdvps_ptr);</span><br><span class="line">                                        </span><br><span class="line">                                                <span class="comment">// Atomically increment the number of associated VCPUs</span></span><br><span class="line">                                                (<span class="type">void</span>)_lock_xadd_32b(&amp;(tdcs_ptr-&gt;management_fields.num_assoc_vcpus), <span class="number">1</span>);</span><br><span class="line">                                        </span><br><span class="line">                                                *new_association = <span class="literal">true</span>;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                            <span class="keyword">else</span></span><br><span class="line">                                            &#123;</span><br><span class="line">                                                *new_association = <span class="literal">false</span>;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        </span><br><span class="line">                                            <span class="keyword">return</span> TDX_SUCCESS;</span><br><span class="line">                                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">    IF_RARE (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to associate VCPU - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_vm_vmcs_as_active(tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class="line">    td_vmcs_loaded = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((vcpu_and_flags.host_recoverability_hint) &amp;&amp; (tdvps_ptr-&gt;management.last_td_exit != LAST_EXIT_ASYNC_TRAP))</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = api_error_with_operand_id(TDX_OPERAND_INVALID, OPERAND_ID_RCX);</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Host recoverability is set, but last exit wasn&#x27;t ASYNC_TRAP - %d\n&quot;</span>, tdvps_ptr-&gt;management.last_td_exit);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vcpu_and_flags.resume_l1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resume to L1 is only supported on exit from L2</span></span><br><span class="line">        <span class="keyword">if</span> (tdvps_ptr-&gt;management.curr_vm == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            return_val = api_error_with_operand_id(TDX_OPERAND_INVALID, OPERAND_ID_RCX);</span><br><span class="line">            TDX_ERROR(<span class="string">&quot;Resume to L1 is only supported on exit from L2\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RESUME_L1 is sticky; the internal flag is cleared later, only if actual L1 entry happens</span></span><br><span class="line">        set_l2_exit_host_routing(tdvps_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We read TSC below.  Compare IA32_TSC_ADJUST to the value sampled on TDHSYSINIT</span></span><br><span class="line">    <span class="comment">// to make sure the host VMM doesn&#x27;t play any trick on us.</span></span><br><span class="line">    IF_RARE (ia32_rdmsr(IA32_TSC_ADJ_MSR_ADDR) != global_data_ptr-&gt;plt_common_config.ia32_tsc_adjust)</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = api_error_with_operand_id(TDX_INCONSISTENT_MSR, IA32_TSC_ADJ_MSR_ADDR);</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Inconsistent IA32_TSC_ADJUST MSR!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read TSC and verify that it is higher than LAST_EXIT_TSC.</span></span><br><span class="line">    <span class="comment">// Do the calculation as signed 64b, works even if TSC rolls over.</span></span><br><span class="line">    IF_RARE (((<span class="type">int64_t</span>)(ia32_rdtsc() - tdvps_ptr-&gt;management.last_exit_tsc)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = TDX_TSC_ROLLBACK;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;TSC is lower than LAST_EXIT_TSC!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If MONITOR/MWAIT support is enabled, then MONITOR_FSM must be enabled</span></span><br><span class="line">    <span class="keyword">if</span> (tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.monitor_mwait_supported &amp;&amp;</span><br><span class="line">        !misc_enable.enable_monitor_fsm)</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = api_error_with_operand_id(TDX_INCORRECT_MSR_VALUE, IA32_MISC_ENABLES_MSR_ADDR);</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;If MONITOR/MWAIT support is enabled, then MONITOR_FSM must be enabled\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save the VMM value of IA32_DS_AREA</span></span><br><span class="line">    local_data_ptr-&gt;vmm_non_extended_state.ia32_ds_area = ia32_rdmsr(IA32_DS_AREA_MSR_ADDR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the TLB tracking state. This is done as a critical section,</span></span><br><span class="line">    <span class="comment">// allowing concurrent TDHVPENTERs, but no concurrent TDHMEMTRACK</span></span><br><span class="line">    IF_RARE (!adjust_tlb_tracking_state(tdr_ptr, tdcs_ptr, tdvps_ptr, new_associate_flag))</span><br><span class="line">    &#123;</span><br><span class="line">                        <span class="type">bool_t</span> <span class="title function_">adjust_tlb_tracking_state</span><span class="params">(<span class="type">tdr_t</span>* tdr_ptr, <span class="type">tdcs_t</span>* tdcs_ptr, <span class="type">tdvps_t</span>* tdvps_ptr,</span></span><br><span class="line"><span class="params">                                                     <span class="type">bool_t</span> new_association)</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">tdcs_epoch_tracking_fields_t</span>* epoch_tracking = &amp;tdcs_ptr-&gt;epoch_tracking;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Lock the TD epoch</span></span><br><span class="line">                        <span class="keyword">if</span> (acquire_sharex_lock_sh(&amp;epoch_tracking-&gt;epoch_lock) != LOCK_RET_SUCCESS)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Sample the TD epoch and atomically increment the REFCOUNT</span></span><br><span class="line">                        <span class="type">uint64_t</span> vcpu_epoch = epoch_tracking-&gt;epoch_and_refcount.td_epoch;</span><br><span class="line">                        (<span class="type">void</span>)_lock_xadd_16b(&amp;epoch_tracking-&gt;epoch_and_refcount.refcount[vcpu_epoch &amp; <span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// End of critical section, release lock.</span></span><br><span class="line">                        release_sharex_lock_sh(&amp;epoch_tracking-&gt;epoch_lock);</span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">if</span> (vcpu_epoch != tdvps_ptr-&gt;management.vcpu_epoch)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!new_association)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                 *  The current VCPU was already associated with the current LP at the</span></span><br><span class="line"><span class="comment">                                 *  beginning of TDHVPENTER.</span></span><br><span class="line"><span class="comment">                                 *  Flush the TLB context and extended paging structure (EPxE) caches</span></span><br><span class="line"><span class="comment">                                 *  associated with the current TD.</span></span><br><span class="line"><span class="comment">                                 *  Else, no need to flush, since this LP is guaranteed not to hold any</span></span><br><span class="line"><span class="comment">                                 *  address translation for this VCPU</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                                <span class="comment">// Execute INVEPT type 1 for each Secure EPT</span></span><br><span class="line">                                flush_all_td_asids(tdr_ptr, tdcs_ptr);</span><br><span class="line">                    </span><br><span class="line">                                <span class="comment">// Invalidate all soft-translated GPAs</span></span><br><span class="line">                                invalidate_all_gpa_translations(tdcs_ptr, tdvps_ptr);</span><br><span class="line">                            &#125;</span><br><span class="line">                    </span><br><span class="line">                            <span class="comment">// Store the sampled value of TD_EPOCH as the new value of VCPU_EPOCH</span></span><br><span class="line">                            tdvps_ptr-&gt;management.vcpu_epoch = vcpu_epoch;</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to acquire global lock for TD epoch\n&quot;</span>);</span><br><span class="line">        return_val = api_error_with_operand_id(TDX_OPERAND_BUSY, OPERAND_ID_TD_EPOCH);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stepping_filter_e filter_result = FILTER_OK_CONTINUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sample current VMCS state for handling stepping filter FILTER_OK_NOTIFY_EPS_FAULT case</span></span><br><span class="line">    <span class="type">vm_vmexit_exit_reason_t</span> exit_reason;</span><br><span class="line">    <span class="type">vmx_exit_qualification_t</span> exit_qualification;</span><br><span class="line">    <span class="type">pa_t</span> faulting_gpa;</span><br><span class="line"></span><br><span class="line">    ia32_vmread(VMX_VM_EXIT_REASON_ENCODE, &amp;exit_reason.raw);</span><br><span class="line">    ia32_vmread(VMX_VM_EXIT_QUALIFICATION_ENCODE, &amp;exit_qualification.raw);</span><br><span class="line">    ia32_vmread(VMX_GUEST_PHYSICAL_ADDRESS_INFO_FULL_ENCODE, &amp;faulting_gpa.raw);</span><br><span class="line"></span><br><span class="line">    IF_RARE ((return_val = handle_stepping_filter(tdr_ptr, tdcs_ptr, tdvps_ptr, exit_reason, &amp;faulting_gpa,</span><br><span class="line">                                                  &amp;is_sept_locked, &amp;filter_result)) != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed handling stepping filter - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdvps_ptr-&gt;management.curr_vm != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = handle_l2_entry(tdr_ptr, tdcs_ptr, tdvps_ptr,</span><br><span class="line">                                           &amp;exit_reason, &amp;exit_qualification, &amp;faulting_gpa);</span><br><span class="line"></span><br><span class="line">        IF_RARE (return_val != TDX_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            TDX_ERROR(<span class="string">&quot;Failed to handle L2 entry\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the stepping filter above indicated a #VE injection, inject it now to the L1 VMM</span></span><br><span class="line">    <span class="comment">// being entered, with the values sampled above from the VMCS of the VM that previously exited.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((filter_result == FILTER_OK_NOTIFY_EPS_FAULT) &amp;&amp; can_inject_epf_ve(exit_qualification, tdvps_ptr))</span><br><span class="line">    &#123;</span><br><span class="line">        tdx_debug_assert(tdvps_ptr-&gt;management.curr_vm == <span class="number">0</span>);</span><br><span class="line">        tdx_inject_ve((<span class="type">uint32_t</span>)exit_reason.raw, exit_qualification.raw, tdvps_ptr, faulting_gpa.raw, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*-------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    At this point we&#x27;re at the VM to be entered - if there was an L2-&gt;L1 virtual exit</span></span><br><span class="line"><span class="comment">    then the state of L1 is after the L2-&gt;L1 exit.</span></span><br><span class="line"><span class="comment">    If the stepping filter above indicated too many EPT violations on private GPA,</span></span><br><span class="line"><span class="comment">    emulate an EPT violation TD exit; do not do an actual VM entry so the VM is not</span></span><br><span class="line"><span class="comment">    exposed to the 0-step attack.</span></span><br><span class="line"><span class="comment">    -------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filter_result == FILTER_FAIL_TDENTER_EPFS)</span><br><span class="line">    &#123;</span><br><span class="line">        tdx_debug_assert(is_sept_locked == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// decrement the TLB tracker that was incremented at the beginning of TDENTER</span></span><br><span class="line">        revert_tlb_tracking_state(tdcs_ptr, tdvps_ptr);</span><br><span class="line"></span><br><span class="line">        emulate_ept_violation_td_exit(get_local_data(), faulting_gpa, tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class="line"></span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Too many EPT violation on private GPA - 0x%llx\n&quot;</span>, faulting_gpa.raw);</span><br><span class="line">        return_val = VMEXIT_REASON_EPT_VIOLATION;</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translate soft-translated GPAs, if required</span></span><br><span class="line">    <span class="keyword">if</span> ((tdvps_ptr-&gt;management.curr_vm != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        !translate_gpas(tdr_ptr, tdcs_ptr, tdvps_ptr, tdvps_ptr-&gt;management.curr_vm, &amp;faulting_gpa.raw))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// decrement the TLB tracker that was incremented at the beginning of TDENTER</span></span><br><span class="line">        revert_tlb_tracking_state(tdcs_ptr, tdvps_ptr);</span><br><span class="line"></span><br><span class="line">        emulate_ept_violation_td_exit(get_local_data(), faulting_gpa, tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;EPT violation due GPA (0x%llx) translation\n&quot;</span>, faulting_gpa.raw);</span><br><span class="line"></span><br><span class="line">        return_val = VMEXIT_REASON_EPT_VIOLATION;</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALL CHECKS PASSED:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* OP_STATE has been locked in a temporary mode; it is released before</span></span><br><span class="line"><span class="comment">       entering non-root mode. */</span></span><br><span class="line">    tdx_debug_assert(op_state_locked_flag);</span><br><span class="line">    release_sharex_lock_hp_sh(&amp;(tdcs_ptr-&gt;management_fields.op_state_lock));</span><br><span class="line">    op_state_locked_flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the current VCPU to be executed on this LP is not the same as the last one,</span></span><br><span class="line">    <span class="comment">// issue an indirect branch prediction barrier (IBPB) command</span></span><br><span class="line">    <span class="keyword">if</span> (tdvpr_pa.raw != local_data_ptr-&gt;vp_ctx.last_tdvpr_pa.raw)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The TD ASID (Address Space Identifier) does not distinguish between different VCPUs of the same TD.</span></span><br><span class="line">        <span class="comment">// Therefore, when switching VCPU of the same TD on the same LP we should invalidate EPT.</span></span><br><span class="line">        <span class="comment">// Practically, we do this on every VCPU switch (even not of the same TD).</span></span><br><span class="line">        <span class="comment">// This is because it is difficult to track the history of TD execution on an LP</span></span><br><span class="line">        <span class="comment">// (i.e., we should check for every TD/VCPU combination in the past).</span></span><br><span class="line">        flush_all_td_asids(tdr_ptr, tdcs_ptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Issue an indirect branch prediction barrier (IBPB) command, since the CPU does not</span></span><br><span class="line">        <span class="comment">// distinguish between VCPUs for its branch prediction.</span></span><br><span class="line">        <span class="type">ia32_pred_cmd_t</span> pred_cmd = &#123; .raw = <span class="number">0</span> &#125;;</span><br><span class="line">        pred_cmd.ibpb = <span class="number">1</span>;</span><br><span class="line">        ia32_wrmsr(IA32_PRED_CMD_MSR_ADDR, pred_cmd.raw);</span><br><span class="line">        local_data_ptr-&gt;vp_ctx.last_tdvpr_pa.raw = tdvpr_pa.raw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save the TDR, TDCS and TDVPS linear pointers for use after every VM exit</span></span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdr               = tdr_ptr;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdr_pamt_entry    = tdr_pamt_entry_ptr;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdr_pa            = tdr_pa;</span><br><span class="line"></span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdvps             = tdvps_ptr;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdvpr_pamt_entry  = tdvpr_pamt_entry_ptr;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdvpr_pamt_block  = tdvpr_pamt_block;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdvpr_pa          = tdvpr_pa;</span><br><span class="line"></span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdcs              = tdcs_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save some other TD state to avoid accessing TDCS and TDVPS in case of a</span></span><br><span class="line">    <span class="comment">// memory integrity error</span></span><br><span class="line">    local_data_ptr-&gt;vp_ctx.attributes = tdcs_ptr-&gt;executions_ctl_fields.attributes;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.xfam = tdvps_ptr-&gt;management.xfam;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.xfd_supported = tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.xfd_supported;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.ia32_perf_global_status = tdvps_ptr-&gt;guest_msr_state.ia32_perf_global_status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore Guest Extended State</span></span><br><span class="line">    <span class="keyword">if</span> (tdvps_ptr-&gt;management.last_td_exit == LAST_EXIT_TDVMCALL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Last TD exit was a TDGVPVMCALL. GPR and XMM state passed from the host</span></span><br><span class="line">        <span class="comment">// VMM to the guest TD are selected by guest RCX, saved by TDGVPVMCALL.</span></span><br><span class="line">        control.raw = tdvps_ptr-&gt;guest_state.gpr_state.rcx;</span><br><span class="line"></span><br><span class="line">        save_regs_after_tdvmcall(tdvps_ptr, control, tdvps_ptr-&gt;guest_state.gpr_state.gprs);</span><br><span class="line">                <span class="type">static</span> <span class="type">void</span> <span class="title function_">save_regs_after_tdvmcall</span><span class="params">(<span class="type">tdvps_t</span>* tdvps_ptr, <span class="type">tdvmcall_control_t</span> control, </span></span><br><span class="line"><span class="params">                    <span class="type">uint64_t</span> gprs[<span class="number">16</span>])</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">uint64_t</span> mask;</span><br><span class="line">                    <span class="type">uint32_t</span> i;</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">/* Save XMM registers selected by guest RCX to TDVPS.</span></span><br><span class="line"><span class="comment">                     * Later on the whole state of XMMs, MXCSR and optionally YMMs and ZMMs is</span></span><br><span class="line"><span class="comment">                     * restored from TDVPS.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    save_xmms_by_mask(tdvps_ptr, control.xmm_select);</span><br><span class="line">                                <span class="type">static</span> <span class="type">void</span> <span class="title function_">save_xmms_by_mask</span><span class="params">(<span class="type">tdvps_t</span>* tdvps_ptr, <span class="type">uint16_t</span> xmm_select)</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="type">uint128_t</span> xmms[<span class="number">16</span>];</span><br><span class="line">                            </span><br><span class="line">                                store_xmms_in_buffer(xmms);</span><br><span class="line">                            </span><br><span class="line">                                <span class="comment">// Copy the required VMM XMM&#x27;s to the guest XMM&#x27;s</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (xmm_select &amp; (<span class="type">uint16_t</span>)BIT(i))</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        tdvps_ptr-&gt;guest_extension_state.xbuf.legacy_region.xmm[i] = xmms[i];</span><br><span class="line">                            </span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            </span><br><span class="line">                                basic_memset_to_zero(xmms, <span class="keyword">sizeof</span>(xmms));</span><br><span class="line">                            </span><br><span class="line">                                <span class="keyword">if</span> (xmm_select != <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.xstate_bv |= BIT(<span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            </span><br><span class="line">                            &#125;</span><br><span class="line">                    <span class="comment">/* Save VMM GPRs selected by guest RCX to TDVPS.</span></span><br><span class="line"><span class="comment">                     * RAX and RCX are not copied, start from RDX.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    mask = <span class="number">0x0004</span>;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((control.gpr_select &amp; mask) != <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            gprs[i] = get_local_data()-&gt;vmm_regs.gprs[i];</span><br><span class="line">                        &#125;       </span><br><span class="line">                        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">                    gprs[<span class="number">0</span>] = TDX_SUCCESS;   <span class="comment">// RAX</span></span><br><span class="line">                    gprs[<span class="number">1</span>] = control.raw;   <span class="comment">// RCX</span></span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tdvps_ptr-&gt;management.last_td_exit == LAST_EXIT_ASYNC_TRAP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Following a trap-like TD exit, update the guest&#x27;s TDCALL completion status with</span></span><br><span class="line">        <span class="comment">// the host hint bit.</span></span><br><span class="line">        <span class="type">api_error_code_t</span> guest_tdcall_status;</span><br><span class="line">        guest_tdcall_status.raw = tdvps_ptr-&gt;guest_state.gpr_state.rax;</span><br><span class="line">        guest_tdcall_status.host_recoverability_hint = vcpu_and_flags.host_recoverability_hint;</span><br><span class="line">        tdvps_ptr-&gt;guest_state.gpr_state.rax = guest_tdcall_status.raw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdvps_ptr-&gt;management.curr_vm == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">vmx_procbased_ctls_t</span> vm_procbased_ctls;</span><br><span class="line">        <span class="comment">/* If PEND_NMI was requested, and there&#x27;s no pending #VE (which should be handled</span></span><br><span class="line"><span class="comment">           by the guest TD before NMI), set NMI Window Exiting execution control so NMI</span></span><br><span class="line"><span class="comment">           can be injected at the proper time. */</span></span><br><span class="line">        <span class="keyword">if</span> (tdvps_ptr-&gt;management.pend_nmi &amp;&amp; (tdvps_ptr-&gt;ve_info.valid == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ia32_vmread(VMX_VM_EXECUTION_CONTROL_PROC_BASED_ENCODE, &amp;vm_procbased_ctls.raw);</span><br><span class="line">            vm_procbased_ctls.nmi_window_exiting = <span class="number">1</span>;</span><br><span class="line">            ia32_vmwrite(VMX_VM_EXECUTION_CONTROL_PROC_BASED_ENCODE, vm_procbased_ctls.raw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// Reentering into L2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If NMI unblocking by IRET was indicated during VM exit, re-block NMI</span></span><br><span class="line">        <span class="keyword">if</span> (tdvps_ptr-&gt;management.nmi_unblocking_due_to_iret)</span><br><span class="line">        &#123;</span><br><span class="line">            set_guest_inter_blocking_by_nmi();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tdvps_ptr-&gt;management.state = VCPU_ACTIVE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the guest TD&#x27;s IA32_DEBUGCTL.ENABLE_UNCORE_PMI to the VMM&#x27;s value.</span></span><br><span class="line">    <span class="type">ia32_debugctl_t</span> debugctl;</span><br><span class="line">    ia32_vmread(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, &amp;debugctl.raw);</span><br><span class="line">    debugctl.en_uncore_pmi = local_data_ptr-&gt;ia32_debugctl_value.en_uncore_pmi;</span><br><span class="line">    ia32_vmwrite(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, debugctl.raw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdvps_ptr-&gt;management.curr_vm != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Set the VMX preemption timer, if TSC deadline is enabled</span></span><br><span class="line">        set_vmx_preemption_timer(tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the SEPT lock was acquired by the TDENTER stepping filter, release it now</span></span><br><span class="line">    <span class="comment">// SEPT lock will be acquired by TDENTER stepping filter only if it didn&#x27;t return</span></span><br><span class="line">    <span class="comment">// FILTER_FAIL_TDENTER_SEPT_BUSY or FILTER_FAIL_TDENTER_EPFS</span></span><br><span class="line">    <span class="keyword">if</span> (is_sept_locked)</span><br><span class="line">    &#123;</span><br><span class="line">        release_sharex_lock_ex(&amp;tdcs_ptr-&gt;executions_ctl_fields.secure_ept_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set VMCS.IA32_SPEC_CTRL_SHADOW to the virtual value of IA32_SPEC_CTRL as seen by the TD</span></span><br><span class="line">    ia32_vmwrite(VMX_IA32_SPEC_CTRL_SHADOW,</span><br><span class="line">            calculate_virt_ia32_spec_ctrl(tdcs_ptr, tdvps_ptr-&gt;guest_msr_state.ia32_spec_ctrl));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore other Guest state (GPRs, DRs, MSRs) in TDVPS</span></span><br><span class="line">    restore_guest_td_state_before_td_entry(tdcs_ptr, tdvps_ptr);</span><br><span class="line"></span><br><span class="line">    update_host_state_in_td_vmcs(local_data_ptr, tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class="line"></span><br><span class="line">    local_data_ptr-&gt;single_step_def_state.last_entry_tsc = ia32_rdtsc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdvps_ptr-&gt;management.vm_launched[tdvps_ptr-&gt;management.curr_vm])</span><br><span class="line">    &#123;</span><br><span class="line">        tdx_return_to_td(<span class="literal">true</span>, <span class="literal">true</span>, &amp;tdvps_ptr-&gt;guest_state.gpr_state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tdx_return_to_td(<span class="literal">false</span>, <span class="literal">true</span>, &amp;tdvps_ptr-&gt;guest_state.gpr_state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flow should never reach here</span></span><br><span class="line">    tdx_sanity_check(<span class="number">0</span>, SCEC_SEAMCALL_SOURCE(TDH_VP_ENTER_LEAF), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">EXIT_FAILURE:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_sept_locked)</span><br><span class="line">    &#123;</span><br><span class="line">        release_sharex_lock_ex(&amp;tdcs_ptr-&gt;executions_ctl_fields.secure_ept_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if we need to load the SEAM VMCS</span></span><br><span class="line">    IF_COMMON (td_vmcs_loaded)</span><br><span class="line">    &#123;</span><br><span class="line">        set_seam_vmcs_as_active();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release all acquired locks and free keyhole mappings</span></span><br><span class="line">    IF_COMMON (tdcs_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        IF_COMMON (op_state_locked_flag)</span><br><span class="line">        &#123;</span><br><span class="line">            release_sharex_lock_hp_sh(&amp;(tdcs_ptr-&gt;management_fields.op_state_lock));</span><br><span class="line">        &#125;</span><br><span class="line">        free_la(tdcs_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IF_COMMON (tdr_locked_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        pamt_implicit_release_lock(tdr_pamt_entry_ptr, TDX_LOCK_SHARED);</span><br><span class="line">        free_la(tdr_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IF_COMMON (tdvpr_locked_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        pamt_unwalk(tdvpr_pa, tdvpr_pamt_block, tdvpr_pamt_entry_ptr, TDX_LOCK_SHARED, PT_4KB);</span><br><span class="line">        <span class="keyword">if</span> (tdvps_ptr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            free_la(tdvps_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> return_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tdx_return_to_td</span><span class="params">(<span class="type">bool_t</span> launch_state, <span class="type">bool_t</span> called_from_tdenter, <span class="type">gprs_state_t</span>* gpr_state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TDX Local data</span></span><br><span class="line">    <span class="type">tdx_module_local_t</span>* local_data_ptr = get_local_data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore IA32_SPEC_CTRL</span></span><br><span class="line">    <span class="keyword">if</span> (!called_from_tdenter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// TDENTER already loads the spec ctrl with safe checks</span></span><br><span class="line">        wrmsr_opt(IA32_SPEC_CTRL_MSR_ADDR,</span><br><span class="line">                  local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_spec_ctrl, TDX_MODULE_IA32_SPEC_CTRL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that we have no mapped keyholes left, beside the 2 that we store for TDR/TDVPR PAMT entries</span></span><br><span class="line">    tdx_sanity_check(local_data_ptr-&gt;keyhole_state.total_ref_count == NUM_OF_PRESERVED_KEYHOLES,</span><br><span class="line">                     SCEC_KEYHOLE_MANAGER_SOURCE, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    local_data_ptr-&gt;current_td_vm_id = local_data_ptr-&gt;vp_ctx.tdvps-&gt;management.curr_vm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exit to TD</span></span><br><span class="line">    tdx_tdentry_to_td(launch_state, gpr_state);<span class="comment">//guest_state.gpr_state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">tdx_tdentry_to_td:</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Restore all TD GPRs on module entry from a TDVPS GPR area ptr passed in RSI</span><br><span class="line">     */</span><br><span class="line">    movq (%rsi),     %rax</span><br><span class="line">    movq 8(%rsi),    %rcx</span><br><span class="line">    movq 16(%rsi),   %rdx</span><br><span class="line">    movq 24(%rsi),   %rbx</span><br><span class="line">    // movq 32(%rsi),   %rsp - keep the RSP of the TDX module for debug purposes.</span><br><span class="line">    // Actual RSP of the TD will be loaded during the VMENTRY from the TDCS (TD VMCS)</span><br><span class="line">    movq 40(%rsi),   %rbp</span><br><span class="line"></span><br><span class="line">    // RSI and RDI will be restored later - we are still using them</span><br><span class="line"></span><br><span class="line">    movq 64(%rsi),   %r8</span><br><span class="line">    movq 72(%rsi),   %r9</span><br><span class="line">    movq 80(%rsi),   %r10</span><br><span class="line">    movq 88(%rsi),   %r11</span><br><span class="line">    movq 96(%rsi),   %r12</span><br><span class="line">    movq 104(%rsi),  %r13</span><br><span class="line">    movq 112(%rsi),  %r14</span><br><span class="line">    movq 120(%rsi),  %r15</span><br><span class="line"></span><br><span class="line">    // Launch state is being passed as a parameter</span><br><span class="line">    test %edi, %edi</span><br><span class="line">    jz vmlaunch_lbl</span><br><span class="line"></span><br><span class="line">    movq 56(%rsi),   %rdi</span><br><span class="line">    movq 48(%rsi),   %rsi</span><br><span class="line"></span><br><span class="line">    vmresume</span><br><span class="line">    </span><br><span class="line">#ifdef DEBUGFEATURE_TDX_DBG_TRACE</span><br><span class="line">    call tdx_failed_vmentry</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Unreachable code.  panic.</span><br><span class="line">    */</span><br><span class="line">    ud2</span><br><span class="line"></span><br><span class="line">vmlaunch_lbl:</span><br><span class="line"></span><br><span class="line">    movq 56(%rsi),   %rdi</span><br><span class="line">    movq 48(%rsi),   %rsi</span><br><span class="line"></span><br><span class="line">    vmlaunch</span><br><span class="line">    </span><br><span class="line">#ifdef DEBUGFEATURE_TDX_DBG_TRACE</span><br><span class="line">    call tdx_failed_vmentry</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Unreachable code.  panic. </span><br><span class="line">     */</span><br><span class="line">    ud2</span><br></pre></td></tr></table></figure>

<h3 id="Meta-data"><a href="#Meta-data" class="headerlink" title="Meta data"></a>Meta data</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* VMM can pass one 64bit auxiliary data to vcpu via RCX for guest BIOS. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tdx_td_vcpu_init</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, u64 vcpu_rcx)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kvm_tdx</span> *<span class="title">kvm_tdx</span> =</span> to_kvm_tdx(vcpu-&gt;kvm);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vcpu_tdx</span> *<span class="title">tdx</span> =</span> to_tdx(vcpu);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> *tdvpx_pa = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> tdvpr_pa;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> va;</span><br><span class="line">        <span class="type">int</span> ret, i;</span><br><span class="line">        u64 err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_td_vcpu_created(tdx))</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * vcpu_free method frees allocated pages.  Avoid partial setup so</span></span><br><span class="line"><span class="comment">         * that the method can&#x27;t handle it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        va = __get_free_page(GFP_KERNEL_ACCOUNT);</span><br><span class="line">        <span class="keyword">if</span> (!va)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        tdvpr_pa = __pa(va);</span><br><span class="line"></span><br><span class="line">        tdvpx_pa = kcalloc(tdx_info-&gt;nr_tdvpx_pages, <span class="keyword">sizeof</span>(*tdx-&gt;tdvpx_pa),</span><br><span class="line">                           GFP_KERNEL_ACCOUNT);</span><br><span class="line">        <span class="keyword">if</span> (!tdvpx_pa) &#123;</span><br><span class="line">                ret = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> free_tdvpr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tdx_info-&gt;nr_tdvpx_pages; i++) &#123;</span><br><span class="line">                va = __get_free_page(GFP_KERNEL_ACCOUNT);</span><br><span class="line">                <span class="keyword">if</span> (!va) &#123;</span><br><span class="line">                        ret = -ENOMEM;</span><br><span class="line">                        <span class="keyword">goto</span> free_tdvpx;</span><br><span class="line">                &#125;</span><br><span class="line">                tdvpx_pa[i] = __pa(va);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = tdh_vp_create(kvm_tdx-&gt;tdr_pa, tdvpr_pa);</span><br><span class="line">        <span class="keyword">if</span> (KVM_BUG_ON(err, vcpu-&gt;kvm)) &#123;</span><br><span class="line">                ret = -EIO;</span><br><span class="line">                pr_tdx_error(TDH_VP_CREATE, err, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">goto</span> free_tdvpx;</span><br><span class="line">        &#125;</span><br><span class="line">        tdx-&gt;tdvpr_pa = tdvpr_pa;</span><br><span class="line"></span><br><span class="line">        tdx-&gt;tdvpx_pa = tdvpx_pa;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tdx_info-&gt;nr_tdvpx_pages; i++) &#123;</span><br><span class="line">                err = tdh_vp_addcx(tdx-&gt;tdvpr_pa, tdvpx_pa[i]);</span><br><span class="line">                <span class="keyword">if</span> (KVM_BUG_ON(err, vcpu-&gt;kvm)) &#123;</span><br><span class="line">                        pr_tdx_error(TDH_VP_ADDCX, err, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="keyword">for</span> (; i &lt; tdx_info-&gt;nr_tdvpx_pages; i++) &#123;</span><br><span class="line">                                free_page((<span class="type">unsigned</span> <span class="type">long</span>)__va(tdvpx_pa[i]));</span><br><span class="line">                                tdvpx_pa[i] = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/* vcpu_free method frees TDVPX and TDR donated to TDX */</span></span><br><span class="line">                        <span class="keyword">return</span> -EIO;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = tdh_vp_init(tdx-&gt;tdvpr_pa, vcpu_rcx);</span><br><span class="line">        <span class="keyword">if</span> (KVM_BUG_ON(err, vcpu-&gt;kvm)) &#123;</span><br><span class="line">                pr_tdx_error(TDH_VP_INIT, err, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">return</span> -EIO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WARN_ON_ONCE(kvm_apicv_activated(vcpu-&gt;kvm));</span><br><span class="line">        vcpu-&gt;arch.apic-&gt;apicv_active = <span class="literal">false</span>;</span><br><span class="line">        vcpu-&gt;arch.mp_state = KVM_MP_STATE_RUNNABLE;</span><br><span class="line">        tdx-&gt;td_vcpu_created = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">free_tdvpx:</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tdx_info-&gt;nr_tdvpx_pages; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tdvpx_pa[i])</span><br><span class="line">                        free_page((<span class="type">unsigned</span> <span class="type">long</span>)__va(tdvpx_pa[i]));</span><br><span class="line">                tdvpx_pa[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        kfree(tdvpx_pa);</span><br><span class="line">        tdx-&gt;tdvpx_pa = <span class="literal">NULL</span>;</span><br><span class="line">free_tdvpr:</span><br><span class="line">        <span class="keyword">if</span> (tdvpr_pa)</span><br><span class="line">                free_page((<span class="type">unsigned</span> <span class="type">long</span>)__va(tdvpr_pa));</span><br><span class="line">        tdx-&gt;tdvpr_pa = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">api_error_type <span class="title function_">tdh_vp_create</span><span class="params">(<span class="type">uint64_t</span> target_tdvpr_pa, <span class="type">uint64_t</span> target_tdr_pa)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TDVPS related variables</span></span><br><span class="line">    <span class="type">pa_t</span>                  tdvpr_pa;                  <span class="comment">// TDVPR physical address</span></span><br><span class="line">    <span class="type">tdvps_t</span>             * tdvps_ptr;                 <span class="comment">// Pointer to the TDVPS (multi-page linear address)</span></span><br><span class="line">    <span class="type">pamt_block_t</span>          tdvpr_pamt_block;          <span class="comment">// TDVPR PAMT block</span></span><br><span class="line">    <span class="type">pamt_entry_t</span>        * tdvpr_pamt_entry_ptr;      <span class="comment">// Pointer to the TDVPR PAMT entry</span></span><br><span class="line">    <span class="type">bool_t</span>                tdvpr_locked_flag = <span class="literal">false</span>; <span class="comment">// Indicate TDVPR is locked</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TDR related variables</span></span><br><span class="line">    <span class="type">pa_t</span>                  tdr_pa;                    <span class="comment">// TDR physical address</span></span><br><span class="line">    <span class="type">tdr_t</span>               * tdr_ptr;                   <span class="comment">// Pointer to the TDR page (linear address)</span></span><br><span class="line">    <span class="type">pamt_block_t</span>          tdr_pamt_block;            <span class="comment">// TDR PAMT block</span></span><br><span class="line">    <span class="type">pamt_entry_t</span>        * tdr_pamt_entry_ptr;        <span class="comment">// Pointer to the TDR PAMT entry</span></span><br><span class="line">    <span class="type">bool_t</span>                tdr_locked_flag = <span class="literal">false</span>;   <span class="comment">// Indicate TDR is locked</span></span><br><span class="line"></span><br><span class="line">    <span class="type">tdcs_t</span>              * tdcs_ptr = <span class="literal">NULL</span>;           <span class="comment">// Pointer to the TDCS page (linear address)</span></span><br><span class="line"></span><br><span class="line">    api_error_type        return_val = UNINITIALIZE_ERROR;</span><br><span class="line"></span><br><span class="line">    tdvpr_pa.raw = target_tdvpr_pa;</span><br><span class="line">    tdr_pa.raw = target_tdr_pa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check, lock and map the owner TDR page</span></span><br><span class="line">    return_val = check_lock_and_map_explicit_tdr(tdr_pa,</span><br><span class="line">                                                 OPERAND_ID_RDX,</span><br><span class="line">                                                 TDX_RANGE_RW,</span><br><span class="line">                                                 TDX_LOCK_SHARED,</span><br><span class="line">                                                 PT_TDR,</span><br><span class="line">                                                 &amp;tdr_pamt_block,</span><br><span class="line">                                                 &amp;tdr_pamt_entry_ptr,</span><br><span class="line">                                                 &amp;tdr_locked_flag,</span><br><span class="line">                                                 &amp;tdr_ptr);</span><br><span class="line">    <span class="keyword">if</span> (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to check/lock/map a TDR - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map the TDCS structure and check the state</span></span><br><span class="line">    return_val = check_state_map_tdcs_and_lock(tdr_ptr, TDX_RANGE_RW, TDX_LOCK_SHARED,</span><br><span class="line">                                               <span class="literal">false</span>, TDH_VP_CREATE_LEAF, &amp;tdcs_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;State check or TDCS lock failure - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check, lock and map the new TDVPR page</span></span><br><span class="line">    return_val = check_lock_and_map_explicit_private_4k_hpa(tdvpr_pa,</span><br><span class="line">                                                            OPERAND_ID_RCX,</span><br><span class="line">                                                            tdr_ptr,</span><br><span class="line">                                                            TDX_RANGE_RW,</span><br><span class="line">                                                            TDX_LOCK_EXCLUSIVE,</span><br><span class="line">                                                            PT_NDA,</span><br><span class="line">                                                            &amp;tdvpr_pamt_block,</span><br><span class="line">                                                            &amp;tdvpr_pamt_entry_ptr,</span><br><span class="line">                                                            &amp;tdvpr_locked_flag,</span><br><span class="line">                                                            (<span class="type">void</span>**)&amp;tdvps_ptr);</span><br><span class="line">    <span class="keyword">if</span> (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to check/lock/map a TDVPR - error = 0x%llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALL_CHECKS_PASSED:  The function is guaranteed to succeed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the content of the TDVPR page using direct writes</span></span><br><span class="line">    zero_area_cacheline(tdvps_ptr, TDX_PAGE_SIZE_IN_BYTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize TDVPS management fields.</span></span><br><span class="line"><span class="comment">     * Fields which are initialized to zero are implicitly zero&#x27;d in the</span></span><br><span class="line"><span class="comment">     * previous state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tdvps_ptr-&gt;management.num_tdvps_pages = <span class="number">1</span>;</span><br><span class="line">    tdvps_ptr-&gt;management.assoc_lpid = (<span class="type">uint32_t</span>)<span class="number">-1</span>;</span><br><span class="line">    tdvps_ptr-&gt;management.tdvps_pa[<span class="number">0</span>] = assign_hkid_to_hpa(tdr_ptr, tdvpr_pa).raw;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the new TDVPR page in its owner TDR</span></span><br><span class="line">    (<span class="type">void</span>)_lock_xadd_64b(&amp;(tdr_ptr-&gt;management_fields.chldcnt), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the new TDVPR page PAMT fields</span></span><br><span class="line">    tdvpr_pamt_entry_ptr-&gt;pt = PT_TDVPR;</span><br><span class="line">    set_pamt_entry_owner(tdvpr_pamt_entry_ptr, tdr_pa);</span><br><span class="line"></span><br><span class="line">EXIT:</span><br><span class="line">    <span class="comment">// Release all acquired locks and free keyhole mappings</span></span><br><span class="line">    <span class="keyword">if</span> (tdvpr_locked_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        pamt_unwalk(tdvpr_pa, tdvpr_pamt_block, tdvpr_pamt_entry_ptr, TDX_LOCK_EXCLUSIVE, PT_4KB);</span><br><span class="line">        free_la(tdvps_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdcs_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        release_sharex_lock_hp_sh(&amp;tdcs_ptr-&gt;management_fields.op_state_lock);</span><br><span class="line">        free_la(tdcs_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdr_locked_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        pamt_unwalk(tdr_pa, tdr_pamt_block, tdr_pamt_entry_ptr, TDX_LOCK_SHARED, PT_4KB);</span><br><span class="line">        free_la(tdr_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> return_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>没有成功上锁会直接返回错误 TDX_OPERAND_BUSY</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared/exclusive lock with host priority</span></span><br><span class="line">_STATIC_INLINE_ api_error_code_e <span class="title function_">acquire_sharex_lock_hp</span><span class="params">(<span class="type">sharex_hp_lock_t</span> * lock_ptr, <span class="type">lock_type_t</span> lock_type,</span></span><br><span class="line"><span class="params">                                                        <span class="type">bool_t</span> is_guest)</span><span class="comment">//is_guest=false</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lock_type == TDX_LOCK_EXCLUSIVE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> acquire_sharex_lock_hp_ex(lock_ptr, is_guest);</span><br><span class="line">                                    _STATIC_INLINE_ api_error_code_e <span class="title function_">acquire_sharex_lock_hp_ex</span><span class="params">(<span class="type">sharex_hp_lock_t</span> * lock_ptr, <span class="type">bool_t</span> is_guest)</span></span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="type">sharex_hp_lock_t</span> retval;</span><br><span class="line">                                    </span><br><span class="line">                                        tdx_debug_assert(lock_ptr != <span class="literal">NULL</span>);</span><br><span class="line">                                    </span><br><span class="line">                                        retval.raw = _lock_cmpxchg_16b(SHAREX_HP_FREE, SHAREX_HP_EXCLUSIVE_LOCK, &amp;lock_ptr-&gt;raw); <span class="comment">// Set EXCLUSIVE to 1</span></span><br><span class="line">                                    </span><br><span class="line">                                        <span class="keyword">if</span> (retval.raw == SHAREX_HP_FREE)</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            <span class="keyword">return</span> TDX_SUCCESS;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">else</span> <span class="keyword">if</span> (retval.raw == SHAREX_HP_HOST_PRIORITY)</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            <span class="keyword">if</span> (is_guest)</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="keyword">return</span> TDX_OPERAND_BUSY_HOST_PRIORITY;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                            <span class="keyword">else</span></span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="comment">// HOST_PRIORITY is 1, try again if you are host</span></span><br><span class="line">                                                <span class="comment">// Set EXCLUSIVE to 1, clear HOST_PRIORITY</span></span><br><span class="line">                                                retval.raw = _lock_cmpxchg_16b(SHAREX_HP_HOST_PRIORITY, SHAREX_HP_EXCLUSIVE_LOCK, &amp;lock_ptr-&gt;raw);</span><br><span class="line">                                                <span class="keyword">return</span> (retval.raw == SHAREX_HP_HOST_PRIORITY) ? TDX_SUCCESS : TDX_OPERAND_BUSY;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">else</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                            <span class="keyword">if</span> (is_guest)</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="keyword">return</span> TDX_OPERAND_BUSY;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                            <span class="keyword">else</span></span><br><span class="line">                                            &#123;</span><br><span class="line">                                                _lock_or_16b(&amp;lock_ptr-&gt;raw, SHAREX_HP_HOST_PRIORITY);</span><br><span class="line">                                                <span class="keyword">return</span> TDX_OPERAND_BUSY;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (lock_type == TDX_LOCK_SHARED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> acquire_sharex_lock_hp_sh(lock_ptr, is_guest);</span><br><span class="line">                            _STATIC_INLINE_ api_error_code_e <span class="title function_">acquire_sharex_lock_hp_sh</span><span class="params">(<span class="type">sharex_hp_lock_t</span> * lock_ptr, <span class="type">bool_t</span> is_guest)</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="type">sharex_hp_lock_t</span> retval;</span><br><span class="line">                        </span><br><span class="line">                            tdx_debug_assert(lock_ptr != <span class="literal">NULL</span>);</span><br><span class="line">                        </span><br><span class="line">                            <span class="keyword">if</span> (is_guest)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">// Increment SHARE_COUNTER</span></span><br><span class="line">                                retval.raw = _lock_xadd_16b(&amp;lock_ptr-&gt;raw, SHAREX_HP_SINGLE_READER);</span><br><span class="line">                        </span><br><span class="line">                                <span class="keyword">if</span> (retval.host_prio)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="comment">// Decrement SHARE_COUNTER</span></span><br><span class="line">                                    retval.raw = _lock_xadd_16b(&amp;lock_ptr-&gt;raw, (<span class="type">uint16_t</span>)-SHAREX_HP_SINGLE_READER);</span><br><span class="line">                                    <span class="keyword">return</span> TDX_OPERAND_BUSY_HOST_PRIORITY;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (retval.exclusive)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">return</span> TDX_OPERAND_BUSY; <span class="comment">// Counter is n/a</span></span><br><span class="line">                                &#125;</span><br><span class="line">                        </span><br><span class="line">                                <span class="comment">// Sanity-check the counter after we know that exclusive bit was not set</span></span><br><span class="line">                                <span class="comment">// Only when exclusive bit is not set the shared-counters has &quot;real&quot; &quot;readers&quot;</span></span><br><span class="line">                                <span class="comment">// And that number should not overflow</span></span><br><span class="line">                                tdx_sanity_check((retval.counter != SHAREX_HP_FULL_COUNTER), SCEC_LOCK_SOURCE, <span class="number">10</span>);</span><br><span class="line">                        </span><br><span class="line">                                <span class="keyword">return</span> TDX_SUCCESS;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">// Increment SHARE_COUNTER</span></span><br><span class="line">                                retval.raw = _lock_xadd_16b(&amp;lock_ptr-&gt;raw, SHAREX_HP_SINGLE_READER);</span><br><span class="line">                        </span><br><span class="line">                                <span class="keyword">if</span> (retval.exclusive)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    _lock_or_16b(&amp;lock_ptr-&gt;raw, SHAREX_HP_HOST_PRIORITY);</span><br><span class="line">                                    <span class="keyword">return</span> TDX_OPERAND_BUSY;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (retval.host_prio)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="comment">// Leave SHARE_COUNTER incremented and reset HP bit</span></span><br><span class="line">                                    _lock_and_16b(&amp;lock_ptr-&gt;raw, (<span class="type">uint16_t</span>)~SHAREX_HP_HOST_PRIORITY);</span><br><span class="line">                                &#125;</span><br><span class="line">                        </span><br><span class="line">                                <span class="comment">// Sanity-check the counter after we know that exclusive bit was not set</span></span><br><span class="line">                                <span class="comment">// Only when exclusive bit is not set the shared-counters has &quot;real&quot; &quot;readers&quot;</span></span><br><span class="line">                                <span class="comment">// And that number should not overflow</span></span><br><span class="line">                                tdx_sanity_check((retval.counter != SHAREX_HP_FULL_COUNTER), SCEC_LOCK_SOURCE, <span class="number">11</span>);</span><br><span class="line">                        </span><br><span class="line">                                <span class="keyword">return</span> TDX_SUCCESS;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tdx_sanity_check(<span class="number">0</span>, SCEC_LOCK_SOURCE, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not supposed to return this after sanity check</span></span><br><span class="line">    <span class="keyword">return</span> UNINITIALIZE_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pamt 管理了整个 tdx 的物理内存使用(hkid) 类似 rmptable?</p>
<p>为什么要加锁？</p>
<ol>
<li>Tdx module 切换使用了 tdr tdvpr 的数据结构 (shared)</li>
<li>kvm 其他线程可能会修改 pamt (exclusive)</li>
</ol>
<p>如果类比简单的 function call  传参使用寄存器的保存可以不用另一块内存 而使用栈 那么就不需要额外对 pamt entry 的加锁操作(lock_xadd_16b 是否比较慢)</p>
<h3 id="Sum"><a href="#Sum" class="headerlink" title="Sum"></a>Sum</h3><p>host-&gt;firmware-&gt;guest-&gt;firmware-&gt;host</p>
<ol>
<li>host 将参数通过通用寄存器传参给 tdx module(先写到内存 再写到寄存器)  seamcall</li>
<li>tdx module 保存通用寄存器到内存并清零</li>
<li>对 pamt entry 加共享锁</li>
<li>map (keyhole)  tdvps</li>
<li>check_and_associate_vcpu 为了 VCPU state 的缓存一致性</li>
<li>set_vm_vmcs_as_active(tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</li>
<li>检查 tsc (rdmsr)</li>
<li>adjust_tlb_tracking_state 如果 epoch 不一致则刷缓存</li>
<li>handle_stepping_filter 根据 rip 变化检查 zero-step attack 报告给 guest  ept violation</li>
<li>如果上次 vmexit 是因为 vmcall 则把 vmm 的寄存器再传给 vm 的寄存器(内存)</li>
<li>恢复 guest 其他状态 比如 debug_registers&#x2F;performance monitoring counters&#x2F;msr  extended state(xmm)</li>
<li>从内存中恢复 guest 通用寄存器的值  vmresume&#x2F;vmlaunch</li>
<li>guest 将参数通过通用寄存器传参给 tdx module  tdcall 对应 1</li>
<li>tdx module 保存通用寄存器并清零 对应 2</li>
<li>所有通用寄存器换个内存地址再存一遍</li>
<li>某些情况需要 inject_ve 然后进 guest 的 ve handler 转成 tdcall 再来一遍</li>
<li>vm 通用寄存器传给 vmm(内存) 对应 10</li>
<li>存 guest 其他状态(extended states  xfam) 对应 11</li>
<li>tlb track 对应 8</li>
<li>放锁 对应 3</li>
<li>set_seam_vmcs_as_active</li>
<li>load_vmm_state_before_td_exit 恢复 host 状态</li>
<li>从内存中恢复 host 通用寄存器的值 seamret 对应 12</li>
</ol>
<p>修改 tdvps：</p>
<ol>
<li>tdvps_ptr-&gt;management.last_seamdb_index   tdx module update 需要支持 td-preserving</li>
<li>tdvps_p-&gt;management.module_dependent_hpa_updated  和 tdx module update  vCPU 调度有关</li>
<li>tdvps-&gt;ptr-&gt;management.assoc_lpid   vCPU 调度</li>
<li>tdcs_ptr-&gt;epoch_tracking-&gt;epoch_and_refcount     tlb track</li>
<li>tdvps_ptr-&gt;management.state &#x3D; VCPU_ACTIVE  与 migration 有关</li>
<li>step 检查失败 退出前 management.state 和 management.last_td_exit</li>
<li>嵌套虚拟化 l2_xxx</li>
</ol>
<h3 id="Check-tsc"><a href="#Check-tsc" class="headerlink" title="Check tsc"></a>Check tsc</h3><p><a target="_blank" rel="noopener" href="https://forums.guru3d.com/threads/a-bit-detailed-info-on-intel-time-stamp-counter-tsc.433977/">https://forums.guru3d.com/threads/a-bit-detailed-info-on-intel-time-stamp-counter-tsc.433977/</a></p>
<blockquote>
<p>17.15.3 Time-Stamp Counter Adjustment</p>
<p>Software can modify the value of the time-stamp counter (TSC) of a logical processor by using the WRMSR instruction to write to the IA32_TIME_STAMP_COUNTER MSR (address 10H). Because such a write applies only to that logical processor, software seeking to synchronize the TSC values of multiple logical processors must perform these writes on each logical processor. It may be difficult for software to do this in a way than ensures that all logical processors will have the same value for the TSC at a given point in time.<br>The synchronization of TSC adjustment can be simplified by using the 64-bit IA32_TSC_ADJUST MSR (address 3BH). Like the IA32_TIME_STAMP_COUNTER MSR, the IA32_TSC_ADJUST MSR is maintained separately for each logical processor. A logical processor maintains and uses the IA32_TSC_ADJUST MSR as follows:<br>• On RESET, the value of the IA32_TSC_ADJUST MSR is 0.<br>• If an execution of WRMSR to the IA32_TIME_STAMP_COUNTER MSR adds (or subtracts) value X from the TSC, the logical processor also adds (or subtracts) value X from the IA32_TSC_ADJUST MSR.<br>• If an execution of WRMSR to the IA32_TSC_ADJUST MSR adds (or subtracts) value X from that MSR, the logical processor also adds (or subtracts) value X from the TSC.</p>
<p>Unlike the TSC, the value of the IA32_TSC_ADJUST MSR changes only in response to WRMSR (either to the MSR itself, or to the IA32_TIME_STAMP_COUNTER MSR). Its value does not otherwise change as time elapses. Software seeking to adjust the TSC can do so by using WRMSR to write the same value to the IA32_TSC_ADJUST MSR on each logical processor.<br>Processor support for the IA32_TSC_ADJUST MSR is indicated by CPUID.(EAX&#x3D;07H, ECX&#x3D;0H):EBX.TSC_ADJUST (bit 1).</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/414698448">https://zhuanlan.zhihu.com/p/414698448</a></p>
<blockquote>
<p>这篇 LKML 讨论中提及到，一些 BIOS SMI（System Management Interruption，系统管理中断）处理程序会通过修改 TSC 值隐藏其执行时间</p>
</blockquote>
<p>检查 tsc 是否被修改， 上次 exit 的 tsc 是否比 enter 时的要小</p>
<p>是否是 tdx 依赖 tsc 提供精确的时间 避免 hypervisor 修改了 tsc 导致 tdx module 功能不正常？</p>
<ul>
<li>preemption timer set_vmx_preemption_timer 每次进 guest 前会调用  但这个功能是不是不太用？</li>
<li>Tdx module 正常处理会需要拿锁(tdcall) 如果拿锁失败会返回 TDX_OPERAND_BUSY_HOST_PRIORITY 当某次拿锁失败离第一次失败的时间超过阈值 会直接返回到 VMM(如果没超过阈值就返回 guest)</li>
<li>migration  计算 guestTD 视角的 virtual tsc</li>
</ul>
<h3 id="Tlb-tracking"><a href="#Tlb-tracking" class="headerlink" title="Tlb tracking"></a>Tlb tracking</h3><p>9.7</p>
<blockquote>
<p>TLB tracking is required when removing a mapped TD private page (TDH.MEM.PAGE.REMOVE) or when changing the page mapping size (TDH.MEM.PAGE.PROMOTE), etc.</p>
<p>This sequence is intended to be used by the host VMM to help guarantee no EPT TLB entries exist to a set of GPA ranges.</p>
</blockquote>
<p>全局：tdcs</p>
<p>percpu:tdvps</p>
<p>每次 vpenter 的时候更新 tdvps &lt;- tdcs 如果 epoch 不一致就刷新</p>
<p>epoch 是每次调 mem_track 的时候会 ++</p>
<p>refcount 是统计上一轮有没有同步完成 每次 vmexit 的时候每个 vcpu 会-1 每次 vmenter 每个 vcpu 会 +1</p>
<p>如果没有同步完成 mem_track 会返回错误 然后 tdx_track 会 while 重复尝试直到成功</p>
<p>在 sept_flush_remote_tlbs</p>
<p>sept_remove_private_spte</p>
<p>flush_tlb_current</p>
<p>的时候调用</p>
<p>为什么不直接 smp_call_function_many(allcpu, tdx_flush_vp)   实际上只有__tdx_mmu_release_hkid 调了这个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @struct epoch_and_refcount_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief Holds the epoch and refcount in a 128bit structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoch_and_refcount_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The TD epoch counter. This counter is incremented by the host VMM using the TDHMEMTRACK function</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">uint64_t</span>       td_epoch;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Each REFCOUNT counts the number of LPs which may have TLB entries created</span></span><br><span class="line"><span class="comment">             * during a specific TD_EPOCH, and that are currently executing in TDX non-root mode</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">uint16_t</span>       refcount[<span class="number">2</span>];</span><br><span class="line">            <span class="type">uint8_t</span>        reserved[TDX_SIZE_OF_EPOCH_REFCOUNT_RESERVED_IN_BYTES];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">uint128_t</span> raw;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="type">epoch_and_refcount_t</span>;</span><br></pre></td></tr></table></figure>

<p>kvm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TLB shoot down procedure:</span></span><br><span class="line"><span class="comment"> * There is a global epoch counter and each vcpu has local epoch counter.</span></span><br><span class="line"><span class="comment"> * - TDH.MEM.RANGE.BLOCK(TDR. level, range) on one vcpu</span></span><br><span class="line"><span class="comment"> *   This blocks the subsequenct creation of TLB translation on that range.</span></span><br><span class="line"><span class="comment"> *   This corresponds to clear the present bit(all RXW) in EPT entry</span></span><br><span class="line"><span class="comment"> * - TDH.MEM.TRACK(TDR): advances the epoch counter which is global.</span></span><br><span class="line"><span class="comment"> * - IPI to remote vcpus</span></span><br><span class="line"><span class="comment"> * - TDExit and re-entry with TDH.VP.ENTER on remote vcpus</span></span><br><span class="line"><span class="comment"> * - On re-entry, TDX module compares the local epoch counter with the global</span></span><br><span class="line"><span class="comment"> *   epoch counter.  If the local epoch counter is older than the global epoch</span></span><br><span class="line"><span class="comment"> *   counter, update the local epoch counter and flushes TLB.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tdx_track</span><span class="params">(<span class="keyword">struct</span> kvm *kvm)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kvm_tdx</span> *<span class="title">kvm_tdx</span> =</span> to_kvm_tdx(kvm);</span><br><span class="line">        u64 err;</span><br><span class="line"></span><br><span class="line">        KVM_BUG_ON(!is_hkid_assigned(kvm_tdx), kvm);</span><br><span class="line">        <span class="comment">/* If TD isn&#x27;t finalized, it&#x27;s before any vcpu running. */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!is_td_finalized(kvm_tdx)))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * tdx_flush_tlb() waits for this function to issue TDH.MEM.TRACK() by</span></span><br><span class="line"><span class="comment">         * the counter.  The counter is used instead of bool because multiple</span></span><br><span class="line"><span class="comment">         * TDH_MEM_TRACK() can be issued concurrently by multiple vcpus.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * optimization: The TLB shoot down procedure described in The TDX</span></span><br><span class="line"><span class="comment">         * specification is, TDH.MEM.TRACK(), send IPI to remote vcpus, confirm</span></span><br><span class="line"><span class="comment">         * all remote vcpus exit to VMM, and execute vcpu, both local and</span></span><br><span class="line"><span class="comment">         * remote.  Twist the sequence to reduce IPI overhead as follows.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * local                        remote</span></span><br><span class="line"><span class="comment">         * -----                        ------</span></span><br><span class="line"><span class="comment">         * increment tdh_mem_track</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * request KVM_REQ_TLB_FLUSH</span></span><br><span class="line"><span class="comment">         * send IPI</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *                                TDEXIT to KVM due to IPI</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *                                IPI handler calls tdx_flush_tlb()</span></span><br><span class="line"><span class="comment">         *                              to process KVM_REQ_TLB_FLUSH.</span></span><br><span class="line"><span class="comment">         *                                spin wait for tdh_mem_track == 0</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * TDH.MEM.TRACK()</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * decrement tdh_mem_track</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *                                complete KVM_REQ_TLB_FLUSH</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * TDH.VP.ENTER to flush tlbs        TDH.VP.ENTER to flush tlbs</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;kvm_tdx-&gt;tdh_mem_track);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * KVM_REQ_TLB_FLUSH waits for the empty IPI handler, ack_flush(), with</span></span><br><span class="line"><span class="comment">         * KVM_REQUEST_WAIT.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        kvm_make_all_cpus_request(kvm, KVM_REQ_TLB_FLUSH);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                err = tdh_mem_track(kvm_tdx-&gt;tdr_pa);</span><br><span class="line">        &#125; <span class="keyword">while</span> (unlikely((err &amp; TDX_SEAMCALL_STATUS_MASK) == TDX_OPERAND_BUSY));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Release remote vcpu waiting for TDH.MEM.TRACK in tdx_flush_tlb(). */</span></span><br><span class="line">        <span class="type">atomic_dec</span>(&amp;kvm_tdx-&gt;tdh_mem_track);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (KVM_BUG_ON(err, kvm))</span><br><span class="line">                pr_tdx_error(TDH_MEM_TRACK, err, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里并不会调 tdx module 的 tdh_vp_flush  而是等 tdh_mem_track 完成 进 vm 的时候在 vpenter 里面刷</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tdx_flush_tlb</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Don&#x27;t need to flush shared EPTP:</span></span><br><span class="line"><span class="comment">         * &quot;TD VCPU TLB Address Spaced Identifier&quot; in the TDX module spec:</span></span><br><span class="line"><span class="comment">         * The TLB entries for TD are tagged with:</span></span><br><span class="line"><span class="comment">         *  SEAM (1 bit)</span></span><br><span class="line"><span class="comment">         *  VPID</span></span><br><span class="line"><span class="comment">         *  Secure EPT root (51:12 bits) with HKID = 0</span></span><br><span class="line"><span class="comment">         *  PCID</span></span><br><span class="line"><span class="comment">         * for *both* Secure-EPT and Shared-EPT.</span></span><br><span class="line"><span class="comment">         * TLB flush with Secure-EPT root by tdx_track() results in flushing</span></span><br><span class="line"><span class="comment">         * the conversion of both Secure-EPT and Shared-EPT.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * See tdx_track().  Wait for tlb shootdown initiater to finish</span></span><br><span class="line"><span class="comment">         * TDH_MEM_TRACK() so that shared-EPT/secure-EPT TLB is flushed</span></span><br><span class="line"><span class="comment">         * on the next TDENTER.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="type">atomic_read</span>(&amp;to_kvm_tdx(vcpu-&gt;kvm)-&gt;tdh_mem_track))</span><br><span class="line">                cpu_relax();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vmm_dispatcher</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">api_error_type <span class="title function_">tdh_mem_track</span><span class="params">(<span class="type">uint64_t</span> target_tdr_pa)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TDR related variables</span></span><br><span class="line">    <span class="type">pa_t</span>                  tdr_pa;                    <span class="comment">// TDR physical address</span></span><br><span class="line">    <span class="type">tdr_t</span>               * tdr_ptr;                   <span class="comment">// Pointer to the TDR page (linear address)</span></span><br><span class="line">    <span class="type">pamt_block_t</span>          tdr_pamt_block;            <span class="comment">// TDR PAMT block</span></span><br><span class="line">    <span class="type">pamt_entry_t</span>        * tdr_pamt_entry_ptr;        <span class="comment">// Pointer to the TDR PAMT entry</span></span><br><span class="line">    <span class="type">bool_t</span>                tdr_locked_flag = <span class="literal">false</span>;   <span class="comment">// Indicate TDR is locked</span></span><br><span class="line"></span><br><span class="line">    <span class="type">tdcs_t</span>              * tdcs_ptr = <span class="literal">NULL</span>;           <span class="comment">// Pointer to the TDCS structure (Multi-page)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool_t</span>                epoch_locked_flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    api_error_type        return_val = UNINITIALIZE_ERROR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    tdr_pa.raw = target_tdr_pa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check, lock and map the owner TDR page</span></span><br><span class="line">    return_val = check_lock_and_map_explicit_tdr(tdr_pa,</span><br><span class="line">                                                 OPERAND_ID_RCX,</span><br><span class="line">                                                 TDX_RANGE_RO,</span><br><span class="line">                                                 TDX_LOCK_SHARED,</span><br><span class="line">                                                 PT_TDR,</span><br><span class="line">                                                 &amp;tdr_pamt_block,</span><br><span class="line">                                                 &amp;tdr_pamt_entry_ptr,</span><br><span class="line">                                                 &amp;tdr_locked_flag,</span><br><span class="line">                                                 &amp;tdr_ptr);</span><br><span class="line">    <span class="keyword">if</span> (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to check/lock/map a TDR - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map the TDCS structure and check the state</span></span><br><span class="line">    return_val = check_state_map_tdcs_and_lock(tdr_ptr, TDX_RANGE_RW, TDX_LOCK_SHARED,</span><br><span class="line">                                               <span class="literal">false</span>, TDH_MEM_TRACK_LEAF, &amp;tdcs_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;State check or TDCS lock failure - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock the TD epoch</span></span><br><span class="line">    <span class="keyword">if</span> (acquire_sharex_lock_ex(&amp;tdcs_ptr-&gt;epoch_tracking.epoch_lock)</span><br><span class="line">                                != LOCK_RET_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Could not lock the TD epoch\n&quot;</span>);</span><br><span class="line">        return_val = api_error_with_operand_id(TDX_OPERAND_BUSY, OPERAND_ID_TD_EPOCH);</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line">    epoch_locked_flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that no VCPUs are associated with the previous epoch</span></span><br><span class="line">    <span class="type">uint64_t</span> td_epoch = tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.td_epoch;</span><br><span class="line">    <span class="type">uint16_t</span>* refcount = tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.refcount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (refcount[<span class="number">1</span> - (td_epoch  &amp; <span class="number">1</span>)] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;VCPU associated with the previous epoch\n&quot;</span>);</span><br><span class="line">        return_val = TDX_PREVIOUS_TLB_EPOCH_BUSY;</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALL_CHECKS_PASSED:  The function is guaranteed to succeed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch to the next TD epoch.  Note that since we only have 2 REFCOUNTs,</span></span><br><span class="line">    <span class="comment">// the previous epoch&#x27;s REFCOUNT, verified above to be 0, is now the</span></span><br><span class="line">    <span class="comment">// current epoch&#x27;s REFCOUNT.</span></span><br><span class="line">    <span class="comment">// TD_EPOCH&#x27;s bit 63 must be 0 since this is a special range used for migration.</span></span><br><span class="line">    <span class="comment">// This can&#x27;t happen in practice (it would take thousands of years)</span></span><br><span class="line">    tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.td_epoch++;</span><br><span class="line"></span><br><span class="line">EXIT:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoch_locked_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        release_sharex_lock_ex(&amp;tdcs_ptr-&gt;epoch_tracking.epoch_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tdcs_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        release_sharex_lock_hp_sh(&amp;tdcs_ptr-&gt;management_fields.op_state_lock);</span><br><span class="line">        free_la(tdcs_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdr_locked_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        pamt_unwalk(tdr_pa, tdr_pamt_block, tdr_pamt_entry_ptr, TDX_LOCK_SHARED, PT_4KB);</span><br><span class="line">        free_la(tdr_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> return_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/invept">https://www.felixcloutier.com/x86/invept</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">flush_td_asid</span><span class="params">(<span class="type">tdr_t</span>* tdr_ptr, <span class="type">tdcs_t</span>* tdcs_ptr, <span class="type">uint16_t</span> vm_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ia32e_eptp_t</span> eptp = get_l2_septp(tdr_ptr, tdcs_ptr, vm_id);</span><br><span class="line"></span><br><span class="line">    <span class="type">ept_descriptor_t</span> ept_desc = &#123;.ept = eptp.raw, .reserved = <span class="number">0</span>&#125;;</span><br><span class="line">    ia32_invept(&amp;ept_desc, INVEPT_SINGLE_CONTEXT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">flush_all_td_asids</span><span class="params">(<span class="type">tdr_t</span>* tdr_ptr, <span class="type">tdcs_t</span>* tdcs_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Execute INVEPT type 1 for each Secure EPT</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint16_t</span> vm_id = <span class="number">0</span>; vm_id &lt;= tdcs_ptr-&gt;management_fields.num_l2_vms; vm_id++)</span><br><span class="line">    &#123;</span><br><span class="line">        flush_td_asid(tdr_ptr, tdcs_ptr, vm_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">invalidate_gpa_translations</span><span class="params">(<span class="type">tdvps_t</span> *tdvps_ptr, <span class="type">uint16_t</span> vm_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    tdvps_ptr-&gt;management.l2_enter_guest_state_hpa[vm_id] = NULL_PA;</span><br><span class="line">    tdvps_ptr-&gt;management.l2_vapic_hpa[vm_id] = NULL_PA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">invalidate_all_gpa_translations</span><span class="params">(<span class="type">tdcs_t</span>* tdcs_p, <span class="type">tdvps_t</span>* tdvps_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint16_t</span> vm_id = <span class="number">0</span>; vm_id &lt;= tdcs_p-&gt;management_fields.num_l2_vms; vm_id++)</span><br><span class="line">    &#123;</span><br><span class="line">        invalidate_gpa_translations(tdvps_p, vm_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h4><p>嵌套虚拟化 td 可分为 L1 VMM L2 VM</p>
<p>management.curr_vm&#x3D;0 表示是 L1  否则是 L2VM 的编号</p>
<p>tdh_mng_init 初始化</p>
<p>Kvm setup_tdparams  td_params 在 kvm 的结构体中并没有 num_l2_vms kernel 并没有支持嵌套虚拟化？</p>
<p>所有涉及到 l2_enter_guest_state_hpa 的操作不在非嵌套虚拟化的路径中</p>
<p>并且由于 num_l2_vms 是 0  invalidate_all_gpa_translations 相当于是空的</p>
<h4 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h4><p>hypervisor 不刷 tlb</p>
<p><u>TLB Poisoning Attacks on AMD Secure Encrypted Virtualization</u></p>
<p>同一个 lp 调度不同 vcpu 时不刷</p>
<p><a target="_blank" rel="noopener" href="https://www.amd.com/en/resources/product-security/bulletin/amd-sb-1023.html">https://www.amd.com/en/resources/product-security/bulletin/amd-sb-1023.html</a></p>
<p>amd 硬件强制刷</p>
<p>tdx_vcpu_load 和 pre_sev_run 有差不多的逻辑 换 vcpu 就要刷</p>
<p>刷完以后 tdx module 把 tdvps_ptr-&gt;management.assoc_lpid 写为-1 即 VCPU_NO_LP</p>
<p>在每次 tdh_vp_enter 的时候都会检查 lpid 要么不变要么为-1 否则返回错误</p>
<p>并且 tdh_vp_enter 也会检查当前 vcpu 和上一次是否一致 不一致就刷</p>
<blockquote>
<p>The same ASID based on the TD’s EPTP is used for caching both secure and shared EPT translations (remember: EPTP is the HPA of the **secure **EPT root page). Thus, to flush shared EPT translations, the host VMM uses INVEPT specifying the TD’s EPTP, not its Shared EPTP. The host VMM can obtain the value of EPTP from the TD VMCSs using TDH.VP.RD.</p>
<p>An alternative method the host VMM may use is to do TLB tracking similar to how it’s done for Secure EPT, i.e., execute TDH.MEM.TRACK and a round of IPI. Contrary to Secure EPT, this is not enforced by the TDX module.</p>
</blockquote>
<p>epoch 只在 tdx_mem_track 中更改</p>
<p>tdx_mem_track 只由 kvm 调用</p>
<p>9.15 <strong>Removing a Secure EPT Page: TDH.MEM.SEPT.REMOVE</strong></p>
<blockquote>
<p>The host VMM can remove a Secure EPT page using TDH.MEM.SEPT.REMOVE, freeing it for any use, provided all its 35 entries are FREE. The host VMM should first perform the TLB tracking protocol on the page.<br>The host VMM should first call TDH.MEM.RANGE.BLOCK on the Secure EPT page. TDH.MEM.RANGE.BLOCK marks the parent EPT entry for that page as **BLOCKED **and records the TD epoch in the PAMT entry of the page.</p>
<p>Typically, the host VMM then calls TDH.MEM.TRACK and performs a round of IPIs. After that, there should be no active address translation to GPA range presented by the Secure EPT page to be removed</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tdh_mem_sept_remove</span></span><br><span class="line">    <span class="keyword">if</span> (sept_state_is_tlb_tracking_required(sept_entry_copy) &amp;&amp;</span><br><span class="line">        op_state_is_tlb_tracking_required(tdcs_ptr-&gt;management_fields.op_state))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The TD may be running and this page must be blocked and tracked before it&#x27;s removed.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Verify the entry is *BLOCKED (originally MAPPED or PENDING)</span></span><br><span class="line">        <span class="keyword">if</span> (!sept_state_is_any_blocked(sept_entry_copy))</span><br><span class="line">        &#123;</span><br><span class="line">            return_val = api_error_with_operand_id(TDX_GPA_RANGE_NOT_BLOCKED, OPERAND_ID_RCX);</span><br><span class="line">            set_arch_septe_details_in_vmm_regs(sept_entry_copy, gpa_mappings.level, local_data_ptr);</span><br><span class="line">            TDX_ERROR(<span class="string">&quot;Removed SEPT entry is not blocked - 0x%llx\n&quot;</span>, sept_entry_copy.raw);</span><br><span class="line">            <span class="keyword">goto</span> EXIT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Verify the TLB tacking of the blocked Secure-EPT page has been completed</span></span><br><span class="line">        <span class="keyword">if</span> (!is_tlb_tracked(tdcs_ptr, removed_page_pamt_entry_ptr[<span class="number">0</span>]-&gt;bepoch))</span><br><span class="line">        &#123;</span><br><span class="line">            TDX_ERROR(<span class="string">&quot;Removed SEPT page TLB tracking is not complete\n&quot;</span>);</span><br><span class="line">            return_val = api_error_with_operand_id(TDX_TLB_TRACKING_NOT_DONE, OPERAND_ID_RCX);</span><br><span class="line">            <span class="keyword">goto</span> EXIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>tdh_mem_range_block-&gt;block_sept_entry 每个 septe 会记录是否被 block</p>
<p>如果 kvm 没有调用 tdh_mem_range_block  tdx module 会检查并报错</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Checks TLB tracking conditions</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param tdcs_t Pointer to TDCS for reading TD&#x27;s epoch value and refcount</span></span><br><span class="line"><span class="comment"> * @param bepoch The EPOCH value that needs to be checked if tracked</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_STATIC_INLINE_ <span class="type">bool_t</span> <span class="title function_">is_tlb_tracked</span><span class="params">(<span class="type">tdcs_t</span> * tdcs_ptr, <span class="type">bepoch_t</span> bepoch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bepoch.mig_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">epoch_and_refcount_t</span> epoch_and_refcount = &#123;</span><br><span class="line">            .raw = _lock_read_128b(&amp;tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.raw)</span><br><span class="line">                                              &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((bepoch.raw == epoch_and_refcount.td_epoch - <span class="number">1</span>) &amp;&amp;</span><br><span class="line">        (epoch_and_refcount.refcount[bepoch.raw &amp; <span class="number">1</span>] == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (bepoch.raw &lt; epoch_and_refcount.td_epoch - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bepoch 在 tdh_mem_range_block 的时候设为 tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.td_epoch</p>
<p>这里的条件是</p>
<ol>
<li>td_epoch 比之前 block 的时候大 1 那这轮 flush 必须都完成</li>
<li>td_epoch 比之前 block 的时候不止大 1 那表示之前的 flush 已经完成</li>
</ol>
<p>remove 改 pte 必须先 block-&gt;block 后必须 track-&gt;track 必须 flush</p>
<p><img src="/images/OiaUbKFGfoYRvVxEqWgc2XwpnYd.png" title="image"></p>
<p>KVM 如果不发 IPI vCPU 不下来  在 remove 的时候 根据 refcount 还是可以判断最近一次的同步有没有完成</p>
<p>refcount 在每次 enter 的时候 +1 exit 的时候-1 动态变化 只有所有 vCPU 都没 enter 的时候才会是 0</p>
<h4 id="TDH-MEM-RANGE-BLOCK"><a href="#TDH-MEM-RANGE-BLOCK" class="headerlink" title="TDH.MEM.RANGE.BLOCK"></a>TDH.MEM.RANGE.BLOCK</h4><blockquote>
<p>Execute TDH.MEM.RANGE.BLOCK on each GPA range, blocking subsequent creation of TLB translation to that range.<br>Note that cached translations may still exist at this stage.</p>
</blockquote>
<blockquote>
<p>The host VMM can remove a Secure EPT page using TDH.MEM.SEPT.REMOVE, freeing it for any use, provided all its 35 entries are FREE. The host VMM should first perform the TLB tracking protocol on the page.<br>The host VMM should first call TDH.MEM.RANGE.BLOCK on the Secure EPT page. TDH.MEM.RANGE.BLOCK marks the parent EPT entry for that page as **BLOCKED **and records the TD epoch in the PAMT entry of the page.</p>
<p>Typically, the host VMM then calls TDH.MEM.TRACK and performs a round of IPIs. After that, there should be no active address translation to GPA range presented by the Secure EPT page to be removed.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prepare the EPT entry value with TDB set, RWX cleared and suppress VE set</span></span><br><span class="line">    <span class="type">ia32e_sept_t</span> new_septe_val;</span><br><span class="line">    new_septe_val.raw = page_sept_entry_copy.raw;</span><br><span class="line"></span><br><span class="line">    block_sept_entry(&amp;new_septe_val, sept_level_and_gpa.level);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Update the SEPT entry in memory</span></span><br><span class="line">    atomic_mem_write_64b(&amp;page_sept_entry_ptr-&gt;raw, new_septe_val.raw);</span><br></pre></td></tr></table></figure>

<p>一个新的 pte 改了属性  atomic write 修改到页表上？ 硬件有特殊的行为吗？</p>
<p>9.2 Secure EPT Entry</p>
<blockquote>
<p>From the CPU perspective, Secure EPT has the same structure as a legacy VMX EPT.<br>For the purpose of private memory management, the Intel TDX module hold a state value in each Secure EPT entry. This state value is encoded by multiple bits.</p>
</blockquote>
<p><img src="/images/BsCQbP6eno1j48x2g3YcmObEneg.png" title="image"></p>
<h4 id="Sum-1"><a href="#Sum-1" class="headerlink" title="Sum"></a>Sum</h4><ol>
<li>先改页表 block  不让访问 （但是其他 vCPU 还是可以通过 tlb 访问 没问题 因为还没有到 remove 的流程）</li>
<li>刷 tlb ipi</li>
<li>改页表 remove  此时需要保证之前的刷 tlb 完成</li>
</ol>
<h3 id="Associate-vcpu"><a href="#Associate-vcpu" class="headerlink" title="Associate vcpu"></a>Associate vcpu</h3><p>10.3</p>
<blockquote>
<p>Some TD VCPU state is non-coherently cached. This includes:<br>• Address translations (TLB&#x2F;PxE entries) must be explicitly flushed in case they may be stale.<br>• TD VMCS is cached by the CPU. VMX architecture requires making a VMCS current by VMPTRLD before using it with most VMX instructions, and then explicitly writing it to memory and making it non-current by VMCLEAR before the VMCS memory image can be handled (e.g., by making it current on another LP).<br>This non-coherent caching implies that some explicit and&#x2F;or implicit operations are done to help guarantee correctness. This is described in the following sections</p>
</blockquote>
<p>tdvps_ptr-&gt;management.assoc_lpid</p>
<p>就是刷缓存的时候用(主要是第二条)</p>
<ol>
<li>每次 vpenter adjust_tlb_tracking_state 如果不是 new_association  flushasid invalidate gpa translations</li>
<li>tdh_vp_flush 当前的 lpid 必须和传入的 tdvps 记录的 lpid 一致</li>
</ol>
<p>kvm 有 tdx_flush_vp_on_cpu  当每次 tdx_vcpu_load 的时候 当前 cpu 和记录的 cpu 不一致的时候调用(Migrate VCPUs between LPs)</p>
<h3 id="Xmm"><a href="#Xmm" class="headerlink" title="Xmm"></a>Xmm</h3><p>tdcall 的时候 根据传入的 xmm_mask 选择保存并传递 其他全部清零</p>
<p>async 的时候 xsave</p>
<blockquote>
<p>The Intel TDX module helps ensure that any guest TD extended state is saved and isolated from the host VMM across TD exit and entry. It is the VMM’s responsibility to save its own extended state across TD entry and exit.<br>• Before TDH.VP.ENTER, the host VMM should save (e.g., using XSAVES) any extended state that the guest TD VCPU is allowed to use (per XFAM) and the host VMM expects to need after TDH.VP.ENTER is complete.<br>• The TDH.VP.ENTER function loads the extended state that the TD VCPU is allowed to use, per XFAM, from the VCPU’s TDVPS. An exception to this is when TDH.VP.ENTER follows a previous TDG.VP.VMCALL – in the case TDH.VP.ENTER does not load the XMM state (corresponding to XFAM bit 1) from TDVPS; it passes it directly from the host VMM.<br>• On an asynchronous TD exit, the Intel TDX module saves the extended state that the TD VCPU was allowed to use, per XFAM, to the VCPU’s TDVPS. It then clears the extended state.<br>• On TDG.VP.VMCALL, the Intel TDX module works similarly, but it selectively does not clear some of the XMM register<br>state (corresponding to XFAM bit 1). That XMM state is passed directly to the host VMM.<br>• On completion of TDH.VP.ENTER (following TD exit), the VMM may restore any extended state that it saved before<br>TDH.VP.ENTER.</p>
</blockquote>
<p>xfam：eXtended Features Available Mask   决定 guest vCPU 能用哪些属性 然后保存恢复的时候直接把这个传进去</p>
<p>kvm 配置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">save_guest_td_extended_state</span><span class="params">(<span class="type">tdvps_t</span>* tdvps_ptr, <span class="type">uint64_t</span> xfam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Set Guest XCR0 and XSS context for saving the state</span></span><br><span class="line">    ia32_xsetbv(<span class="number">0</span>, xfam &amp; XCR0_USER_BIT_MASK);</span><br><span class="line">    ia32_wrmsr(IA32_XSS_MSR_ADDR, xfam &amp; XCR0_SUPERVISOR_BIT_MASK);</span><br><span class="line"></span><br><span class="line">    ia32_xsaves(&amp;tdvps_ptr-&gt;guest_extension_state.xbuf, xfam);</span><br><span class="line">&#125;</span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">restore_guest_td_extended_state</span><span class="params">(<span class="type">tdcs_t</span>* tdcs_ptr, <span class="type">tdvps_t</span>* tdvps_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> xstate_bv = tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.xstate_bv;</span><br><span class="line">    <span class="type">uint64_t</span> xcomp_bv = tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.xcomp_bv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for XBUFF header corruption before trying to use SAFE_XRSTORS</span></span><br><span class="line">    <span class="comment">// Checks are done according to SDM Volume 1, Chapter 13.12</span></span><br><span class="line">    <span class="comment">// A #GP occurs in the following cases:</span></span><br><span class="line">    <span class="comment">//  - XCOMP_BV[63] = 0.</span></span><br><span class="line">    <span class="comment">//  - XCOMP_BV sets a bit in the range 62:0 that is not set in XCR0 | IA32_XSS</span></span><br><span class="line">    <span class="comment">//    (in our case XCR0 | IA32_XSS is just the XFAM)</span></span><br><span class="line">    <span class="comment">//  - XSTATE_BV sets a bit(including bit 63) that is not set in XCOMP_BV.</span></span><br><span class="line">    <span class="comment">//  - Bytes 63 : 16 of the XSAVE header are not all 0.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((xcomp_bv &amp; BIT(<span class="number">63</span>)) == <span class="number">0</span>) ||</span><br><span class="line">        ((xcomp_bv &amp; ~BIT(<span class="number">63</span>) &amp; ~(tdvps_ptr-&gt;management.xfam)) != <span class="number">0</span>) ||</span><br><span class="line">        ((xstate_bv &amp; ~xcomp_bv) != <span class="number">0</span>) ||</span><br><span class="line">        (!tdx_memcmp_to_zero(tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.reserved,</span><br><span class="line">                             <span class="keyword">sizeof</span>(tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.reserved))))</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed checks on XBUFF header. xcomp_bv = 0x%llx, xstate_bv = 0x%llx, xfam = 0x%llx\n&quot;</span>,</span><br><span class="line">                xcomp_bv, xstate_bv, tdvps_ptr-&gt;management.xfam);</span><br><span class="line">        guest_ext_state_load_failure(tdcs_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set Guest XCR0 and XSS context for restoring the state</span></span><br><span class="line">    ia32_xsetbv(<span class="number">0</span>, tdvps_ptr-&gt;management.xfam &amp; XCR0_USER_BIT_MASK);</span><br><span class="line">    ia32_wrmsr(IA32_XSS_MSR_ADDR, tdvps_ptr-&gt;management.xfam &amp; XCR0_SUPERVISOR_BIT_MASK);</span><br><span class="line"></span><br><span class="line">    safe_xrstors(&amp;tdvps_ptr-&gt;guest_extension_state.xbuf, tdvps_ptr-&gt;management.xfam, tdcs_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/xsave">https://www.felixcloutier.com/x86/xsave</a></p>
<p><a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/xrstor">https://www.felixcloutier.com/x86/xrstor</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span>  fcw;</span><br><span class="line">    <span class="type">uint16_t</span>  fsw;</span><br><span class="line">    <span class="type">uint8_t</span>   ftw;</span><br><span class="line">    <span class="type">uint8_t</span>   reserved_0;</span><br><span class="line">    <span class="type">uint16_t</span>  fop;</span><br><span class="line">    <span class="type">uint64_t</span>  fip;</span><br><span class="line">    <span class="type">uint64_t</span>  fdp;</span><br><span class="line">    <span class="type">uint32_t</span>  mxcsr;</span><br><span class="line">    <span class="type">uint32_t</span>  mxcsr_mask;</span><br><span class="line">    <span class="type">uint128_t</span> st_mm[<span class="number">8</span>];</span><br><span class="line">    <span class="type">uint128_t</span> xmm[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span>   reserved_1[<span class="number">96</span>];</span><br><span class="line">&#125; <span class="type">xsave_legacy_region_t</span>;</span><br><span class="line">tdx_static_assert(<span class="keyword">sizeof</span>(<span class="type">xsave_legacy_region_t</span>) == <span class="number">512</span>, <span class="type">xsave_legacy_region_t</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/T2FwbKKOToNlUgxsOeickQpdnrg.png" title="image"></p>
<p>xfam 是 instruction mask  实际上叫 eXtended Features Available Mask</p>
<p>Section 13.4.1, “Legacy Region of an XSAVE Area” of Intel(® )64 and IA-32 Architectures Software Developer’s Manual, Volume 1</p>
<p>和 XCR0 and 以后称为 requested-feature bitmap (RFBM)  可以理解为需不需要保存对应的 state-component</p>
<p>13.11 XSAVES</p>
<blockquote>
<p>Execution of XSAVES saves into the XSAVE area those state components corresponding to bits that are set in RFBM (subject to the optimizations described below). State components 0 and 1 are located in the legacy region of the XSAVE area (see Section 13.4.1). Each state component <em>i</em>, 2 ≤ _i _≤ 62, is located in the extended region; the XSAVES instruction always uses the compacted format for the extended region (see Section 13.4.3).<br>Execution of XSAVES performs the init optimization to reduce the amount of data written to memory. If XINUSE[<em>i</em>] &#x3D; 0, state component _i _is not saved to the XSAVE area (even if RFBM[<em>i</em>] &#x3D; 1). However, if RFBM[1] &#x3D; 1 and MXCSR does not have the value 1F80H, XSAVES saves all of state component 1 (SSE — including the XMM registers) even if XINUSE[1] &#x3D; 0.</p>
</blockquote>
<p>有优化</p>
<ul>
<li>在初始化状态下是不会保存（0）</li>
<li>最近才恢复的就不用保存（没修改）</li>
</ul>
<p>每次 XRSTORS 会记录一个四元组信息  XSAVES 检查这个四元组 满足条件就不保存</p>
<ol>
<li>特权级是 ring0</li>
<li>xsave area 地址一样</li>
<li>如果 XRSTORS 调用时是 VMX non-root 那 XSAVES 调用也必须是 VMX non-root</li>
<li>对应的 state-component 没有被修改</li>
</ol>
<p>第一个优化：host guest 是否会用完 xmm 就清零？ 发生 hypercall 的时候除了需要传递的 xmm 其他都是清零的</p>
<p>第二个优化：两次 vmexit 之间  guest&#x2F;host 不会执行其他的 xrstors</p>
<blockquote>
<p>The XSAVEOPT, XSAVEC, and XSAVES instructions use two optimizations to reduce the amount of data that they write to memory. They avoid writing data for any state component known to be in its initial configuration (the <strong>init optimization</strong>). In addition, if either XSAVEOPT or XSAVES is using the same XSAVE area as that used by the most recent execution of XRSTOR or XRSTORS, it may avoid writing data for any state component whose configuration is known not to have been modified since then (the <strong>modified optimization</strong>). (XSAVE does not use these optimizations, and XSAVEC does not use the modified optimization.) The operation of XSAVEOPT, XSAVEC, and XSAVES are described in more detail in Section 13.9 through Section 13.11.<br>• **SSE state. **In 64-bit mode, SSE state is in its initial configuration if each of XMM0–XMM15 is 0. Outside 64-bit mode, SSE state is in its initial configuration if each of XMM0–XMM7 is 0. XINUSE[1] pertains only to the state of the XMM registers and not to MXCSR. An execution of XRSTOR or XRSTORS outside 64-bit mode does not update XMM8–XMM15. (See Section 13.13.)<br>• **AVX state. **In 64-bit mode, AVX state is in its initial configuration if each of YMM0_H–YMM15_H is 0. Outside 64-bit mode, AVX state is in its initial configuration if each of YMM0_H–YMM7_H is 0. An execution of XRSTOR or XRSTORS outside 64-bit mode does not update YMM8_H–YMM15_H. (See Section 13.13.)</p>
</blockquote>
<blockquote>
<p>Like XSAVEOPT, XSAVES may perform the modified optimization. Each execution of XRSTOR and XRSTORS establishes XRSTOR_INFO as a 4-tuple <em>w</em>,<em>x</em>,<em>y</em>,_z_ (see Section 13.8.3 and Section 13.12). Execution of XSAVES uses the modified optimization only if the following all hold:</p>
<p>• _w _&#x3D; CPL;<br>• _x _&#x3D; 1 if and only if the logical processor is in VMX non-root operation;<br>• _y _is the linear address of the XSAVE area being used by XSAVEOPT; and<br>• <em>z</em>[63] is 1 and <em>z</em>[62:0] &#x3D; RFBM[62:0]. (This last item implies that XSAVES does not use the modified optimization if the last execution of XRSTOR used the standard form and followed the last execution of XRSTORS.)<br>If XSAVES uses the modified optimization and XMODIFIED[<em>i</em>] &#x3D; 0 (see Section 13.6), state component _i _is not saved to the XSAVE area.</p>
</blockquote>
<h3 id="Branch-prediction"><a href="#Branch-prediction" class="headerlink" title="Branch prediction"></a>Branch prediction</h3><p>是个 side-channel</p>
<blockquote>
<p>Branch predictions cached by the CPU before entering a guest TD should not impact the behavior of that TD. The Intel TDX module helps ensure that by applying CPU mechanisms to isolate the branch predictions of each guest TD from branch predication done outside its execution.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the current VCPU to be executed on this LP is not the same as the last one,</span></span><br><span class="line">    <span class="comment">// issue an indirect branch prediction barrier (IBPB) command</span></span><br><span class="line">    <span class="keyword">if</span> (tdvpr_pa.raw != local_data_ptr-&gt;vp_ctx.last_tdvpr_pa.raw)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The TD ASID (Address Space Identifier) does not distinguish between different VCPUs of the same TD.</span></span><br><span class="line">        <span class="comment">// Therefore, when switching VCPU of the same TD on the same LP we should invalidate EPT.</span></span><br><span class="line">        <span class="comment">// Practically, we do this on every VCPU switch (even not of the same TD).</span></span><br><span class="line">        <span class="comment">// This is because it is difficult to track the history of TD execution on an LP</span></span><br><span class="line">        <span class="comment">// (i.e., we should check for every TD/VCPU combination in the past).</span></span><br><span class="line">        flush_all_td_asids(tdr_ptr, tdcs_ptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Issue an indirect branch prediction barrier (IBPB) command, since the CPU does not</span></span><br><span class="line">        <span class="comment">// distinguish between VCPUs for its branch prediction.</span></span><br><span class="line">        <span class="type">ia32_pred_cmd_t</span> pred_cmd = &#123; .raw = <span class="number">0</span> &#125;;</span><br><span class="line">        pred_cmd.ibpb = <span class="number">1</span>;</span><br><span class="line">        ia32_wrmsr(IA32_PRED_CMD_MSR_ADDR, pred_cmd.raw);</span><br><span class="line">        local_data_ptr-&gt;vp_ctx.last_tdvpr_pa.raw = tdvpr_pa.raw;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.intel.cn/content/www/cn/zh/developer/articles/technical/software-security-guidance/technical-documentation/indirect-branch-predictor-barrier.html">https://www.intel.cn/content/www/cn/zh/developer/articles/technical/software-security-guidance/technical-documentation/indirect-branch-predictor-barrier.html</a></p>
<p>用 barrier 防御 tdx module 在 host-guest 间做 barrier</p>
<p>guest 也可以写这个 msr kvm 配置是否需要下陷</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (boot_cpu_has(X86_FEATURE_IBPB))</span><br><span class="line">        vmx_set_intercept_for_msr(vcpu, MSR_IA32_PRED_CMD, MSR_TYPE_W,</span><br><span class="line">                                  !guest_has_pred_cmd_msr(vcpu));</span><br></pre></td></tr></table></figure>

<p>guest 为了安全 可以每次进 guest(embassy)自己做一遍 IBPB</p>
<p>为了性能 host 允许 non-root mode 直接执行 不下陷</p>
<h2 id="Sev"><a href="#Sev" class="headerlink" title="Sev"></a>Sev</h2><p><a target="_blank" rel="noopener" href="https://github.com/amd/AMD-ASPFW">https://github.com/amd/AMD-ASPFW</a> 找不到 vmexit 相关 只有 kvm 调 cmd 的部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sev_issue_cmd</span><br><span class="line">sev_issue_cmd_external_user</span><br><span class="line">sev_do_cmd</span><br><span class="line">__sev_do_cmd_locked</span><br><span class="line">    reg = cmd;</span><br><span class="line">    iowrite32(ret,..);</span><br><span class="line">    </span><br><span class="line">    ret = sev_wait_cmd_ioc();</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2026/02/02/papers/TZ-LLM%20Protecting%20On-Device%20Large%20Language%20Models%20with%20Arm%20TrustZone/" rel="prev" title="TZ-LLM: Protecting On-Device Large Language Models with Arm TrustZone">
                  <i class="fa fa-angle-left"></i> TZ-LLM: Protecting On-Device Large Language Models with Arm TrustZone
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">szy</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">80k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">4:52</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
