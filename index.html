<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"szy0127.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"preload":true}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="S blog">
<meta property="og:url" content="http://szy0127.github.io/index.html">
<meta property="og:site_name" content="S blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="szy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://szy0127.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>S blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">S blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">szy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2026/02/19/papers/Vmem%20A%20Lightweight%20Hot-Upgradable%20Memory%20Management%20for%20In-production%20Cloud%20Environment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/19/papers/Vmem%20A%20Lightweight%20Hot-Upgradable%20Memory%20Management%20for%20In-production%20Cloud%20Environment/" class="post-title-link" itemprop="url">Vmem: A Lightweight Hot-Upgradable Memory Management for In-production Cloud Environment</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2026-02-19 21:14:03" itemprop="dateCreated datePublished" datetime="2026-02-19T21:14:03+08:00">2026-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-20 20:47:55" itemprop="dateModified" datetime="2026-02-20T20:47:55+08:00">2026-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>483</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Vmem-A-Lightweight-Hot-Upgradable-Memory-Management-for-In-production-Cloud-Environment"><a href="#Vmem-A-Lightweight-Hot-Upgradable-Memory-Management-for-In-production-Cloud-Environment" class="headerlink" title="Vmem: A Lightweight Hot-Upgradable Memory Management for In-production Cloud Environment"></a>Vmem: A Lightweight Hot-Upgradable Memory Management for In-production Cloud Environment</h1><p>阿里云</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Hugetlb</th>
<th>Folio</th>
<th>HVO</th>
<th>Dmemfs</th>
<th>Desired</th>
</tr>
</thead>
<tbody><tr>
<td>Hot Upgrade</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Metadata Overhead</td>
<td>High</td>
<td>High</td>
<td>Med.</td>
<td>Low</td>
<td>Low</td>
</tr>
<tr>
<td>Elastic Resource Pool</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Page Granularity</td>
<td>2M, 1G</td>
<td>2ⁿ × 4K</td>
<td>2M, 1G</td>
<td>2M, 1G</td>
<td>2M, 1G</td>
</tr>
<tr>
<td>Shared Page Pools</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Deterministic Alloc.</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Fast Boot</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Kernel Modifications</td>
<td>Built-in</td>
<td>Extensive</td>
<td>Extensive</td>
<td>Extensive</td>
<td>Minimal</td>
</tr>
</tbody></table>
<p>五个目标：</p>
<ol>
<li>轻量化 只针对云计算</li>
<li>memory overhead小 可销售的内存多</li>
<li>支持大页</li>
<li>内存配置高效</li>
<li>热升级</li>
</ol>
<p>设计：</p>
<ol>
<li><p>memmap+PFNMAP 宿主机启动时直接把大部分内存预留给虚拟机 剩下很多struct page</p>
<ul>
<li>memmap在内存初始化早期就预留内存，这部分内存都不会进入sparse memory model的管理。对memblock会占用struct page，即使memblock_reserve也没用，只是不进入buddy system而已。</li>
<li>PFNMAP让内核所有的内存相关函数不使用struct page，对于&#x2F;dev&#x2F;mem的mmap会自动带这个flag</li>
</ul>
</li>
<li><p>内存切片，2M粒度。传统大页提前预留，2M不能组合为1G，1G也不能拆分为2M</p>
</li>
<li><p>混合大页双向分配。 需要1G的时候从低到高分配低地址，需要2M的时候从高到低分配高地址</p>
</li>
<li><p>内存映射使用fastmap，四级页表遍历太慢，直接用更简单的数据结构建立映射。</p>
<blockquote>
<p>During memory use, it is often necessary to query the mapping between physical and virtual memory, such as VM start&#x2F;stop scenarios. The conventional method traverses page tables for address translation, which is costly. </p>
</blockquote>
<p>硬件仍然用页表，但是软件翻译不需要页表，可以用另一个数据结构。</p>
<p>但是kvm不是有自己的memslot用于翻译吗。</p>
</li>
<li><p>vmem.ko 转发请求到vmem_mm_i.ko  热升级。vmem_mm_i.ko提供一些函数指针 用于操作内存，热升级时，vmem.ko负责遍历vma 替换数据结构中的old指针为新指针，将refcnt降为0，这样可以unload掉旧版本</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2026/02/14/papers/SCAVY%20Automated%20Discovery%20of%20Memory%20Corruption%20Targets%20in%20Linux%20Kernel%20for%20Privilege%20Escalation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/14/papers/SCAVY%20Automated%20Discovery%20of%20Memory%20Corruption%20Targets%20in%20Linux%20Kernel%20for%20Privilege%20Escalation/" class="post-title-link" itemprop="url">SCAVY: Automated Discovery of Memory Corruption Targets in Linux Kernel for Privilege Escalation</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2026-02-14 14:23:42 / Modified: 22:46:23" itemprop="dateCreated datePublished" datetime="2026-02-14T14:23:42+08:00">2026-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>10 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SCAVY-Automated-Discovery-of-Memory-Corruption-Targets-in-Linux-Kernel-for-Privilege-Escalation"><a href="#SCAVY-Automated-Discovery-of-Memory-Corruption-Targets-in-Linux-Kernel-for-Privilege-Escalation" class="headerlink" title="SCAVY: Automated Discovery of Memory Corruption Targets in Linux Kernel for Privilege Escalation"></a>SCAVY: Automated Discovery of Memory Corruption Targets in Linux Kernel for Privilege Escalation</h1><p>Usenix Security‘24</p>
<p><a target="_blank" rel="noopener" href="https://github.com/BadDataLab/SCAVY">https://github.com/BadDataLab/SCAVY</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/19324">https://xz.aliyun.com/news/19324</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li>CVE提出的内存漏洞，例如UAF等，都太小，不足以完成一次提升权限的利用</li>
<li>一些利用方法 受到传统保护机制 例如SMEP的影响 成功率不高</li>
<li>因为没有端到端的严重威胁 所以某些CVE并不会受到重视 立即被开发者修复</li>
</ol>
<p>本文找内核关键数据结构 可以被CVE利用达到权限提升的目的</p>
<p>linux漏洞利用思路</p>
<ol>
<li>fuzz 找一些内存越界、UAF等导致的crash场景</li>
<li>找一些这个内存corrupt进一步可拥有的capability</li>
<li>组合多个POC 完成权限提升</li>
<li>提高稳定性（触发概率）与能力（绕过更多的安全措施）</li>
</ol>
<p>本文目标找到更多的memory target可以给2 3用，不参与1 4</p>
<p>一个例子：vm_area_struct</p>
<ol>
<li>mmap映射&#x2F;etc&#x2F;passwd和另一个普通文件，内核分配两个vm_area_struct</li>
<li>通过一个已经存在的CVE泄漏&#x2F;etc&#x2F;passwd对应的vm_area_struct的地址，覆盖普通文件的vm_area_struct的值</li>
<li>msync写回，此时文件是&#x2F;etc&#x2F;passwd 但权限变为可写</li>
<li>su提权</li>
</ol>
<p>千问对于本文工作的解释：</p>
<hr>
<h3 id="🎯-核心目标"><a href="#🎯-核心目标" class="headerlink" title="🎯 核心目标"></a>🎯 核心目标</h3><blockquote>
<p><strong>自动找出内核中哪些内存区域被破坏后，能让普通用户获得 root 权限。</strong></p>
</blockquote>
<p>这比传统模糊测试（fuzzing）更进一步——不仅要找崩溃（crash），还要判断这个崩溃是否“有用”（即能否提权）。</p>
<hr>
<h2 id="一、为什么传统方法不够？"><a href="#一、为什么传统方法不够？" class="headerlink" title="一、为什么传统方法不够？"></a>一、为什么传统方法不够？</h2><ul>
<li>像 <strong>Syzkaller</strong> 这样的模糊测试器擅长触发各种代码路径（高覆盖率），但不关心“破坏哪个字段才有用”。</li>
<li>像 <strong>KOOBE &#x2F; FUZE</strong> 能检测内存越界或破坏，但无法判断破坏后是否能提权。</li>
<li>手动分析崩溃是否可利用非常耗时。</li>
</ul>
<p>👉 <strong>SCAVY 的创新点：把整个利用过程拆成三个阶段，每个阶段用不同的策略精准打击。</strong></p>
<hr>
<h2 id="二、漏洞利用的“三阶段模型”"><a href="#二、漏洞利用的“三阶段模型”" class="headerlink" title="二、漏洞利用的“三阶段模型”"></a>二、漏洞利用的“三阶段模型”</h2><p>SCAVY 观察到真实提权漏洞通常分三步：</p>
<table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">目标</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. 分配目标对象</strong></td>
<td align="left">找到内核中可被控制分配的结构体</td>
<td align="left">创建文件 → 分配 <code>struct file</code></td>
</tr>
<tr>
<td align="left"><strong>2. 破坏关键字段</strong></td>
<td align="left">修改该结构体中的某个字段（如权限、指针）</td>
<td align="left">把 <code>file-&gt;f_cred-&gt;uid</code> 改成 0（root）</td>
</tr>
<tr>
<td align="left"><strong>3. 触发提权行为</strong></td>
<td align="left">使用被破坏的对象执行特权操作</td>
<td align="left">用被篡改的文件句柄写 <code>/etc/passwd</code></td>
</tr>
</tbody></table>
<p>SCAVY 就围绕这三个阶段设计了对应的自动化技术。</p>
<hr>
<h2 id="三、关键技术详解"><a href="#三、关键技术详解" class="headerlink" title="三、关键技术详解"></a>三、关键技术详解</h2><h3 id="🔧-阶段-1：找到“可分配的内核结构体”（Allocator-Discovery）"><a href="#🔧-阶段-1：找到“可分配的内核结构体”（Allocator-Discovery）" class="headerlink" title="🔧 阶段 1：找到“可分配的内核结构体”（Allocator Discovery）"></a>🔧 阶段 1：找到“可分配的内核结构体”（Allocator Discovery）</h3><p><strong>问题</strong>：内核有成千上万个结构体，哪些能被用户通过系统调用分配？</p>
<p><strong>SCAVY 的做法</strong>：</p>
<ul>
<li>在内核中插桩（instrument）所有内存分配函数（如 <code>kmalloc</code>）；</li>
<li>同时记录<strong>类型转换</strong>（比如 <code>(struct task_struct *)kmalloc(...)</code>），从而知道“这块内存是什么类型”；</li>
<li>用 <strong>Kprobe</strong> 把分配地址 + 类型信息传到用户空间；</li>
<li>模糊测试器遍历系统调用，收集所有“用户能触发分配的结构体”。</li>
</ul>
<p>✅ <strong>优势</strong>：不用污点分析，轻量高效，可扩展到百万级测试用例。</p>
<hr>
<h3 id="🔍-阶段-2：找出“可被破坏的关键字段”（Field-Discovery）"><a href="#🔍-阶段-2：找出“可被破坏的关键字段”（Field-Discovery）" class="headerlink" title="🔍 阶段 2：找出“可被破坏的关键字段”（Field Discovery）"></a>🔍 阶段 2：找出“可被破坏的关键字段”（Field Discovery）</h3><p><strong>问题</strong>：一个结构体有几十个字段，破坏哪个才有用？</p>
<p><strong>SCAVY 的做法</strong>：</p>
<ul>
<li>对每个字段（4~8 字节）注入随机值；</li>
<li>用 <strong>硬件观察点（watchpoint）</strong> 监控：这个字段是否被读取？</li>
<li>如果被读了 → 说明它“可能影响程序逻辑” → 标记为潜在目标。</li>
</ul>
<p>💡 <strong>为什么有效</strong>？<br>因为如果字段从未被使用，破坏它毫无意义；一旦被读，就可能改变控制流或权限判断。</p>
<hr>
<h3 id="⚔️-阶段-3：验证“破坏后能否提权”（Privilege-Escalation-Detection）"><a href="#⚔️-阶段-3：验证“破坏后能否提权”（Privilege-Escalation-Detection）" class="headerlink" title="⚔️ 阶段 3：验证“破坏后能否提权”（Privilege Escalation Detection）"></a>⚔️ 阶段 3：验证“破坏后能否提权”（Privilege Escalation Detection）</h3><p>这是最核心的创新！</p>
<h4 id="挑战："><a href="#挑战：" class="headerlink" title="挑战："></a>挑战：</h4><ul>
<li>很多破坏会导致立即崩溃（“过早崩溃”），来不及执行提权操作；</li>
<li>如何判断“这次崩溃真的能提权”？</li>
</ul>
<h4 id="SCAVY-的解决方案：三次对比执行（Differential-Analysis）"><a href="#SCAVY-的解决方案：三次对比执行（Differential-Analysis）" class="headerlink" title="SCAVY 的解决方案：三次对比执行（Differential Analysis）"></a>SCAVY 的解决方案：<strong>三次对比执行（Differential Analysis）</strong></h4><p>对同一个测试用例，运行三次：</p>
<table>
<thead>
<tr>
<th align="left">运行</th>
<th align="left">内存状态</th>
<th align="left">目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Run A</strong></td>
<td align="left">正常（无破坏）</td>
<td align="left">基线：所有特权操作应失败</td>
</tr>
<tr>
<td align="left"><strong>Run B</strong></td>
<td align="left">注入<strong>随机值</strong>破坏</td>
<td align="left">测试是否产生异常行为</td>
</tr>
<tr>
<td align="left"><strong>Run C</strong></td>
<td align="left">注入<strong>从 root 进程复制的有效值</strong></td>
<td align="left">模拟“完美伪造”，看能否成功提权</td>
</tr>
</tbody></table>
<p>然后比较三者的：</p>
<ul>
<li>系统调用返回值（如 <code>write()</code> 是否成功）</li>
<li>输出数据（如读到的文件内容）</li>
<li>访问被破坏内存的指令</li>
<li>代码覆盖率（用 Jaccard 相似度 &gt;0.9 判同）</li>
</ul>
<p>✅ <strong>如果 Run C 和 Run A 行为不同（比如原本失败的 <code>write</code> 成功了）→ 判定为可提权！</strong></p>
<blockquote>
<p>举个例子： </p>
<ul>
<li>正常时写 <code>/etc/passwd</code> 失败（权限拒绝）； </li>
<li>破坏 <code>file-&gt;f_cred</code> 后，写成功了 → 说明获得了 root 权限！</li>
</ul>
</blockquote>
<hr>
<p>核心就是替换某个kernel object的某个field为root所在进程的对应值，看权限是否发生变化</p>
<p>传统方案只能检测crash，或者监测到能利用的比较少，本文的方法能检测到的可利用位置更多</p>
<p>本文自动化检测出的位置，仍然需要人工验证</p>
<ol>
<li>某个object的某个field 的确能导致权限提升。（实际上存在false positive）</li>
<li>进一步，利用真实的CVE，完成对于某个object的某个field的覆盖和利用，真正达到提权的效果</li>
</ol>
<p>人工验证后的成果：</p>
<table>
<thead>
<tr>
<th>CVE</th>
<th>CWE</th>
<th>Exploited Struct&#x2F;Field</th>
</tr>
</thead>
<tbody><tr>
<td>2017-7308</td>
<td>Type Conversion</td>
<td><code>vm_area_struct::vm_file</code></td>
</tr>
<tr>
<td>2017-7184</td>
<td>Input Validation</td>
<td><code>vm_area_struct::vm_file</code></td>
</tr>
<tr>
<td>2010-2959</td>
<td>Int Overflow</td>
<td><code>kioctx::internal_pages</code></td>
</tr>
<tr>
<td>2016-0728</td>
<td>Use-After-Free</td>
<td><code>key::description</code></td>
</tr>
<tr>
<td>2022-27666*</td>
<td>OOB Write</td>
<td><code>vm_area_struct::vm_file</code></td>
</tr>
<tr>
<td>2022-27666*</td>
<td>OOB Write</td>
<td><code>file::f_mapping</code></td>
</tr>
<tr>
<td>2009-3547</td>
<td>nullptr deref.</td>
<td><code>pipe_inode_info::bufs</code></td>
</tr>
<tr>
<td>2014-3153</td>
<td>Input Validation</td>
<td><code>cred::euid</code></td>
</tr>
<tr>
<td>2017-11176</td>
<td>Use-After-Free</td>
<td><code>task_struct::cred</code></td>
</tr>
<tr>
<td>2004-1235</td>
<td>Race condition</td>
<td><code>file_struct::fops</code></td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2026/02/12/papers/SLUBStick%20Arbitrary%20Memory%20Writes%20through%20Practical%20Software%20Cross-Cache%20Attackswithin%20the%20Linux%20Kernel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/12/papers/SLUBStick%20Arbitrary%20Memory%20Writes%20through%20Practical%20Software%20Cross-Cache%20Attackswithin%20the%20Linux%20Kernel/" class="post-title-link" itemprop="url">SLUBStick: Arbitrary Memory Writes through Practical Software Cross-Cache Attacks within the Linux Kernel</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2026-02-12 21:43:37" itemprop="dateCreated datePublished" datetime="2026-02-12T21:43:37+08:00">2026-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-14 13:01:38" itemprop="dateModified" datetime="2026-02-14T13:01:38+08:00">2026-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>8 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SLUBStick-Arbitrary-Memory-Writes-through-Practical-Software-Cross-Cache-Attacks-within-the-Linux-Kernel"><a href="#SLUBStick-Arbitrary-Memory-Writes-through-Practical-Software-Cross-Cache-Attacks-within-the-Linux-Kernel" class="headerlink" title="SLUBStick: Arbitrary Memory Writes through Practical Software Cross-Cache Attacks within the Linux Kernel"></a>SLUBStick: Arbitrary Memory Writes through Practical Software Cross-Cache Attacks within the Linux Kernel</h1><p>Usenix Security‘24</p>
<p><a target="_blank" rel="noopener" href="https://github.com/isec-tugraz/SLUBStick/tree/main">https://github.com/isec-tugraz/SLUBStick/tree/main</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li>传统的内存漏洞，比如UAF DF OOB 都需要依赖更进一步的方式完成利用（提权）。需要依赖Linux slab、buddy system分配内存的模式，利用成功率不高，然后很容易被修复（对高版本linux无效）</li>
<li>slab分配器，会在空闲对象过多的时候 把这块完整的内存页还给buddy system</li>
</ol>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>整体利用思路：</p>
<ol>
<li>用传统内存漏洞构造一个悬挂指针的情况（所在内存页已经归还 但是仍然可以写数据）</li>
<li>释放所在的slab 直到还给buddysystem</li>
<li>让这个可被写的对象所在内存页重新分配为用户态页表页</li>
<li>修改用户态页表页 完成任意地址映射</li>
</ol>
<p>挑战：</p>
<ol>
<li>如何稳定回收并复用这个page</li>
<li>怎么把准备好的数据通过悬垂指针写到这个page上</li>
<li>怎么改映射达成任意地址读写</li>
</ol>
<h2 id="利用过程详细解释"><a href="#利用过程详细解释" class="headerlink" title="利用过程详细解释"></a>利用过程详细解释</h2><ol>
<li>free某个object 如何做到这个object所在的page会还给buddy system？</li>
</ol>
<ul>
<li>拥有这个object所在的slab上的其他所有object，同时释放其他所有object</li>
</ul>
<ol start="2">
<li>如何拥有一个victim object所在slab上的其他所有object？</li>
</ol>
<ul>
<li>通过open(‘&#x2F;dev&#x2F;xxx’)反复申请并占用 阅读源码可以找到不同size的都有</li>
</ul>
<ol start="3">
<li>如何判断这些从内核拿到的object会和victim object在一个slab上？</li>
</ol>
<ul>
<li>通过add_key这个系统调用测量时间，当一个slab消耗完以后，从buddy system再拿新的slab会明显变慢。add_key故意失败 会一次malloc+一次free 可重入，没有其他时间干扰 噪声小。因此一次add_key+一次open就可以得知open拿到的内核object是否和上一次在同一个slab上</li>
</ul>
<ol start="4">
<li>victim object所在page还给buddy system后 如何再次分配这个页面？</li>
</ol>
<ul>
<li>buddy system是LIFO的，再次申请这个大小即可。使用mmap+memset 这个page会被分配为PUD页表页</li>
</ul>
<ol start="5">
<li>如何修改页表？</li>
</ol>
<ul>
<li>利用悬垂指针。用有漏洞的内核模块和正常的内核模块构造出正常内核object所在内存页被free但是仍然可以通过ioctl访问服务的情况，在服务中copy一份伪造的PUD页表页数据。</li>
</ul>
<ol start="6">
<li>利用悬垂指针修改页表需要利用内核本身提供的服务，限制多，需要保证两个时间窗口的满足。1 kmalloc到copy_from_user之间，需要free所有slab到buddy system完成 否则PUD页不一定是悬垂指针指向的页。 2 完成服务到free obejct时间需要足够长 否则没有完成后续的攻击 这个PUD页就被回收 修改数据了。</li>
</ol>
<ul>
<li>使用FUSE，自己写fuse 在fuse_read中加入sleep，然后挂载到某个文件夹，copy_from_user传入文件fd读数据，在发生读的时候会到用户态FUSE控制。</li>
</ul>
<ol start="7">
<li>伪造的PUD可能只有8byte，也就是一个PTE有效，只能访问1G物理内存，且不可重入。</li>
</ol>
<ul>
<li>再次大范围mmap+memset，然后检查这1G物理内存的内存数据，如果发现之前不是PTE但之后是PTE，说明这个page变成了最后一级页表页，修改这个PTE即可完成对容易物理地址的映射。</li>
</ul>
<ol start="8">
<li>修改页表，如何确定&#x2F;etc&#x2F;passwd所在物理内存？</li>
</ol>
<ul>
<li>&#x2F;etc&#x2F;passwd权限是可读的，读了以后存在在内核的page cache。page cache都是完整的页，直接比较前若干的字符即可</li>
<li>遍历pfn 16G内存可以全部遍历比较，循环总体时间在可接受范围内(16G&#x2F;4K&#x3D;4M  4M*1us&#x3D;4s) 总体可控制在分钟量级</li>
<li>最后达到的效果其实是，可改页表映射整个地址范围，然后任意物理地址读</li>
</ul>
<p>一些细节：</p>
<p>先根据漏洞的存在double free的object的size 找到对应的内核对象</p>
<ol>
<li>alloc vuln</li>
<li>free vuln</li>
<li>open 此时从slab中拿到vuln所在地址给另一个内核对象</li>
<li>free vuln</li>
<li>free 整个slab给buddy system</li>
</ol>
<p>此时达到效果：拥有一个内核对象可以通过ioctl交互 并且这个内核对象所在的地址已经被释放到buddy system中</p>
<p>下一次ioctl copy_from_user会copy到页表上</p>
<p>立即复制了一份假的PUD页表页 512项 每项指向一个1G大页，从4G开始 （这一步已经可以通过va访问512G内存了 直接遍历猜passwd不是一样吗？）实际上内核不会存在这么好用的情况 实际上可能只能写入部分byte 导致控制的内存范围比较小 并且由于内核的限制不能遍历范围反复尝试 只能触发一次 如果只写了8byte 那么相当于只能控制1G的内存空间 所以后续要基于这个1G的空间来做</p>
<p>这解释了为什么后续data明明只mmap了一个页，但是可以访问PGD 因为mmap+memset以后 补全了一个PUD页表页 而这个被补全的PUD页表页来自刻意释放到buddy system 后续通过悬挂指针copy from user制造的假的PUD pte信息。（实际上不是修改512G 而是某个1G 所以需要捕获异常）</p>
<p>然后遍历地址空间 再找到PUD页表页的地址</p>
<p>之前这个页还是内核控制 用户态无法访问 但是现在已经改了页表 用户态可以直接读写了</p>
<p>先随便找个地址mmap 拿到一个虚拟地址，此时memset触发PUD分配，然后之后用这个虚拟地址就可以访问全部的物理地址了。</p>
<p>current_addr记录的是用于访问PUD的va</p>
<p>直接硬猜，遍历每个4K页的开头 如果发现格式是PTE 那就认为这个page 是最后一级page table</p>
<p>某个ioctl+内部的copy from user 实际上实现的是替换了PUD页表页中的某个pude 让进程可以访问某个1G的物理地址空间 对应图8b</p>
<p>然后需要找一下 是哪个1G被映射上 可以被访问了</p>
<p>mmap是映射了PGD 512G 然后1G 1G看 没有映射上的就会被错误处理然后跳过 映射上的就可以访问 记录为current_addr 这是访问这1G的起始地址</p>
<p>遍历这个1G 4K粒度看第一个8byte是不是PTE格式</p>
<p>然后找个最大的地址 1&lt;&lt;46 生成大量页表页</p>
<p>然后再遍历这个1G 如果发现原来不是PTE 现在是PTE 那么说明这个1G中存在一个页表页 我们可以读写这1G 就可以读写这个PTE</p>
<p>keyctl_pkey_verify 调用memdup_user</p>
<p>先kmalloc然后copy_from_user size和src由用户态提供 提供伪造的PUD数据</p>
<p>保证两个时间窗口</p>
<ol>
<li>kmalloc以后 copy之前 需要已经被分配为页表页 否则元数据会被覆盖</li>
<li>成功修改页表以后 需要延迟释放kernel object 否则后续漏洞利用没有时间完成</li>
</ol>
<p>使用fuse 用户态 不需要特权</p>
<p>自己写一个fuse_read 然后挂在到某个目录下 之后open这个目录下的文件 内核copy_from_user会到fuse_read处理，此时直接sleep即可</p>
<p>总体利用顺序：</p>
<ol>
<li>有一个有漏洞的内核驱动，和一个正常提供服务的内核模块，两个object的size一样。</li>
<li>alloc A free A alloc B freeA 把B所在的object还给slab了</li>
<li>获得该slab上的其他所有对象 全free掉 B所在的页还给buddysystem</li>
<li>addr&#x3D;mmap+memset 使得刚换给buddy system的页变为PUD页</li>
<li>通过ioctl访问B的服务 copy_from_user准备一份假的PUD数据，包含512个大页PTE，预期可以正常映射1页。</li>
<li>此时进行获得了访问1G物理地址的能力，这个物理地址是通过addr访问的，遍历可以找出来</li>
<li>在大地址下，再次mmap+memset，再次分配大量页表页，在addr可控的1G内根据PTE格式寻找页表页</li>
<li>修改页表页的PTE，指向任意物理地址</li>
</ol>
<p>一些巧妙的地方：</p>
<ol>
<li>控制victim object所在的所有slab对象同时被free 使得整个page被free到buddy system 然后通过LIFO再拿出来</li>
<li>将受控的page作为PUD页表页，通过修改映射的方式获取一个很强的攻击原语</li>
<li>利用FUSE暂停内核态copy_from_user的处理，控制时间，在内核可利用能力受限的情况下稳定利用。</li>
<li>遍历整个物理地址空间比较内存数据。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2026/02/12/papers/BUDAlloc%20Defeating%20Use-After-Free%20Bugs%20by%20Decoupling%20Virtual%20Address%20Management%20from%20Kernel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/12/papers/BUDAlloc%20Defeating%20Use-After-Free%20Bugs%20by%20Decoupling%20Virtual%20Address%20Management%20from%20Kernel/" class="post-title-link" itemprop="url">BUDAlloc: Defeating Use-After-Free Bugs by Decoupling Virtual Address Management from Kernel</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2026-02-12 13:54:53 / Modified: 16:13:24" itemprop="dateCreated datePublished" datetime="2026-02-12T13:54:53+08:00">2026-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>5 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="BUDAlloc-Defeating-Use-After-Free-Bugs-by-Decoupling-Virtual-Address-Management-from-Kernel"><a href="#BUDAlloc-Defeating-Use-After-Free-Bugs-by-Decoupling-Virtual-Address-Management-from-Kernel" class="headerlink" title="BUDAlloc: Defeating Use-After-Free Bugs by Decoupling Virtual Address Management from Kernel"></a>BUDAlloc: Defeating Use-After-Free Bugs by Decoupling Virtual Address Management from Kernel</h1><p>Usenix Security 24</p>
<p><a target="_blank" rel="noopener" href="https://github.com/casys-kaist/BUDAlloc/tree/main">https://github.com/casys-kaist/BUDAlloc/tree/main</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>UAF：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br></pre></td></tr></table></figure>

<p>p1 p2是不同模块 使用的内存是同一块，所以仍然可以通过p1访问p2 修改内核关键数据结构提权</p>
<p>解决方案：OTA</p>
<blockquote>
<p>In a basic OTA implementation, each object is allocated on a separate page, which is unmapped when the object is freed</p>
</blockquote>
<p>p1 free以后 在操作系统上没有限制 理论上应该立即unmap 这样访问p1就会被page fault拦截</p>
<p>但是malloc粒度小，unmap必须4K粒度</p>
<p>解决方案：virtual alias</p>
<p>VA PA中 分配的object仍然是连续的</p>
<p>但是会在VA中为每个object开辟单独的内存页 返回alias地址给用户用 实际上映射的还是PA</p>
<p>但是这个每个object单独的页就可以被方便地unmap</p>
<p>举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">p3 = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>VA中 p1 p2 p3的object分别为0xf000 0xf008 0xf010</p>
<p>PA中 分别为0x1000 0x1008 0x1010</p>
<p>创建三个别名</p>
<p>VA1 &#x3D; 0xf1 0000</p>
<p>VA2 &#x3D; 0xf2 0000</p>
<p>VA3 &#x3D; 0xf3 0000</p>
<p>建立映射</p>
<p>VA 0xf000 - PA 0x1000</p>
<p>VA1 0xf1 0000 - PA 0x1000</p>
<p>VA2 0xf2 0000 - PA 0x1000</p>
<p>VA3 0xf3 0000 - PA 0x1000</p>
<p>p1 &#x3D; VA1</p>
<p>p2 &#x3D; VA2 + 0x8</p>
<p>p3 &#x3D; VA3 + 0x10</p>
<p>达到很好的效果：</p>
<ul>
<li>物理地址是不影响 不浪费的 不会有碎片</li>
<li>虚拟地址空间需要很大 但是本身是虚拟地址所以无所谓</li>
<li>每个小object被free后都可以立即unmap</li>
</ul>
<p>存在的问题：</p>
<ol>
<li>malloc的时候需要syscall一次 不然没法传递给内核map的信息</li>
<li>free的时候需要syscall一次 立即unmap防止UAF</li>
<li>map&#x2F;unmap涉及到内核的锁 串行化</li>
</ol>
<p>导致性能差</p>
<h2 id="BUDAlloc设计"><a href="#BUDAlloc设计" class="headerlink" title="BUDAlloc设计"></a>BUDAlloc设计</h2><ol>
<li>用户态用一个trie树记录alias的映射，不立即mremap，而是等一次page fault。page fault时 内核从共享的trie树中找地址。实际上可以prefault 一次page fault handler中根据metadata把之后的都补上映射</li>
<li>延迟unmap。每次free后只是记录metadata，等到下一次page fault再batch处理。 一定无法保证正确性，但实践中发现，这个window非常小，已经可以保护几乎所有CVE的UAF场景。</li>
<li>用eBPF提供page fault handler</li>
<li>用户态决定一个伪PA，kernel再把伪PA翻译成真PA，这里把并发的锁控制从内核的buddy system等转移到了用户态，用户态可以有更多的语义信息和并发控制算法，提高可扩展性</li>
</ol>
<p>天然具有的兼容性：</p>
<ol>
<li>On demand paging</li>
<li>Copy on write</li>
<li>proc file system</li>
</ol>
<p>兼容性存在问题的地方：</p>
<ol>
<li>reverse map</li>
<li>PTE ref count</li>
</ol>
<p>（工程型问题，都解决了）</p>
<p><strong>对应用程序透明，可执行二进制文件是不需要修改的</strong></p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>关注如下几点：</p>
<ol>
<li>UAF CVE是否完全防御</li>
<li>性能</li>
<li>多核性能 可扩展性</li>
<li>memory overhead</li>
<li>程序兼容性</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2026/02/11/papers/PrometheusMigrate%20Efficient%20Live%20Migration%20of%20Confidential%20Virtual%20Machine%20with%20Software%20Abstraction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/11/papers/PrometheusMigrate%20Efficient%20Live%20Migration%20of%20Confidential%20Virtual%20Machine%20with%20Software%20Abstraction/" class="post-title-link" itemprop="url">PrometheusMigrate: Efficient Live Migration of Confidential Virtual Machine with Software Abstraction</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2026-02-11 13:53:50" itemprop="dateCreated datePublished" datetime="2026-02-11T13:53:50+08:00">2026-02-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-12 12:46:29" itemprop="dateModified" datetime="2026-02-12T12:46:29+08:00">2026-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>471</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="PrometheusMigrate-Efficient-Live-Migration-of-Confidential-Virtual-Machine-with-Software-Abstraction"><a href="#PrometheusMigrate-Efficient-Live-Migration-of-Confidential-Virtual-Machine-with-Software-Abstraction" class="headerlink" title="PrometheusMigrate: Efficient Live Migration of Confidential Virtual Machine with Software Abstraction"></a>PrometheusMigrate: Efficient Live Migration of Confidential Virtual Machine with Software Abstraction</h1><p>背景：</p>
<ol>
<li>传统vm migration：source destination建立一个通信通道，page by page传数据，track dirty page，低于一个阈值以后stop the world，由qemu来做</li>
<li>sev vm migration，qemu不能访问cvm的private memory，所以需要调用sev firmware的api，firmware进行解密，然后用传输密钥加密，另一段进行类似的操作。firmware有专门的处理器，计算能力很弱，导致migration特别慢</li>
</ol>
<p>设计：</p>
<ol>
<li>给guest 额外的vcpu用于vm migration</li>
<li>guest mode下 不需要解密，可以直接获得明文，所以自己用一个AES加密就可以发送给destination</li>
<li>两侧的guest建立一个通信通道 用AES加解密即可</li>
</ol>
<p>2000s-34s</p>
<p>比baseline还差很多 因为baseline不需要加解密</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2026/02/10/papers/PipeLLM%20Fast%20and%20Confidential%20Large%20Language%20Model%20Services%20with%20Speculative%20Pipelined%20Encryption/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/10/papers/PipeLLM%20Fast%20and%20Confidential%20Large%20Language%20Model%20Services%20with%20Speculative%20Pipelined%20Encryption/" class="post-title-link" itemprop="url">PipeLLM: Fast and Confidential Large Language Model Services with Speculative Pipelined Encryption</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2026-02-10 15:37:04" itemprop="dateCreated datePublished" datetime="2026-02-10T15:37:04+08:00">2026-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-12 12:46:29" itemprop="dateModified" datetime="2026-02-12T12:46:29+08:00">2026-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>970</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>4 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="PipeLLM-Fast-and-Confidential-Large-Language-Model-Services-with-Speculative-Pipelined-Encryption"><a href="#PipeLLM-Fast-and-Confidential-Large-Language-Model-Services-with-Speculative-Pipelined-Encryption" class="headerlink" title="PipeLLM: Fast and Confidential Large Language Model Services with Speculative Pipelined Encryption"></a>PipeLLM: Fast and Confidential Large Language Model Services with Speculative Pipelined Encryption</h1><p>背景：</p>
<ol>
<li>英伟达 GPU 也提供了机密计算 类似CPU侧的TDX SEV 提供一个host不可访问的enclave 避免被攻击偷数据</li>
<li>CVM中对private memory 也就是被CPU加密的私有内存调用cuda memcpy 会自动先出发CPU侧的AES加密 然后放到CVM shmem中 给GPU DMA 然后GPU解密。 加密用到的IV是两个硬件初始化的时候自动生成的 不需要每次通信。</li>
<li>在大模型推理 训练服务中，CPU GPU数据传输过程中的加解密存在关键路径上，overhead很大（由于GPU内存比模型小，所以一定存在swap）</li>
</ol>
<p>对于一次推理，目前的CC是CPU swap 同步加密 GPU等待 然后计算 然后CPU同步解密</p>
<p>实际上CPU加解密和GPU计算是可以并行的</p>
<p>需要预测GPU后续需要哪些数据 让CPU提前加密传输过去</p>
<p>只关注模型参数卸载和kv cache swap</p>
<p>如何预测后面要用哪个？（swap-in）</p>
<p>app使用的pattern是固定的：</p>
<ul>
<li>大模型推理 FlexGen 需要卸载模型参数 pattern是重复的 layer1 layer2 layer3</li>
<li>中等模型推理 vLLM 需要swap kv cache 使用FIFO和LIFO</li>
<li>chunk大小一般大于128K 有明显特征</li>
</ul>
<p>具体实现</p>
<p>cuda library中 cudaMemcpyAsync中</p>
<p>判断if (enable_encrypt &amp;&amp; kind &#x3D;&#x3D; cudaMemcpyHostToDevice &amp;&amp; count &gt;&#x3D; encrypt_threshold_sz)  </p>
<p>进行预测</p>
<p>否则用原来的同步copy</p>
<p><a target="_blank" rel="noopener" href="https://github.com/SJTU-IPADS/PipeLLM">https://github.com/SJTU-IPADS/PipeLLM</a></p>
<p>预测基于每次cudaMemcpyAsync中记录的之前的record</p>
<p>是一个tuple 分为src和size 判断重复只需要判断record是不是一样</p>
<p>PipeLLM：</p>
<ol>
<li>修改cuda libaray 对用户透明</li>
<li>cudaMemcpyAsync中 根据不同workload提前分析的pattern 把同步改为异步</li>
<li>CPU异步加解密和GPU计算并行</li>
<li>overhead可以从50%-80%降低到19%</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2026/02/03/virtualization/SEV%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/03/virtualization/SEV%E6%BC%8F%E6%B4%9E/" class="post-title-link" itemprop="url">SEV漏洞</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2026-02-03 20:53:45 / Modified: 20:53:51" itemprop="dateCreated datePublished" datetime="2026-02-03T20:53:45+08:00">2026-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/virtualization/" itemprop="url" rel="index"><span itemprop="name">virtualization</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>553</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SEV漏洞"><a href="#SEV漏洞" class="headerlink" title="SEV漏洞"></a>SEV漏洞</h1><h2 id="1-sev-io"><a href="#1-sev-io" class="headerlink" title="1. sev io"></a>1. sev io</h2><ol>
<li>通过sshd特殊的二进制代码标记 识别到guest加载sshd 替换验证函数的5个字节 永远返回true</li>
<li>构建解密数据库 当有数据从vm发出时host写guest的内存 然后可以从bouncebuffer拿到解密后的数据<br>任意c 得到m 可以破解任何加密数据3 构建解密数据库 给vm发数据 修改bounce buffer 再读guest内存<br>任意m 得到c</li>
<li>可以往vm内存插任意数据和代码</li>
</ol>
<h2 id="2-SEVered"><a href="#2-SEVered" class="headerlink" title="2. SEVered"></a>2. SEVered</h2><p>如果guest的某个http接口提供一个服务 可以拿数据<br>先通过invalidate所有host page的方式找到某个resource的page列表 然后remap到自己想要解密的memory上 就可以让guest帮忙解密以后通过http发出来</p>
<h2 id="3-crossline"><a href="#3-crossline" class="headerlink" title="3. crossline"></a>3. crossline</h2><p>attack vm的asid填入victim vm的 然后就有victim的key 通过修改页表指向victim获得victim vm内存数据</p>
<h2 id="4-cipherleak"><a href="#4-cipherleak" class="headerlink" title="4. cipherleak"></a>4. cipherleak</h2><p>vmsa物理地址不变 观察rax密文 得到映射表用sev step 识别pattern 读rax得到某些结果 和应用程序有关<br>如cpuid指令 触发vc handler ghcb读真raxsnp并没有用rmp限制读对内存 观察变或不变 泄露key</p>
<h2 id="5-cachewarp"><a href="#5-cachewarp" class="headerlink" title="5. cachewarp"></a>5. cachewarp</h2><p>invd指令</p>
<h2 id="6-helker"><a href="#6-helker" class="headerlink" title="6. helker"></a>6. helker</h2><p>插入int 0x80中断</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2026/02/03/virtualization/TDX%20module/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/03/virtualization/TDX%20module/" class="post-title-link" itemprop="url">TDX module</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2026-02-03 20:38:46 / Modified: 20:39:55" itemprop="dateCreated datePublished" datetime="2026-02-03T20:38:46+08:00">2026-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/virtualization/" itemprop="url" rel="index"><span itemprop="name">virtualization</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>96k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>5:47</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="TDX-module"><a href="#TDX-module" class="headerlink" title="TDX module"></a>TDX module</h1><p><a target="_blank" rel="noopener" href="https://github.com/amd/AMD-ASPFW/blob/main/fw/psp_bl_uapps/sev_uapp/src/sev_dispatch.c">https://github.com/amd/AMD-ASPFW/blob/main/fw/psp_bl_uapps&#x2F;sev_uapp&#x2F;src&#x2F;sev_dispatch.c</a></p>
<h2 id="tdx"><a href="#tdx" class="headerlink" title="tdx"></a>tdx</h2><h3 id="tdcall"><a href="#tdcall" class="headerlink" title="tdcall"></a>tdcall</h3><p><a target="_blank" rel="noopener" href="https://github.com/intel/tdx-module/blob/tdx_1.5/src/td_dispatcher/tdx_td_dispatcher.c">https://github.com/intel/tdx-module/blob/tdx_1.5&#x2F;src&#x2F;td_dispatcher&#x2F;tdx_td_dispatcher.c</a></p>
<p>rcx 是通用寄存器 bitmap 决定哪些寄存器会从 td 传到 vmm 避免被 tdx module 清零</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">noinstr u64 __tdx_hypercall(<span class="keyword">struct</span> tdx_module_args *args)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * For TDVMCALL explicitly set RCX to the bitmap of shared registers.</span></span><br><span class="line"><span class="comment">         * The caller isn&#x27;t expected to set @args-&gt;rcx anyway.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        args-&gt;rcx = TDVMCALL_EXPOSE_REGS_MASK;</span><br><span class="line">s</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Failure of __tdcall_saved_ret() indicates a failure of the TDVMCALL</span></span><br><span class="line"><span class="comment">         * mechanism itself and that something has gone horribly wrong with</span></span><br><span class="line"><span class="comment">         * the TDX module.  __tdx_hypercall_failed() never returns.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (__tdcall_saved_ret(TDG_VP_VMCALL, args))</span><br><span class="line">                __tdx_hypercall_failed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* TDVMCALL leaf return code is in R10 */</span></span><br><span class="line">        <span class="keyword">return</span> args-&gt;r10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tdx module 记录所有通用寄存器并清零</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl tdx_tdexit_entry_point</span><br><span class="line">.globl tdx_tdentry_to_td</span><br><span class="line"></span><br><span class="line">tdx_tdexit_entry_point:</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Save all TD GPRs on module entry to LP local data</span><br><span class="line">     * Local data is located at GSBASE</span><br><span class="line">     */</span><br><span class="line">    movq %rax,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET</span><br><span class="line">    movq %rcx,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+8</span><br><span class="line">    movq %rdx,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+16</span><br><span class="line">    movq %rbx,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+24</span><br><span class="line">    movq %rsp,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+32</span><br><span class="line">    movq %rbp,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+40</span><br><span class="line">    movq %rsi,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+48</span><br><span class="line">    movq %rdi,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+56</span><br><span class="line">    movq %r8,   %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+64</span><br><span class="line">    movq %r9,   %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+72</span><br><span class="line">    movq %r10,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+80</span><br><span class="line">    movq %r11,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+88</span><br><span class="line">    movq %r12,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+96</span><br><span class="line">    movq %r13,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+104</span><br><span class="line">    movq %r14,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+112</span><br><span class="line">    movq %r15,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+120</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * clear TD GPRs on entry to the TDX module</span><br><span class="line">         */</span><br><span class="line">    xor %rax, %rax</span><br><span class="line">    xor %rcx, %rcx</span><br><span class="line">    xor %rdx, %rdx</span><br><span class="line">    xor %rbx, %rbx</span><br><span class="line">    xor %rbp, %rbp</span><br><span class="line">    xor %rsi, %rsi</span><br><span class="line">    xor %rdi, %rdi</span><br><span class="line">    xor %r8, %r8</span><br><span class="line">    xor %r9, %r9</span><br><span class="line">    xor %r10, %r10</span><br><span class="line">    xor %r11, %r11</span><br><span class="line">    xor %r12, %r12</span><br><span class="line">    xor %r13, %r13</span><br><span class="line">    xor %r14, %r14</span><br><span class="line">    xor %r15, %r15</span><br><span class="line"></span><br><span class="line">    // Protection against speculative attacks on GPRs</span><br><span class="line">    lfence</span><br><span class="line"></span><br><span class="line">    // Choose which dispatcher we want to call based on current TD VM,</span><br><span class="line">    // stored in local data before the TD entry</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_CURRENT_TD_VM_ID_OFFSET, %rax</span><br><span class="line">    test %rax, %rax</span><br><span class="line">    jnz l2_dispatcher</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Call the VMM API dispatcher</span><br><span class="line">     */</span><br><span class="line">    callq tdx_td_dispatcher</span><br><span class="line">     </span><br><span class="line">    /**</span><br><span class="line">     * Unreachable code.  panic. </span><br><span class="line">     */</span><br><span class="line">    ud2</span><br><span class="line"></span><br><span class="line">l2_dispatcher:</span><br><span class="line"></span><br><span class="line">    callq tdx_td_l2_dispatcher</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Unreachable code.  panic.</span><br><span class="line">     */</span><br><span class="line">    ud2</span><br></pre></td></tr></table></figure>

<p>gs 寄存器往后偏移的数据作为 local_data 的基地址</p>
<p>local_data_fast_ref_ptr 存的就是 local_data 的地址</p>
<p>这样做默认了 gs base 就是 local_data 为什么不直接读？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tdx_td_dispatcher</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">tdx_module_local_t</span>* tdx_local_data_ptr = get_local_data();</span><br><span class="line">            _STATIC_INLINE_ <span class="type">tdx_module_local_t</span>* <span class="title function_">get_local_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">uint64_t</span> local_data_addr;</span><br><span class="line">            </span><br><span class="line">                _ASM_ (<span class="string">&quot;movq %%gs:%c[local_data], %0\n\t&quot;</span></span><br><span class="line">                         :<span class="string">&quot;=r&quot;</span>(local_data_addr)</span><br><span class="line">                         :[local_data]<span class="string">&quot;i&quot;</span>(offsetof(<span class="type">tdx_module_local_t</span>, local_data_fast_ref_ptr)));</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">return</span> (<span class="type">tdx_module_local_t</span>*)local_data_addr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">vm_vmexit_exit_reason_t</span> vm_exit_reason;</span><br><span class="line">    <span class="type">vmx_exit_qualification_t</span> vm_exit_qualification;</span><br><span class="line">    <span class="type">vmx_exit_inter_info_t</span> vm_exit_inter_info;</span><br><span class="line"></span><br><span class="line">    <span class="type">vmx_guest_inter_state_t</span> guest_inter_state;</span><br><span class="line">    <span class="type">vmx_procbased_ctls_t</span> vm_procbased_ctls;</span><br><span class="line"></span><br><span class="line">    <span class="type">td_param_attributes_t</span> attr;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool_t</span> interrupt_occurred = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> vm_id = tdx_local_data_ptr-&gt;vp_ctx.tdvps-&gt;management.curr_vm;</span><br><span class="line"></span><br><span class="line">    tdx_sanity_check((vm_id == tdx_local_data_ptr-&gt;current_td_vm_id) &amp;&amp; (vm_id == <span class="number">0</span>),</span><br><span class="line">                     SCEC_TD_DISPATCHER_SOURCE, <span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">    stepping_filter_e vmexit_stepping_result;</span><br><span class="line">    vmexit_stepping_result = tdx_td_l1_l2_dispatcher_common_prologue(tdx_local_data_ptr, <span class="number">0</span>, &amp;vm_exit_reason,</span><br><span class="line">                                    &amp;vm_exit_qualification, &amp;vm_exit_inter_info);</span><br><span class="line"></span><br><span class="line">                stepping_filter_e <span class="title function_">tdx_td_l1_l2_dispatcher_common_prologue</span><span class="params">(<span class="type">tdx_module_local_t</span>* local_data, <span class="type">uint16_t</span> vm_id,</span></span><br><span class="line"><span class="params">                            <span class="type">vm_vmexit_exit_reason_t</span>* vm_exit_reason, <span class="type">vmx_exit_qualification_t</span>* vm_exit_qualification,</span></span><br><span class="line"><span class="params">                            <span class="type">vmx_exit_inter_info_t</span>* vm_exit_inter_info)</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">tdx_module_global_t</span>* tdx_global_data_ptr = get_global_data();</span><br><span class="line">                    </span><br><span class="line">                        TDX_LOG(<span class="string">&quot;TD Dispatcher Entry from VM %d\n&quot;</span>, vm_id);</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Execute the BHB defense sequence</span></span><br><span class="line">                        <span class="keyword">if</span> (tdx_global_data_ptr-&gt;rtm_supported)</span><br><span class="line">                        &#123;</span><br><span class="line">                            tsx_abort_sequence();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// BHB draining sequence</span></span><br><span class="line">                            <span class="comment">// There are 6 taken branches in each iteration (one CALL, four JMPs, and one JNZ),</span></span><br><span class="line">                            <span class="comment">// so for GLC (194 branch stews in BHB), NUM_ITERS = round-up(194 / 6) = 32.</span></span><br><span class="line">                            <span class="type">uint64_t</span> num_iters = NUM_OF_BHB_CLEARING_ITERATIONS;</span><br><span class="line">                            <span class="type">uint64_t</span> num_iters_multi_8 = <span class="number">8</span>*num_iters;</span><br><span class="line">                    </span><br><span class="line">                            _ASM_VOLATILE_ (</span><br><span class="line">                                <span class="string">&quot;movq %0, %%rcx\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;1:  call 2f\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;lfence\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;2:  jmp 3f\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;nop\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;3:  jmp 4f\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;nop\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;4:  jmp 5f\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;nop\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;5:  jmp 6f\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;nop\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;6:  dec %%rcx\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;jnz 1b\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;add %1, %%rsp\n&quot;</span></span><br><span class="line">                                <span class="string">&quot;lfence\n&quot;</span></span><br><span class="line">                                : : <span class="string">&quot;a&quot;</span>(num_iters), <span class="string">&quot;b&quot;</span>(num_iters_multi_8) : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;rcx&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Save current time to verify on next TD entry and for TDEXIT filter checks</span></span><br><span class="line">                        local_data-&gt;vp_ctx.tdvps-&gt;management.last_exit_tsc = ia32_rdtsc();</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Save TD GPR state to TDVPS.</span></span><br><span class="line">                        <span class="comment">// DR&#x27;s, XSTATE and XCR&#x27;s, MSR&#x27;s will be saved if exit to TD will be required later</span></span><br><span class="line">                        <span class="comment">// In case of need of performance improvement - should be done only when actual vmexit to VMM happens</span></span><br><span class="line">                        save_guest_td_gpr_state_on_td_vmexit();</span><br><span class="line">                            <span class="type">static</span> <span class="type">void</span> <span class="title function_">save_guest_td_gpr_state_on_td_vmexit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="type">tdx_module_local_t</span>* local_data_ptr = get_local_data();</span><br><span class="line">                                <span class="type">tdvps_t</span>* tdvps_ptr = local_data_ptr-&gt;vp_ctx.tdvps;</span><br><span class="line">                            </span><br><span class="line">                                <span class="comment">// GPR&#x27;s saving: move them from local data area (already saved there by assembly prologue) to current TDVPS</span></span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rax = local_data_ptr-&gt;td_regs.rax;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rcx = local_data_ptr-&gt;td_regs.rcx;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rdx = local_data_ptr-&gt;td_regs.rdx;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rbx = local_data_ptr-&gt;td_regs.rbx;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rbp = local_data_ptr-&gt;td_regs.rbp;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rsi = local_data_ptr-&gt;td_regs.rsi;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.rdi = local_data_ptr-&gt;td_regs.rdi;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r8  = local_data_ptr-&gt;td_regs.r8;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r9  = local_data_ptr-&gt;td_regs.r9;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r10 = local_data_ptr-&gt;td_regs.r10;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r11 = local_data_ptr-&gt;td_regs.r11;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r12 = local_data_ptr-&gt;td_regs.r12;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r13 = local_data_ptr-&gt;td_regs.r13;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r14 = local_data_ptr-&gt;td_regs.r14;</span><br><span class="line">                                tdvps_ptr-&gt;guest_state.gpr_state.r15 = local_data_ptr-&gt;td_regs.r15;</span><br><span class="line">                            &#125;</span><br><span class="line">                    </span><br><span class="line">                        local_data-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_spec_ctrl = ia32_rdmsr(IA32_SPEC_CTRL_MSR_ADDR);</span><br><span class="line">                        wrmsr_opt(IA32_SPEC_CTRL_MSR_ADDR, TDX_MODULE_IA32_SPEC_CTRL,</span><br><span class="line">                                local_data-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_spec_ctrl);</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Clear NMI unblocking flag;</span></span><br><span class="line">                        <span class="comment">// For L1 this is used only for L2 VM entries following L2 VM exits</span></span><br><span class="line">                        <span class="comment">// For L2 it will be set later if required, and using on L2 VM entry</span></span><br><span class="line">                        local_data-&gt;vp_ctx.tdvps-&gt;management.nmi_unblocking_due_to_iret = <span class="literal">false</span>;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Get exit information</span></span><br><span class="line">                        ia32_vmread(VMX_VM_EXIT_REASON_ENCODE, &amp;vm_exit_reason-&gt;raw);</span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">if</span> (vm_exit_reason-&gt;vmenter_fail == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// If no failed VMENTRY occurred then the VMCS is launched after a VMEXIT</span></span><br><span class="line">                            local_data-&gt;vp_ctx.tdvps-&gt;management.vm_launched[vm_id] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        ia32_vmread(VMX_VM_EXIT_QUALIFICATION_ENCODE, &amp;vm_exit_qualification-&gt;raw);</span><br><span class="line">                        ia32_vmread(VMX_VM_EXIT_INTERRUPTION_INFO_ENCODE, &amp;vm_exit_inter_info-&gt;raw);</span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">if</span> (local_data-&gt;vp_ctx.tdr-&gt;management_fields.fatal)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// A #MC VM exit has occurred on another LP, indicating memory integrity error.</span></span><br><span class="line">                            <span class="comment">// Do an async TD exit without accessing TD memory.</span></span><br><span class="line">                            async_tdexit_to_vmm(TDX_NON_RECOVERABLE_TD_NON_ACCESSIBLE, *vm_exit_reason,</span><br><span class="line">                                                           vm_exit_qualification-&gt;raw, <span class="number">0</span>, <span class="number">0</span>, vm_exit_inter_info-&gt;raw);</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// If a preempted bus lock has been reported in the exit reason, set the local data bus lock flag.</span></span><br><span class="line">                        <span class="comment">// This flag is sticky bit; it gets reset only when reported on TD exit.</span></span><br><span class="line">                        <span class="keyword">if</span> (vm_exit_reason-&gt;bus_lock_preempted)</span><br><span class="line">                        &#123;</span><br><span class="line">                            local_data-&gt;vp_ctx.bus_lock_preempted = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// If the TD is debuggable, the host VMM can request all L2 exits to be converted to TD exits.</span></span><br><span class="line">                        <span class="keyword">if</span> ((vm_id &gt; <span class="number">0</span>) &amp;&amp; local_data-&gt;vp_ctx.tdvps-&gt;management.l2_debug_ctls[vm_id].td_exit_on_l2_vm_exit)</span><br><span class="line">                        &#123;</span><br><span class="line">                            tdx_debug_assert(local_data-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.attributes.debug == <span class="number">1</span>);</span><br><span class="line">                            async_tdexit_to_vmm(TDX_TD_EXIT_ON_L2_VM_EXIT, *vm_exit_reason, vm_exit_qualification-&gt;raw, <span class="number">0</span>, <span class="number">0</span>, vm_exit_inter_info-&gt;raw);</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">return</span> vmexit_stepping_result;</span><br><span class="line">                    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vmexit_stepping_result != FILTER_OK_CONTINUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle_vm_entry_failures(tdx_local_data_ptr, vm_exit_reason, vm_exit_qualification);</span><br><span class="line"></span><br><span class="line">    attr = tdx_local_data_ptr-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.attributes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (vm_exit_reason.basic_reason)&#123;</span><br><span class="line">        <span class="keyword">case</span> VMEXIT_REASON_VMFUNC_INSTRUCTION:</span><br><span class="line">        <span class="keyword">case</span> VMEXIT_REASON_ENCLS_INSTRUCTION:</span><br><span class="line">        <span class="keyword">case</span> VMEXIT_REASON_ENCLV_INSTRUCTION:</span><br><span class="line">        <span class="keyword">case</span> VMEXIT_REASON_ENQCMDS_PASID_TRANSLATION_FAILURE:</span><br><span class="line">        <span class="keyword">case</span> VMEXIT_REASON_SEAMCALL:</span><br><span class="line">            inject_ud();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> VMEXIT_REASON_TDCALL:</span><br><span class="line">            td_call(tdx_local_data_ptr, &amp;interrupt_occurred);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">td_call</span><span class="params">(<span class="type">tdx_module_local_t</span>* tdx_local_data_ptr, <span class="type">bool_t</span>* interrupt_occurred)</span></span><br><span class="line">    <span class="title function_">if</span> <span class="params">(!is_td_guest_in_64b_mode())</span><span class="keyword">return</span>;</span><br><span class="line">     leaf_opcode.raw = tdx_local_data_ptr-&gt;td_regs.rax;</span><br><span class="line">     <span class="keyword">if</span> ((leaf_opcode.reserved0 != <span class="number">0</span>) || (leaf_opcode.reserved1 != <span class="number">0</span>)) <span class="keyword">goto</span> EXIT;</span><br><span class="line">    <span class="keyword">if</span> ((leaf_opcode.version &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        (leaf_opcode.leaf != TDG_VM_RD_LEAF))<span class="keyword">goto</span> EXIT;</span><br><span class="line">      <span class="keyword">switch</span> (leaf_opcode.leaf)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> TDG_VP_VMCALL_LEAF:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Special case.  will (or may) not return to the TD but to go to VMM.</span></span><br><span class="line">                retval = tdg_vp_vmcall(tdx_local_data_ptr-&gt;td_regs.rcx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      EXIT:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">api_error_type <span class="title function_">tdg_vp_vmcall</span><span class="params">(<span class="type">uint64_t</span> controller_value)</span></span><br><span class="line">&#123;</span><br><span class="line">    api_error_type retval = TDX_OPERAND_INVALID;</span><br><span class="line">    <span class="type">tdx_module_local_t</span>* tdx_local_data_ptr = get_local_data();</span><br><span class="line"></span><br><span class="line">    <span class="type">tdvmcall_control_t</span> control = &#123; .raw = controller_value &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> gpr_check_mask = (<span class="type">uint16_t</span>)(BIT(<span class="number">0</span>) | BIT(<span class="number">1</span>) | BIT(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdx_local_data_ptr-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.config_flags.no_rbp_mod)</span><br><span class="line">    &#123;</span><br><span class="line">        gpr_check_mask |= (<span class="type">uint16_t</span>)BIT(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bits 0, 1 and 4 and 63:32 of RCX must be 0</span></span><br><span class="line">    <span class="keyword">if</span> (((control.gpr_select &amp; gpr_check_mask) != <span class="number">0</span>) ||</span><br><span class="line">         (control.reserved != <span class="number">0</span>))<span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TDX-SEAM loads the host VMM GPRs (in its LP-scope state save area), except RAX,</span></span><br><span class="line">    <span class="comment">// with the guest TD GPR (from TDVPS).</span></span><br><span class="line">    copy_gprs_data_from_td_to_vmm(tdx_local_data_ptr, control);</span><br><span class="line">            <span class="type">static</span> <span class="type">void</span> <span class="title function_">copy_gprs_data_from_td_to_vmm</span><span class="params">(<span class="type">tdx_module_local_t</span>* tdx_local_data_ptr,</span></span><br><span class="line"><span class="params">                                                      <span class="type">tdvmcall_control_t</span> control)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Copy guest TD&#x27;s GPRs, selected by the input parameter, to the host VMM GPRs image.</span></span><br><span class="line">                <span class="comment">// Clear other non-selected GPRs.</span></span><br><span class="line">                <span class="type">td_exit_qualification_t</span> td_exit_qual = &#123; .raw = <span class="number">0</span> &#125;;</span><br><span class="line">                td_exit_qual.vm = tdx_local_data_ptr-&gt;vp_ctx.tdvps-&gt;management.curr_vm;</span><br><span class="line">                td_exit_qual.gpr_select = control.gpr_select;</span><br><span class="line">                td_exit_qual.xmm_select = control.xmm_select;</span><br><span class="line">            </span><br><span class="line">                tdx_local_data_ptr-&gt;vmm_regs.rcx = td_exit_qual.raw;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// RAX is not copied, RCX filled above, start from RDX</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">2</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((control.gpr_select &amp; BIT(i)) != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tdx_local_data_ptr-&gt;vmm_regs.gprs[i] = tdx_local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_state.gpr_state.gprs[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Avoid modifying RBP</span></span><br><span class="line">                        <span class="keyword">if</span> (!tdx_local_data_ptr-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.config_flags.no_rbp_mod ||</span><br><span class="line">                                (i != <span class="number">5</span>))</span><br><span class="line">                        &#123;</span><br><span class="line">                            tdx_local_data_ptr-&gt;vmm_regs.gprs[i] = <span class="number">0ULL</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the exit reason in RAX</span></span><br><span class="line">    <span class="comment">// Check the sticky BUS_LOCK_PREEMPTED flag, report and clear if true.</span></span><br><span class="line">    <span class="type">vm_vmexit_exit_reason_t</span> vm_exit_reason = &#123; .raw = VMEXIT_REASON_TDCALL&#125;;</span><br><span class="line">    <span class="keyword">if</span> (tdx_local_data_ptr-&gt;vp_ctx.bus_lock_preempted)</span><br><span class="line">    &#123;</span><br><span class="line">        vm_exit_reason.bus_lock_preempted = <span class="literal">true</span>;</span><br><span class="line">        tdx_local_data_ptr-&gt;vp_ctx.bus_lock_preempted = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tdx_local_data_ptr-&gt;vmm_regs.rax = vm_exit_reason.raw;</span><br><span class="line"></span><br><span class="line">    <span class="type">ia32_xcr0_t</span> xcr0 = &#123; .raw = tdx_local_data_ptr-&gt;vp_ctx.xfam &#125;;</span><br><span class="line">    xcr0.sse = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64_t</span> scrub_mask = xcr0.raw;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TDGVPVMCALL behaves as a trap-like TD exit.</span></span><br><span class="line">    <span class="comment">// TDX-SEAM advances the guest TD RIP (in TD VMCS) to the instruction following TDCALL.</span></span><br><span class="line">    td_vmexit_to_vmm(VCPU_READY, LAST_EXIT_TDVMCALL, scrub_mask, control.xmm_select, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    EXIT_FAILURE:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">td_vmexit_to_vmm</span><span class="params">(<span class="type">uint8_t</span> vcpu_state, <span class="type">uint8_t</span> last_td_exit, <span class="type">uint64_t</span> scrub_mask,</span></span><br><span class="line"><span class="params">                      <span class="type">uint16_t</span> xmm_select, <span class="type">bool_t</span> is_td_dead, <span class="type">bool_t</span> is_trap_exit)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Local data</span></span><br><span class="line">    <span class="type">tdx_module_local_t</span>* tdx_local_data_ptr = get_local_data();</span><br><span class="line">    <span class="type">vp_ctx_t</span>* vp_ctx = &amp;tdx_local_data_ptr-&gt;vp_ctx;</span><br><span class="line">    <span class="type">tdvps_t</span>* tdvps_ptr = tdx_local_data_ptr-&gt;vp_ctx.tdvps;</span><br><span class="line">    <span class="type">tdcs_t</span>* tdcs_ptr = tdx_local_data_ptr-&gt;vp_ctx.tdcs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Avoid accessing TD private memory and control structures (except TDR).</span></span><br><span class="line">    <span class="comment">// The TD is dead, no need so save its state.</span></span><br><span class="line">    <span class="keyword">if</span> (!is_td_dead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1.  Save any guest state that it has not saved as part of the common guest-side operation, e.g.,</span></span><br><span class="line">        <span class="comment">//     the extended state per TDCS.XFAM</span></span><br><span class="line">        save_guest_td_state_before_td_exit(tdcs_ptr, tdx_local_data_ptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.  Set TDVPS.STATE to one of the VCPU_READY sub states, as an indication to the next TD entry.</span></span><br><span class="line">        tdvps_ptr-&gt;management.state = vcpu_state;</span><br><span class="line">        tdvps_ptr-&gt;management.last_td_exit = last_td_exit;</span><br><span class="line">        <span class="comment">// At this point the VCPU state will no longer be accessed</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((tdvps_ptr-&gt;management.curr_vm != <span class="number">0</span>) &amp;&amp; !is_trap_exit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// On TD exit from L2 VM, write the output memory operands of TDG.VP.ENTER to memory.</span></span><br><span class="line">            <span class="comment">// This is done at this point, before the TLB tracking counter is decremented,</span></span><br><span class="line">            <span class="comment">// because after that the memory is not protected by TLB tracking and may not</span></span><br><span class="line">            <span class="comment">// be valid for writing anymore.</span></span><br><span class="line">            write_l2_enter_outputs(tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save Guest-TD XCR0 and XSS</span></span><br><span class="line">        save_guest_td_extended_state(tdvps_ptr, tdx_local_data_ptr-&gt;vp_ctx.xfam);</span><br><span class="line">            _STATIC_INLINE_ <span class="type">void</span> <span class="title function_">save_guest_td_extended_state</span><span class="params">(<span class="type">tdvps_t</span>* tdvps_ptr, <span class="type">uint64_t</span> xfam)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Set Guest XCR0 and XSS context for saving the state</span></span><br><span class="line">                ia32_xsetbv(<span class="number">0</span>, xfam &amp; XCR0_USER_BIT_MASK);</span><br><span class="line">                ia32_wrmsr(IA32_XSS_MSR_ADDR, xfam &amp; XCR0_SUPERVISOR_BIT_MASK);</span><br><span class="line">            </span><br><span class="line">                ia32_xsaves(&amp;tdvps_ptr-&gt;guest_extension_state.xbuf, xfam);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_trap_exit)<span class="comment">//true</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// TDGVPVMCALL behaves as a trap-like TD exit.</span></span><br><span class="line">            <span class="comment">// TDX-SEAM advances the guest TD RIP (in TD VMCS) to the instruction following TDCALL.</span></span><br><span class="line">            advance_guest_rip();</span><br><span class="line">                <span class="type">void</span> <span class="title function_">advance_guest_rip</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">                &#123;</span><br><span class="line">                    current_vmcs_guest_rip_advance(<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">                    clear_movss_sti_blocking();</span><br><span class="line">                    set_guest_pde_bs();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.  Execute the TD exit TLB tracking sequence, adjusting the TDCS tracking counters.</span></span><br><span class="line">        <span class="type">tdcs_epoch_tracking_fields_t</span>* epoch_tracking = &amp;tdcs_ptr-&gt;epoch_tracking;</span><br><span class="line">        (<span class="type">void</span>)_lock_xadd_16b(&amp;epoch_tracking-&gt;epoch_and_refcount.refcount[tdvps_ptr-&gt;management.vcpu_epoch &amp; <span class="number">1</span>], (<span class="type">uint16_t</span>)<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.  At this point TDR, TDCS and TDVPS will no longer be used during the flow.</span></span><br><span class="line">    <span class="comment">//     Release the shared lock on those control structures, which was acquired by TDHVPENTER.</span></span><br><span class="line">    pamt_implicit_release_lock(vp_ctx-&gt;tdr_pamt_entry, TDX_LOCK_SHARED);</span><br><span class="line">    pamt_unwalk(vp_ctx-&gt;tdvpr_pa, vp_ctx-&gt;tdvpr_pamt_block, vp_ctx-&gt;tdvpr_pamt_entry, TDX_LOCK_SHARED, PT_4KB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load host VMM state:</span></span><br><span class="line">    set_seam_vmcs_as_active();</span><br><span class="line">        _STATIC_INLINE_ <span class="type">void</span> <span class="title function_">set_seam_vmcs_as_active</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Set the SEAM VMCS as the current VMCS</span></span><br><span class="line">            <span class="comment">// SEAM VMCS addr: seamrr_base + page_size + (lp_id * page_size)</span></span><br><span class="line">            <span class="type">uint64_t</span> seam_vmcs_pa = get_global_data()-&gt;seamrr_base +</span><br><span class="line">                                    (TDX_PAGE_SIZE_IN_BYTES * (get_local_data()-&gt;lp_info.lp_id + <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">            ia32_vmptrld((<span class="type">vmcs_ptr_t</span>*)seam_vmcs_pa);</span><br><span class="line">        </span><br><span class="line">            get_local_data()-&gt;vp_ctx.active_vmcs = ACTIVE_VMCS_NONE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.  Load any host VMM state, which is not part of the output of TDHVPENTER, and that</span></span><br><span class="line">    <span class="comment">//     might have been modified by TDX-SEAM itself and by the guest TD, with synthetic INIT values.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is done before loading VMM state - to save additional XCR0/XSS save-restore</span></span><br><span class="line">    initialize_extended_state(scrub_mask);</span><br><span class="line">        <span class="type">void</span> <span class="title function_">initialize_extended_state</span><span class="params">(<span class="type">uint64_t</span> xfam)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ia32_xsetbv(<span class="number">0</span>, xfam &amp; XCR0_USER_BIT_MASK);</span><br><span class="line">            ia32_wrmsr(IA32_XSS_MSR_ADDR, xfam &amp; XCR0_SUPERVISOR_BIT_MASK);</span><br><span class="line">        </span><br><span class="line">            ia32_xrstors(&amp;get_global_data()-&gt;xbuf, xfam);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6.  Restore host VMM CPU state from the TDX-SEAM LP-scope state save area.</span></span><br><span class="line">    <span class="comment">//     At this point, any flow that needed to update the host VMM state, e.g.,</span></span><br><span class="line">    <span class="comment">//     write to RDX as an output operand, has done so by updating the state save area.</span></span><br><span class="line">    load_vmm_state_before_td_exit(tdx_local_data_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In case of TDGVPVMCALL, Guest XMM&#x27;s will be passed down to VMM, based on XFAM.SSE bit</span></span><br><span class="line">    <span class="comment">// If the bit is 0 then they won&#x27;t be zeroed by initialization</span></span><br><span class="line">    <span class="comment">// In case of Async TDEXIT, set XMM0-15 of the VMM to 0.</span></span><br><span class="line">    <span class="keyword">if</span> (last_td_exit == LAST_EXIT_TDVMCALL)</span><br><span class="line">    &#123;</span><br><span class="line">        load_xmms_by_mask(tdvps_ptr, xmm_select);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.   Run the common SEAMRET routine.</span></span><br><span class="line">    tdx_vmm_post_dispatching();</span><br><span class="line">            <span class="type">void</span> <span class="title function_">tdx_vmm_post_dispatching</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            advance_guest_rip();</span><br><span class="line">        </span><br><span class="line">            <span class="type">tdx_module_local_t</span>* local_data_ptr = get_local_data();</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// Restore IA32_SPEC_CTRL</span></span><br><span class="line">            wrmsr_opt(IA32_SPEC_CTRL_MSR_ADDR, local_data_ptr-&gt;vmm_non_extended_state.ia32_spec_ctrl,</span><br><span class="line">                                               TDX_MODULE_IA32_SPEC_CTRL);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// If simplified LAM was saved &amp; disabled, restore its state</span></span><br><span class="line">            <span class="keyword">if</span> (local_data_ptr-&gt;vmm_non_extended_state.ia32_lam_enable != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ia32_wrmsr(IA32_LAM_ENABLE_MSR_ADDR, local_data_ptr-&gt;vmm_non_extended_state.ia32_lam_enable);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            mark_lp_as_free();</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// Check that we have no mapped keyholes left</span></span><br><span class="line">            tdx_sanity_check(local_data_ptr-&gt;keyhole_state.total_ref_count == <span class="number">0</span>, SCEC_KEYHOLE_MANAGER_SOURCE, <span class="number">20</span>);</span><br><span class="line">        </span><br><span class="line">            TDX_LOG(<span class="string">&quot;tdx_vmm_post_dispatching - preparing to do SEAMRET\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">            tdx_seamret_to_vmm(); <span class="comment">// Restore GPRs and SEAMRET</span></span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">            <span class="comment">// Shouldn&#x27;t reach here:</span></span><br><span class="line">            tdx_sanity_check(<span class="number">0</span>, SCEC_VMM_DISPATCHER_SOURCE, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unreachable Code. Panic</span></span><br><span class="line">    tdx_sanity_check(<span class="number">0</span>, SCEC_TDEXIT_SOURCE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 lock 是在 vp_enter 的时候拿的 是 shared lock</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">save_guest_td_state_before_td_exit</span><span class="params">(<span class="type">tdcs_t</span>* tdcs_ptr, <span class="type">tdx_module_local_t</span>* local_data_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">tdx_module_global_t</span>* global_data = get_global_data();</span><br><span class="line"></span><br><span class="line">    <span class="type">tdvps_t</span>* tdvps_ptr = local_data_ptr-&gt;vp_ctx.tdvps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extended state control</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.xfd_supported)</span><br><span class="line">    &#123;</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_xfd = ia32_rdmsr(IA32_XFD_MSR_ADDR);</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_xfd_err = ia32_rdmsr(IA32_XFD_ERROR_MSR_ADDR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CR2 state</span></span><br><span class="line">    tdvps_ptr-&gt;guest_state.cr2 = ia32_store_cr2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XCR0 state</span></span><br><span class="line">    tdvps_ptr-&gt;guest_state.xcr0 = ia32_xgetbv(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debug state</span></span><br><span class="line">    tdvps_ptr-&gt;guest_state.dr0 = ia32_store_dr0();</span><br><span class="line">    tdvps_ptr-&gt;guest_state.dr1 = ia32_store_dr1();</span><br><span class="line">    tdvps_ptr-&gt;guest_state.dr2 = ia32_store_dr2();</span><br><span class="line">    tdvps_ptr-&gt;guest_state.dr3 = ia32_store_dr3();</span><br><span class="line">    tdvps_ptr-&gt;guest_state.dr6 = ia32_store_dr6();</span><br><span class="line"></span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_ds_area = ia32_rdmsr(IA32_DS_AREA_MSR_ADDR);</span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">ia32_xcr0_t</span>)tdvps_ptr-&gt;management.xfam).lbr)</span><br><span class="line">    &#123;</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_lbr_depth = ia32_rdmsr(IA32_LBR_DEPTH_MSR_ADDR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perfmon State</span></span><br><span class="line">    <span class="keyword">if</span> (tdcs_ptr-&gt;executions_ctl_fields.attributes.perfmon)</span><br><span class="line">    &#123;</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_fixed_ctr_ctrl = ia32_rdmsr(IA32_FIXED_CTR_CTRL_MSR_ADDR);</span><br><span class="line">        <span class="comment">//cpuid_config.values.edx.num_fcs  5bit: 0-32</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; global_data-&gt;num_fixed_ctrs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((global_data-&gt;fc_bitmap &amp; BIT(i)) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tdvps_ptr-&gt;guest_msr_state.ia32_fixed_ctr[i] = ia32_rdmsr(IA32_FIXED_CTR0_MSR_ADDR + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; NUM_PMC; i++) <span class="comment">// NUM_PMC = 8</span></span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                tdvps_ptr-&gt;guest_msr_state.ia32_a_pmc[i] = ia32_rdmsr(IA32_A_PMC0_MSR_ADDR + i);</span><br><span class="line">                tdvps_ptr-&gt;guest_msr_state.ia32_perfevtsel[i] = ia32_rdmsr(IA32_PERFEVTSEL0_MSR_ADDR + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tdvps_ptr-&gt;guest_msr_state.ia32_offcore_rsp[i] = ia32_rdmsr(IA32_OFFCORE_RSPx_MSR_ADDR + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_perf_global_status = ia32_rdmsr(IA32_PERF_GLOBAL_STATUS_MSR_ADDR);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == global_data-&gt;plt_common_config.ia32_perf_capabilities.perf_metrics_available)</span><br><span class="line">        &#123;</span><br><span class="line">            tdvps_ptr-&gt;guest_msr_state.ia32_perf_metrics = ia32_rdmsr(IA32_PERF_METRICS_MSR_ADDR);</span><br><span class="line">        &#125;</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_pebs_enable = ia32_rdmsr(IA32_PEBS_ENABLE_MSR_ADDR);</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_pebs_data_cfg = ia32_rdmsr(IA32_PEBS_DATA_CFG_MSR_ADDR);</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_pebs_ld_lat = ia32_rdmsr(IA32_PEBS_LD_LAT_MSR_ADDR);</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_pebs_frontend = ia32_rdmsr(IA32_PEBS_FRONTEND_MSR_ADDR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.waitpkg_supported)</span><br><span class="line">    &#123;</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_umwait_control= ia32_rdmsr(IA32_UMWAIT_CONTROL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.tsx_supported)</span><br><span class="line">    &#123;</span><br><span class="line">        tdvps_ptr-&gt;guest_msr_state.ia32_tsx_ctrl = ia32_rdmsr(IA32_TSX_CTRL_MSR_ADDR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_uarch_misc_ctl = ia32_rdmsr(IA32_UARCH_MISC_CTL_MSR_ADDR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save the following MSRs:</span></span><br><span class="line">    <span class="comment">// IA32_STAR, IA32_LSTAR,</span></span><br><span class="line">    <span class="comment">// IA32_FMASK, IA32_KERNEL_GS_BASE, IA32_TSC_AUX</span></span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_star            = ia32_rdmsr(IA32_STAR_MSR_ADDR);</span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_lstar           = ia32_rdmsr(IA32_LSTAR_MSR_ADDR);</span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_fmask           = ia32_rdmsr(IA32_FMASK_MSR_ADDR);</span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_kernel_gs_base  = ia32_rdmsr(IA32_KERNEL_GS_BASE_MSR_ADDR);</span><br><span class="line">    tdvps_ptr-&gt;guest_msr_state.ia32_tsc_aux         = ia32_rdmsr(IA32_TSC_AUX_MSR_ADDR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">current_vmcs_guest_rip_advance</span><span class="params">(<span class="type">uint64_t</span> instruction_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> current_vmm_rip;</span><br><span class="line">    ia32_vmread(VMX_GUEST_RIP_ENCODE, &amp;current_vmm_rip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instruction_len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ia32_vmread(VMX_VM_EXIT_INSTRUCTION_LENGTH_ENCODE, &amp;instruction_len);</span><br><span class="line">        tdx_sanity_check(instruction_len != <span class="number">0</span>, SCEC_HELPERS_SOURCE, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ia32_vmwrite(VMX_GUEST_RIP_ENCODE, current_vmm_rip + instruction_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_movss_sti_blocking</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vmx_guest_inter_state_t</span> guest_inter_state;</span><br><span class="line">    ia32_vmread(VMX_GUEST_INTERRUPTIBILITY_ENCODE, &amp;guest_inter_state.raw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (guest_inter_state.blocking_by_mov_ss != <span class="number">0</span> || guest_inter_state.blocking_by_sti != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        guest_inter_state.blocking_by_mov_ss = <span class="number">0</span>;</span><br><span class="line">        guest_inter_state.blocking_by_sti = <span class="number">0</span>;</span><br><span class="line">        ia32_vmwrite(VMX_GUEST_INTERRUPTIBILITY_ENCODE, guest_inter_state.raw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_guest_pde_bs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ia32_rflags_t</span> rflags;</span><br><span class="line">    ia32_vmread(VMX_GUEST_RFLAGS_ENCODE, &amp;rflags.raw);</span><br><span class="line"></span><br><span class="line">    <span class="type">ia32_debugctl_t</span> debugctl;</span><br><span class="line">    ia32_vmread(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, &amp;debugctl.raw);</span><br><span class="line"></span><br><span class="line">    <span class="type">pending_debug_exception_t</span> pde;</span><br><span class="line">    ia32_vmread(VMX_GUEST_PND_DEBUG_EXCEPTION_ENCODE, &amp;pde.raw);</span><br><span class="line"></span><br><span class="line">    pde.bs = (rflags.tf == <span class="number">1</span> &amp;&amp; debugctl.btf == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    ia32_vmwrite(VMX_GUEST_PND_DEBUG_EXCEPTION_ENCODE, pde.raw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_vmm_state_before_td_exit</span><span class="params">(<span class="type">tdx_module_local_t</span>* local_data_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">tdx_module_global_t</span>* global_data = get_global_data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear CR2 to its INIT value</span></span><br><span class="line">    ia32_load_cr2(CR2_RESET_STATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debug state restoration</span></span><br><span class="line">    init_all_dr_opt(local_data_ptr-&gt;vp_ctx.tdvps);</span><br><span class="line"></span><br><span class="line">    wrmsr_opt(IA32_DS_AREA_MSR_ADDR, local_data_ptr-&gt;vmm_non_extended_state.ia32_ds_area, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_ds_area);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (local_data_ptr-&gt;vp_ctx.xfd_supported)</span><br><span class="line">    &#123;</span><br><span class="line">        init_msr_opt(IA32_XFD_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_xfd);</span><br><span class="line">        init_msr_opt(IA32_XFD_ERROR_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_xfd_err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perfmon State</span></span><br><span class="line">    <span class="keyword">if</span> (local_data_ptr-&gt;vp_ctx.attributes.perfmon)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; global_data-&gt;num_fixed_ctrs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((global_data-&gt;fc_bitmap &amp; BIT(i)) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                init_msr_opt(IA32_FIXED_CTR0_MSR_ADDR + i, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_fixed_ctr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; NUM_PMC; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                init_msr_opt(IA32_A_PMC0_MSR_ADDR + i, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_a_pmc[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            init_msr_opt(IA32_OFFCORE_RSPx_MSR_ADDR + i, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_offcore_rsp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ia32_wrmsr(IA32_PERF_GLOBAL_STATUS_RESET_MSR_ADDR, ia32_rdmsr(IA32_PERF_GLOBAL_STATUS_MSR_ADDR));</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == global_data-&gt;plt_common_config.ia32_perf_capabilities.perf_metrics_available)</span><br><span class="line">        &#123;</span><br><span class="line">            init_msr_opt(IA32_PERF_METRICS_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_perf_metrics);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_msr_opt(IA32_UARCH_MISC_CTL_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_uarch_misc_ctl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Initialize the following MSRs:</span></span><br><span class="line"><span class="comment">     * IA32_STAR, IA32_LSTAR, IA32_FMASK, IA32_TSC_AUX,  &amp; IA32_KERNEL_GS_BASE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    init_msr_opt(IA32_TSC_AUX_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_tsc_aux);</span><br><span class="line">    init_msr_opt(IA32_STAR_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_star);</span><br><span class="line">    init_msr_opt(IA32_LSTAR_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_lstar);</span><br><span class="line">    init_msr_opt(IA32_FMASK_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_fmask);</span><br><span class="line">    init_msr_opt(IA32_KERNEL_GS_BASE_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_kernel_gs_base);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (local_data_ptr-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.cpuid_flags.tsx_supported)</span><br><span class="line">    &#123;</span><br><span class="line">        ia32_wrmsr(IA32_TSX_CTRL_MSR_ADDR, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        wrmsr_opt(IA32_TSX_CTRL_MSR_ADDR, local_data_ptr-&gt;vmm_non_extended_state.ia32_tsx_ctrl, IA32_TSX_CTRL_DISABLE_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Use vmwrite to update the following SEAM-VMCS guest fields</span></span><br><span class="line"><span class="comment">     *  IA32_DEBUGCTL, IA32_PERF_GLOBAL_CTRL, IA32_RTIT_CTL, IA32_LBR_CTL and DR7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint64_t</span> debugctl_msr_value;</span><br><span class="line">    ia32_vmread(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, &amp;debugctl_msr_value);</span><br><span class="line">    debugctl_msr_value = debugctl_msr_value &amp; IA32_DEBUGCTLMSR_MASK_BITS_PRESERVED;</span><br><span class="line">    ia32_vmwrite(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, debugctl_msr_value);</span><br><span class="line">    <span class="keyword">if</span> (local_data_ptr-&gt;vp_ctx.attributes.perfmon)</span><br><span class="line">    &#123;</span><br><span class="line">        ia32_vmwrite(VMX_GUEST_IA32_PERF_GLOBAL_CONTROL_FULL_ENCODE, VMX_GUEST_IA32_PERF_GLOBAL_CONTROL_INIT_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">ia32_xcr0_t</span>)local_data_ptr-&gt;vp_ctx.xfam).pt)</span><br><span class="line">    &#123;</span><br><span class="line">        ia32_vmwrite(VMX_GUEST_RTIT_CTL_FULL_ENCODE, VMX_GUEST_RTIT_CTL_INIT_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">ia32_xcr0_t</span>)local_data_ptr-&gt;vp_ctx.xfam).lbr)</span><br><span class="line">    &#123;</span><br><span class="line">        ia32_vmwrite(VMX_GUEST_LBR_CTL_FULL_ENCODE, VMX_GUEST_LBR_CTL_INIT_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    ia32_vmwrite(VMX_GUEST_DR7_ENCODE, VMX_GUEST_DR7_INIT_VALUE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_msr_opt</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> cur_value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (addr == IA32_FMASK_MSR_ADDR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur_value != IA32_FMASK_MSR_RESET_STATE)</span><br><span class="line">        &#123;</span><br><span class="line">            ia32_wrmsr(IA32_FMASK_MSR_ADDR, IA32_FMASK_MSR_RESET_STATE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (addr == IA32_LBR_DEPTH_MSR_ADDR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur_value != IA32_LBR_DEPTH_MSR_RESET_STATE)</span><br><span class="line">        &#123;</span><br><span class="line">            ia32_wrmsr(IA32_LBR_DEPTH_MSR_ADDR, IA32_LBR_DEPTH_MSR_RESET_STATE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// All other MSR&#x27;s are reset to 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur_value != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ia32_wrmsr(addr, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">_STATIC_INLINE_ <span class="type">uint64_t</span> <span class="title function_">ia32_store_dr0</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> dr0;</span><br><span class="line">    _ASM_VOLATILE_ (<span class="string">&quot;mov %%dr0, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (dr0));</span><br><span class="line">    <span class="keyword">return</span> dr0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_STATIC_INLINE_ <span class="type">uint64_t</span> <span class="title function_">ia32_store_dr1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> dr1;</span><br><span class="line">    _ASM_VOLATILE_ (<span class="string">&quot;mov %%dr1, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (dr1));</span><br><span class="line">    <span class="keyword">return</span> dr1;</span><br><span class="line">&#125;</span><br><span class="line">_STATIC_INLINE_ <span class="type">uint64_t</span> <span class="title function_">ia32_rdmsr</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> low,high;</span><br><span class="line">    _ASM_VOLATILE_ (<span class="string">&quot;rdmsr&quot;</span> : <span class="string">&quot;=a&quot;</span>(low), <span class="string">&quot;=d&quot;</span>(high) : <span class="string">&quot;c&quot;</span>(addr));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint64_t</span>)((((<span class="type">uint64_t</span>)(high)) &lt;&lt; <span class="number">32</span>) | (<span class="type">uint64_t</span>)(low));</span><br><span class="line">&#125;</span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">ia32_xsaves</span><span class="params">(<span class="type">void</span>* xsave_area, <span class="type">uint64_t</span> xfam)</span></span><br><span class="line">&#123;</span><br><span class="line">    _ASM_VOLATILE_ ( <span class="string">&quot;xsaves %0 \n&quot;</span> : <span class="string">&quot;=m&quot;</span>(*((<span class="type">uint64_t</span> *)xsave_area)) : <span class="string">&quot;d&quot;</span>((<span class="type">uint32_t</span>)(xfam &gt;&gt; <span class="number">32</span>)),</span><br><span class="line">            <span class="string">&quot;a&quot;</span>((<span class="type">uint32_t</span>)xfam) : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">ia32_xseglobaltbv</span><span class="params">(<span class="type">uint64_t</span> xcr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    _ASM_VOLATILE_ (<span class="string">&quot;xsetbv&quot;</span> : : <span class="string">&quot;a&quot;</span>((<span class="type">uint32_t</span>)value), <span class="string">&quot;d&quot;</span>((<span class="type">uint32_t</span>)(value &gt;&gt; <span class="number">32</span>)), <span class="string">&quot;c&quot;</span>(xcr));</span><br><span class="line">&#125;</span><br><span class="line">_STATIC_INLINE_ <span class="type">uint16_t</span> _lock_xadd_16b(<span class="type">uint16_t</span> *mem, <span class="type">uint16_t</span> quantum)</span><br><span class="line">&#123;</span><br><span class="line">    _ASM_VOLATILE_ (<span class="string">&quot;lock; xaddw %2, %0&quot;</span> : <span class="string">&quot;=m&quot;</span> ( *mem ), <span class="string">&quot;=a&quot;</span>(quantum) : <span class="string">&quot;a&quot;</span>(quantum) : <span class="string">&quot;memory&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> quantum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Write to VMCS entry</span></span><br><span class="line"><span class="comment"> * @param encoding</span></span><br><span class="line"><span class="comment"> * @param value</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">ia32_vmwrite</span><span class="params">(<span class="type">uint64_t</span> encoding, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//According to SDM, in 64-bit mode the instruction will fail is given an</span></span><br><span class="line">    <span class="comment">//operand that sets encoding bit beyond 32-bit</span></span><br><span class="line">    tdx_debug_assert(encoding &lt; BIT(<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//asm instruction expects both operands to be 64bit.</span></span><br><span class="line">    <span class="type">ia32_rflags_t</span> rflags;</span><br><span class="line">    _ASM_VOLATILE_ (<span class="string">&quot;vmwriteq %1,%2\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;popq %0&quot;</span></span><br><span class="line">                        : <span class="string">&quot;=r&quot;</span>(rflags.raw)</span><br><span class="line">            :<span class="string">&quot;r&quot;</span>(value), <span class="string">&quot;r&quot;</span>(encoding)</span><br><span class="line">            : <span class="string">&quot;cc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        tdx_sanity_check((rflags.cf == <span class="number">0</span> &amp;&amp; rflags.zf == <span class="number">0</span>), SCEC_VT_ACCESSORS_SOURCE, (<span class="type">uint32_t</span>)encoding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Load pointer to VMCS</span></span><br><span class="line"><span class="comment"> * @param vmcs_p</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">ia32_vmptrld</span><span class="params">(<span class="type">vmcs_ptr_t</span> *vmcs_p)</span> &#123;</span><br><span class="line">    <span class="type">ia32_rflags_t</span> rflags;</span><br><span class="line">        _ASM_VOLATILE_ (<span class="string">&quot;vmptrld %1\n&quot;</span></span><br><span class="line">                    <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">                    <span class="string">&quot;popq %0\n&quot;</span></span><br><span class="line">                    : <span class="string">&quot;=r&quot;</span>(rflags.raw)</span><br><span class="line">                        :<span class="string">&quot;m&quot;</span>(vmcs_p):<span class="string">&quot;memory&quot;</span> , <span class="string">&quot;cc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Runtime assert - VMPTRLD should always succeed</span></span><br><span class="line">        tdx_sanity_check((rflags.cf == <span class="number">0</span> &amp;&amp; rflags.zf == <span class="number">0</span>), SCEC_VT_ACCESSORS_SOURCE, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl tdx_seamret_to_vmm</span><br><span class="line">.type  tdx_seamret_to_vmm,@function</span><br><span class="line">tdx_seamret_to_vmm:</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Restore all VMM GPRs on module entry from LP local data</span><br><span class="line">     * Local data is located at GSBASE</span><br><span class="line">     */</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET,     %rax</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+8,   %rcx</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+16,  %rdx</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+24,  %rbx</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+32,  %rsp // not actually needed</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+40,  %rbp</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+48,  %rsi</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+56,  %rdi</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+64,  %r8</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+72,  %r9</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+80,  %r10</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+88,  %r11</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+96,  %r12</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+104, %r13</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+112, %r14</span><br><span class="line">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+120, %r15</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Call SEAMRET</span><br><span class="line">     */</span><br><span class="line">        .byte 0x66, 0x0F, 0x01, 0xCD</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * No accesible code from this point</span><br><span class="line">     * Panic with UD2 if reached</span><br><span class="line">     */</span><br><span class="line">    ud2.section .text</span><br></pre></td></tr></table></figure>

<ul>
<li>读写内存</li>
<li>汇编指令</li>
<li>if 不确定是否成立</li>
<li>循环不确定次数</li>
</ul>
<h3 id="Seamcall"><a href="#Seamcall" class="headerlink" title="Seamcall"></a>Seamcall</h3><p>host 侧：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/intel/tdx/blob/kvm-upstream/arch/x86/kvm/vmx/tdx.c">https://github.com/intel/tdx/blob/kvm-upstream/arch/x86/kvm/vmx/tdx.c</a></p>
<p>rax&#x3D;0  前 16bit 表示 seamcall 的动作  0 表示 vmlaunch&#x2F;vmresume</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinstr <span class="type">void</span> <span class="title function_">tdx_vcpu_enter_exit</span><span class="params">(<span class="keyword">struct</span> vcpu_tdx *tdx)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tdx_module_args</span> <span class="title">args</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Avoid section mismatch with to_tdx() with KVM_VM_BUG().  The caller</span></span><br><span class="line"><span class="comment">         * should call to_tdx().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kvm_vcpu</span> *<span class="title">vcpu</span> =</span> &amp;tdx-&gt;vcpu;</span><br><span class="line"></span><br><span class="line">        guest_state_enter_irqoff();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span> optimization:</span></span><br><span class="line"><span class="comment">         * - Eliminate copy between args and vcpu-&gt;arch.regs.</span></span><br><span class="line"><span class="comment">         * - copyin/copyout registers only if (tdx-&gt;tdvmvall.regs_mask != 0)</span></span><br><span class="line"><span class="comment">         *   which means TDG.VP.VMCALL.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        args = (<span class="keyword">struct</span> tdx_module_args) &#123;</span><br><span class="line">                .rcx = tdx-&gt;tdvpr_pa,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG(reg, REG)        .reg = vcpu-&gt;arch.regs[VCPU_REGS_ ## REG]</span></span><br><span class="line">                REG(rdx, RDX),</span><br><span class="line">                REG(r8,  R8),</span><br><span class="line">                REG(r9,  R9),</span><br><span class="line">                REG(r10, R10),</span><br><span class="line">                REG(r11, R11),</span><br><span class="line">                REG(r12, R12),</span><br><span class="line">                REG(r13, R13),</span><br><span class="line">                REG(r14, R14),</span><br><span class="line">                REG(r15, R15),</span><br><span class="line">                REG(rbx, RBX),</span><br><span class="line">                REG(rdi, RDI),</span><br><span class="line">                REG(rsi, RSI),</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> REG</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        tdx-&gt;exit_reason.full = __seamcall_saved_ret(TDH_VP_ENTER, &amp;args);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REG(reg, REG)        vcpu-&gt;arch.regs[VCPU_REGS_ ## REG] = args.reg</span></span><br><span class="line">                REG(rcx, RCX);</span><br><span class="line">                REG(rdx, RDX);</span><br><span class="line">                REG(r8,  R8);</span><br><span class="line">                REG(r9,  R9);</span><br><span class="line">                REG(r10, R10);</span><br><span class="line">                REG(r11, R11);</span><br><span class="line">                REG(r12, R12);</span><br><span class="line">                REG(r13, R13);</span><br><span class="line">                REG(r14, R14);</span><br><span class="line">                REG(r15, R15);</span><br><span class="line">                REG(rbx, RBX);</span><br><span class="line">                REG(rdi, RDI);</span><br><span class="line">                REG(rsi, RSI);</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> REG</span></span><br><span class="line"></span><br><span class="line">        WARN_ON_ONCE(!kvm_rebooting &amp;&amp;</span><br><span class="line">                     (tdx-&gt;exit_reason.full &amp; TDX_SW_ERROR) == TDX_SW_ERROR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((u16)tdx-&gt;exit_reason.basic == EXIT_REASON_EXCEPTION_NMI &amp;&amp;</span><br><span class="line">            is_nmi(tdexit_intr_info(vcpu))) &#123;</span><br><span class="line">                kvm_before_interrupt(vcpu, KVM_HANDLING_NMI);</span><br><span class="line">                vmx_do_nmi_irqoff();</span><br><span class="line">                kvm_after_interrupt(vcpu);</span><br><span class="line">        &#125;</span><br><span class="line">        guest_state_exit_irqoff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把需要 tdx module 处理使用的参数通过寄存器传入  也是类似 function call</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">.macro TDX_MODULE_CALL host:req ret=0 saved=0</span><br><span class="line">        FRAME_BEGIN</span><br><span class="line"></span><br><span class="line">        /* Move Leaf ID to RAX */</span><br><span class="line">        mov %rdi, %rax</span><br><span class="line"></span><br><span class="line">        /* Move other input regs from &#x27;struct tdx_module_args&#x27; */</span><br><span class="line">        movq        TDX_MODULE_rcx(%rsi), %rcx</span><br><span class="line">        movq        TDX_MODULE_rdx(%rsi), %rdx</span><br><span class="line">        movq        TDX_MODULE_r8(%rsi),  %r8</span><br><span class="line">        movq        TDX_MODULE_r9(%rsi),  %r9</span><br><span class="line">        movq        TDX_MODULE_r10(%rsi), %r10</span><br><span class="line">        movq        TDX_MODULE_r11(%rsi), %r11</span><br><span class="line"></span><br><span class="line">.if \saved</span><br><span class="line">        /*</span><br><span class="line">         * Move additional input regs from the structure.  For simplicity</span><br><span class="line">         * assume that anything needs the callee-saved regs also tramples</span><br><span class="line">         * on RDI/RSI (see VP.ENTER).</span><br><span class="line">         */</span><br><span class="line">        /* Save those callee-saved GPRs as mandated by the x86_64 ABI */</span><br><span class="line">        pushq        %rbx</span><br><span class="line">        pushq        %r12</span><br><span class="line">        pushq        %r13</span><br><span class="line">        pushq        %r14</span><br><span class="line">        pushq        %r15</span><br><span class="line"></span><br><span class="line">        movq        TDX_MODULE_r12(%rsi), %r12</span><br><span class="line">        movq        TDX_MODULE_r13(%rsi), %r13</span><br><span class="line">        movq        TDX_MODULE_r14(%rsi), %r14</span><br><span class="line">        movq        TDX_MODULE_r15(%rsi), %r15</span><br><span class="line">        movq        TDX_MODULE_rbx(%rsi), %rbx</span><br><span class="line"></span><br><span class="line">.if \ret</span><br><span class="line">        /* Save the structure pointer as RSI is about to be clobbered */</span><br><span class="line">        pushq        %rsi</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">        movq        TDX_MODULE_rdi(%rsi), %rdi</span><br><span class="line">        /* RSI needs to be done at last */</span><br><span class="line">        movq        TDX_MODULE_rsi(%rsi), %rsi</span><br><span class="line">.endif        /* \saved */</span><br><span class="line"></span><br><span class="line">.if \host</span><br><span class="line">.Lseamcall\@:</span><br><span class="line">        seamcall</span><br><span class="line">        /*</span><br><span class="line">         * SEAMCALL instruction is essentially a VMExit from VMX root</span><br><span class="line">         * mode to SEAM VMX root mode.  VMfailInvalid (CF=1) indicates</span><br><span class="line">         * that the targeted SEAM firmware is not loaded or disabled,</span><br><span class="line">         * or P-SEAMLDR is busy with another SEAMCALL.  %rax is not</span><br><span class="line">         * changed in this case.</span><br><span class="line">         *</span><br><span class="line">         * Set %rax to TDX_SEAMCALL_VMFAILINVALID for VMfailInvalid.</span><br><span class="line">         * This value will never be used as actual SEAMCALL error code as</span><br><span class="line">         * it is from the Reserved status code class.</span><br><span class="line">         */</span><br><span class="line">        jc .Lseamcall_vmfailinvalid\@</span><br><span class="line">.else</span><br><span class="line">        tdcall</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">.if \ret</span><br><span class="line">.if \saved</span><br><span class="line">        /*</span><br><span class="line">         * Restore the structure from stack to save the output registers</span><br><span class="line">         *</span><br><span class="line">         * In case of VP.ENTER returns due to TDVMCALL, all registers are</span><br><span class="line">         * valid thus no register can be used as spare to restore the</span><br><span class="line">         * structure from the stack (see &quot;TDH.VP.ENTER Output Operands</span><br><span class="line">         * Definition on TDCALL(TDG.VP.VMCALL) Following a TD Entry&quot;).</span><br><span class="line">         * For this case, need to make one register as spare by saving it</span><br><span class="line">         * to the stack and then manually load the structure pointer to</span><br><span class="line">         * the spare register.</span><br><span class="line">         *</span><br><span class="line">         * Note for other TDCALLs/SEAMCALLs there are spare registers</span><br><span class="line">         * thus no need for such hack but just use this for all.</span><br><span class="line">         */</span><br><span class="line">        pushq        %rax                /* save the TDCALL/SEAMCALL return code */</span><br><span class="line">        movq        8(%rsp), %rax        /* restore the structure pointer */</span><br><span class="line">        movq        %rsi, TDX_MODULE_rsi(%rax)        /* save RSI */</span><br><span class="line">        popq        %rax                /* restore the return code */</span><br><span class="line">        popq        %rsi                /* pop the structure pointer */</span><br><span class="line"></span><br><span class="line">        /* Copy additional output regs to the structure  */</span><br><span class="line">        movq %r12, TDX_MODULE_r12(%rsi)</span><br><span class="line">        movq %r13, TDX_MODULE_r13(%rsi)</span><br><span class="line">        movq %r14, TDX_MODULE_r14(%rsi)</span><br><span class="line">        movq %r15, TDX_MODULE_r15(%rsi)</span><br><span class="line">        movq %rbx, TDX_MODULE_rbx(%rsi)</span><br><span class="line">        movq %rdi, TDX_MODULE_rdi(%rsi)</span><br><span class="line">.endif        /* \saved */</span><br><span class="line"></span><br><span class="line">        /* Copy output registers to the structure */</span><br><span class="line">        movq %rcx, TDX_MODULE_rcx(%rsi)</span><br><span class="line">        movq %rdx, TDX_MODULE_rdx(%rsi)</span><br><span class="line">        movq %r8,  TDX_MODULE_r8(%rsi)</span><br><span class="line">        movq %r9,  TDX_MODULE_r9(%rsi)</span><br><span class="line">        movq %r10, TDX_MODULE_r10(%rsi)</span><br><span class="line">        movq %r11, TDX_MODULE_r11(%rsi)</span><br><span class="line">.endif        /* \ret */</span><br><span class="line"></span><br><span class="line">.if \saved &amp;&amp; \ret</span><br><span class="line">        /*</span><br><span class="line">         * Clear registers shared by guest for VP.VMCALL/VP.ENTER to prevent</span><br><span class="line">         * speculative use of guest&#x27;s/VMM&#x27;s values, including those are</span><br><span class="line">         * restored from the stack.</span><br><span class="line">         *</span><br><span class="line">         * See arch/x86/kvm/vmx/vmenter.S:</span><br><span class="line">         *</span><br><span class="line">         * In theory, a L1 cache miss when restoring register from stack</span><br><span class="line">         * could lead to speculative execution with guest&#x27;s values.</span><br><span class="line">         *</span><br><span class="line">         * Note: RBP/RSP are not used as shared register.  RSI has been</span><br><span class="line">         * restored already.</span><br><span class="line">         *</span><br><span class="line">         * XOR is cheap, thus unconditionally do for all leafs.</span><br><span class="line">         */</span><br><span class="line">        xorl %ecx,  %ecx</span><br><span class="line">        xorl %edx,  %edx</span><br><span class="line">        xorl %r8d,  %r8d</span><br><span class="line">        xorl %r9d,  %r9d</span><br><span class="line">        xorl %r10d, %r10d</span><br><span class="line">        xorl %r11d, %r11d</span><br><span class="line">        xorl %r12d, %r12d</span><br><span class="line">        xorl %r13d, %r13d</span><br><span class="line">        xorl %r14d, %r14d</span><br><span class="line">        xorl %r15d, %r15d</span><br><span class="line">        xorl %ebx,  %ebx</span><br><span class="line">        xorl %edi,  %edi</span><br><span class="line">.endif        /* \ret &amp;&amp; \host */</span><br><span class="line"></span><br><span class="line">.if \host</span><br><span class="line">.Lout\@:</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">.if \saved</span><br><span class="line">        /* Restore callee-saved GPRs as mandated by the x86_64 ABI */</span><br><span class="line">        popq        %r15</span><br><span class="line">        popq        %r14</span><br><span class="line">        popq        %r13</span><br><span class="line">        popq        %r12</span><br><span class="line">        popq        %rbx</span><br><span class="line">.endif        /* \saved */</span><br><span class="line"></span><br><span class="line">        FRAME_END</span><br><span class="line">        RET</span><br><span class="line"></span><br><span class="line">.if \host</span><br><span class="line">.Lseamcall_vmfailinvalid\@:</span><br><span class="line">        mov $TDX_SEAMCALL_VMFAILINVALID, %rax</span><br><span class="line">        jmp .Lseamcall_fail\@</span><br><span class="line"></span><br><span class="line">.Lseamcall_trap\@:</span><br><span class="line">        /*</span><br><span class="line">         * SEAMCALL caused #GP or #UD.  By reaching here RAX contains</span><br><span class="line">         * the trap number.  Convert the trap number to the TDX error</span><br><span class="line">         * code by setting TDX_SW_ERROR to the high 32-bits of RAX.</span><br><span class="line">         *</span><br><span class="line">         * Note cannot OR TDX_SW_ERROR directly to RAX as OR instruction</span><br><span class="line">         * only accepts 32-bit immediate at most.</span><br><span class="line">         */</span><br><span class="line">        movq $TDX_SW_ERROR, %rdi</span><br><span class="line">        orq  %rdi, %rax</span><br><span class="line"></span><br><span class="line">.Lseamcall_fail\@:</span><br><span class="line">.if \ret &amp;&amp; \saved</span><br><span class="line">        /* pop the unused structure pointer back to RSI */</span><br><span class="line">        popq %rsi</span><br><span class="line">.endif</span><br><span class="line">        jmp .Lout\@</span><br><span class="line"></span><br><span class="line">        _ASM_EXTABLE_FAULT(.Lseamcall\@, .Lseamcall_trap\@)</span><br><span class="line">.endif        /* \host */</span><br><span class="line"></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>

<p>Tdx module:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.globl tdx_seamcall_entry_point</span><br><span class="line">.type  tdx_seamcall_entry_point,@function</span><br><span class="line">tdx_seamcall_entry_point:</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Save all VMM GPRs on module entry to LP local data</span><br><span class="line">     * Local data is located at GSBASE</span><br><span class="line">     */</span><br><span class="line">    movq %rax,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET</span><br><span class="line">    movq %rcx,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+8</span><br><span class="line">    movq %rdx,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+16</span><br><span class="line">    movq %rbx,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+24</span><br><span class="line">    movq %rsp,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+32 // not actually needed</span><br><span class="line">    movq %rbp,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+40</span><br><span class="line">    movq %rsi,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+48</span><br><span class="line">    movq %rdi,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+56</span><br><span class="line">    movq %r8,   %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+64</span><br><span class="line">    movq %r9,   %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+72</span><br><span class="line">    movq %r10,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+80</span><br><span class="line">    movq %r11,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+88</span><br><span class="line">    movq %r12,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+96</span><br><span class="line">    movq %r13,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+104</span><br><span class="line">    movq %r14,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+112</span><br><span class="line">    movq %r15,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+120</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * clear VMM GPRs on entry to the TDX module</span><br><span class="line">         */</span><br><span class="line">    xor %rax, %rax</span><br><span class="line">    xor %rcx, %rcx</span><br><span class="line">    xor %rdx, %rdx</span><br><span class="line">    xor %rbx, %rbx</span><br><span class="line">    xor %rbp, %rbp</span><br><span class="line">    xor %rsi, %rsi</span><br><span class="line">    xor %rdi, %rdi</span><br><span class="line">    xor %r8, %r8</span><br><span class="line">    xor %r9, %r9</span><br><span class="line">    xor %r10, %r10</span><br><span class="line">    xor %r11, %r11</span><br><span class="line">    xor %r12, %r12</span><br><span class="line">    xor %r13, %r13</span><br><span class="line">    xor %r14, %r14</span><br><span class="line">    xor %r15, %r15</span><br><span class="line"></span><br><span class="line">    // Protection against speculative attacks on GPRs</span><br><span class="line">    lfence</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Call the VMM API dispatcher</span><br><span class="line">     */</span><br><span class="line">     callq tdx_vmm_dispatcher</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Dispatcher should not retrun to this code</span><br><span class="line">     * It returns to the VMM using SEAMRET</span><br><span class="line">     * Panic with UD2 if reached</span><br><span class="line">     */</span><br><span class="line">    ud2</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tdx_vmm_dispatcher</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Must be first thing to do before accessing local/global data or sysinfo table</span></span><br><span class="line">    <span class="type">tdx_module_local_t</span>* local_data = init_data_fast_ref_ptrs();</span><br><span class="line">        _STATIC_INLINE_ <span class="type">tdx_module_local_t</span>* <span class="title function_">init_data_fast_ref_ptrs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">tdx_module_local_t</span>* local_data = calculate_local_data();</span><br><span class="line">                    <span class="comment">// In SEAM TDX module, GSBASE holds a pointer to the local data of current thread</span></span><br><span class="line">                    <span class="comment">// We are reading GSBASE by loading effective address of 0 with GS prefix</span></span><br><span class="line">                    _STATIC_INLINE_ <span class="type">tdx_module_local_t</span>* <span class="title function_">calculate_local_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">void</span>* local_data_addr;</span><br><span class="line">                        _ASM_VOLATILE_ (<span class="string">&quot;rdgsbase %0&quot;</span></span><br><span class="line">                                        :<span class="string">&quot;=r&quot;</span>(local_data_addr)</span><br><span class="line">                                        :</span><br><span class="line">                                        :<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">return</span> (<span class="type">tdx_module_local_t</span>*)local_data_addr;</span><br><span class="line">                    &#125;</span><br><span class="line">            IF_RARE (!local_data-&gt;local_data_fast_ref_ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                local_data-&gt;local_data_fast_ref_ptr  = local_data;</span><br><span class="line">                local_data-&gt;sysinfo_fast_ref_ptr     = calculate_sysinfo_table();</span><br><span class="line">                local_data-&gt;global_data_fast_ref_ptr = calculate_global_data((<span class="type">sysinfo_table_t</span>*)</span><br><span class="line">                                                            local_data-&gt;sysinfo_fast_ref_ptr);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> local_data;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        leaf_opcode.raw = local_data-&gt;vmm_regs.rax;</span><br><span class="line">                    <span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">gprs_state_u</span></span></span><br><span class="line"><span class="class">                    &#123;</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                        &#123;</span></span><br><span class="line">                            <span class="type">uint64_t</span> rax;</span><br><span class="line">                            <span class="type">uint64_t</span> rcx;</span><br><span class="line">                            <span class="type">uint64_t</span> rdx;</span><br><span class="line">                            <span class="type">uint64_t</span> rbx;</span><br><span class="line">                            <span class="type">uint64_t</span> rsp;</span><br><span class="line">                            <span class="type">uint64_t</span> rbp;</span><br><span class="line">                            <span class="type">uint64_t</span> rsi;</span><br><span class="line">                            <span class="type">uint64_t</span> rdi;</span><br><span class="line">                            <span class="type">uint64_t</span> r8;</span><br><span class="line">                            <span class="type">uint64_t</span> r9;</span><br><span class="line">                            <span class="type">uint64_t</span> r10;</span><br><span class="line">                            <span class="type">uint64_t</span> r11;</span><br><span class="line">                            <span class="type">uint64_t</span> r12;</span><br><span class="line">                            <span class="type">uint64_t</span> r13;</span><br><span class="line">                            <span class="type">uint64_t</span> r14;</span><br><span class="line">                            <span class="type">uint64_t</span> r15;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    </span><br><span class="line">                        <span class="type">uint64_t</span> gprs[<span class="number">16</span>];</span><br><span class="line">                    &#125; <span class="type">gprs_state_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br></pre></td><td class="code"><pre><span class="line">api_error_type <span class="title function_">tdh_vp_enter</span><span class="params">(<span class="type">uint64_t</span> vcpu_handle_and_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Local data for return values and global data</span></span><br><span class="line">    <span class="type">tdx_module_local_t</span>  * local_data_ptr = get_local_data();</span><br><span class="line">    <span class="type">tdx_module_global_t</span> * global_data_ptr = get_global_data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TDVPR related variables</span></span><br><span class="line">    <span class="type">pa_t</span>                  tdvpr_pa;                    <span class="comment">// TDVPR physical address</span></span><br><span class="line">    <span class="type">tdvps_t</span>             * tdvps_ptr = <span class="literal">NULL</span>;            <span class="comment">// Pointer to the TDVPS (multi-page linear address)</span></span><br><span class="line">    <span class="type">pamt_block_t</span>          tdvpr_pamt_block;            <span class="comment">// TDVPR PAMT block</span></span><br><span class="line">    <span class="type">pamt_entry_t</span>        * tdvpr_pamt_entry_ptr;        <span class="comment">// Pointer to the TDVPR PAMT entry</span></span><br><span class="line">    <span class="type">bool_t</span>                tdvpr_locked_flag = <span class="literal">false</span>;   <span class="comment">// Indicate TDVPR is locked</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TDR related variables</span></span><br><span class="line">    <span class="type">pa_t</span>                  tdr_pa;                      <span class="comment">// TDR physical address</span></span><br><span class="line">    <span class="type">tdr_t</span>               * tdr_ptr;                     <span class="comment">// Pointer to the TDR page (linear address)</span></span><br><span class="line">    <span class="type">pamt_entry_t</span>        * tdr_pamt_entry_ptr;          <span class="comment">// Pointer to the TDR PAMT entry</span></span><br><span class="line">    <span class="type">bool_t</span>                tdr_locked_flag = <span class="literal">false</span>;     <span class="comment">// Indicate TDVPR is locked</span></span><br><span class="line"></span><br><span class="line">    <span class="type">tdcs_t</span>              * tdcs_ptr = <span class="literal">NULL</span>;             <span class="comment">// Pointer to the TDCS page (linear address)</span></span><br><span class="line">    <span class="type">bool_t</span>                op_state_locked_flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span>              td_hkid;</span><br><span class="line">    <span class="type">tdvmcall_control_t</span>    control;</span><br><span class="line">    <span class="type">bool_t</span>                td_vmcs_loaded = <span class="literal">false</span>;      <span class="comment">// Indicates whether TD VMCS was loaded</span></span><br><span class="line">    <span class="type">vcpu_and_flags_t</span>      vcpu_and_flags = &#123; .raw = vcpu_handle_and_flags &#125;;</span><br><span class="line">    <span class="type">bool_t</span>                is_sept_locked = <span class="literal">false</span>;</span><br><span class="line">    api_error_type        return_val = UNINITIALIZE_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="type">ia32_misc_enable_t</span> misc_enable = &#123; .raw = ia32_rdmsr(IA32_MISC_ENABLES_MSR_ADDR) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Boot NT4 bit should not be set</span></span><br><span class="line">    <span class="keyword">if</span> (misc_enable.boot_nt4)</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = TDX_LIMIT_CPUID_MAXVAL_SET;</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vcpu_and_flags.reserved_0 || vcpu_and_flags.reserved_1)</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = api_error_with_operand_id(TDX_OPERAND_INVALID, OPERAND_ID_RCX);</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Input VCPU handle and flags has reserved bits sets - 0x%llx\n&quot;</span>, vcpu_and_flags.raw);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tdvpr_pa.raw = <span class="number">0</span>;</span><br><span class="line">    tdvpr_pa.page_4k_num = vcpu_and_flags.tdvpra_hpa_51_12;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check and lock the TDVPR page</span></span><br><span class="line">    return_val = check_and_lock_explicit_4k_private_hpa(tdvpr_pa,</span><br><span class="line">                                                         OPERAND_ID_RCX,</span><br><span class="line">                                                         TDX_LOCK_SHARED,</span><br><span class="line">                                                         PT_TDVPR,</span><br><span class="line">                                                         &amp;tdvpr_pamt_block,</span><br><span class="line">                                                         &amp;tdvpr_pamt_entry_ptr,</span><br><span class="line">                                                         &amp;tdvpr_locked_flag);</span><br><span class="line"></span><br><span class="line">    IF_RARE (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to check/lock a TDVPR (0x%llx) - error = %llx\n&quot;</span>, tdvpr_pa.raw, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get and lock the owner TDR page</span></span><br><span class="line">    <span class="comment">// TDR is mapped in static keyhole range, and thus doesn&#x27;t need to be freed</span></span><br><span class="line">    tdr_pa = get_pamt_entry_owner(tdvpr_pamt_entry_ptr);</span><br><span class="line">    return_val = lock_and_map_implicit_tdr(tdr_pa,</span><br><span class="line">                                           OPERAND_ID_TDR,</span><br><span class="line">                                           TDX_RANGE_RW,</span><br><span class="line">                                           TDX_LOCK_SHARED,</span><br><span class="line">                                           &amp;tdr_pamt_entry_ptr,</span><br><span class="line">                                           &amp;tdr_locked_flag,</span><br><span class="line">                                           &amp;tdr_ptr);</span><br><span class="line">                              api_error_type <span class="title function_">lock_and_map_implicit_tdr</span><span class="params">(</span></span><br><span class="line"><span class="params">                                    <span class="type">pa_t</span> tdr_pa,</span></span><br><span class="line"><span class="params">                                    <span class="type">uint64_t</span> operand_id,</span></span><br><span class="line"><span class="params">                                    <span class="type">mapping_type_t</span> mapping_type,</span></span><br><span class="line"><span class="params">                                    <span class="type">lock_type_t</span> lock_type,</span></span><br><span class="line"><span class="params">                                    <span class="type">pamt_entry_t</span>** pamt_entry,</span></span><br><span class="line"><span class="params">                                    <span class="type">bool_t</span>* is_locked,</span></span><br><span class="line"><span class="params">                                    <span class="type">tdr_t</span>** tdr_p</span></span><br><span class="line"><span class="params">                                    )</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                api_error_code_e errc = pamt_implicit_get_and_lock(tdr_pa, PT_4KB, lock_type, pamt_entry);</span><br><span class="line">                                            api_error_code_e <span class="title function_">pamt_implicit_get_and_lock</span><span class="params">(<span class="type">pa_t</span> pa, <span class="type">page_size_t</span> leaf_size, <span class="type">lock_type_t</span> leaf_lock_type,</span></span><br><span class="line"><span class="params">                                                            <span class="type">pamt_entry_t</span>** pamt_entry)</span></span><br><span class="line">                                            &#123;</span><br><span class="line">                                                api_error_code_e errc;</span><br><span class="line">                                                <span class="type">pamt_entry_t</span>* tmp_pamt_entry = pamt_implicit_get(pa, leaf_size);</span><br><span class="line">                                            </span><br><span class="line">                                                <span class="keyword">if</span> ((errc = acquire_sharex_lock_hp(&amp;tmp_pamt_entry-&gt;entry_lock, leaf_lock_type, <span class="literal">false</span>)) != TDX_SUCCESS)</span><br><span class="line">                                                &#123;</span><br><span class="line">                                                    free_la(tmp_pamt_entry);</span><br><span class="line">                                                    *pamt_entry = <span class="literal">NULL</span>;</span><br><span class="line">                                                    <span class="keyword">return</span> errc;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            </span><br><span class="line">                                                *pamt_entry = tmp_pamt_entry;</span><br><span class="line">                                                <span class="keyword">return</span> TDX_SUCCESS;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                <span class="keyword">if</span> (errc != TDX_SUCCESS)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    TDX_ERROR(<span class="string">&quot;get_implicit_page_pamt_and_lock error\n&quot;</span>);</span><br><span class="line">                                    <span class="keyword">return</span> api_error_with_operand_id(errc, operand_id);</span><br><span class="line">                                &#125;</span><br><span class="line">                            </span><br><span class="line">                                *is_locked = <span class="literal">true</span>;</span><br><span class="line">                            </span><br><span class="line">                                <span class="type">uint16_t</span> hkid = get_global_data()-&gt;hkid;</span><br><span class="line">                                tdr_pa = set_hkid_to_pa(tdr_pa, hkid);</span><br><span class="line">                            </span><br><span class="line">                                <span class="type">uint64_t</span> tdr_addr = tdr_pa.full_pa;</span><br><span class="line">                            </span><br><span class="line">                                *tdr_p = map_continuous_pages(&amp;tdr_addr, <span class="number">1</span>, mapping_type, STATIC_KEYHOLE_IDX_TDR);</span><br><span class="line">                            </span><br><span class="line">                                <span class="keyword">return</span> TDX_SUCCESS;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">    IF_RARE (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to lock/map a TDR - error = %lld\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map the TDCS structure and check the state</span></span><br><span class="line">    return_val = check_state_map_tdcs_and_lock(tdr_ptr, TDX_RANGE_RW, TDX_LOCK_SHARED,</span><br><span class="line">                                               <span class="literal">false</span>, TDH_VP_ENTER_LEAF, &amp;tdcs_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;State check or TDCS lock failure - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    op_state_locked_flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the TD&#x27;s ephemeral HKID</span></span><br><span class="line">    td_hkid = tdr_ptr-&gt;key_management_fields.hkid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map the TDVPS structure</span></span><br><span class="line">    <span class="comment">// TDVPS is mapped in static keyhole range, and thus doesn&#x27;t need to be freed</span></span><br><span class="line">    tdvps_ptr = map_tdvps(tdvpr_pa, td_hkid, tdcs_ptr-&gt;management_fields.num_l2_vms, TDX_RANGE_RW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdvps_ptr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;TDVPS mapping failed\n&quot;</span>);</span><br><span class="line">        return_val = TDX_TDCX_NUM_INCORRECT;</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Associate the VCPU</span></span><br><span class="line">    <span class="type">bool_t</span> new_associate_flag = <span class="literal">false</span>;</span><br><span class="line">    return_val = check_and_associate_vcpu(tdvps_ptr, tdcs_ptr, &amp;new_associate_flag, <span class="literal">false</span>);</span><br><span class="line">                api_error_code_e <span class="title function_">check_and_associate_vcpu</span><span class="params">(<span class="type">tdvps_t</span> * tdvps_ptr,</span></span><br><span class="line"><span class="params">                                              <span class="type">tdcs_t</span> * tdcs_ptr,</span></span><br><span class="line"><span class="params">                                              <span class="type">bool_t</span>* new_association,</span></span><br><span class="line"><span class="params">                                                          <span class="type">bool_t</span> allow_disabled)</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">uint8_t</span> curr_vcpu_state = tdvps_ptr-&gt;management.state;</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *  Check the VCPU state to make sure it has been initialized and is not</span></span><br><span class="line"><span class="comment">                     *  being torn down.  This may race with state changes if the VCPU is</span></span><br><span class="line"><span class="comment">                     *  associated with another LP.  In this case the subsequent association</span></span><br><span class="line"><span class="comment">                     *  below will fail</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (!((curr_vcpu_state == VCPU_READY) ||</span><br><span class="line">                          ((curr_vcpu_state == VCPU_DISABLED) &amp;&amp; allow_disabled)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> TDX_VCPU_STATE_INCORRECT;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">return</span> associate_vcpu(tdvps_ptr, tdcs_ptr, new_association);</span><br><span class="line">                                                    api_error_code_e <span class="title function_">associate_vcpu</span><span class="params">(<span class="type">tdvps_t</span> * tdvps_ptr,</span></span><br><span class="line"><span class="params">                                                                <span class="type">tdcs_t</span> * tdcs_ptr,</span></span><br><span class="line"><span class="params">                                                                <span class="type">bool_t</span>* new_association)</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                            <span class="type">uint32_t</span>         prev_assoc_lpid;  <span class="comment">// Previous associated LPID</span></span><br><span class="line">                                            <span class="type">uint32_t</span>         curr_lp_id = get_local_data()-&gt;lp_info.lp_id;</span><br><span class="line">                                        </span><br><span class="line">                                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                             *  Atomically check that this VCPU is not associated with any LP, and</span></span><br><span class="line"><span class="comment">                                             *  associate it with the current LP.  The VCPU may already be associated</span></span><br><span class="line"><span class="comment">                                             *  with the current LP, but if it&#x27;s associated with another LP this is</span></span><br><span class="line"><span class="comment">                                             *  an error.</span></span><br><span class="line"><span class="comment">                                             */</span></span><br><span class="line">                                            prev_assoc_lpid = _lock_cmpxchg_32b(VCPU_NO_LP, <span class="comment">// Expected value: no lp</span></span><br><span class="line">                                                                                curr_lp_id,  <span class="comment">// New Value</span></span><br><span class="line">                                                                                &amp;tdvps_ptr-&gt;management.assoc_lpid); <span class="comment">// Target</span></span><br><span class="line">                                            <span class="keyword">if</span> ((prev_assoc_lpid != VCPU_NO_LP) &amp;&amp; (prev_assoc_lpid != curr_lp_id))</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="keyword">return</span> TDX_VCPU_ASSOCIATED;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        </span><br><span class="line">                                            <span class="comment">// Association succeeded.  VCPU state must be VCPU_READY_*</span></span><br><span class="line">                                        </span><br><span class="line">                                            <span class="comment">// Set ACTIVE_VMCS to -1 to indicate the need for VMPTRLD</span></span><br><span class="line">                                            get_local_data()-&gt;vp_ctx.active_vmcs = ACTIVE_VMCS_NONE;</span><br><span class="line">                                        </span><br><span class="line">                                            <span class="type">uint64_t</span> seamdb_index = get_global_data()-&gt;seamdb_index;</span><br><span class="line">                                            <span class="keyword">if</span> (tdvps_ptr-&gt;management.last_seamdb_index != seamdb_index)</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="comment">// The TDX module has been updated since the last time this VCPU was associated.</span></span><br><span class="line">                                                <span class="comment">// The VCPU remains associated with the current LP.</span></span><br><span class="line">                                                clear_module_host_state_flags(tdvps_ptr);</span><br><span class="line">                                                clear_lp_host_state_flags(tdvps_ptr);</span><br><span class="line">                                                tdvps_ptr-&gt;management.last_seamdb_index = seamdb_index;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        </span><br><span class="line">                                            <span class="comment">// If this is a new association, update TD VMCS</span></span><br><span class="line">                                            <span class="keyword">if</span> (prev_assoc_lpid == VCPU_NO_LP)</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="comment">// The current VCPU is associated with a new LP</span></span><br><span class="line">                                        </span><br><span class="line">                                                clear_lp_host_state_flags(tdvps_ptr);</span><br><span class="line">                                        </span><br><span class="line">                                                <span class="comment">// Atomically increment the number of associated VCPUs</span></span><br><span class="line">                                                (<span class="type">void</span>)_lock_xadd_32b(&amp;(tdcs_ptr-&gt;management_fields.num_assoc_vcpus), <span class="number">1</span>);</span><br><span class="line">                                        </span><br><span class="line">                                                *new_association = <span class="literal">true</span>;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                            <span class="keyword">else</span></span><br><span class="line">                                            &#123;</span><br><span class="line">                                                *new_association = <span class="literal">false</span>;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        </span><br><span class="line">                                            <span class="keyword">return</span> TDX_SUCCESS;</span><br><span class="line">                                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">    IF_RARE (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to associate VCPU - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_vm_vmcs_as_active(tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class="line">    td_vmcs_loaded = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((vcpu_and_flags.host_recoverability_hint) &amp;&amp; (tdvps_ptr-&gt;management.last_td_exit != LAST_EXIT_ASYNC_TRAP))</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = api_error_with_operand_id(TDX_OPERAND_INVALID, OPERAND_ID_RCX);</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Host recoverability is set, but last exit wasn&#x27;t ASYNC_TRAP - %d\n&quot;</span>, tdvps_ptr-&gt;management.last_td_exit);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vcpu_and_flags.resume_l1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resume to L1 is only supported on exit from L2</span></span><br><span class="line">        <span class="keyword">if</span> (tdvps_ptr-&gt;management.curr_vm == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            return_val = api_error_with_operand_id(TDX_OPERAND_INVALID, OPERAND_ID_RCX);</span><br><span class="line">            TDX_ERROR(<span class="string">&quot;Resume to L1 is only supported on exit from L2\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RESUME_L1 is sticky; the internal flag is cleared later, only if actual L1 entry happens</span></span><br><span class="line">        set_l2_exit_host_routing(tdvps_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We read TSC below.  Compare IA32_TSC_ADJUST to the value sampled on TDHSYSINIT</span></span><br><span class="line">    <span class="comment">// to make sure the host VMM doesn&#x27;t play any trick on us.</span></span><br><span class="line">    IF_RARE (ia32_rdmsr(IA32_TSC_ADJ_MSR_ADDR) != global_data_ptr-&gt;plt_common_config.ia32_tsc_adjust)</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = api_error_with_operand_id(TDX_INCONSISTENT_MSR, IA32_TSC_ADJ_MSR_ADDR);</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Inconsistent IA32_TSC_ADJUST MSR!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read TSC and verify that it is higher than LAST_EXIT_TSC.</span></span><br><span class="line">    <span class="comment">// Do the calculation as signed 64b, works even if TSC rolls over.</span></span><br><span class="line">    IF_RARE (((<span class="type">int64_t</span>)(ia32_rdtsc() - tdvps_ptr-&gt;management.last_exit_tsc)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = TDX_TSC_ROLLBACK;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;TSC is lower than LAST_EXIT_TSC!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If MONITOR/MWAIT support is enabled, then MONITOR_FSM must be enabled</span></span><br><span class="line">    <span class="keyword">if</span> (tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.monitor_mwait_supported &amp;&amp;</span><br><span class="line">        !misc_enable.enable_monitor_fsm)</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = api_error_with_operand_id(TDX_INCORRECT_MSR_VALUE, IA32_MISC_ENABLES_MSR_ADDR);</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;If MONITOR/MWAIT support is enabled, then MONITOR_FSM must be enabled\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save the VMM value of IA32_DS_AREA</span></span><br><span class="line">    local_data_ptr-&gt;vmm_non_extended_state.ia32_ds_area = ia32_rdmsr(IA32_DS_AREA_MSR_ADDR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the TLB tracking state. This is done as a critical section,</span></span><br><span class="line">    <span class="comment">// allowing concurrent TDHVPENTERs, but no concurrent TDHMEMTRACK</span></span><br><span class="line">    IF_RARE (!adjust_tlb_tracking_state(tdr_ptr, tdcs_ptr, tdvps_ptr, new_associate_flag))</span><br><span class="line">    &#123;</span><br><span class="line">                        <span class="type">bool_t</span> <span class="title function_">adjust_tlb_tracking_state</span><span class="params">(<span class="type">tdr_t</span>* tdr_ptr, <span class="type">tdcs_t</span>* tdcs_ptr, <span class="type">tdvps_t</span>* tdvps_ptr,</span></span><br><span class="line"><span class="params">                                                     <span class="type">bool_t</span> new_association)</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">tdcs_epoch_tracking_fields_t</span>* epoch_tracking = &amp;tdcs_ptr-&gt;epoch_tracking;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Lock the TD epoch</span></span><br><span class="line">                        <span class="keyword">if</span> (acquire_sharex_lock_sh(&amp;epoch_tracking-&gt;epoch_lock) != LOCK_RET_SUCCESS)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Sample the TD epoch and atomically increment the REFCOUNT</span></span><br><span class="line">                        <span class="type">uint64_t</span> vcpu_epoch = epoch_tracking-&gt;epoch_and_refcount.td_epoch;</span><br><span class="line">                        (<span class="type">void</span>)_lock_xadd_16b(&amp;epoch_tracking-&gt;epoch_and_refcount.refcount[vcpu_epoch &amp; <span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// End of critical section, release lock.</span></span><br><span class="line">                        release_sharex_lock_sh(&amp;epoch_tracking-&gt;epoch_lock);</span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">if</span> (vcpu_epoch != tdvps_ptr-&gt;management.vcpu_epoch)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!new_association)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                 *  The current VCPU was already associated with the current LP at the</span></span><br><span class="line"><span class="comment">                                 *  beginning of TDHVPENTER.</span></span><br><span class="line"><span class="comment">                                 *  Flush the TLB context and extended paging structure (EPxE) caches</span></span><br><span class="line"><span class="comment">                                 *  associated with the current TD.</span></span><br><span class="line"><span class="comment">                                 *  Else, no need to flush, since this LP is guaranteed not to hold any</span></span><br><span class="line"><span class="comment">                                 *  address translation for this VCPU</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                                <span class="comment">// Execute INVEPT type 1 for each Secure EPT</span></span><br><span class="line">                                flush_all_td_asids(tdr_ptr, tdcs_ptr);</span><br><span class="line">                    </span><br><span class="line">                                <span class="comment">// Invalidate all soft-translated GPAs</span></span><br><span class="line">                                invalidate_all_gpa_translations(tdcs_ptr, tdvps_ptr);</span><br><span class="line">                            &#125;</span><br><span class="line">                    </span><br><span class="line">                            <span class="comment">// Store the sampled value of TD_EPOCH as the new value of VCPU_EPOCH</span></span><br><span class="line">                            tdvps_ptr-&gt;management.vcpu_epoch = vcpu_epoch;</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to acquire global lock for TD epoch\n&quot;</span>);</span><br><span class="line">        return_val = api_error_with_operand_id(TDX_OPERAND_BUSY, OPERAND_ID_TD_EPOCH);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stepping_filter_e filter_result = FILTER_OK_CONTINUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sample current VMCS state for handling stepping filter FILTER_OK_NOTIFY_EPS_FAULT case</span></span><br><span class="line">    <span class="type">vm_vmexit_exit_reason_t</span> exit_reason;</span><br><span class="line">    <span class="type">vmx_exit_qualification_t</span> exit_qualification;</span><br><span class="line">    <span class="type">pa_t</span> faulting_gpa;</span><br><span class="line"></span><br><span class="line">    ia32_vmread(VMX_VM_EXIT_REASON_ENCODE, &amp;exit_reason.raw);</span><br><span class="line">    ia32_vmread(VMX_VM_EXIT_QUALIFICATION_ENCODE, &amp;exit_qualification.raw);</span><br><span class="line">    ia32_vmread(VMX_GUEST_PHYSICAL_ADDRESS_INFO_FULL_ENCODE, &amp;faulting_gpa.raw);</span><br><span class="line"></span><br><span class="line">    IF_RARE ((return_val = handle_stepping_filter(tdr_ptr, tdcs_ptr, tdvps_ptr, exit_reason, &amp;faulting_gpa,</span><br><span class="line">                                                  &amp;is_sept_locked, &amp;filter_result)) != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed handling stepping filter - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdvps_ptr-&gt;management.curr_vm != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return_val = handle_l2_entry(tdr_ptr, tdcs_ptr, tdvps_ptr,</span><br><span class="line">                                           &amp;exit_reason, &amp;exit_qualification, &amp;faulting_gpa);</span><br><span class="line"></span><br><span class="line">        IF_RARE (return_val != TDX_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            TDX_ERROR(<span class="string">&quot;Failed to handle L2 entry\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the stepping filter above indicated a #VE injection, inject it now to the L1 VMM</span></span><br><span class="line">    <span class="comment">// being entered, with the values sampled above from the VMCS of the VM that previously exited.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((filter_result == FILTER_OK_NOTIFY_EPS_FAULT) &amp;&amp; can_inject_epf_ve(exit_qualification, tdvps_ptr))</span><br><span class="line">    &#123;</span><br><span class="line">        tdx_debug_assert(tdvps_ptr-&gt;management.curr_vm == <span class="number">0</span>);</span><br><span class="line">        tdx_inject_ve((<span class="type">uint32_t</span>)exit_reason.raw, exit_qualification.raw, tdvps_ptr, faulting_gpa.raw, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*-------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">    At this point we&#x27;re at the VM to be entered - if there was an L2-&gt;L1 virtual exit</span></span><br><span class="line"><span class="comment">    then the state of L1 is after the L2-&gt;L1 exit.</span></span><br><span class="line"><span class="comment">    If the stepping filter above indicated too many EPT violations on private GPA,</span></span><br><span class="line"><span class="comment">    emulate an EPT violation TD exit; do not do an actual VM entry so the VM is not</span></span><br><span class="line"><span class="comment">    exposed to the 0-step attack.</span></span><br><span class="line"><span class="comment">    -------------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filter_result == FILTER_FAIL_TDENTER_EPFS)</span><br><span class="line">    &#123;</span><br><span class="line">        tdx_debug_assert(is_sept_locked == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// decrement the TLB tracker that was incremented at the beginning of TDENTER</span></span><br><span class="line">        revert_tlb_tracking_state(tdcs_ptr, tdvps_ptr);</span><br><span class="line"></span><br><span class="line">        emulate_ept_violation_td_exit(get_local_data(), faulting_gpa, tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class="line"></span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Too many EPT violation on private GPA - 0x%llx\n&quot;</span>, faulting_gpa.raw);</span><br><span class="line">        return_val = VMEXIT_REASON_EPT_VIOLATION;</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translate soft-translated GPAs, if required</span></span><br><span class="line">    <span class="keyword">if</span> ((tdvps_ptr-&gt;management.curr_vm != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        !translate_gpas(tdr_ptr, tdcs_ptr, tdvps_ptr, tdvps_ptr-&gt;management.curr_vm, &amp;faulting_gpa.raw))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// decrement the TLB tracker that was incremented at the beginning of TDENTER</span></span><br><span class="line">        revert_tlb_tracking_state(tdcs_ptr, tdvps_ptr);</span><br><span class="line"></span><br><span class="line">        emulate_ept_violation_td_exit(get_local_data(), faulting_gpa, tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;EPT violation due GPA (0x%llx) translation\n&quot;</span>, faulting_gpa.raw);</span><br><span class="line"></span><br><span class="line">        return_val = VMEXIT_REASON_EPT_VIOLATION;</span><br><span class="line">        <span class="keyword">goto</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALL CHECKS PASSED:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* OP_STATE has been locked in a temporary mode; it is released before</span></span><br><span class="line"><span class="comment">       entering non-root mode. */</span></span><br><span class="line">    tdx_debug_assert(op_state_locked_flag);</span><br><span class="line">    release_sharex_lock_hp_sh(&amp;(tdcs_ptr-&gt;management_fields.op_state_lock));</span><br><span class="line">    op_state_locked_flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the current VCPU to be executed on this LP is not the same as the last one,</span></span><br><span class="line">    <span class="comment">// issue an indirect branch prediction barrier (IBPB) command</span></span><br><span class="line">    <span class="keyword">if</span> (tdvpr_pa.raw != local_data_ptr-&gt;vp_ctx.last_tdvpr_pa.raw)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The TD ASID (Address Space Identifier) does not distinguish between different VCPUs of the same TD.</span></span><br><span class="line">        <span class="comment">// Therefore, when switching VCPU of the same TD on the same LP we should invalidate EPT.</span></span><br><span class="line">        <span class="comment">// Practically, we do this on every VCPU switch (even not of the same TD).</span></span><br><span class="line">        <span class="comment">// This is because it is difficult to track the history of TD execution on an LP</span></span><br><span class="line">        <span class="comment">// (i.e., we should check for every TD/VCPU combination in the past).</span></span><br><span class="line">        flush_all_td_asids(tdr_ptr, tdcs_ptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Issue an indirect branch prediction barrier (IBPB) command, since the CPU does not</span></span><br><span class="line">        <span class="comment">// distinguish between VCPUs for its branch prediction.</span></span><br><span class="line">        <span class="type">ia32_pred_cmd_t</span> pred_cmd = &#123; .raw = <span class="number">0</span> &#125;;</span><br><span class="line">        pred_cmd.ibpb = <span class="number">1</span>;</span><br><span class="line">        ia32_wrmsr(IA32_PRED_CMD_MSR_ADDR, pred_cmd.raw);</span><br><span class="line">        local_data_ptr-&gt;vp_ctx.last_tdvpr_pa.raw = tdvpr_pa.raw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save the TDR, TDCS and TDVPS linear pointers for use after every VM exit</span></span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdr               = tdr_ptr;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdr_pamt_entry    = tdr_pamt_entry_ptr;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdr_pa            = tdr_pa;</span><br><span class="line"></span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdvps             = tdvps_ptr;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdvpr_pamt_entry  = tdvpr_pamt_entry_ptr;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdvpr_pamt_block  = tdvpr_pamt_block;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdvpr_pa          = tdvpr_pa;</span><br><span class="line"></span><br><span class="line">    local_data_ptr-&gt;vp_ctx.tdcs              = tdcs_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save some other TD state to avoid accessing TDCS and TDVPS in case of a</span></span><br><span class="line">    <span class="comment">// memory integrity error</span></span><br><span class="line">    local_data_ptr-&gt;vp_ctx.attributes = tdcs_ptr-&gt;executions_ctl_fields.attributes;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.xfam = tdvps_ptr-&gt;management.xfam;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.xfd_supported = tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.xfd_supported;</span><br><span class="line">    local_data_ptr-&gt;vp_ctx.ia32_perf_global_status = tdvps_ptr-&gt;guest_msr_state.ia32_perf_global_status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore Guest Extended State</span></span><br><span class="line">    <span class="keyword">if</span> (tdvps_ptr-&gt;management.last_td_exit == LAST_EXIT_TDVMCALL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Last TD exit was a TDGVPVMCALL. GPR and XMM state passed from the host</span></span><br><span class="line">        <span class="comment">// VMM to the guest TD are selected by guest RCX, saved by TDGVPVMCALL.</span></span><br><span class="line">        control.raw = tdvps_ptr-&gt;guest_state.gpr_state.rcx;</span><br><span class="line"></span><br><span class="line">        save_regs_after_tdvmcall(tdvps_ptr, control, tdvps_ptr-&gt;guest_state.gpr_state.gprs);</span><br><span class="line">                <span class="type">static</span> <span class="type">void</span> <span class="title function_">save_regs_after_tdvmcall</span><span class="params">(<span class="type">tdvps_t</span>* tdvps_ptr, <span class="type">tdvmcall_control_t</span> control, </span></span><br><span class="line"><span class="params">                    <span class="type">uint64_t</span> gprs[<span class="number">16</span>])</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">uint64_t</span> mask;</span><br><span class="line">                    <span class="type">uint32_t</span> i;</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">/* Save XMM registers selected by guest RCX to TDVPS.</span></span><br><span class="line"><span class="comment">                     * Later on the whole state of XMMs, MXCSR and optionally YMMs and ZMMs is</span></span><br><span class="line"><span class="comment">                     * restored from TDVPS.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    save_xmms_by_mask(tdvps_ptr, control.xmm_select);</span><br><span class="line">                                <span class="type">static</span> <span class="type">void</span> <span class="title function_">save_xmms_by_mask</span><span class="params">(<span class="type">tdvps_t</span>* tdvps_ptr, <span class="type">uint16_t</span> xmm_select)</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="type">uint128_t</span> xmms[<span class="number">16</span>];</span><br><span class="line">                            </span><br><span class="line">                                store_xmms_in_buffer(xmms);</span><br><span class="line">                            </span><br><span class="line">                                <span class="comment">// Copy the required VMM XMM&#x27;s to the guest XMM&#x27;s</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (xmm_select &amp; (<span class="type">uint16_t</span>)BIT(i))</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        tdvps_ptr-&gt;guest_extension_state.xbuf.legacy_region.xmm[i] = xmms[i];</span><br><span class="line">                            </span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            </span><br><span class="line">                                basic_memset_to_zero(xmms, <span class="keyword">sizeof</span>(xmms));</span><br><span class="line">                            </span><br><span class="line">                                <span class="keyword">if</span> (xmm_select != <span class="number">0</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.xstate_bv |= BIT(<span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            </span><br><span class="line">                            &#125;</span><br><span class="line">                    <span class="comment">/* Save VMM GPRs selected by guest RCX to TDVPS.</span></span><br><span class="line"><span class="comment">                     * RAX and RCX are not copied, start from RDX.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    mask = <span class="number">0x0004</span>;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((control.gpr_select &amp; mask) != <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            gprs[i] = get_local_data()-&gt;vmm_regs.gprs[i];</span><br><span class="line">                        &#125;       </span><br><span class="line">                        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">                    gprs[<span class="number">0</span>] = TDX_SUCCESS;   <span class="comment">// RAX</span></span><br><span class="line">                    gprs[<span class="number">1</span>] = control.raw;   <span class="comment">// RCX</span></span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tdvps_ptr-&gt;management.last_td_exit == LAST_EXIT_ASYNC_TRAP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Following a trap-like TD exit, update the guest&#x27;s TDCALL completion status with</span></span><br><span class="line">        <span class="comment">// the host hint bit.</span></span><br><span class="line">        <span class="type">api_error_code_t</span> guest_tdcall_status;</span><br><span class="line">        guest_tdcall_status.raw = tdvps_ptr-&gt;guest_state.gpr_state.rax;</span><br><span class="line">        guest_tdcall_status.host_recoverability_hint = vcpu_and_flags.host_recoverability_hint;</span><br><span class="line">        tdvps_ptr-&gt;guest_state.gpr_state.rax = guest_tdcall_status.raw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdvps_ptr-&gt;management.curr_vm == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">vmx_procbased_ctls_t</span> vm_procbased_ctls;</span><br><span class="line">        <span class="comment">/* If PEND_NMI was requested, and there&#x27;s no pending #VE (which should be handled</span></span><br><span class="line"><span class="comment">           by the guest TD before NMI), set NMI Window Exiting execution control so NMI</span></span><br><span class="line"><span class="comment">           can be injected at the proper time. */</span></span><br><span class="line">        <span class="keyword">if</span> (tdvps_ptr-&gt;management.pend_nmi &amp;&amp; (tdvps_ptr-&gt;ve_info.valid == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ia32_vmread(VMX_VM_EXECUTION_CONTROL_PROC_BASED_ENCODE, &amp;vm_procbased_ctls.raw);</span><br><span class="line">            vm_procbased_ctls.nmi_window_exiting = <span class="number">1</span>;</span><br><span class="line">            ia32_vmwrite(VMX_VM_EXECUTION_CONTROL_PROC_BASED_ENCODE, vm_procbased_ctls.raw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// Reentering into L2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If NMI unblocking by IRET was indicated during VM exit, re-block NMI</span></span><br><span class="line">        <span class="keyword">if</span> (tdvps_ptr-&gt;management.nmi_unblocking_due_to_iret)</span><br><span class="line">        &#123;</span><br><span class="line">            set_guest_inter_blocking_by_nmi();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tdvps_ptr-&gt;management.state = VCPU_ACTIVE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the guest TD&#x27;s IA32_DEBUGCTL.ENABLE_UNCORE_PMI to the VMM&#x27;s value.</span></span><br><span class="line">    <span class="type">ia32_debugctl_t</span> debugctl;</span><br><span class="line">    ia32_vmread(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, &amp;debugctl.raw);</span><br><span class="line">    debugctl.en_uncore_pmi = local_data_ptr-&gt;ia32_debugctl_value.en_uncore_pmi;</span><br><span class="line">    ia32_vmwrite(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, debugctl.raw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdvps_ptr-&gt;management.curr_vm != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Set the VMX preemption timer, if TSC deadline is enabled</span></span><br><span class="line">        set_vmx_preemption_timer(tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the SEPT lock was acquired by the TDENTER stepping filter, release it now</span></span><br><span class="line">    <span class="comment">// SEPT lock will be acquired by TDENTER stepping filter only if it didn&#x27;t return</span></span><br><span class="line">    <span class="comment">// FILTER_FAIL_TDENTER_SEPT_BUSY or FILTER_FAIL_TDENTER_EPFS</span></span><br><span class="line">    <span class="keyword">if</span> (is_sept_locked)</span><br><span class="line">    &#123;</span><br><span class="line">        release_sharex_lock_ex(&amp;tdcs_ptr-&gt;executions_ctl_fields.secure_ept_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set VMCS.IA32_SPEC_CTRL_SHADOW to the virtual value of IA32_SPEC_CTRL as seen by the TD</span></span><br><span class="line">    ia32_vmwrite(VMX_IA32_SPEC_CTRL_SHADOW,</span><br><span class="line">            calculate_virt_ia32_spec_ctrl(tdcs_ptr, tdvps_ptr-&gt;guest_msr_state.ia32_spec_ctrl));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore other Guest state (GPRs, DRs, MSRs) in TDVPS</span></span><br><span class="line">    restore_guest_td_state_before_td_entry(tdcs_ptr, tdvps_ptr);</span><br><span class="line"></span><br><span class="line">    update_host_state_in_td_vmcs(local_data_ptr, tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class="line"></span><br><span class="line">    local_data_ptr-&gt;single_step_def_state.last_entry_tsc = ia32_rdtsc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdvps_ptr-&gt;management.vm_launched[tdvps_ptr-&gt;management.curr_vm])</span><br><span class="line">    &#123;</span><br><span class="line">        tdx_return_to_td(<span class="literal">true</span>, <span class="literal">true</span>, &amp;tdvps_ptr-&gt;guest_state.gpr_state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tdx_return_to_td(<span class="literal">false</span>, <span class="literal">true</span>, &amp;tdvps_ptr-&gt;guest_state.gpr_state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flow should never reach here</span></span><br><span class="line">    tdx_sanity_check(<span class="number">0</span>, SCEC_SEAMCALL_SOURCE(TDH_VP_ENTER_LEAF), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">EXIT_FAILURE:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_sept_locked)</span><br><span class="line">    &#123;</span><br><span class="line">        release_sharex_lock_ex(&amp;tdcs_ptr-&gt;executions_ctl_fields.secure_ept_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if we need to load the SEAM VMCS</span></span><br><span class="line">    IF_COMMON (td_vmcs_loaded)</span><br><span class="line">    &#123;</span><br><span class="line">        set_seam_vmcs_as_active();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release all acquired locks and free keyhole mappings</span></span><br><span class="line">    IF_COMMON (tdcs_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        IF_COMMON (op_state_locked_flag)</span><br><span class="line">        &#123;</span><br><span class="line">            release_sharex_lock_hp_sh(&amp;(tdcs_ptr-&gt;management_fields.op_state_lock));</span><br><span class="line">        &#125;</span><br><span class="line">        free_la(tdcs_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IF_COMMON (tdr_locked_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        pamt_implicit_release_lock(tdr_pamt_entry_ptr, TDX_LOCK_SHARED);</span><br><span class="line">        free_la(tdr_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IF_COMMON (tdvpr_locked_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        pamt_unwalk(tdvpr_pa, tdvpr_pamt_block, tdvpr_pamt_entry_ptr, TDX_LOCK_SHARED, PT_4KB);</span><br><span class="line">        <span class="keyword">if</span> (tdvps_ptr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            free_la(tdvps_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> return_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tdx_return_to_td</span><span class="params">(<span class="type">bool_t</span> launch_state, <span class="type">bool_t</span> called_from_tdenter, <span class="type">gprs_state_t</span>* gpr_state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TDX Local data</span></span><br><span class="line">    <span class="type">tdx_module_local_t</span>* local_data_ptr = get_local_data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore IA32_SPEC_CTRL</span></span><br><span class="line">    <span class="keyword">if</span> (!called_from_tdenter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// TDENTER already loads the spec ctrl with safe checks</span></span><br><span class="line">        wrmsr_opt(IA32_SPEC_CTRL_MSR_ADDR,</span><br><span class="line">                  local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_spec_ctrl, TDX_MODULE_IA32_SPEC_CTRL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that we have no mapped keyholes left, beside the 2 that we store for TDR/TDVPR PAMT entries</span></span><br><span class="line">    tdx_sanity_check(local_data_ptr-&gt;keyhole_state.total_ref_count == NUM_OF_PRESERVED_KEYHOLES,</span><br><span class="line">                     SCEC_KEYHOLE_MANAGER_SOURCE, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    local_data_ptr-&gt;current_td_vm_id = local_data_ptr-&gt;vp_ctx.tdvps-&gt;management.curr_vm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exit to TD</span></span><br><span class="line">    tdx_tdentry_to_td(launch_state, gpr_state);<span class="comment">//guest_state.gpr_state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">tdx_tdentry_to_td:</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Restore all TD GPRs on module entry from a TDVPS GPR area ptr passed in RSI</span><br><span class="line">     */</span><br><span class="line">    movq (%rsi),     %rax</span><br><span class="line">    movq 8(%rsi),    %rcx</span><br><span class="line">    movq 16(%rsi),   %rdx</span><br><span class="line">    movq 24(%rsi),   %rbx</span><br><span class="line">    // movq 32(%rsi),   %rsp - keep the RSP of the TDX module for debug purposes.</span><br><span class="line">    // Actual RSP of the TD will be loaded during the VMENTRY from the TDCS (TD VMCS)</span><br><span class="line">    movq 40(%rsi),   %rbp</span><br><span class="line"></span><br><span class="line">    // RSI and RDI will be restored later - we are still using them</span><br><span class="line"></span><br><span class="line">    movq 64(%rsi),   %r8</span><br><span class="line">    movq 72(%rsi),   %r9</span><br><span class="line">    movq 80(%rsi),   %r10</span><br><span class="line">    movq 88(%rsi),   %r11</span><br><span class="line">    movq 96(%rsi),   %r12</span><br><span class="line">    movq 104(%rsi),  %r13</span><br><span class="line">    movq 112(%rsi),  %r14</span><br><span class="line">    movq 120(%rsi),  %r15</span><br><span class="line"></span><br><span class="line">    // Launch state is being passed as a parameter</span><br><span class="line">    test %edi, %edi</span><br><span class="line">    jz vmlaunch_lbl</span><br><span class="line"></span><br><span class="line">    movq 56(%rsi),   %rdi</span><br><span class="line">    movq 48(%rsi),   %rsi</span><br><span class="line"></span><br><span class="line">    vmresume</span><br><span class="line">    </span><br><span class="line">#ifdef DEBUGFEATURE_TDX_DBG_TRACE</span><br><span class="line">    call tdx_failed_vmentry</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Unreachable code.  panic.</span><br><span class="line">    */</span><br><span class="line">    ud2</span><br><span class="line"></span><br><span class="line">vmlaunch_lbl:</span><br><span class="line"></span><br><span class="line">    movq 56(%rsi),   %rdi</span><br><span class="line">    movq 48(%rsi),   %rsi</span><br><span class="line"></span><br><span class="line">    vmlaunch</span><br><span class="line">    </span><br><span class="line">#ifdef DEBUGFEATURE_TDX_DBG_TRACE</span><br><span class="line">    call tdx_failed_vmentry</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Unreachable code.  panic. </span><br><span class="line">     */</span><br><span class="line">    ud2</span><br></pre></td></tr></table></figure>

<h3 id="Meta-data"><a href="#Meta-data" class="headerlink" title="Meta data"></a>Meta data</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* VMM can pass one 64bit auxiliary data to vcpu via RCX for guest BIOS. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tdx_td_vcpu_init</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu, u64 vcpu_rcx)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kvm_tdx</span> *<span class="title">kvm_tdx</span> =</span> to_kvm_tdx(vcpu-&gt;kvm);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vcpu_tdx</span> *<span class="title">tdx</span> =</span> to_tdx(vcpu);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> *tdvpx_pa = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> tdvpr_pa;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> va;</span><br><span class="line">        <span class="type">int</span> ret, i;</span><br><span class="line">        u64 err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_td_vcpu_created(tdx))</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * vcpu_free method frees allocated pages.  Avoid partial setup so</span></span><br><span class="line"><span class="comment">         * that the method can&#x27;t handle it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        va = __get_free_page(GFP_KERNEL_ACCOUNT);</span><br><span class="line">        <span class="keyword">if</span> (!va)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        tdvpr_pa = __pa(va);</span><br><span class="line"></span><br><span class="line">        tdvpx_pa = kcalloc(tdx_info-&gt;nr_tdvpx_pages, <span class="keyword">sizeof</span>(*tdx-&gt;tdvpx_pa),</span><br><span class="line">                           GFP_KERNEL_ACCOUNT);</span><br><span class="line">        <span class="keyword">if</span> (!tdvpx_pa) &#123;</span><br><span class="line">                ret = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> free_tdvpr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tdx_info-&gt;nr_tdvpx_pages; i++) &#123;</span><br><span class="line">                va = __get_free_page(GFP_KERNEL_ACCOUNT);</span><br><span class="line">                <span class="keyword">if</span> (!va) &#123;</span><br><span class="line">                        ret = -ENOMEM;</span><br><span class="line">                        <span class="keyword">goto</span> free_tdvpx;</span><br><span class="line">                &#125;</span><br><span class="line">                tdvpx_pa[i] = __pa(va);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = tdh_vp_create(kvm_tdx-&gt;tdr_pa, tdvpr_pa);</span><br><span class="line">        <span class="keyword">if</span> (KVM_BUG_ON(err, vcpu-&gt;kvm)) &#123;</span><br><span class="line">                ret = -EIO;</span><br><span class="line">                pr_tdx_error(TDH_VP_CREATE, err, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">goto</span> free_tdvpx;</span><br><span class="line">        &#125;</span><br><span class="line">        tdx-&gt;tdvpr_pa = tdvpr_pa;</span><br><span class="line"></span><br><span class="line">        tdx-&gt;tdvpx_pa = tdvpx_pa;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tdx_info-&gt;nr_tdvpx_pages; i++) &#123;</span><br><span class="line">                err = tdh_vp_addcx(tdx-&gt;tdvpr_pa, tdvpx_pa[i]);</span><br><span class="line">                <span class="keyword">if</span> (KVM_BUG_ON(err, vcpu-&gt;kvm)) &#123;</span><br><span class="line">                        pr_tdx_error(TDH_VP_ADDCX, err, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="keyword">for</span> (; i &lt; tdx_info-&gt;nr_tdvpx_pages; i++) &#123;</span><br><span class="line">                                free_page((<span class="type">unsigned</span> <span class="type">long</span>)__va(tdvpx_pa[i]));</span><br><span class="line">                                tdvpx_pa[i] = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/* vcpu_free method frees TDVPX and TDR donated to TDX */</span></span><br><span class="line">                        <span class="keyword">return</span> -EIO;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = tdh_vp_init(tdx-&gt;tdvpr_pa, vcpu_rcx);</span><br><span class="line">        <span class="keyword">if</span> (KVM_BUG_ON(err, vcpu-&gt;kvm)) &#123;</span><br><span class="line">                pr_tdx_error(TDH_VP_INIT, err, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">return</span> -EIO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WARN_ON_ONCE(kvm_apicv_activated(vcpu-&gt;kvm));</span><br><span class="line">        vcpu-&gt;arch.apic-&gt;apicv_active = <span class="literal">false</span>;</span><br><span class="line">        vcpu-&gt;arch.mp_state = KVM_MP_STATE_RUNNABLE;</span><br><span class="line">        tdx-&gt;td_vcpu_created = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">free_tdvpx:</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tdx_info-&gt;nr_tdvpx_pages; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tdvpx_pa[i])</span><br><span class="line">                        free_page((<span class="type">unsigned</span> <span class="type">long</span>)__va(tdvpx_pa[i]));</span><br><span class="line">                tdvpx_pa[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        kfree(tdvpx_pa);</span><br><span class="line">        tdx-&gt;tdvpx_pa = <span class="literal">NULL</span>;</span><br><span class="line">free_tdvpr:</span><br><span class="line">        <span class="keyword">if</span> (tdvpr_pa)</span><br><span class="line">                free_page((<span class="type">unsigned</span> <span class="type">long</span>)__va(tdvpr_pa));</span><br><span class="line">        tdx-&gt;tdvpr_pa = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">api_error_type <span class="title function_">tdh_vp_create</span><span class="params">(<span class="type">uint64_t</span> target_tdvpr_pa, <span class="type">uint64_t</span> target_tdr_pa)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TDVPS related variables</span></span><br><span class="line">    <span class="type">pa_t</span>                  tdvpr_pa;                  <span class="comment">// TDVPR physical address</span></span><br><span class="line">    <span class="type">tdvps_t</span>             * tdvps_ptr;                 <span class="comment">// Pointer to the TDVPS (multi-page linear address)</span></span><br><span class="line">    <span class="type">pamt_block_t</span>          tdvpr_pamt_block;          <span class="comment">// TDVPR PAMT block</span></span><br><span class="line">    <span class="type">pamt_entry_t</span>        * tdvpr_pamt_entry_ptr;      <span class="comment">// Pointer to the TDVPR PAMT entry</span></span><br><span class="line">    <span class="type">bool_t</span>                tdvpr_locked_flag = <span class="literal">false</span>; <span class="comment">// Indicate TDVPR is locked</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TDR related variables</span></span><br><span class="line">    <span class="type">pa_t</span>                  tdr_pa;                    <span class="comment">// TDR physical address</span></span><br><span class="line">    <span class="type">tdr_t</span>               * tdr_ptr;                   <span class="comment">// Pointer to the TDR page (linear address)</span></span><br><span class="line">    <span class="type">pamt_block_t</span>          tdr_pamt_block;            <span class="comment">// TDR PAMT block</span></span><br><span class="line">    <span class="type">pamt_entry_t</span>        * tdr_pamt_entry_ptr;        <span class="comment">// Pointer to the TDR PAMT entry</span></span><br><span class="line">    <span class="type">bool_t</span>                tdr_locked_flag = <span class="literal">false</span>;   <span class="comment">// Indicate TDR is locked</span></span><br><span class="line"></span><br><span class="line">    <span class="type">tdcs_t</span>              * tdcs_ptr = <span class="literal">NULL</span>;           <span class="comment">// Pointer to the TDCS page (linear address)</span></span><br><span class="line"></span><br><span class="line">    api_error_type        return_val = UNINITIALIZE_ERROR;</span><br><span class="line"></span><br><span class="line">    tdvpr_pa.raw = target_tdvpr_pa;</span><br><span class="line">    tdr_pa.raw = target_tdr_pa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check, lock and map the owner TDR page</span></span><br><span class="line">    return_val = check_lock_and_map_explicit_tdr(tdr_pa,</span><br><span class="line">                                                 OPERAND_ID_RDX,</span><br><span class="line">                                                 TDX_RANGE_RW,</span><br><span class="line">                                                 TDX_LOCK_SHARED,</span><br><span class="line">                                                 PT_TDR,</span><br><span class="line">                                                 &amp;tdr_pamt_block,</span><br><span class="line">                                                 &amp;tdr_pamt_entry_ptr,</span><br><span class="line">                                                 &amp;tdr_locked_flag,</span><br><span class="line">                                                 &amp;tdr_ptr);</span><br><span class="line">    <span class="keyword">if</span> (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to check/lock/map a TDR - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map the TDCS structure and check the state</span></span><br><span class="line">    return_val = check_state_map_tdcs_and_lock(tdr_ptr, TDX_RANGE_RW, TDX_LOCK_SHARED,</span><br><span class="line">                                               <span class="literal">false</span>, TDH_VP_CREATE_LEAF, &amp;tdcs_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;State check or TDCS lock failure - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check, lock and map the new TDVPR page</span></span><br><span class="line">    return_val = check_lock_and_map_explicit_private_4k_hpa(tdvpr_pa,</span><br><span class="line">                                                            OPERAND_ID_RCX,</span><br><span class="line">                                                            tdr_ptr,</span><br><span class="line">                                                            TDX_RANGE_RW,</span><br><span class="line">                                                            TDX_LOCK_EXCLUSIVE,</span><br><span class="line">                                                            PT_NDA,</span><br><span class="line">                                                            &amp;tdvpr_pamt_block,</span><br><span class="line">                                                            &amp;tdvpr_pamt_entry_ptr,</span><br><span class="line">                                                            &amp;tdvpr_locked_flag,</span><br><span class="line">                                                            (<span class="type">void</span>**)&amp;tdvps_ptr);</span><br><span class="line">    <span class="keyword">if</span> (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to check/lock/map a TDVPR - error = 0x%llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALL_CHECKS_PASSED:  The function is guaranteed to succeed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the content of the TDVPR page using direct writes</span></span><br><span class="line">    zero_area_cacheline(tdvps_ptr, TDX_PAGE_SIZE_IN_BYTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize TDVPS management fields.</span></span><br><span class="line"><span class="comment">     * Fields which are initialized to zero are implicitly zero&#x27;d in the</span></span><br><span class="line"><span class="comment">     * previous state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tdvps_ptr-&gt;management.num_tdvps_pages = <span class="number">1</span>;</span><br><span class="line">    tdvps_ptr-&gt;management.assoc_lpid = (<span class="type">uint32_t</span>)<span class="number">-1</span>;</span><br><span class="line">    tdvps_ptr-&gt;management.tdvps_pa[<span class="number">0</span>] = assign_hkid_to_hpa(tdr_ptr, tdvpr_pa).raw;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the new TDVPR page in its owner TDR</span></span><br><span class="line">    (<span class="type">void</span>)_lock_xadd_64b(&amp;(tdr_ptr-&gt;management_fields.chldcnt), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the new TDVPR page PAMT fields</span></span><br><span class="line">    tdvpr_pamt_entry_ptr-&gt;pt = PT_TDVPR;</span><br><span class="line">    set_pamt_entry_owner(tdvpr_pamt_entry_ptr, tdr_pa);</span><br><span class="line"></span><br><span class="line">EXIT:</span><br><span class="line">    <span class="comment">// Release all acquired locks and free keyhole mappings</span></span><br><span class="line">    <span class="keyword">if</span> (tdvpr_locked_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        pamt_unwalk(tdvpr_pa, tdvpr_pamt_block, tdvpr_pamt_entry_ptr, TDX_LOCK_EXCLUSIVE, PT_4KB);</span><br><span class="line">        free_la(tdvps_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdcs_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        release_sharex_lock_hp_sh(&amp;tdcs_ptr-&gt;management_fields.op_state_lock);</span><br><span class="line">        free_la(tdcs_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdr_locked_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        pamt_unwalk(tdr_pa, tdr_pamt_block, tdr_pamt_entry_ptr, TDX_LOCK_SHARED, PT_4KB);</span><br><span class="line">        free_la(tdr_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> return_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>没有成功上锁会直接返回错误 TDX_OPERAND_BUSY</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared/exclusive lock with host priority</span></span><br><span class="line">_STATIC_INLINE_ api_error_code_e <span class="title function_">acquire_sharex_lock_hp</span><span class="params">(<span class="type">sharex_hp_lock_t</span> * lock_ptr, <span class="type">lock_type_t</span> lock_type,</span></span><br><span class="line"><span class="params">                                                        <span class="type">bool_t</span> is_guest)</span><span class="comment">//is_guest=false</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lock_type == TDX_LOCK_EXCLUSIVE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> acquire_sharex_lock_hp_ex(lock_ptr, is_guest);</span><br><span class="line">                                    _STATIC_INLINE_ api_error_code_e <span class="title function_">acquire_sharex_lock_hp_ex</span><span class="params">(<span class="type">sharex_hp_lock_t</span> * lock_ptr, <span class="type">bool_t</span> is_guest)</span></span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="type">sharex_hp_lock_t</span> retval;</span><br><span class="line">                                    </span><br><span class="line">                                        tdx_debug_assert(lock_ptr != <span class="literal">NULL</span>);</span><br><span class="line">                                    </span><br><span class="line">                                        retval.raw = _lock_cmpxchg_16b(SHAREX_HP_FREE, SHAREX_HP_EXCLUSIVE_LOCK, &amp;lock_ptr-&gt;raw); <span class="comment">// Set EXCLUSIVE to 1</span></span><br><span class="line">                                    </span><br><span class="line">                                        <span class="keyword">if</span> (retval.raw == SHAREX_HP_FREE)</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            <span class="keyword">return</span> TDX_SUCCESS;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">else</span> <span class="keyword">if</span> (retval.raw == SHAREX_HP_HOST_PRIORITY)</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            <span class="keyword">if</span> (is_guest)</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="keyword">return</span> TDX_OPERAND_BUSY_HOST_PRIORITY;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                            <span class="keyword">else</span></span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="comment">// HOST_PRIORITY is 1, try again if you are host</span></span><br><span class="line">                                                <span class="comment">// Set EXCLUSIVE to 1, clear HOST_PRIORITY</span></span><br><span class="line">                                                retval.raw = _lock_cmpxchg_16b(SHAREX_HP_HOST_PRIORITY, SHAREX_HP_EXCLUSIVE_LOCK, &amp;lock_ptr-&gt;raw);</span><br><span class="line">                                                <span class="keyword">return</span> (retval.raw == SHAREX_HP_HOST_PRIORITY) ? TDX_SUCCESS : TDX_OPERAND_BUSY;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">else</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                            <span class="keyword">if</span> (is_guest)</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="keyword">return</span> TDX_OPERAND_BUSY;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                            <span class="keyword">else</span></span><br><span class="line">                                            &#123;</span><br><span class="line">                                                _lock_or_16b(&amp;lock_ptr-&gt;raw, SHAREX_HP_HOST_PRIORITY);</span><br><span class="line">                                                <span class="keyword">return</span> TDX_OPERAND_BUSY;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (lock_type == TDX_LOCK_SHARED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> acquire_sharex_lock_hp_sh(lock_ptr, is_guest);</span><br><span class="line">                            _STATIC_INLINE_ api_error_code_e <span class="title function_">acquire_sharex_lock_hp_sh</span><span class="params">(<span class="type">sharex_hp_lock_t</span> * lock_ptr, <span class="type">bool_t</span> is_guest)</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="type">sharex_hp_lock_t</span> retval;</span><br><span class="line">                        </span><br><span class="line">                            tdx_debug_assert(lock_ptr != <span class="literal">NULL</span>);</span><br><span class="line">                        </span><br><span class="line">                            <span class="keyword">if</span> (is_guest)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">// Increment SHARE_COUNTER</span></span><br><span class="line">                                retval.raw = _lock_xadd_16b(&amp;lock_ptr-&gt;raw, SHAREX_HP_SINGLE_READER);</span><br><span class="line">                        </span><br><span class="line">                                <span class="keyword">if</span> (retval.host_prio)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="comment">// Decrement SHARE_COUNTER</span></span><br><span class="line">                                    retval.raw = _lock_xadd_16b(&amp;lock_ptr-&gt;raw, (<span class="type">uint16_t</span>)-SHAREX_HP_SINGLE_READER);</span><br><span class="line">                                    <span class="keyword">return</span> TDX_OPERAND_BUSY_HOST_PRIORITY;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (retval.exclusive)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">return</span> TDX_OPERAND_BUSY; <span class="comment">// Counter is n/a</span></span><br><span class="line">                                &#125;</span><br><span class="line">                        </span><br><span class="line">                                <span class="comment">// Sanity-check the counter after we know that exclusive bit was not set</span></span><br><span class="line">                                <span class="comment">// Only when exclusive bit is not set the shared-counters has &quot;real&quot; &quot;readers&quot;</span></span><br><span class="line">                                <span class="comment">// And that number should not overflow</span></span><br><span class="line">                                tdx_sanity_check((retval.counter != SHAREX_HP_FULL_COUNTER), SCEC_LOCK_SOURCE, <span class="number">10</span>);</span><br><span class="line">                        </span><br><span class="line">                                <span class="keyword">return</span> TDX_SUCCESS;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">// Increment SHARE_COUNTER</span></span><br><span class="line">                                retval.raw = _lock_xadd_16b(&amp;lock_ptr-&gt;raw, SHAREX_HP_SINGLE_READER);</span><br><span class="line">                        </span><br><span class="line">                                <span class="keyword">if</span> (retval.exclusive)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    _lock_or_16b(&amp;lock_ptr-&gt;raw, SHAREX_HP_HOST_PRIORITY);</span><br><span class="line">                                    <span class="keyword">return</span> TDX_OPERAND_BUSY;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (retval.host_prio)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="comment">// Leave SHARE_COUNTER incremented and reset HP bit</span></span><br><span class="line">                                    _lock_and_16b(&amp;lock_ptr-&gt;raw, (<span class="type">uint16_t</span>)~SHAREX_HP_HOST_PRIORITY);</span><br><span class="line">                                &#125;</span><br><span class="line">                        </span><br><span class="line">                                <span class="comment">// Sanity-check the counter after we know that exclusive bit was not set</span></span><br><span class="line">                                <span class="comment">// Only when exclusive bit is not set the shared-counters has &quot;real&quot; &quot;readers&quot;</span></span><br><span class="line">                                <span class="comment">// And that number should not overflow</span></span><br><span class="line">                                tdx_sanity_check((retval.counter != SHAREX_HP_FULL_COUNTER), SCEC_LOCK_SOURCE, <span class="number">11</span>);</span><br><span class="line">                        </span><br><span class="line">                                <span class="keyword">return</span> TDX_SUCCESS;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tdx_sanity_check(<span class="number">0</span>, SCEC_LOCK_SOURCE, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not supposed to return this after sanity check</span></span><br><span class="line">    <span class="keyword">return</span> UNINITIALIZE_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pamt 管理了整个 tdx 的物理内存使用(hkid) 类似 rmptable?</p>
<p>为什么要加锁？</p>
<ol>
<li>Tdx module 切换使用了 tdr tdvpr 的数据结构 (shared)</li>
<li>kvm 其他线程可能会修改 pamt (exclusive)</li>
</ol>
<p>如果类比简单的 function call  传参使用寄存器的保存可以不用另一块内存 而使用栈 那么就不需要额外对 pamt entry 的加锁操作(lock_xadd_16b 是否比较慢)</p>
<h3 id="Sum"><a href="#Sum" class="headerlink" title="Sum"></a>Sum</h3><p>host-&gt;firmware-&gt;guest-&gt;firmware-&gt;host</p>
<ol>
<li>host 将参数通过通用寄存器传参给 tdx module(先写到内存 再写到寄存器)  seamcall</li>
<li>tdx module 保存通用寄存器到内存并清零</li>
<li>对 pamt entry 加共享锁</li>
<li>map (keyhole)  tdvps</li>
<li>check_and_associate_vcpu 为了 VCPU state 的缓存一致性</li>
<li>set_vm_vmcs_as_active(tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</li>
<li>检查 tsc (rdmsr)</li>
<li>adjust_tlb_tracking_state 如果 epoch 不一致则刷缓存</li>
<li>handle_stepping_filter 根据 rip 变化检查 zero-step attack 报告给 guest  ept violation</li>
<li>如果上次 vmexit 是因为 vmcall 则把 vmm 的寄存器再传给 vm 的寄存器(内存)</li>
<li>恢复 guest 其他状态 比如 debug_registers&#x2F;performance monitoring counters&#x2F;msr  extended state(xmm)</li>
<li>从内存中恢复 guest 通用寄存器的值  vmresume&#x2F;vmlaunch</li>
<li>guest 将参数通过通用寄存器传参给 tdx module  tdcall 对应 1</li>
<li>tdx module 保存通用寄存器并清零 对应 2</li>
<li>所有通用寄存器换个内存地址再存一遍</li>
<li>某些情况需要 inject_ve 然后进 guest 的 ve handler 转成 tdcall 再来一遍</li>
<li>vm 通用寄存器传给 vmm(内存) 对应 10</li>
<li>存 guest 其他状态(extended states  xfam) 对应 11</li>
<li>tlb track 对应 8</li>
<li>放锁 对应 3</li>
<li>set_seam_vmcs_as_active</li>
<li>load_vmm_state_before_td_exit 恢复 host 状态</li>
<li>从内存中恢复 host 通用寄存器的值 seamret 对应 12</li>
</ol>
<p>修改 tdvps：</p>
<ol>
<li>tdvps_ptr-&gt;management.last_seamdb_index   tdx module update 需要支持 td-preserving</li>
<li>tdvps_p-&gt;management.module_dependent_hpa_updated  和 tdx module update  vCPU 调度有关</li>
<li>tdvps-&gt;ptr-&gt;management.assoc_lpid   vCPU 调度</li>
<li>tdcs_ptr-&gt;epoch_tracking-&gt;epoch_and_refcount     tlb track</li>
<li>tdvps_ptr-&gt;management.state &#x3D; VCPU_ACTIVE  与 migration 有关</li>
<li>step 检查失败 退出前 management.state 和 management.last_td_exit</li>
<li>嵌套虚拟化 l2_xxx</li>
</ol>
<h3 id="Check-tsc"><a href="#Check-tsc" class="headerlink" title="Check tsc"></a>Check tsc</h3><p><a target="_blank" rel="noopener" href="https://forums.guru3d.com/threads/a-bit-detailed-info-on-intel-time-stamp-counter-tsc.433977/">https://forums.guru3d.com/threads/a-bit-detailed-info-on-intel-time-stamp-counter-tsc.433977/</a></p>
<blockquote>
<p>17.15.3 Time-Stamp Counter Adjustment</p>
<p>Software can modify the value of the time-stamp counter (TSC) of a logical processor by using the WRMSR instruction to write to the IA32_TIME_STAMP_COUNTER MSR (address 10H). Because such a write applies only to that logical processor, software seeking to synchronize the TSC values of multiple logical processors must perform these writes on each logical processor. It may be difficult for software to do this in a way than ensures that all logical processors will have the same value for the TSC at a given point in time.<br>The synchronization of TSC adjustment can be simplified by using the 64-bit IA32_TSC_ADJUST MSR (address 3BH). Like the IA32_TIME_STAMP_COUNTER MSR, the IA32_TSC_ADJUST MSR is maintained separately for each logical processor. A logical processor maintains and uses the IA32_TSC_ADJUST MSR as follows:<br>• On RESET, the value of the IA32_TSC_ADJUST MSR is 0.<br>• If an execution of WRMSR to the IA32_TIME_STAMP_COUNTER MSR adds (or subtracts) value X from the TSC, the logical processor also adds (or subtracts) value X from the IA32_TSC_ADJUST MSR.<br>• If an execution of WRMSR to the IA32_TSC_ADJUST MSR adds (or subtracts) value X from that MSR, the logical processor also adds (or subtracts) value X from the TSC.</p>
<p>Unlike the TSC, the value of the IA32_TSC_ADJUST MSR changes only in response to WRMSR (either to the MSR itself, or to the IA32_TIME_STAMP_COUNTER MSR). Its value does not otherwise change as time elapses. Software seeking to adjust the TSC can do so by using WRMSR to write the same value to the IA32_TSC_ADJUST MSR on each logical processor.<br>Processor support for the IA32_TSC_ADJUST MSR is indicated by CPUID.(EAX&#x3D;07H, ECX&#x3D;0H):EBX.TSC_ADJUST (bit 1).</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/414698448">https://zhuanlan.zhihu.com/p/414698448</a></p>
<blockquote>
<p>这篇 LKML 讨论中提及到，一些 BIOS SMI（System Management Interruption，系统管理中断）处理程序会通过修改 TSC 值隐藏其执行时间</p>
</blockquote>
<p>检查 tsc 是否被修改， 上次 exit 的 tsc 是否比 enter 时的要小</p>
<p>是否是 tdx 依赖 tsc 提供精确的时间 避免 hypervisor 修改了 tsc 导致 tdx module 功能不正常？</p>
<ul>
<li>preemption timer set_vmx_preemption_timer 每次进 guest 前会调用  但这个功能是不是不太用？</li>
<li>Tdx module 正常处理会需要拿锁(tdcall) 如果拿锁失败会返回 TDX_OPERAND_BUSY_HOST_PRIORITY 当某次拿锁失败离第一次失败的时间超过阈值 会直接返回到 VMM(如果没超过阈值就返回 guest)</li>
<li>migration  计算 guestTD 视角的 virtual tsc</li>
</ul>
<h3 id="Tlb-tracking"><a href="#Tlb-tracking" class="headerlink" title="Tlb tracking"></a>Tlb tracking</h3><p>9.7</p>
<blockquote>
<p>TLB tracking is required when removing a mapped TD private page (TDH.MEM.PAGE.REMOVE) or when changing the page mapping size (TDH.MEM.PAGE.PROMOTE), etc.</p>
<p>This sequence is intended to be used by the host VMM to help guarantee no EPT TLB entries exist to a set of GPA ranges.</p>
</blockquote>
<p>全局：tdcs</p>
<p>percpu:tdvps</p>
<p>每次 vpenter 的时候更新 tdvps &lt;- tdcs 如果 epoch 不一致就刷新</p>
<p>epoch 是每次调 mem_track 的时候会 ++</p>
<p>refcount 是统计上一轮有没有同步完成 每次 vmexit 的时候每个 vcpu 会-1 每次 vmenter 每个 vcpu 会 +1</p>
<p>如果没有同步完成 mem_track 会返回错误 然后 tdx_track 会 while 重复尝试直到成功</p>
<p>在 sept_flush_remote_tlbs</p>
<p>sept_remove_private_spte</p>
<p>flush_tlb_current</p>
<p>的时候调用</p>
<p>为什么不直接 smp_call_function_many(allcpu, tdx_flush_vp)   实际上只有__tdx_mmu_release_hkid 调了这个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @struct epoch_and_refcount_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief Holds the epoch and refcount in a 128bit structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoch_and_refcount_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * The TD epoch counter. This counter is incremented by the host VMM using the TDHMEMTRACK function</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">uint64_t</span>       td_epoch;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Each REFCOUNT counts the number of LPs which may have TLB entries created</span></span><br><span class="line"><span class="comment">             * during a specific TD_EPOCH, and that are currently executing in TDX non-root mode</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">uint16_t</span>       refcount[<span class="number">2</span>];</span><br><span class="line">            <span class="type">uint8_t</span>        reserved[TDX_SIZE_OF_EPOCH_REFCOUNT_RESERVED_IN_BYTES];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">uint128_t</span> raw;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="type">epoch_and_refcount_t</span>;</span><br></pre></td></tr></table></figure>

<p>kvm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TLB shoot down procedure:</span></span><br><span class="line"><span class="comment"> * There is a global epoch counter and each vcpu has local epoch counter.</span></span><br><span class="line"><span class="comment"> * - TDH.MEM.RANGE.BLOCK(TDR. level, range) on one vcpu</span></span><br><span class="line"><span class="comment"> *   This blocks the subsequenct creation of TLB translation on that range.</span></span><br><span class="line"><span class="comment"> *   This corresponds to clear the present bit(all RXW) in EPT entry</span></span><br><span class="line"><span class="comment"> * - TDH.MEM.TRACK(TDR): advances the epoch counter which is global.</span></span><br><span class="line"><span class="comment"> * - IPI to remote vcpus</span></span><br><span class="line"><span class="comment"> * - TDExit and re-entry with TDH.VP.ENTER on remote vcpus</span></span><br><span class="line"><span class="comment"> * - On re-entry, TDX module compares the local epoch counter with the global</span></span><br><span class="line"><span class="comment"> *   epoch counter.  If the local epoch counter is older than the global epoch</span></span><br><span class="line"><span class="comment"> *   counter, update the local epoch counter and flushes TLB.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tdx_track</span><span class="params">(<span class="keyword">struct</span> kvm *kvm)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kvm_tdx</span> *<span class="title">kvm_tdx</span> =</span> to_kvm_tdx(kvm);</span><br><span class="line">        u64 err;</span><br><span class="line"></span><br><span class="line">        KVM_BUG_ON(!is_hkid_assigned(kvm_tdx), kvm);</span><br><span class="line">        <span class="comment">/* If TD isn&#x27;t finalized, it&#x27;s before any vcpu running. */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!is_td_finalized(kvm_tdx)))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * tdx_flush_tlb() waits for this function to issue TDH.MEM.TRACK() by</span></span><br><span class="line"><span class="comment">         * the counter.  The counter is used instead of bool because multiple</span></span><br><span class="line"><span class="comment">         * TDH_MEM_TRACK() can be issued concurrently by multiple vcpus.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * optimization: The TLB shoot down procedure described in The TDX</span></span><br><span class="line"><span class="comment">         * specification is, TDH.MEM.TRACK(), send IPI to remote vcpus, confirm</span></span><br><span class="line"><span class="comment">         * all remote vcpus exit to VMM, and execute vcpu, both local and</span></span><br><span class="line"><span class="comment">         * remote.  Twist the sequence to reduce IPI overhead as follows.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * local                        remote</span></span><br><span class="line"><span class="comment">         * -----                        ------</span></span><br><span class="line"><span class="comment">         * increment tdh_mem_track</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * request KVM_REQ_TLB_FLUSH</span></span><br><span class="line"><span class="comment">         * send IPI</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *                                TDEXIT to KVM due to IPI</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *                                IPI handler calls tdx_flush_tlb()</span></span><br><span class="line"><span class="comment">         *                              to process KVM_REQ_TLB_FLUSH.</span></span><br><span class="line"><span class="comment">         *                                spin wait for tdh_mem_track == 0</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * TDH.MEM.TRACK()</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * decrement tdh_mem_track</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *                                complete KVM_REQ_TLB_FLUSH</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * TDH.VP.ENTER to flush tlbs        TDH.VP.ENTER to flush tlbs</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;kvm_tdx-&gt;tdh_mem_track);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * KVM_REQ_TLB_FLUSH waits for the empty IPI handler, ack_flush(), with</span></span><br><span class="line"><span class="comment">         * KVM_REQUEST_WAIT.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        kvm_make_all_cpus_request(kvm, KVM_REQ_TLB_FLUSH);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                err = tdh_mem_track(kvm_tdx-&gt;tdr_pa);</span><br><span class="line">        &#125; <span class="keyword">while</span> (unlikely((err &amp; TDX_SEAMCALL_STATUS_MASK) == TDX_OPERAND_BUSY));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Release remote vcpu waiting for TDH.MEM.TRACK in tdx_flush_tlb(). */</span></span><br><span class="line">        <span class="type">atomic_dec</span>(&amp;kvm_tdx-&gt;tdh_mem_track);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (KVM_BUG_ON(err, kvm))</span><br><span class="line">                pr_tdx_error(TDH_MEM_TRACK, err, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里并不会调 tdx module 的 tdh_vp_flush  而是等 tdh_mem_track 完成 进 vm 的时候在 vpenter 里面刷</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tdx_flush_tlb</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Don&#x27;t need to flush shared EPTP:</span></span><br><span class="line"><span class="comment">         * &quot;TD VCPU TLB Address Spaced Identifier&quot; in the TDX module spec:</span></span><br><span class="line"><span class="comment">         * The TLB entries for TD are tagged with:</span></span><br><span class="line"><span class="comment">         *  SEAM (1 bit)</span></span><br><span class="line"><span class="comment">         *  VPID</span></span><br><span class="line"><span class="comment">         *  Secure EPT root (51:12 bits) with HKID = 0</span></span><br><span class="line"><span class="comment">         *  PCID</span></span><br><span class="line"><span class="comment">         * for *both* Secure-EPT and Shared-EPT.</span></span><br><span class="line"><span class="comment">         * TLB flush with Secure-EPT root by tdx_track() results in flushing</span></span><br><span class="line"><span class="comment">         * the conversion of both Secure-EPT and Shared-EPT.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * See tdx_track().  Wait for tlb shootdown initiater to finish</span></span><br><span class="line"><span class="comment">         * TDH_MEM_TRACK() so that shared-EPT/secure-EPT TLB is flushed</span></span><br><span class="line"><span class="comment">         * on the next TDENTER.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="type">atomic_read</span>(&amp;to_kvm_tdx(vcpu-&gt;kvm)-&gt;tdh_mem_track))</span><br><span class="line">                cpu_relax();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vmm_dispatcher</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">api_error_type <span class="title function_">tdh_mem_track</span><span class="params">(<span class="type">uint64_t</span> target_tdr_pa)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TDR related variables</span></span><br><span class="line">    <span class="type">pa_t</span>                  tdr_pa;                    <span class="comment">// TDR physical address</span></span><br><span class="line">    <span class="type">tdr_t</span>               * tdr_ptr;                   <span class="comment">// Pointer to the TDR page (linear address)</span></span><br><span class="line">    <span class="type">pamt_block_t</span>          tdr_pamt_block;            <span class="comment">// TDR PAMT block</span></span><br><span class="line">    <span class="type">pamt_entry_t</span>        * tdr_pamt_entry_ptr;        <span class="comment">// Pointer to the TDR PAMT entry</span></span><br><span class="line">    <span class="type">bool_t</span>                tdr_locked_flag = <span class="literal">false</span>;   <span class="comment">// Indicate TDR is locked</span></span><br><span class="line"></span><br><span class="line">    <span class="type">tdcs_t</span>              * tdcs_ptr = <span class="literal">NULL</span>;           <span class="comment">// Pointer to the TDCS structure (Multi-page)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool_t</span>                epoch_locked_flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    api_error_type        return_val = UNINITIALIZE_ERROR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    tdr_pa.raw = target_tdr_pa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check, lock and map the owner TDR page</span></span><br><span class="line">    return_val = check_lock_and_map_explicit_tdr(tdr_pa,</span><br><span class="line">                                                 OPERAND_ID_RCX,</span><br><span class="line">                                                 TDX_RANGE_RO,</span><br><span class="line">                                                 TDX_LOCK_SHARED,</span><br><span class="line">                                                 PT_TDR,</span><br><span class="line">                                                 &amp;tdr_pamt_block,</span><br><span class="line">                                                 &amp;tdr_pamt_entry_ptr,</span><br><span class="line">                                                 &amp;tdr_locked_flag,</span><br><span class="line">                                                 &amp;tdr_ptr);</span><br><span class="line">    <span class="keyword">if</span> (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed to check/lock/map a TDR - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map the TDCS structure and check the state</span></span><br><span class="line">    return_val = check_state_map_tdcs_and_lock(tdr_ptr, TDX_RANGE_RW, TDX_LOCK_SHARED,</span><br><span class="line">                                               <span class="literal">false</span>, TDH_MEM_TRACK_LEAF, &amp;tdcs_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (return_val != TDX_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;State check or TDCS lock failure - error = %llx\n&quot;</span>, return_val);</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock the TD epoch</span></span><br><span class="line">    <span class="keyword">if</span> (acquire_sharex_lock_ex(&amp;tdcs_ptr-&gt;epoch_tracking.epoch_lock)</span><br><span class="line">                                != LOCK_RET_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Could not lock the TD epoch\n&quot;</span>);</span><br><span class="line">        return_val = api_error_with_operand_id(TDX_OPERAND_BUSY, OPERAND_ID_TD_EPOCH);</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line">    epoch_locked_flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that no VCPUs are associated with the previous epoch</span></span><br><span class="line">    <span class="type">uint64_t</span> td_epoch = tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.td_epoch;</span><br><span class="line">    <span class="type">uint16_t</span>* refcount = tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.refcount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (refcount[<span class="number">1</span> - (td_epoch  &amp; <span class="number">1</span>)] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;VCPU associated with the previous epoch\n&quot;</span>);</span><br><span class="line">        return_val = TDX_PREVIOUS_TLB_EPOCH_BUSY;</span><br><span class="line">        <span class="keyword">goto</span> EXIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALL_CHECKS_PASSED:  The function is guaranteed to succeed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch to the next TD epoch.  Note that since we only have 2 REFCOUNTs,</span></span><br><span class="line">    <span class="comment">// the previous epoch&#x27;s REFCOUNT, verified above to be 0, is now the</span></span><br><span class="line">    <span class="comment">// current epoch&#x27;s REFCOUNT.</span></span><br><span class="line">    <span class="comment">// TD_EPOCH&#x27;s bit 63 must be 0 since this is a special range used for migration.</span></span><br><span class="line">    <span class="comment">// This can&#x27;t happen in practice (it would take thousands of years)</span></span><br><span class="line">    tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.td_epoch++;</span><br><span class="line"></span><br><span class="line">EXIT:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoch_locked_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        release_sharex_lock_ex(&amp;tdcs_ptr-&gt;epoch_tracking.epoch_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tdcs_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        release_sharex_lock_hp_sh(&amp;tdcs_ptr-&gt;management_fields.op_state_lock);</span><br><span class="line">        free_la(tdcs_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tdr_locked_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        pamt_unwalk(tdr_pa, tdr_pamt_block, tdr_pamt_entry_ptr, TDX_LOCK_SHARED, PT_4KB);</span><br><span class="line">        free_la(tdr_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> return_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/invept">https://www.felixcloutier.com/x86/invept</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">flush_td_asid</span><span class="params">(<span class="type">tdr_t</span>* tdr_ptr, <span class="type">tdcs_t</span>* tdcs_ptr, <span class="type">uint16_t</span> vm_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ia32e_eptp_t</span> eptp = get_l2_septp(tdr_ptr, tdcs_ptr, vm_id);</span><br><span class="line"></span><br><span class="line">    <span class="type">ept_descriptor_t</span> ept_desc = &#123;.ept = eptp.raw, .reserved = <span class="number">0</span>&#125;;</span><br><span class="line">    ia32_invept(&amp;ept_desc, INVEPT_SINGLE_CONTEXT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">flush_all_td_asids</span><span class="params">(<span class="type">tdr_t</span>* tdr_ptr, <span class="type">tdcs_t</span>* tdcs_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Execute INVEPT type 1 for each Secure EPT</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint16_t</span> vm_id = <span class="number">0</span>; vm_id &lt;= tdcs_ptr-&gt;management_fields.num_l2_vms; vm_id++)</span><br><span class="line">    &#123;</span><br><span class="line">        flush_td_asid(tdr_ptr, tdcs_ptr, vm_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">invalidate_gpa_translations</span><span class="params">(<span class="type">tdvps_t</span> *tdvps_ptr, <span class="type">uint16_t</span> vm_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    tdvps_ptr-&gt;management.l2_enter_guest_state_hpa[vm_id] = NULL_PA;</span><br><span class="line">    tdvps_ptr-&gt;management.l2_vapic_hpa[vm_id] = NULL_PA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">invalidate_all_gpa_translations</span><span class="params">(<span class="type">tdcs_t</span>* tdcs_p, <span class="type">tdvps_t</span>* tdvps_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint16_t</span> vm_id = <span class="number">0</span>; vm_id &lt;= tdcs_p-&gt;management_fields.num_l2_vms; vm_id++)</span><br><span class="line">    &#123;</span><br><span class="line">        invalidate_gpa_translations(tdvps_p, vm_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h4><p>嵌套虚拟化 td 可分为 L1 VMM L2 VM</p>
<p>management.curr_vm&#x3D;0 表示是 L1  否则是 L2VM 的编号</p>
<p>tdh_mng_init 初始化</p>
<p>Kvm setup_tdparams  td_params 在 kvm 的结构体中并没有 num_l2_vms kernel 并没有支持嵌套虚拟化？</p>
<p>所有涉及到 l2_enter_guest_state_hpa 的操作不在非嵌套虚拟化的路径中</p>
<p>并且由于 num_l2_vms 是 0  invalidate_all_gpa_translations 相当于是空的</p>
<h4 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h4><p>hypervisor 不刷 tlb</p>
<p><u>TLB Poisoning Attacks on AMD Secure Encrypted Virtualization</u></p>
<p>同一个 lp 调度不同 vcpu 时不刷</p>
<p><a target="_blank" rel="noopener" href="https://www.amd.com/en/resources/product-security/bulletin/amd-sb-1023.html">https://www.amd.com/en/resources/product-security/bulletin/amd-sb-1023.html</a></p>
<p>amd 硬件强制刷</p>
<p>tdx_vcpu_load 和 pre_sev_run 有差不多的逻辑 换 vcpu 就要刷</p>
<p>刷完以后 tdx module 把 tdvps_ptr-&gt;management.assoc_lpid 写为-1 即 VCPU_NO_LP</p>
<p>在每次 tdh_vp_enter 的时候都会检查 lpid 要么不变要么为-1 否则返回错误</p>
<p>并且 tdh_vp_enter 也会检查当前 vcpu 和上一次是否一致 不一致就刷</p>
<blockquote>
<p>The same ASID based on the TD’s EPTP is used for caching both secure and shared EPT translations (remember: EPTP is the HPA of the **secure **EPT root page). Thus, to flush shared EPT translations, the host VMM uses INVEPT specifying the TD’s EPTP, not its Shared EPTP. The host VMM can obtain the value of EPTP from the TD VMCSs using TDH.VP.RD.</p>
<p>An alternative method the host VMM may use is to do TLB tracking similar to how it’s done for Secure EPT, i.e., execute TDH.MEM.TRACK and a round of IPI. Contrary to Secure EPT, this is not enforced by the TDX module.</p>
</blockquote>
<p>epoch 只在 tdx_mem_track 中更改</p>
<p>tdx_mem_track 只由 kvm 调用</p>
<p>9.15 <strong>Removing a Secure EPT Page: TDH.MEM.SEPT.REMOVE</strong></p>
<blockquote>
<p>The host VMM can remove a Secure EPT page using TDH.MEM.SEPT.REMOVE, freeing it for any use, provided all its 35 entries are FREE. The host VMM should first perform the TLB tracking protocol on the page.<br>The host VMM should first call TDH.MEM.RANGE.BLOCK on the Secure EPT page. TDH.MEM.RANGE.BLOCK marks the parent EPT entry for that page as **BLOCKED **and records the TD epoch in the PAMT entry of the page.</p>
<p>Typically, the host VMM then calls TDH.MEM.TRACK and performs a round of IPIs. After that, there should be no active address translation to GPA range presented by the Secure EPT page to be removed</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tdh_mem_sept_remove</span></span><br><span class="line">    <span class="keyword">if</span> (sept_state_is_tlb_tracking_required(sept_entry_copy) &amp;&amp;</span><br><span class="line">        op_state_is_tlb_tracking_required(tdcs_ptr-&gt;management_fields.op_state))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The TD may be running and this page must be blocked and tracked before it&#x27;s removed.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Verify the entry is *BLOCKED (originally MAPPED or PENDING)</span></span><br><span class="line">        <span class="keyword">if</span> (!sept_state_is_any_blocked(sept_entry_copy))</span><br><span class="line">        &#123;</span><br><span class="line">            return_val = api_error_with_operand_id(TDX_GPA_RANGE_NOT_BLOCKED, OPERAND_ID_RCX);</span><br><span class="line">            set_arch_septe_details_in_vmm_regs(sept_entry_copy, gpa_mappings.level, local_data_ptr);</span><br><span class="line">            TDX_ERROR(<span class="string">&quot;Removed SEPT entry is not blocked - 0x%llx\n&quot;</span>, sept_entry_copy.raw);</span><br><span class="line">            <span class="keyword">goto</span> EXIT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Verify the TLB tacking of the blocked Secure-EPT page has been completed</span></span><br><span class="line">        <span class="keyword">if</span> (!is_tlb_tracked(tdcs_ptr, removed_page_pamt_entry_ptr[<span class="number">0</span>]-&gt;bepoch))</span><br><span class="line">        &#123;</span><br><span class="line">            TDX_ERROR(<span class="string">&quot;Removed SEPT page TLB tracking is not complete\n&quot;</span>);</span><br><span class="line">            return_val = api_error_with_operand_id(TDX_TLB_TRACKING_NOT_DONE, OPERAND_ID_RCX);</span><br><span class="line">            <span class="keyword">goto</span> EXIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>tdh_mem_range_block-&gt;block_sept_entry 每个 septe 会记录是否被 block</p>
<p>如果 kvm 没有调用 tdh_mem_range_block  tdx module 会检查并报错</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Checks TLB tracking conditions</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param tdcs_t Pointer to TDCS for reading TD&#x27;s epoch value and refcount</span></span><br><span class="line"><span class="comment"> * @param bepoch The EPOCH value that needs to be checked if tracked</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_STATIC_INLINE_ <span class="type">bool_t</span> <span class="title function_">is_tlb_tracked</span><span class="params">(<span class="type">tdcs_t</span> * tdcs_ptr, <span class="type">bepoch_t</span> bepoch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bepoch.mig_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">epoch_and_refcount_t</span> epoch_and_refcount = &#123;</span><br><span class="line">            .raw = _lock_read_128b(&amp;tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.raw)</span><br><span class="line">                                              &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((bepoch.raw == epoch_and_refcount.td_epoch - <span class="number">1</span>) &amp;&amp;</span><br><span class="line">        (epoch_and_refcount.refcount[bepoch.raw &amp; <span class="number">1</span>] == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (bepoch.raw &lt; epoch_and_refcount.td_epoch - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bepoch 在 tdh_mem_range_block 的时候设为 tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.td_epoch</p>
<p>这里的条件是</p>
<ol>
<li>td_epoch 比之前 block 的时候大 1 那这轮 flush 必须都完成</li>
<li>td_epoch 比之前 block 的时候不止大 1 那表示之前的 flush 已经完成</li>
</ol>
<p>remove 改 pte 必须先 block-&gt;block 后必须 track-&gt;track 必须 flush</p>
<p><img src="/images/OiaUbKFGfoYRvVxEqWgc2XwpnYd.png" title="image"></p>
<p>KVM 如果不发 IPI vCPU 不下来  在 remove 的时候 根据 refcount 还是可以判断最近一次的同步有没有完成</p>
<p>refcount 在每次 enter 的时候 +1 exit 的时候-1 动态变化 只有所有 vCPU 都没 enter 的时候才会是 0</p>
<h4 id="TDH-MEM-RANGE-BLOCK"><a href="#TDH-MEM-RANGE-BLOCK" class="headerlink" title="TDH.MEM.RANGE.BLOCK"></a>TDH.MEM.RANGE.BLOCK</h4><blockquote>
<p>Execute TDH.MEM.RANGE.BLOCK on each GPA range, blocking subsequent creation of TLB translation to that range.<br>Note that cached translations may still exist at this stage.</p>
</blockquote>
<blockquote>
<p>The host VMM can remove a Secure EPT page using TDH.MEM.SEPT.REMOVE, freeing it for any use, provided all its 35 entries are FREE. The host VMM should first perform the TLB tracking protocol on the page.<br>The host VMM should first call TDH.MEM.RANGE.BLOCK on the Secure EPT page. TDH.MEM.RANGE.BLOCK marks the parent EPT entry for that page as **BLOCKED **and records the TD epoch in the PAMT entry of the page.</p>
<p>Typically, the host VMM then calls TDH.MEM.TRACK and performs a round of IPIs. After that, there should be no active address translation to GPA range presented by the Secure EPT page to be removed.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prepare the EPT entry value with TDB set, RWX cleared and suppress VE set</span></span><br><span class="line">    <span class="type">ia32e_sept_t</span> new_septe_val;</span><br><span class="line">    new_septe_val.raw = page_sept_entry_copy.raw;</span><br><span class="line"></span><br><span class="line">    block_sept_entry(&amp;new_septe_val, sept_level_and_gpa.level);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Update the SEPT entry in memory</span></span><br><span class="line">    atomic_mem_write_64b(&amp;page_sept_entry_ptr-&gt;raw, new_septe_val.raw);</span><br></pre></td></tr></table></figure>

<p>一个新的 pte 改了属性  atomic write 修改到页表上？ 硬件有特殊的行为吗？</p>
<p>9.2 Secure EPT Entry</p>
<blockquote>
<p>From the CPU perspective, Secure EPT has the same structure as a legacy VMX EPT.<br>For the purpose of private memory management, the Intel TDX module hold a state value in each Secure EPT entry. This state value is encoded by multiple bits.</p>
</blockquote>
<p><img src="/images/BsCQbP6eno1j48x2g3YcmObEneg.png" title="image"></p>
<h4 id="Sum-1"><a href="#Sum-1" class="headerlink" title="Sum"></a>Sum</h4><ol>
<li>先改页表 block  不让访问 （但是其他 vCPU 还是可以通过 tlb 访问 没问题 因为还没有到 remove 的流程）</li>
<li>刷 tlb ipi</li>
<li>改页表 remove  此时需要保证之前的刷 tlb 完成</li>
</ol>
<h3 id="Associate-vcpu"><a href="#Associate-vcpu" class="headerlink" title="Associate vcpu"></a>Associate vcpu</h3><p>10.3</p>
<blockquote>
<p>Some TD VCPU state is non-coherently cached. This includes:<br>• Address translations (TLB&#x2F;PxE entries) must be explicitly flushed in case they may be stale.<br>• TD VMCS is cached by the CPU. VMX architecture requires making a VMCS current by VMPTRLD before using it with most VMX instructions, and then explicitly writing it to memory and making it non-current by VMCLEAR before the VMCS memory image can be handled (e.g., by making it current on another LP).<br>This non-coherent caching implies that some explicit and&#x2F;or implicit operations are done to help guarantee correctness. This is described in the following sections</p>
</blockquote>
<p>tdvps_ptr-&gt;management.assoc_lpid</p>
<p>就是刷缓存的时候用(主要是第二条)</p>
<ol>
<li>每次 vpenter adjust_tlb_tracking_state 如果不是 new_association  flushasid invalidate gpa translations</li>
<li>tdh_vp_flush 当前的 lpid 必须和传入的 tdvps 记录的 lpid 一致</li>
</ol>
<p>kvm 有 tdx_flush_vp_on_cpu  当每次 tdx_vcpu_load 的时候 当前 cpu 和记录的 cpu 不一致的时候调用(Migrate VCPUs between LPs)</p>
<h3 id="Xmm"><a href="#Xmm" class="headerlink" title="Xmm"></a>Xmm</h3><p>tdcall 的时候 根据传入的 xmm_mask 选择保存并传递 其他全部清零</p>
<p>async 的时候 xsave</p>
<blockquote>
<p>The Intel TDX module helps ensure that any guest TD extended state is saved and isolated from the host VMM across TD exit and entry. It is the VMM’s responsibility to save its own extended state across TD entry and exit.<br>• Before TDH.VP.ENTER, the host VMM should save (e.g., using XSAVES) any extended state that the guest TD VCPU is allowed to use (per XFAM) and the host VMM expects to need after TDH.VP.ENTER is complete.<br>• The TDH.VP.ENTER function loads the extended state that the TD VCPU is allowed to use, per XFAM, from the VCPU’s TDVPS. An exception to this is when TDH.VP.ENTER follows a previous TDG.VP.VMCALL – in the case TDH.VP.ENTER does not load the XMM state (corresponding to XFAM bit 1) from TDVPS; it passes it directly from the host VMM.<br>• On an asynchronous TD exit, the Intel TDX module saves the extended state that the TD VCPU was allowed to use, per XFAM, to the VCPU’s TDVPS. It then clears the extended state.<br>• On TDG.VP.VMCALL, the Intel TDX module works similarly, but it selectively does not clear some of the XMM register<br>state (corresponding to XFAM bit 1). That XMM state is passed directly to the host VMM.<br>• On completion of TDH.VP.ENTER (following TD exit), the VMM may restore any extended state that it saved before<br>TDH.VP.ENTER.</p>
</blockquote>
<p>xfam：eXtended Features Available Mask   决定 guest vCPU 能用哪些属性 然后保存恢复的时候直接把这个传进去</p>
<p>kvm 配置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">save_guest_td_extended_state</span><span class="params">(<span class="type">tdvps_t</span>* tdvps_ptr, <span class="type">uint64_t</span> xfam)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Set Guest XCR0 and XSS context for saving the state</span></span><br><span class="line">    ia32_xsetbv(<span class="number">0</span>, xfam &amp; XCR0_USER_BIT_MASK);</span><br><span class="line">    ia32_wrmsr(IA32_XSS_MSR_ADDR, xfam &amp; XCR0_SUPERVISOR_BIT_MASK);</span><br><span class="line"></span><br><span class="line">    ia32_xsaves(&amp;tdvps_ptr-&gt;guest_extension_state.xbuf, xfam);</span><br><span class="line">&#125;</span><br><span class="line">_STATIC_INLINE_ <span class="type">void</span> <span class="title function_">restore_guest_td_extended_state</span><span class="params">(<span class="type">tdcs_t</span>* tdcs_ptr, <span class="type">tdvps_t</span>* tdvps_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> xstate_bv = tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.xstate_bv;</span><br><span class="line">    <span class="type">uint64_t</span> xcomp_bv = tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.xcomp_bv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for XBUFF header corruption before trying to use SAFE_XRSTORS</span></span><br><span class="line">    <span class="comment">// Checks are done according to SDM Volume 1, Chapter 13.12</span></span><br><span class="line">    <span class="comment">// A #GP occurs in the following cases:</span></span><br><span class="line">    <span class="comment">//  - XCOMP_BV[63] = 0.</span></span><br><span class="line">    <span class="comment">//  - XCOMP_BV sets a bit in the range 62:0 that is not set in XCR0 | IA32_XSS</span></span><br><span class="line">    <span class="comment">//    (in our case XCR0 | IA32_XSS is just the XFAM)</span></span><br><span class="line">    <span class="comment">//  - XSTATE_BV sets a bit(including bit 63) that is not set in XCOMP_BV.</span></span><br><span class="line">    <span class="comment">//  - Bytes 63 : 16 of the XSAVE header are not all 0.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((xcomp_bv &amp; BIT(<span class="number">63</span>)) == <span class="number">0</span>) ||</span><br><span class="line">        ((xcomp_bv &amp; ~BIT(<span class="number">63</span>) &amp; ~(tdvps_ptr-&gt;management.xfam)) != <span class="number">0</span>) ||</span><br><span class="line">        ((xstate_bv &amp; ~xcomp_bv) != <span class="number">0</span>) ||</span><br><span class="line">        (!tdx_memcmp_to_zero(tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.reserved,</span><br><span class="line">                             <span class="keyword">sizeof</span>(tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.reserved))))</span><br><span class="line">    &#123;</span><br><span class="line">        TDX_ERROR(<span class="string">&quot;Failed checks on XBUFF header. xcomp_bv = 0x%llx, xstate_bv = 0x%llx, xfam = 0x%llx\n&quot;</span>,</span><br><span class="line">                xcomp_bv, xstate_bv, tdvps_ptr-&gt;management.xfam);</span><br><span class="line">        guest_ext_state_load_failure(tdcs_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set Guest XCR0 and XSS context for restoring the state</span></span><br><span class="line">    ia32_xsetbv(<span class="number">0</span>, tdvps_ptr-&gt;management.xfam &amp; XCR0_USER_BIT_MASK);</span><br><span class="line">    ia32_wrmsr(IA32_XSS_MSR_ADDR, tdvps_ptr-&gt;management.xfam &amp; XCR0_SUPERVISOR_BIT_MASK);</span><br><span class="line"></span><br><span class="line">    safe_xrstors(&amp;tdvps_ptr-&gt;guest_extension_state.xbuf, tdvps_ptr-&gt;management.xfam, tdcs_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/xsave">https://www.felixcloutier.com/x86/xsave</a></p>
<p><a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/xrstor">https://www.felixcloutier.com/x86/xrstor</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span>  fcw;</span><br><span class="line">    <span class="type">uint16_t</span>  fsw;</span><br><span class="line">    <span class="type">uint8_t</span>   ftw;</span><br><span class="line">    <span class="type">uint8_t</span>   reserved_0;</span><br><span class="line">    <span class="type">uint16_t</span>  fop;</span><br><span class="line">    <span class="type">uint64_t</span>  fip;</span><br><span class="line">    <span class="type">uint64_t</span>  fdp;</span><br><span class="line">    <span class="type">uint32_t</span>  mxcsr;</span><br><span class="line">    <span class="type">uint32_t</span>  mxcsr_mask;</span><br><span class="line">    <span class="type">uint128_t</span> st_mm[<span class="number">8</span>];</span><br><span class="line">    <span class="type">uint128_t</span> xmm[<span class="number">16</span>];</span><br><span class="line">    <span class="type">uint8_t</span>   reserved_1[<span class="number">96</span>];</span><br><span class="line">&#125; <span class="type">xsave_legacy_region_t</span>;</span><br><span class="line">tdx_static_assert(<span class="keyword">sizeof</span>(<span class="type">xsave_legacy_region_t</span>) == <span class="number">512</span>, <span class="type">xsave_legacy_region_t</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/T2FwbKKOToNlUgxsOeickQpdnrg.png" title="image"></p>
<p>xfam 是 instruction mask  实际上叫 eXtended Features Available Mask</p>
<p>Section 13.4.1, “Legacy Region of an XSAVE Area” of Intel(® )64 and IA-32 Architectures Software Developer’s Manual, Volume 1</p>
<p>和 XCR0 and 以后称为 requested-feature bitmap (RFBM)  可以理解为需不需要保存对应的 state-component</p>
<p>13.11 XSAVES</p>
<blockquote>
<p>Execution of XSAVES saves into the XSAVE area those state components corresponding to bits that are set in RFBM (subject to the optimizations described below). State components 0 and 1 are located in the legacy region of the XSAVE area (see Section 13.4.1). Each state component <em>i</em>, 2 ≤ _i _≤ 62, is located in the extended region; the XSAVES instruction always uses the compacted format for the extended region (see Section 13.4.3).<br>Execution of XSAVES performs the init optimization to reduce the amount of data written to memory. If XINUSE[<em>i</em>] &#x3D; 0, state component _i _is not saved to the XSAVE area (even if RFBM[<em>i</em>] &#x3D; 1). However, if RFBM[1] &#x3D; 1 and MXCSR does not have the value 1F80H, XSAVES saves all of state component 1 (SSE — including the XMM registers) even if XINUSE[1] &#x3D; 0.</p>
</blockquote>
<p>有优化</p>
<ul>
<li>在初始化状态下是不会保存（0）</li>
<li>最近才恢复的就不用保存（没修改）</li>
</ul>
<p>每次 XRSTORS 会记录一个四元组信息  XSAVES 检查这个四元组 满足条件就不保存</p>
<ol>
<li>特权级是 ring0</li>
<li>xsave area 地址一样</li>
<li>如果 XRSTORS 调用时是 VMX non-root 那 XSAVES 调用也必须是 VMX non-root</li>
<li>对应的 state-component 没有被修改</li>
</ol>
<p>第一个优化：host guest 是否会用完 xmm 就清零？ 发生 hypercall 的时候除了需要传递的 xmm 其他都是清零的</p>
<p>第二个优化：两次 vmexit 之间  guest&#x2F;host 不会执行其他的 xrstors</p>
<blockquote>
<p>The XSAVEOPT, XSAVEC, and XSAVES instructions use two optimizations to reduce the amount of data that they write to memory. They avoid writing data for any state component known to be in its initial configuration (the <strong>init optimization</strong>). In addition, if either XSAVEOPT or XSAVES is using the same XSAVE area as that used by the most recent execution of XRSTOR or XRSTORS, it may avoid writing data for any state component whose configuration is known not to have been modified since then (the <strong>modified optimization</strong>). (XSAVE does not use these optimizations, and XSAVEC does not use the modified optimization.) The operation of XSAVEOPT, XSAVEC, and XSAVES are described in more detail in Section 13.9 through Section 13.11.<br>• **SSE state. **In 64-bit mode, SSE state is in its initial configuration if each of XMM0–XMM15 is 0. Outside 64-bit mode, SSE state is in its initial configuration if each of XMM0–XMM7 is 0. XINUSE[1] pertains only to the state of the XMM registers and not to MXCSR. An execution of XRSTOR or XRSTORS outside 64-bit mode does not update XMM8–XMM15. (See Section 13.13.)<br>• **AVX state. **In 64-bit mode, AVX state is in its initial configuration if each of YMM0_H–YMM15_H is 0. Outside 64-bit mode, AVX state is in its initial configuration if each of YMM0_H–YMM7_H is 0. An execution of XRSTOR or XRSTORS outside 64-bit mode does not update YMM8_H–YMM15_H. (See Section 13.13.)</p>
</blockquote>
<blockquote>
<p>Like XSAVEOPT, XSAVES may perform the modified optimization. Each execution of XRSTOR and XRSTORS establishes XRSTOR_INFO as a 4-tuple <em>w</em>,<em>x</em>,<em>y</em>,_z_ (see Section 13.8.3 and Section 13.12). Execution of XSAVES uses the modified optimization only if the following all hold:</p>
<p>• _w _&#x3D; CPL;<br>• _x _&#x3D; 1 if and only if the logical processor is in VMX non-root operation;<br>• _y _is the linear address of the XSAVE area being used by XSAVEOPT; and<br>• <em>z</em>[63] is 1 and <em>z</em>[62:0] &#x3D; RFBM[62:0]. (This last item implies that XSAVES does not use the modified optimization if the last execution of XRSTOR used the standard form and followed the last execution of XRSTORS.)<br>If XSAVES uses the modified optimization and XMODIFIED[<em>i</em>] &#x3D; 0 (see Section 13.6), state component _i _is not saved to the XSAVE area.</p>
</blockquote>
<h3 id="Branch-prediction"><a href="#Branch-prediction" class="headerlink" title="Branch prediction"></a>Branch prediction</h3><p>是个 side-channel</p>
<blockquote>
<p>Branch predictions cached by the CPU before entering a guest TD should not impact the behavior of that TD. The Intel TDX module helps ensure that by applying CPU mechanisms to isolate the branch predictions of each guest TD from branch predication done outside its execution.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the current VCPU to be executed on this LP is not the same as the last one,</span></span><br><span class="line">    <span class="comment">// issue an indirect branch prediction barrier (IBPB) command</span></span><br><span class="line">    <span class="keyword">if</span> (tdvpr_pa.raw != local_data_ptr-&gt;vp_ctx.last_tdvpr_pa.raw)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The TD ASID (Address Space Identifier) does not distinguish between different VCPUs of the same TD.</span></span><br><span class="line">        <span class="comment">// Therefore, when switching VCPU of the same TD on the same LP we should invalidate EPT.</span></span><br><span class="line">        <span class="comment">// Practically, we do this on every VCPU switch (even not of the same TD).</span></span><br><span class="line">        <span class="comment">// This is because it is difficult to track the history of TD execution on an LP</span></span><br><span class="line">        <span class="comment">// (i.e., we should check for every TD/VCPU combination in the past).</span></span><br><span class="line">        flush_all_td_asids(tdr_ptr, tdcs_ptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Issue an indirect branch prediction barrier (IBPB) command, since the CPU does not</span></span><br><span class="line">        <span class="comment">// distinguish between VCPUs for its branch prediction.</span></span><br><span class="line">        <span class="type">ia32_pred_cmd_t</span> pred_cmd = &#123; .raw = <span class="number">0</span> &#125;;</span><br><span class="line">        pred_cmd.ibpb = <span class="number">1</span>;</span><br><span class="line">        ia32_wrmsr(IA32_PRED_CMD_MSR_ADDR, pred_cmd.raw);</span><br><span class="line">        local_data_ptr-&gt;vp_ctx.last_tdvpr_pa.raw = tdvpr_pa.raw;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.intel.cn/content/www/cn/zh/developer/articles/technical/software-security-guidance/technical-documentation/indirect-branch-predictor-barrier.html">https://www.intel.cn/content/www/cn/zh/developer/articles/technical/software-security-guidance/technical-documentation/indirect-branch-predictor-barrier.html</a></p>
<p>用 barrier 防御 tdx module 在 host-guest 间做 barrier</p>
<p>guest 也可以写这个 msr kvm 配置是否需要下陷</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (boot_cpu_has(X86_FEATURE_IBPB))</span><br><span class="line">        vmx_set_intercept_for_msr(vcpu, MSR_IA32_PRED_CMD, MSR_TYPE_W,</span><br><span class="line">                                  !guest_has_pred_cmd_msr(vcpu));</span><br></pre></td></tr></table></figure>

<p>guest 为了安全 可以每次进 guest(embassy)自己做一遍 IBPB</p>
<p>为了性能 host 允许 non-root mode 直接执行 不下陷</p>
<h2 id="Sev"><a href="#Sev" class="headerlink" title="Sev"></a>Sev</h2><p><a target="_blank" rel="noopener" href="https://github.com/amd/AMD-ASPFW">https://github.com/amd/AMD-ASPFW</a> 找不到 vmexit 相关 只有 kvm 调 cmd 的部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sev_issue_cmd</span><br><span class="line">sev_issue_cmd_external_user</span><br><span class="line">sev_do_cmd</span><br><span class="line">__sev_do_cmd_locked</span><br><span class="line">    reg = cmd;</span><br><span class="line">    iowrite32(ret,..);</span><br><span class="line">    </span><br><span class="line">    ret = sev_wait_cmd_ioc();</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2026/02/02/papers/TZ-LLM%20Protecting%20On-Device%20Large%20Language%20Models%20with%20Arm%20TrustZone/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/02/papers/TZ-LLM%20Protecting%20On-Device%20Large%20Language%20Models%20with%20Arm%20TrustZone/" class="post-title-link" itemprop="url">TZ-LLM: Protecting On-Device Large Language Models with Arm TrustZone</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2026-02-02 00:57:15 / Modified: 00:57:22" itemprop="dateCreated datePublished" datetime="2026-02-02T00:57:15+08:00">2026-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>7 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="TZ-LLM-Protecting-On-Device-Large-Language-Models-with-Arm-TrustZone"><a href="#TZ-LLM-Protecting-On-Device-Large-Language-Models-with-Arm-TrustZone" class="headerlink" title="TZ-LLM: Protecting On-Device Large Language Models with Arm TrustZone"></a>TZ-LLM: Protecting On-Device Large Language Models with Arm TrustZone</h1><p><img src="/images/JFbabXzZUoOVKSxD8qtcrRNnn1d.png" title="image"></p>
<p>EuroSys‘26</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>现代移动应用能够自动将用户数据整合到大语言模型的提示中，以生成个性化的响应。与使用云端系统不同，当前出现了一种日益增长的趋势，即将 LLM 推理任务直接部署在移动设备上运行，因为这样做可以消除查询云服务所带来的网络延迟，并将用户的私有数据保留在其本地设备上。</p>
<p>然而，在移动设备上存储 LLM 模型参数也带来了专有模型泄露给不可信用户的风险，因为移动设备容易遭受越狱攻击。模型泄露可能给模型提供方造成重大经济损失，因为此类模型的开发成本可能高达数百万美元。此外，泄露还可能严重削弱模型提供方在竞争激烈的大语言模型市场中的竞争优势。</p>
<p>根据先前的研究，大多数移动应用对其设备端模型完全未加保护，而其他一些应用虽然对模型文件进行了加密，但仍允许攻击者从内存中提取出明文形式的模型参数。</p>
<p><img src="/images/WMXJba05poqw4Xx16PZc8n8unRc.png" title="image"></p>
<h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>存在 Memory efficiency 和 fast inference 的 trade off</p>
<p>大模型推理需要内存太大，如果动态扩缩容，就会面临冷启动的问题。</p>
<p><img src="/images/PQCHbDGyCoVOU5x95mncnzTWnOh.png" title="image"></p>
<h3 id="NPU"><a href="#NPU" class="headerlink" title="NPU"></a>NPU</h3><p>REE&#x2F;TEE 缺少安全 NPU 共享的方案</p>
<ul>
<li>NPU 在启动时默认配置为非安全设备</li>
<li>Rockchip NPU 将 llama3-8B 模型的 prefill 提高 12.5 倍 decode 提高 1.3 倍</li>
<li>使用两个驱动，REE&#x2F;TEE 中 detach&#x2F;attach 进行完整的切换，一次需要 32ms 太慢</li>
</ul>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><p><img src="/images/PR1PbxK2Hodqymx9tMbcxsGvn0d.png" title="image"></p>
<ul>
<li>TA：llama.cpp</li>
<li>REE OS:OpenHarmony v4.1 with Linux v5.10</li>
<li>TEE OS: OpenHarmony OS and chcore</li>
</ul>
<h3 id="Pipelined-Parameter-Restoration"><a href="#Pipelined-Parameter-Restoration" class="headerlink" title="Pipelined Parameter Restoration"></a>Pipelined Parameter Restoration</h3><p><img src="/images/OXqEbd8QYoZn6GxZocVcQrgCnBh.png" title="image"></p>
<p>相对于传统的纯计算操作，额外增加了三个算子</p>
<ul>
<li>Allocation  (CPU)</li>
<li>Loading (IO)</li>
<li>Decryption (CPU)</li>
</ul>
<p>优先级调度策略：</p>
<ol>
<li>Computation</li>
<li>Decryption</li>
<li>Allocation</li>
<li>Loading</li>
</ol>
<p>允许 CPU 抢占</p>
<h3 id="Pipeline-Aware-Secure-Memory-Management"><a href="#Pipeline-Aware-Secure-Memory-Management" class="headerlink" title="Pipeline-Aware Secure Memory Management"></a>Pipeline-Aware Secure Memory Management</h3><p><img src="/images/LipqbNh6PomMTLxK6X1cWLZQnze.png" title="image"></p>
<p>两个 TZASC region：</p>
<ul>
<li>LLM 参数</li>
<li>KV cache, activations,and other data</li>
</ul>
<p>通过 CMA 实现连续内存获取</p>
<h3 id="TEE-REE-NPU-Time-Sharing"><a href="#TEE-REE-NPU-Time-Sharing" class="headerlink" title="TEE-REE NPU Time-Sharing"></a>TEE-REE NPU Time-Sharing</h3><p><img src="/images/IIpFb7yIzo37C3xNviPcHF5UnTc.png" title="image"></p>
<p>Data plane 负责：</p>
<ol>
<li>初始化 job 上下文，包括 IOPT 内存  register buffer 等</li>
<li>MMIO 提交 job 到硬件</li>
<li>处理中断</li>
</ol>
<p>Control plane 负责：</p>
<ol>
<li>提交 job 到软件队列</li>
<li>调度 job</li>
<li>通过 data plane 提交 job 到硬件</li>
<li>调度下一个 job</li>
</ol>
<p><img src="/images/BTVdb3oc3oXxVuxZ9CPcW1N1nte.png" title="image"></p>
<ul>
<li>REE kernel 中放完整的 NPU driver  包括调度功能</li>
<li>TEE 中放部分 NPU driver 只有构造 job 和提交 job 到硬件</li>
</ul>
<p>NPU multiplexing 实现：</p>
<ol>
<li>TA 有一个乘法任务 提交到 TEE NPU driver</li>
<li>TEE NPU driver 构造一个 secure job 通过 tzdriver （smc）通知 REE NPU driver</li>
<li>REE NPU driver 把这个 secure job 加入调度队列</li>
<li>REE NPU driver 进行正常的调度和计算</li>
<li>REE NPU driver 调度到一个 secure job</li>
<li>通过 tzdriver 控制流返回到 TEE NPU driver</li>
<li>TEE NPU driver 配置 TZPC TZASC GIC 把 NPU 切换为 secure mode</li>
<li>TEE NPU driver 通过 MMIO 提交 secure job 到硬件</li>
<li>TEE NPU driver 等待任务完成 配置 TZPC TZASC GIC  把 NPU 切换为 normal mode</li>
</ol>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><ol>
<li>TTFT</li>
</ol>
<p><img src="/images/C2zBbCyTto4eNWxveEZceAUmnUg.png" title="image"></p>
<ul>
<li>Strawmen baseline: 77.1%-91.1% improvement</li>
<li>REE-Flash baseline：2.5%∼22.3%, 22.2%∼55.3%, 10.2%∼15.2% overhead</li>
<li>REE-Memory baseline: up to 8.5× overhead (parameter restoration)</li>
</ul>
<p><img src="/images/AUfFbo6jLoq6XcxkPTScNJb2nJb.png" title="image"></p>
<p>prompt 短的情况下 overhead 非常明显</p>
<ol>
<li>Decode</li>
</ol>
<p><img src="/images/Q6LjbvcBvoTXv0x4vgUcCZdenPe.png" title="image"></p>
<ul>
<li>Straewman baseline: 0.9%∼23.2% improvement</li>
<li>REE baseline:1.3%∼4.9% overhead (NPU multiplexing)</li>
</ul>
<ol>
<li>NPU</li>
</ol>
<p><img src="/images/HoN7bYhOToAG30x60wvc1LhInSh.png" title="image"></p>
<ul>
<li>额外 3.8% and 3.0% 的 overhead</li>
<li>smc switch + TZASC TZPC 配置 +GIC 配置耗时在 prefill decode 阶段占比为 1.6%∼2.7% and 2.3%∼5.7%</li>
</ul>
<h2 id="Drawback"><a href="#Drawback" class="headerlink" title="Drawback"></a>Drawback</h2><p>Secure memory 需要 CMA 分配连续内存</p>
<ol>
<li>耗时久</li>
</ol>
<p><img src="/images/LGSDb8n3Ro3oJYxNN04cw9aanvg.png" title="image"></p>
<p><img src="/images/Et40bJ5YrorZ66xA18XckcyGnZd.png" title="image"></p>
<p><img src="/images/RJuXbsvzgodRxpxynHPcQHUonU9.png" title="image"></p>
<ol>
<li>影响其他应用性能</li>
</ol>
<p><img src="/images/BwF8bx6zFoYduvxeTJEcktHDnud.png" title="image"></p>
<ol>
<li>需要改 EL3</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://szy0127.github.io/2026/02/02/papers/CortenMM%20Efficient%20Memory%20Management%20with%20Strong%20Correctness%20Guarantees/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="szy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="S blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | S blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/02/02/papers/CortenMM%20Efficient%20Memory%20Management%20with%20Strong%20Correctness%20Guarantees/" class="post-title-link" itemprop="url">CortenMM: Efficient Memory Management with Strong Correctness Guarantees</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2026-02-02 00:57:05 / Modified: 00:57:22" itemprop="dateCreated datePublished" datetime="2026-02-02T00:57:05+08:00">2026-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/papers/" itemprop="url" rel="index"><span itemprop="name">papers</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>5 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CortenMM-Efficient-Memory-Management-with-Strong-Correctness-Guarantees"><a href="#CortenMM-Efficient-Memory-Management-with-Strong-Correctness-Guarantees" class="headerlink" title="CortenMM: Efficient Memory Management with Strong Correctness Guarantees"></a>CortenMM: Efficient Memory Management with Strong Correctness Guarantees</h1><p><img src="/images/YeKsbBKfiogZegxUDSac0ZrUndZ.png" title="image"></p>
<p>SOSP‘25 Best Paper</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="VMA"><a href="#VMA" class="headerlink" title="VMA"></a>VMA</h3><p>内存管理上 Linux 采用 VMA+ 页表的两层抽象，在内存操作上需要两种类型的锁，限制了可扩展性</p>
<p><img src="/images/O8nkbhZW8oBqMvxkM0dcqqdgnOl.png" title="image"></p>
<p><img src="/images/ZtSqbl2kVor08jxOHdBcMgTSnRd.png" title="image"></p>
<ul>
<li>可扩展性差</li>
<li>并发 Bug 多（CVE）</li>
</ul>
<p><img src="/images/RRjdbAp1Coh2lXxf606cYY7gn6f.png" title="image"></p>
<ul>
<li>两个地址范围不相交的 page fault 在页表层面不存在冲突，但是如果处于同一段 VMA 中 就会因为抢 VMA 锁导致竞争</li>
<li>Real-world application 中存在各种 mmap mprotect 的调用 比较复杂</li>
</ul>
<h3 id="Asterinas"><a href="#Asterinas" class="headerlink" title="Asterinas"></a>Asterinas</h3><p>星绽操作系统</p>
<p><img src="/images/MLQHbKAZrosPGqxIiG5cC9Ypnsd.png" title="image"></p>
<p><img src="/images/EDwPb7CLMoODR8xHmVDcF8ojnvg.png" title="image"></p>
<p><img src="/images/C7FUbOBBaoDSBxx6VoWcZHnnnDg.png" title="image"></p>
<h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><p>Key insight：</p>
<ol>
<li>两层抽象的设计是由于历史原因，目前大部分现代 ISA 和 MMU 采用相似的多级页表设计</li>
<li>为了实现 On-demand paging COW swap 等高级的内存管理语义，并不需要多一层抽象</li>
</ol>
<p><img src="/images/SLvXbYraFo5mESx0SD2cItNjnPd.png" title="image"></p>
<ul>
<li>通过页表页的物理地址 可以找到 page descriptor</li>
<li>有且仅有每个页表页存在锁</li>
<li>通过 page descriptor 找到 per-PTE 的 metadata array 存放其他信息</li>
</ul>
<p>从这个设计上能做的简单推论：</p>
<ol>
<li>锁的粒度变细（2M 粒度） 可扩展性变好</li>
<li>On-demand paging 需要复制整个页表 会比复制 VMA 慢 （mmap &#x2F; fork）</li>
</ol>
<h3 id="Lock-protocol"><a href="#Lock-protocol" class="headerlink" title="Lock protocol"></a>Lock protocol</h3><p>CortenMM-rw 读写锁：在遍历页表的过程中拿读锁 找到对应的页表页以后拿写锁</p>
<p><img src="/images/Ios8bgizooEsrlxhL6Ac6cVRnXc.png" title="image"></p>
<p>读锁之间仍然有竞争（原子变量）</p>
<p>CoartenMM-adv：RCU+ 互斥锁</p>
<p>遍历页表的时候不加锁 只记录 RCU 状态</p>
<p><img src="/images/NRqpbc07Coyw96xeT3HcGFqrnSc.png" title="image"></p>
<h3 id="内存接口实现"><a href="#内存接口实现" class="headerlink" title="内存接口实现"></a>内存接口实现</h3><p><img src="/images/ULtvbZuVdoee5PxRMZWcG78GnJe.png" title="image"></p>
<p><img src="/images/VbIPbc2XwoQML9xDSsicx0WfnNg.png" title="image"></p>
<h2 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a>Verification</h2><p>用 Verus(半自动的基于 SMT 的验证器) 进行形式化验证</p>
<ol>
<li>locking protocol 正确，即 两个线程并发访问范围相交的地址 不可能同时拿到锁</li>
<li>对页表的修改正确（map unmap mark），并且页表结构正确（始终处于合法状态）</li>
</ol>
<p><img src="/images/UOndbwNRPo9wJPxplq5cpD9NnSf.png" title="image"></p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><ul>
<li>AMD EPYC 9965</li>
<li>192-core CPU * 2 &#x3D; 384 cores</li>
<li>512GB DRAM * 2 &#x3D; 1T</li>
</ul>
<h3 id="microbenchmark"><a href="#microbenchmark" class="headerlink" title="microbenchmark"></a>microbenchmark</h3><p><img src="/images/Rkuvbyvcxo6zaSx5OPTczO2xn5e.png" title="image"></p>
<p>单线程</p>
<p><img src="/images/Cjs0b1D5QoY1hwxu5s6cGerznFh.png" title="image"></p>
<ul>
<li>Linux 只需要创建 VMA</li>
<li>Cortenmm 需要分配、创建页表页</li>
</ul>
<p>&#x3D;&gt; mmap 慢</p>
<p>发生 page fault Linux 仍然需要创建页表</p>
<p>&#x3D;&gt; mmap+PF 快</p>
<p><img src="/images/HTbcbBqffo8kqBxZJ6kcTvwQnqg.png" title="image"></p>
<ul>
<li>Fork：-17.7%</li>
<li>fork+exec ：+23%</li>
</ul>
<p>多线程</p>
<ul>
<li>low-contention:每个线程在私有内存区域上访问</li>
<li>high-contention：每个线程在共享内存上随机访问</li>
</ul>
<p><img src="/images/GKXqbslSzo5hNlxoyVUculUYneb.png" title="image"></p>
<ul>
<li>cortenmm 几乎线性增长，384thread 情况下 PF 快 33 倍 unmap-virt 快 2270 倍</li>
<li>Cortenmm 64thread 开始掉的原因：最后一层页表页发生竞争</li>
</ul>
<h3 id="Real-world-benchmark"><a href="#Real-world-benchmark" class="headerlink" title="Real-world benchmark"></a>Real-world benchmark</h3><p><img src="/images/WHqqbC1EioGradxjbXJcf5I3nEb.png" title="image"></p>
<p>cortenmm 减少了并发情况下 application 在 page fault&#x2F;unmap&#x2F;mprotect 上的耗时</p>
<p><img src="/images/JlEpb4LctonQi4xZj1hce95pnod.png" title="image"></p>
<p>在某些应用场景下，使用更先进的内存分配器（tcmalloc） 可以大幅度提升 Linux 的可扩展性（通过减少对 unmap 等 syscall 的调用）</p>
<p>但是使用 tcmalloc 会造成其他副作用 比如占用内存变多</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>CortenMM 简化了内存管理系统，摈弃了传统的 VMA，而使用单层抽象，同时提出了一种面向 MMU 编程的事务型接口，并配套设计了相应的加锁协议。这些加锁协议避免了在软件抽象层上产生不必要的竞争，在维持事务原子性的同时显著提升了性能和可扩展性。加锁协议和事务接口中的基本功能进行了形式化验证，从而提供了强有力的一致性保障。在真实世界基准测试中， CortenMM 性能比 Linux 高出 1.2 倍至 26 倍。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">szy</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">413k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">25:03</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
